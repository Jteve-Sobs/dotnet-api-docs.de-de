<Type Name="Regex" FullName="System.Text.RegularExpressions.Regex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bd2da2fec4bf08aea40cc461ac92981f90eec61a" /><Meta Name="ms.sourcegitcommit" Value="b6b9d5f3f9c7eb43f14a8a1a68d044603cb8ed73" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/18/2020" /><Meta Name="ms.locfileid" Value="83448037" /></Metadata><TypeSignature Language="C#" Value="public class Regex" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Regex extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.Regex" />
  <TypeSignature Language="VB.NET" Value="Public Class Regex" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public ref class Regex" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type Regex = class" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public class Regex : System.Runtime.Serialization.ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Regex extends System.Object implements class System.Runtime.Serialization.ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public Class Regex&#xA;Implements ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Regex : System::Runtime::Serialization::ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Regex = class&#xA;    interface ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Regex extends System.Object implements class System.Runtime.Serialization.ISerializable" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System" FromVersion="4.0.0.0" To="System.Text.RegularExpressions" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Text.RegularExpressions" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen unveränderlichen regulären Ausdruck dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex>-Klasse stellt die Engine für reguläre Ausdrücke des .NET Framework dar. Sie kann verwendet werden, um schnell große Mengen an Text zu analysieren, um nach bestimmten Zeichen Mustern zu suchen. So extrahieren, bearbeiten, ersetzen oder löschen Sie Text Teil Zeichenfolgen und zum Hinzufügen der extrahierten Zeichen folgen zu einer Auflistung, um einen Bericht zu generieren.  
  
> [!NOTE]
>  Wenn Ihr primäres Interesse darin besteht, eine Zeichenfolge zu validieren, indem Sie feststellen, ob Sie einem bestimmten Muster entspricht, können Sie die <xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType>-Klasse verwenden.  
  
 Um reguläre Ausdrücke zu verwenden, definieren Sie das Muster, das Sie in einem Textstream identifizieren möchten, mithilfe der Syntax, die unter [Sprache für reguläre Ausdrücke (kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht) dokumentiert ist. Als nächstes können Sie optional ein <xref:System.Text.RegularExpressions.Regex> Objekt instanziieren. Zum Schluss wird eine Methode aufgerufen, die einen Vorgang ausführt, z. b. das Ersetzen von Text, der dem Muster für reguläre Ausdrücke entspricht, oder das Identifizieren einer Muster Übereinstimmung.  
  
> [!NOTE]
>  Einige gängige Muster für reguläre Ausdrücke finden Sie unter [Beispiele für reguläre Ausdrücke](~/docs/standard/base-types/regular-expression-examples.md). Es gibt auch eine Reihe von Online Bibliotheken von Mustern für reguläre Ausdrücke, z. b. die in [Regular-Expressions.info](https://www.regular-expressions.info/examples.html).  
  
<a name="remarks"></a>Weitere Informationen zum Verwenden der <xref:System.Text.RegularExpressions.Regex>-Klasse finden Sie in den folgenden Abschnitten in diesem Thema:  
  
-   [Regex-und String-Methoden](#regex_vs_string)  
  
-   [Statische und Instanzmethoden](#static_vs_instance)  
  
-   [Ausführen von regulären Ausdrucks Vorgängen](#regex_ops)  
  
-   [Definieren eines Timeout Werts](#define_timeout)  
  
 Weitere Informationen über die Sprache für reguläre Ausdrücke finden Sie unter [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Sie können auch eine der folgenden Broschüren herunterladen und ausdrucken:  
  
 [Kurzübersicht im Word-Format (.docx)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)  
 [Kurzübersicht im PDF-Format (.pdf)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)  
  
<a name="regex_vs_string"></a>   
## <a name="regex-vs-string-methods"></a>Regex-und String-Methoden  
 Die <xref:System.String?displayProperty=nameWithType>-Klasse enthält mehrere Such-und Vergleichsmethoden, die Sie verwenden können, um Muster Vergleiche mit Text auszuführen. Beispielsweise bestimmen die Methoden <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.EndsWith%2A?displayProperty=nameWithType>und <xref:System.String.StartsWith%2A?displayProperty=nameWithType>, ob eine Zeichen folgen Instanz eine angegebene Teil Zeichenfolge enthält. und die Methoden <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, <xref:System.String.IndexOfAny%2A?displayProperty=nameWithType>, <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>und <xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType> geben die Anfangsposition einer angegebenen Teil Zeichenfolge in einer Zeichenfolge zurück. Verwenden Sie die Methoden der <xref:System.String?displayProperty=nameWithType>-Klasse, wenn Sie nach einer bestimmten Zeichenfolge suchen. Verwenden Sie die <xref:System.Text.RegularExpressions.Regex>-Klasse, wenn Sie in einer Zeichenfolge nach einem bestimmten Muster suchen. Weitere Informationen und Beispiele finden Sie unter [.NET Framework von regulären Ausdrücken](~/docs/standard/base-types/regular-expressions.md).  
  
 [Zurück zu hinweisen](#remarks)  
  
<a name="static_vs_instance"></a>   
## <a name="static-vs-instance-methods"></a>Statische und Instanzmethoden  
 Nachdem Sie ein Muster für reguläre Ausdrücke definiert haben, können Sie es auf zweierlei Weise für die Engine für reguläre Ausdrücke bereitstellen:  
  
-   Durch Instanziieren eines <xref:System.Text.RegularExpressions.Regex> Objekts, das den regulären Ausdruck darstellt. Zu diesem Zweck übergeben Sie das Muster eines regulären Ausdrucks an einen <xref:System.Text.RegularExpressions.Regex.%23ctor%2A>-Konstruktor. Ein <xref:System.Text.RegularExpressions.Regex>-Objekt ist unveränderlich. Wenn Sie ein <xref:System.Text.RegularExpressions.Regex> Objekt mit einem regulären Ausdruck instanziieren, kann der reguläre Ausdruck dieses Objekts nicht geändert werden.  
  
-   Indem sowohl der reguläre Ausdruck als auch der Text für die Suche nach einem `static` (`Shared` in Visual Basic) <xref:System.Text.RegularExpressions.Regex>-Methode bereitgestellt werden. Dies ermöglicht es Ihnen, einen regulären Ausdruck zu verwenden, ohne explizit ein <xref:System.Text.RegularExpressions.Regex> Objekt zu erstellen.  
  
 Alle <xref:System.Text.RegularExpressions.Regex> Muster Identifizierungs Methoden enthalten sowohl statische als auch Instanzüberladungen.  
  
 Die Engine für reguläre Ausdrücke muss ein bestimmtes Muster kompilieren, bevor das Muster verwendet werden kann. Da <xref:System.Text.RegularExpressions.Regex> Objekte unveränderlich sind, handelt es sich hierbei um eine einmalige Prozedur, die auftritt, wenn ein <xref:System.Text.RegularExpressions.Regex> Klassenkonstruktor oder eine statische Methode aufgerufen wird. Um zu vermeiden, dass ein einzelner regulärer Ausdruck wiederholt kompiliert werden muss, werden die kompilierten regulären Ausdrücke zwischengespeichert, die in statischen Methoden aufrufen verwendet werden. Demzufolge bieten Muster Vergleichsmethoden für reguläre Ausdrücke eine vergleichbare Leistung für statische Methoden und Instanzmethoden.  
  
> [!IMPORTANT]
>  In den .NET Framework Versionen 1,0 und 1,1 wurden alle kompilierten regulären Ausdrücke zwischengespeichert, unabhängig davon, ob Sie in Instanzen oder statischen Methoden aufrufen verwendet wurden. Beginnend mit dem .NET Framework 2,0 werden nur reguläre Ausdrücke zwischengespeichert, die in statischen Methoden aufrufen verwendet werden.  
  
 Das Zwischenspeichern kann sich jedoch in den folgenden zwei Fällen negativ auf die Leistung auswirken:  
  
-   Wenn Sie statische Methodenaufrufe mit einer großen Anzahl regulärer Ausdrücke verwenden. Standardmäßig speichert die Engine für reguläre Ausdrücke die 15 zuletzt verwendeten statischen regulären Ausdrücke zwischen. Wenn Ihre Anwendung mehr als 15 statische reguläre Ausdrücke verwendet, müssen einige reguläre Ausdrücke neu kompiliert werden. Um diese Neukompilierung zu verhindern, können Sie die <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType>-Eigenschaft erhöhen.  
  
-   Wenn Sie neue <xref:System.Text.RegularExpressions.Regex> Objekte mit regulären Ausdrücken instanziieren, die zuvor kompiliert wurden. Der folgende Code definiert z. b. einen regulären Ausdruck, um doppelte Wörter in einem Textstream zu suchen. Obwohl im Beispiel ein einzelner regulärer Ausdruck verwendet wird, wird ein neues <xref:System.Text.RegularExpressions.Regex>-Objekt instanziiert, um jede Textzeile zu verarbeiten. Dies führt zur erneuten Kompilierung des regulären Ausdrucks bei jeder Iteration der Schleife.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#1)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#1)]  
  
     Um die Neukompilierung zu verhindern, sollten Sie ein einzelnes <xref:System.Text.RegularExpressions.Regex> Objekt instanziieren, das für den gesamten Code zugänglich ist, der ihn benötigt, wie im folgenden umgeschriebenen Beispiel dargestellt.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#2)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#2)]  
  
 [Zurück zu hinweisen](#remarks)  
  
<a name="regex_ops"></a>   
## <a name="performing-regular-expression-operations"></a>Ausführen von regulären Ausdrucks Vorgängen  
 Unabhängig davon, ob Sie eine <xref:System.Text.RegularExpressions.Regex> Objekt instanziieren und seine Methoden aufzurufen oder statische Methoden aufzurufen, bietet die <xref:System.Text.RegularExpressions.Regex>-Klasse die folgende Funktion zur Muster Übereinstimmung:  
  
-   Überprüfung einer Entsprechung. Die <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>-Methode wird aufgerufen, um zu bestimmen, ob eine Entsprechung vorhanden ist.  
  
-   Abrufen einer einzelnen Übereinstimmung. Rufen Sie die <xref:System.Text.RegularExpressions.Regex.Match%2A>-Methode auf, um ein <xref:System.Text.RegularExpressions.Match> Objekt abzurufen, das die erste Entsprechung in einer Zeichenfolge oder einem Teil einer Zeichenfolge darstellt. Nachfolgende Übereinstimmungen können durch Aufrufen der <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>-Methode abgerufen werden.  
  
-   Abrufen aller Übereinstimmungen. Rufen Sie die <xref:System.Text.RegularExpressions.Regex.Matches%2A>-Methode auf, um ein <xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType> Objekt abzurufen, das alle Übereinstimmungen darstellt, die in einer Zeichenfolge oder einem Teil einer Zeichenfolge gefunden wurden.  
  
-   Ersetzung von übereinstimmenden Text. Zum Ersetzen von übereinstimmenden Text wird die <xref:System.Text.RegularExpressions.Regex.Replace%2A>-Methode aufgerufen. Der Ersetzungstext kann auch durch einen regulären Ausdruck definiert werden. Darüber hinaus enthalten einige der <xref:System.Text.RegularExpressions.Regex.Replace%2A> Methoden einen <xref:System.Text.RegularExpressions.MatchEvaluator>-Parameter, der es Ihnen ermöglicht, den Ersetzungstext Programm gesteuert zu definieren.  
  
-   Erstellung eines Zeichen folgen Arrays, das aus Teilen einer Eingabe Zeichenfolge gebildet wird. Sie können die <xref:System.Text.RegularExpressions.Regex.Split%2A>-Methode aufzurufen, um eine Eingabe Zeichenfolge an Positionen aufzuteilen, die durch den regulären Ausdruck definiert werden.  
  
 Zusätzlich zu den Methoden für die Muster Übereinstimmung enthält die <xref:System.Text.RegularExpressions.Regex>-Klasse mehrere zweckgebundene Methoden:  
  
-   Die <xref:System.Text.RegularExpressions.Regex.Escape%2A>-Methode schützt alle Zeichen, die als Operatoren für reguläre Ausdrücke in einem regulären Ausdruck oder in einer Eingabe Zeichenfolge interpretiert werden können.  
  
-   Die <xref:System.Text.RegularExpressions.Regex.Unescape%2A>-Methode entfernt diese Escapezeichen.  
  
-   Die <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A>-Methode erstellt eine Assembly, die vordefinierte reguläre Ausdrücke enthält. Die .NET Framework enthält Beispiele für diese speziellen Assemblys im <xref:System.Web.RegularExpressions?displayProperty=nameWithType>-Namespace.  
  
 [Zurück zu hinweisen](#remarks)  
  
<a name="define_timeout"></a>   
## <a name="defining-a-time-out-value"></a>Definieren eines Timeout Werts  
 Der .NET Framework unterstützt eine voll ausgestattete Sprache für reguläre Ausdrücke, die eine beträchtliche Leistungsfähigkeit und Flexibilität bei der Muster Übereinstimmung bietet. Die Leistungsfähigkeit und Flexibilität sind jedoch kostengünstiger: das Risiko einer schlechten Leistung. Reguläre Ausdrücke, die schlecht funktionieren, sind überraschend leicht zu erstellen. In einigen Fällen kann es vorkommen, dass Vorgänge für reguläre Ausdrücke, die auf übermäßiger Rückverfolgung basieren, nicht mehr reagieren, wenn Sie Text verarbeiten, der fast mit dem Muster des regulären Ausdrucks übereinstimmt Weitere Informationen zum .NET Framework Engine für reguläre Ausdrücke finden Sie unter [Details zum Verhalten regulärer Ausdrücke](~/docs/standard/base-types/details-of-regular-expression-behavior.md). Weitere Informationen zur übermäßigen Rückverfolgung finden Sie unter [Rückverfolgung](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 Beginnend mit dem [!INCLUDE[net_v45](~/includes/net-v45-md.md)]können Sie ein Timeout Intervall für Übereinstimmungen mit regulären Ausdrücken definieren. Wenn die Engine für reguläre Ausdrücke keine Übereinstimmung innerhalb dieses Zeitintervalls identifizieren kann, löst der Abgleichsvorgang eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme aus. In den meisten Fällen wird dadurch verhindert, dass die Engine für reguläre Ausdrücke die Verarbeitungsleistung verschwendet, indem versucht wird, Text abzugleichen, der fast mit dem Muster des regulären Ausdrucks überein Es kann jedoch auch darauf hinweisen, dass das Timeout Intervall zu niedrig festgelegt wurde, oder dass die aktuelle Computer Auslastung zu einer Gesamt Leistungsminderung geführt hat.  
  
 Wie Sie die Ausnahme behandeln, hängt von der Ursache der Ausnahme ab. Wenn die Ausnahme auftritt, weil das Timeout Intervall zu niedrig oder aufgrund einer übermäßigen Computer Auslastung festgelegt ist, können Sie das Timeout Intervall erhöhen und den Abgleichsvorgang wiederholen. Wenn die Ausnahme auftritt, weil der reguläre Ausdruck eine übermäßige Rückverfolgung benötigt, können Sie davon ausgehen, dass keine Entsprechung vorhanden ist, und optional können Sie Informationen protokollieren, die Ihnen bei der Änderung des Musters für reguläre Ausdrücke helfen.  
  
 Wenn Sie ein Objekt für reguläre Ausdrücke instanziieren, können Sie ein Timeout Intervall festlegen, indem Sie den <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>-Konstruktor aufrufen. Bei statischen Methoden können Sie ein Timeout Intervall festlegen, indem Sie eine Überladung einer übereinstimmenden Methode aufrufen, die über einen `matchTimeout`-Parameter verfügt. Wenn Sie einen Timeout Wert nicht explizit festlegen, wird der Standard Timeout Wert wie folgt bestimmt:  
  
-   Mit dem Anwendungs weiten Timeout Wert, falls vorhanden. Dies kann ein beliebiger Timeout Wert sein, der sich auf die Anwendungsdomäne bezieht, in der das <xref:System.Text.RegularExpressions.Regex> Objekt instanziiert wird, oder der Aufruf der statischen Methode erfolgt. Sie können den Anwendungs weiten Timeout Wert festlegen, indem Sie die <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType>-Methode aufrufen, um die Zeichen folgen Darstellung eines <xref:System.TimeSpan> Werts der Eigenschaft "REGEX_DEFAULT_MATCH_TIMEOUT" zuzuweisen.  
  
-   Mit dem Wert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>, wenn kein Anwendungs weites Timeout Wert festgelegt wurde.  
  
> [!IMPORTANT]
>  Es wird empfohlen, dass Sie einen Timeout Wert in allen Vorgängen für Muster Vergleiche mit regulären Ausdrücken festlegen. Weitere Informationen finden Sie unter [bewährte Methoden für reguläre Ausdrücke](~/docs/standard/base-types/best-practices.md).  
  
 [Zurück zu hinweisen](#remarks)  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein regulärer Ausdruck verwendet, um nach wiederholten Vorkommen von Wörtern in einer Zeichenfolge zu suchen. Der `\b(?<word>\w+)\s+(\k<word>)\b` für reguläre Ausdrücke kann wie in der folgenden Tabelle dargestellt interpretiert werden.  
  
|Muster|BESCHREIBUNG|  
|-------------|-----------------|  
|`\b`|Die Entsprechung wird an einer Wort Grenze gestartet.|  
|`(?<word>\w+)`|Entsprechung für mindestens ein Wort Zeichen bis zu einer Wort Grenze. Benennen Sie diese erfasste Gruppe `word`.|  
|`\s+`|Entspricht einem oder mehreren Leerzeichen.|  
|`(\k<word>)`|Entspricht der erfassten Gruppe mit dem Namen `word`.|  
|`\b`|Übereinstimmung mit einer Wortgrenze.|  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/Regex_Words/CPP/words.cpp" id="Snippet0":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Regex_Words/CS/words.cs" interactive="try-dotnet" id="Snippet0":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex_Words/VB/words.vb" id="Snippet0"::: 
  
 Im folgenden Beispiel wird veranschaulicht, wie ein regulärer Ausdruck verwendet wird, um zu überprüfen, ob eine Zeichenfolge entweder einen Währungswert darstellt oder das richtige Format aufweist, um einen Währungswert darzustellen. In diesem Fall wird der reguläre Ausdruck dynamisch aus den Eigenschaften <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>und <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> für die aktuelle Kultur des Benutzers erstellt. Wenn die aktuelle Kultur des Systems de-US ist, wird der resultierende reguläre Ausdruck `^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`. Dieser reguläre Ausdruck kann wie in der folgenden Tabelle dargestellt interpretiert werden.  
  
|Muster|BESCHREIBUNG|  
|-------------|-----------------|  
|`^`|Beginnen Sie am Anfang der Zeichenfolge.|  
|`\s*`|Sucht nach 0 (null) oder mehr Leerzeichen.|  
|`[\+-]?`|Entspricht keinem oder einem Vorkommen des positiven Zeichens oder des negativen Zeichens.|  
|`\s?`|Übereinstimmung mit keinem oder einem Leerzeichen.|  
|`\$?`|Sucht nach 0 (null) oder einem Vorkommen des Dollar Zeichens.|  
|`\s?`|Übereinstimmung mit keinem oder einem Leerzeichen.|  
|`\d*`|0 (null) oder mehr Dezimalstellen sollen übereinstimmen.|  
|`\.?`|Entsprechung für NULL oder ein Dezimaltrennzeichen.|  
|`\d{2}?`|Entsprechung für zwei Dezimalziffern NULL oder einmal.|  
|`(\d*\.?\d{2}?){1}`|Vergleichen Sie das Muster von ganzzahligen und Bruch Ziffern, die durch ein Dezimaltrennzeichen getrennt sind, mindestens einmal.|  
|`$`|Entsprechung für das Ende der Zeichenfolge.|  
  
 In diesem Fall geht der reguläre Ausdruck davon aus, dass eine gültige Währungs Zeichenfolge keine Gruppen Trennzeichen enthält, und dass Sie entweder keine Dezimalstellen oder die Anzahl der Bruch Ziffern hat, die durch die <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>-Eigenschaft der aktuellen Kultur definiert werden.  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/cs/regex_example1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/vb/regex_example1.vb" id="Snippet1"::: 
  
 Da der reguläre Ausdruck in diesem Beispiel dynamisch erstellt wird, wissen wir zur Entwurfszeit nicht, ob das Währungssymbol der aktuellen Kultur, das Dezimalzeichen oder positive und negative Vorzeichen von der Engine für reguläre Ausdrücke möglicherweise als Operatoren für reguläre Ausdrücke interpretiert werden. Um eine Fehlinterpretation zu vermeiden, übergibt das Beispiel jede dynamisch generierte Zeichenfolge an die <xref:System.Text.RegularExpressions.Regex.Escape%2A>-Methode.  
  
 ]]></format>
    </remarks>
    <threadsafe>Die <see cref="T:System.Text.RegularExpressions.Regex" />-Klasse ist unveränderlich (schreibgeschützt) und Thread sicher. <see cref="T:System.Text.RegularExpressions.Regex" /> Objekte können in jedem Thread erstellt und von Threads gemeinsam verwendet werden. Weitere Informationen finden Sie unter [Thread Sicherheit](~/docs/standard/base-types/thread-safety-in-regular-expressions.md).</threadsafe>
    <altmember cref="T:System.Configuration.RegexStringValidator" />
    <related type="Article" href="~/docs/standard/base-types/regular-expressions.md">Reguläre Ausdrücke von .NET Framework</related>
    <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
    <related type="ExternalDocumentation" href="https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx">Reguläre Ausdrücke – Kurzübersicht (Download im Word-Format)</related>
    <related type="ExternalDocumentation" href="https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf">Reguläre Ausdrücke – Kurzübersicht (Download im PDF-Format)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass dieser Konstruktor geschützt ist. Sie kann nur von Klassen aufgerufen werden, die von der <xref:System.Text.RegularExpressions.Regex>-Klasse abgeleitet sind.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex pattern" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.RegularExpressions.Regex" />-Klasse für den angegebenen regulären Ausdruck.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `pattern`-Parameter besteht aus Sprachelementen für reguläre Ausdrücke, die die zu Übereinstimmungs enden Zeichen folgen symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie in den Themen [.NET Framework reguläre Ausdrücke](~/docs/standard/base-types/regular-expressions.md) und [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md) Übersicht.  
  
 Das Aufrufen des <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29> Konstruktors entspricht dem Aufrufen des <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29>-Konstruktors mit dem Wert <xref:System.Text.RegularExpressions.RegexOptions.None> für das `options`-Argument.  
  
 Ein <xref:System.Text.RegularExpressions.Regex>-Objekt ist unveränderlich. Dies bedeutet, dass es nur für das Übereinstimmungs Muster verwendet werden kann, das Sie bei der Erstellung definieren. Allerdings kann Sie beliebig oft verwendet werden, ohne dass Sie erneut kompiliert werden muss.  
  
 Dieser Konstruktor instanziiert ein Objekt für reguläre Ausdrücke, das versucht, die Groß-/Kleinschreibung von alphabetischen Zeichen zu vergleichen, die in `pattern`definiert sind. Verwenden Sie den <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>-Konstruktor, wenn die Groß-/Kleinschreibung nicht beachtet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie dieser Konstruktor verwendet wird, um einen regulären Ausdruck zu instanziieren, der mit einem beliebigen Wort übereinstimmt, das mit den Buchstaben "a" oder "t" beginnt.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/constructors1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/constructors1.vb" id="Snippet1":::
  
 Beachten Sie, dass das Muster für reguläre Ausdrücke nicht mit dem Wort "The" am Anfang des Texts identisch sein kann, da bei Vergleichen standardmäßig die Groß-/Kleinschreibung beachtet wird. Ein Beispiel für einen Vergleich ohne Beachtung der Groß-/Kleinschreibung finden Sie im <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29>-Konstruktor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pattern" /> ist <see langword="null" /></exception>
        <block subset="none" type="usage"><para>Dieser Konstruktor erstellt ein <see cref="T:System.Text.RegularExpressions.Regex" /> Objekt, das den Standard Timeout Wert der Anwendungsdomäne verwendet, in der er erstellt wird. Wenn für die Anwendungsdomäne kein Timeout Wert definiert wurde, verwendet das <see cref="T:System.Text.RegularExpressions.Regex" />-Objekt den Wert <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, wodurch verhindert wird, dass der Vorgang abgelaufen ist. Der empfohlene Konstruktor zum Erstellen eines <see cref="T:System.Text.RegularExpressions.Regex" /> Objekts ist <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, mit dem Sie das Timeout Intervall festlegen können.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="info">Das Objekt, das ein serialisiertes Muster und <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Informationen enthält.</param>
        <param name="context">Das Ziel für diese Serialisierung. (Dieser Parameter wird nicht verwendet, geben Sie <see langword="null" /> an.)</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.RegularExpressions.Regex" />-Klasse mithilfe von serialisierten Daten.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">Das Muster, das diese <paramref name="info" /> enthält, ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="info" /> enthält ein ungültiges <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Flag.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die den regulären Ausdruck ändern.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.RegularExpressions.Regex" />-Klasse für den angegebenen regulären Ausdruck mit Optionen zum Verändern des Musters.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `pattern`-Parameter besteht aus Sprachelementen für reguläre Ausdrücke, die die zu Übereinstimmungs enden Zeichen folgen symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie in den Themen [.NET Framework reguläre Ausdrücke](~/docs/standard/base-types/regular-expressions.md) und [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md) Übersicht.  
  
 Ein <xref:System.Text.RegularExpressions.Regex>-Objekt ist unveränderlich. Dies bedeutet, dass es nur für die Übereinstimmungs Parameter verwendet werden kann, die Sie beim Erstellen definieren. Allerdings kann Sie beliebig oft verwendet werden, ohne dass Sie erneut kompiliert werden muss.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie dieser Konstruktor verwendet wird, um einen regulären Ausdruck zu instanziieren, der mit einem beliebigen Wort übereinstimmt, das mit den Buchstaben "a" oder "t" beginnt.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/Constructors2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/Constructors2.vb" id="Snippet2":::
  
 Beachten Sie, dass die Match-Auflistung das Wort "The" enthält, das den Text beginnt, da der `options`-Parameter die Vergleiche ohne Berücksichtigung der Groß-/Kleinschreibung  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pattern" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> enthält ein ungültiges Flag.</exception>
        <block subset="none" type="usage"><para>Dieser Konstruktor erstellt ein <see cref="T:System.Text.RegularExpressions.Regex" /> Objekt, das den Standard Timeout Wert der Anwendungsdomäne verwendet, in der er erstellt wird. Wenn für die Anwendungsdomäne kein Timeout Wert definiert wurde, verwendet das <see cref="T:System.Text.RegularExpressions.Regex" />-Objekt den Wert <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, wodurch verhindert wird, dass der Vorgang abgelaufen ist. Der empfohlene Konstruktor zum Erstellen eines <see cref="T:System.Text.RegularExpressions.Regex" /> Objekts ist <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, mit dem Sie das Timeout Intervall festlegen können.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions, matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options, matchTimeout)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die den regulären Ausdruck ändern.</param>
        <param name="matchTimeout">Ein Timeoutintervall oder <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das angibt, dass die Methode kein Timeout haben sollte.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.RegularExpressions.Regex" />-Klasse für den angegebenen regulären Ausdruck mit Optionen, die das Muster und einen Wert ändern, der angibt, wie lange eine Mustervergleichsmethode versuchen sollte, eine Übereinstimmung zu finden, bevor ein Timeout eintritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `pattern`-Parameter besteht aus Sprachelementen für reguläre Ausdrücke, die die zu Übereinstimmungs enden Zeichen folgen symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie in den Themen [.NET Framework reguläre Ausdrücke](~/docs/standard/base-types/regular-expressions.md) und [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md) Übersicht.  
  
 Ein <xref:System.Text.RegularExpressions.Regex>-Objekt ist unveränderlich. Dies bedeutet, dass es nur für das Übereinstimmungs Muster verwendet werden kann, das Sie beim Erstellen definieren. Allerdings kann Sie beliebig oft verwendet werden, ohne dass Sie erneut kompiliert werden muss.  
  
 Der `matchTimeout`-Parameter gibt an, wie lange eine Muster Vergleichsmethode versuchen sollte, eine Übereinstimmung zu finden, bevor ein Timeout auftritt. Wenn in diesem Zeitintervall keine Übereinstimmung gefunden wird, löst die Muster Vergleichsmethode eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme aus. `matchTimeout` überschreibt jeden Standard Timeout Wert, der für die Anwendungsdomäne definiert ist, in der das <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Die instanzmusterübereinstimmungs-Methoden, die das `matchTimeout` Timeout Intervall beachten, umfassen Folgendes:  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%2A>  
  
-   <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>  
  
 Das Festlegen eines Timeout Intervalls verhindert, dass reguläre Ausdrücke, die auf einer übermäßigen Rückverfolgung basieren, nicht mehr reagieren, wenn Sie Eingaben verarbeiten, die Near-Übereinstimmungen enthalten. Weitere Informationen finden Sie unter [bewährte Methoden für reguläre Ausdrücke](~/docs/standard/base-types/best-practices.md) und [Rückverfolgung](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Berücksichtigen Sie die folgenden Faktoren, um ein angemessenes Timeout Intervall festzulegen:  
  
-   Die Länge und die Komplexität des Musters für reguläre Ausdrücke. Längere und komplexere reguläre Ausdrücke erfordern mehr Zeit als kürzere und einfachere.  
  
-   Der erwartete Computer Ladevorgang. Die Verarbeitung erfordert mehr Zeit für Systeme mit hoher CPU-und Arbeitsspeicher Auslastung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>-Konstruktor aufgerufen, um ein <xref:System.Text.RegularExpressions.Regex>-Objekt mit einem Timeout Wert von einer Sekunde zu instanziieren. Das Muster des regulären Ausdrucks `(a+)+$`, das mit mindestens einer Sequenz von einem oder mehreren "a"-Zeichen am Ende einer Zeile übereinstimmt, unterliegt übermäßiger Rückverfolgung. Wenn eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> ausgelöst wird, wird der Timeout Wert im Beispiel auf den maximalen Wert von drei Sekunden erhöht. Andernfalls wird der Versuch, das Muster abzugleichen, abgebrochen.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb" id="Snippet1"::: 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pattern" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> ist kein gültiger <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Wert.  
  
Oder 
 <paramref name="matchTimeout" /> ist negativ, null oder größer als ca. 24 Tage.</exception>
        <block subset="none" type="usage"><para>Es wird empfohlen, den <paramref name="matchTimeout" />-Parameter auf einen geeigneten Wert, z. b. zwei Sekunden, festzulegen. Wenn Sie Timeouts durch Angeben von <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />deaktivieren, bietet die Engine für reguläre Ausdrücke eine etwas bessere Leistung. Timeouts sollten jedoch nur unter den folgenden Bedingungen deaktiviert werden: 
: Wenn die von einem regulären Ausdruck verarbeitete Eingabe von einer bekannten und vertrauenswürdigen Quelle abgeleitet ist oder aus statischem Text besteht. Dies schließt Text aus, der von Benutzern dynamisch eingegeben wurde.  
  
: Wenn das Muster für reguläre Ausdrücke gründlich getestet wurde, um sicherzustellen, dass es Übereinstimmungen, nicht-Übereinstimmungen und NEAR-Übereinstimmungen effizient behandelt.  
  
-Wenn das Muster für reguläre Ausdrücke keine Sprachelemente enthält, die bekanntermaßen eine übermäßige Rückverfolgung verursachen, wenn eine nahe Übereinstimmung verarbeitet wird.</para></block>
        <related type="Article" href="~/docs/standard/base-types/backtracking-in-regular-expressions.md">Backtracking in regulären Ausdrücken</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="CacheSize">
      <MemberSignature Language="C#" Value="public static int CacheSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CacheSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CacheSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CacheSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CacheSize : int with get, set" Usage="System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Anzahl von Einträgen im aktuellen statischen Cache für die kompilierten regulären Ausdrücke ab oder legt diese fest.</summary>
        <value>Die maximale Anzahl von Einträgen im statischen Cache.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex>-Klasse verwaltet einen internen Cache kompilierter regulärer Ausdrücke, die in statischen Methoden aufrufen verwendet werden. Wenn der in einem Set-Vorgang angegebene Wert kleiner als die aktuelle Cache Größe ist, werden Cache Einträge verworfen, bis die Cache Größe dem angegebenen Wert entspricht.  
  
 Standardmäßig enthält der Cache 15 kompilierte statische reguläre Ausdrücke. Die Anwendung muss die Größe des Caches in der Regel nicht ändern. Verwenden Sie die <xref:System.Text.RegularExpressions.Regex.CacheSize%2A>-Eigenschaft nur, wenn Sie die Zwischenspeicherung deaktivieren möchten, oder wenn Sie über einen ungewöhnlich großen Cache verfügen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert in einem Set-Vorgang ist kleiner als 0 (null).</exception>
        <block subset="none" type="usage"><para>In der .NET Framework vor dem [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]wurden reguläre Ausdrücke zwischengespeichert, die sowohl in statischen als auch in Instanzmethodenaufrufen verwendet werden. Beginnend mit dem [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]werden nur reguläre Ausdrücke zwischengespeichert, die in statischen Methoden aufrufen verwendet werden.</para></block>
      </Docs>
    </Member>
    <Member MemberName="capnames">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable capnames;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable capnames" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capnames" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capnames As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ capnames;" />
      <MemberSignature Language="F#" Value="val mutable capnames : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.capnames" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CapNames">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary CapNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary CapNames" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CapNames" />
      <MemberSignature Language="VB.NET" Value="Protected Property CapNames As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ CapNames { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CapNames : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.CapNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Wörterbuch ab, das Erfassungsgruppen ihren Indexwerten zuordnet, oder legt es fest.</summary>
        <value>Ein Wörterbuch, das Erfassungsgruppen ihren Indexwerten zuordnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass diese Eigenschaft geschützt ist. auf Sie kann nur von einer Klasse zugegriffen werden, die von der <xref:System.Text.RegularExpressions.Regex>-Klasse abgeleitet wurde.  
  
 Ein Set-Vorgang versucht, den Wert, der der-Eigenschaft zugewiesen ist, zu einem <xref:System.Collections.Hashtable> Objekt zu konvertieren. Wenn diese Konvertierung fehlschlägt, wird der <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType>-Konstruktor aufgerufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der einer <see cref="P:System.Text.RegularExpressions.Regex.CapNames" />-Eigenschaft zugeordnete Wert in einer festgelegten Operation ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="caps">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable caps;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable caps" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.caps" />
      <MemberSignature Language="VB.NET" Value="Protected Friend caps As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ caps;" />
      <MemberSignature Language="F#" Value="val mutable caps : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.caps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Caps">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary Caps { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Caps" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Caps" />
      <MemberSignature Language="VB.NET" Value="Protected Property Caps As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ Caps { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Caps : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.Caps" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Wörterbuch ab oder legt es fest, das nummerierte Erfassungsgruppen ihren Indexwerten zuordnet.</summary>
        <value>Ein Wörterbuch, das nummerierte Erfassungsgruppen ihren Indexwerten zuordnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass diese Eigenschaft geschützt ist. auf Sie kann nur von einer Klasse zugegriffen werden, die von der <xref:System.Text.RegularExpressions.Regex>-Klasse abgeleitet wurde.  
  
 Ein Set-Vorgang versucht, den Wert, der der-Eigenschaft zugewiesen ist, zu einem <xref:System.Collections.Hashtable> Objekt zu konvertieren. Wenn diese Konvertierung fehlschlägt, wird der <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType>-Konstruktor aufgerufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der einer <see cref="P:System.Text.RegularExpressions.Regex.Caps" />-Eigenschaft zugeordnete Wert in einer festgelegten Operation ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="capsize">
      <MemberSignature Language="C#" Value="protected internal int capsize;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly int32 capsize" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capsize" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capsize As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected public: int capsize;" />
      <MemberSignature Language="F#" Value="val mutable capsize : int" Usage="System.Text.RegularExpressions.Regex.capsize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="capslist">
      <MemberSignature Language="C#" Value="protected internal string[] capslist;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string[] capslist" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capslist" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capslist As String() " />
      <MemberSignature Language="C++ CLI" Value="protected public: cli::array &lt;System::String ^&gt; ^ capslist;" />
      <MemberSignature Language="F#" Value="val mutable capslist : string[]" Usage="System.Text.RegularExpressions.Regex.capslist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompileToAssembly">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kompiliert reguläre Ausdrücke und speichert diese in einer einzelnen Assembly auf der Festplatte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

In .net Core lösen Aufrufe der `Regex.CompileToAssembly`-Methode eine <xref:System.PlatformNotSupportedException>aus. das Schreiben einer Assembly wird nicht unterstützt.
  
       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CompileToAssembly (regexinfos As RegexCompilationInfo(), assemblyname As AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Ein Array, das die zu kompilierenden regulären Ausdrücke beschreibt.</param>
        <param name="assemblyname">Der Dateiname der Assembly.</param>
        <summary>Kompiliert ein oder mehrere angegebene <see cref="T:System.Text.RegularExpressions.Regex" />-Objekte in eine benannte Assembly.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29>-Methode generiert eine .NET Framework Assembly, in der jeder reguläre Ausdruck, der im `regexinfos` Array definiert ist, durch eine-Klasse dargestellt wird. In der Regel wird die <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29>-Methode von einer separaten Anwendung aufgerufen, die eine Assembly der kompilierten regulären Ausdrücke generiert. Jeder reguläre Ausdruck, der in der Assembly enthalten ist, weist die folgenden Eigenschaften auf:  
  
-   Sie wird von der <xref:System.Text.RegularExpressions.Regex>-Klasse abgeleitet.  
  
-   Ihm wird der voll qualifizierte Name zugewiesen, der durch die `fullnamespace`-und `name` Parameter des entsprechenden <xref:System.Text.RegularExpressions.RegexCompilationInfo> Objekts definiert wird.  
  
-   Es verfügt über einen Standard-Konstruktor (oder einen Parameter losen).  
  
 Normalerweise befindet sich der Code, der den kompilierten regulären Ausdruck instanziiert und verwendet, in einer Assembly oder Anwendung, die von dem Code getrennt ist, der die Assembly erstellt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Assembly mit dem Namen RegExLib. dll erstellt. Die Assembly enthält zwei kompilierte reguläre Ausdrücke. Der erste, `Utilities.RegularExpressions.DuplicatedString`entspricht zwei identischen zusammenhängenden Wörtern. Mit dem zweiten `Utilities.RegularExpressions.EmailAddress`wird überprüft, ob eine Zeichenfolge das richtige Format für eine e-Mail-Adresse hat.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile1.vb#1)]  
  
 Der reguläre Ausdruck, der eine Zeichenfolge auf doppelte Wörter überprüft, wird dann instanziiert und im folgenden Beispiel verwendet.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Die erfolgreiche Kompilierung dieses zweiten Beispiels erfordert, dass ein Verweis auf "RegExLib. dll" (die im ersten Beispiel erstellte Assembly) dem Projekt hinzugefügt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Wert der <see cref="P:System.Reflection.AssemblyName.Name" />-Eigenschaft des <paramref name="assemblyname" />-Parameters ist eine leere oder eine NULL-Zeichenfolge.  
  
Oder 
Das Muster des regulären Ausdrucks eines oder mehrerer Objekte in <paramref name="regexinfos" /> enthält eine ungültige Syntax.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyname" /> oder <paramref name="regexinfos" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Das Erstellen einer Assembly aus kompilierten regulären Ausdrücken wird nicht unterstützt.</exception>
        <block subset="none" type="usage"><para>Wenn Sie auf einem System entwickeln, auf dem [!INCLUDE[net_v45](~/includes/net-v45-md.md)] oder seine Punkt Releases installiert sind, verwenden Sie [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], und Sie verwenden die <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />-Methode, um eine Assembly zu erstellen, die kompilierte reguläre Ausdrücke enthält. Wenn Sie versuchen, einen der regulären Ausdrücke in dieser Assembly auf einem System zu verwenden, das [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] enthält, wird eine Ausnahme ausgelöst. Um dieses Problem zu umgehen, haben Sie die folgenden Möglichkeiten: 
-Erstellen Sie die Assembly, die die kompilierten regulären Ausdrücke enthält, auf einem System, das über [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] verfügt, anstatt spätere Versionen zu installieren.  
  
-Anstatt <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> aufzurufen und den kompilierten regulären Ausdruck aus einer Assembly abzurufen, verwenden Sie entweder statische Methoden oder Instanzen <see cref="T:System.Text.RegularExpressions.Regex" /> Methoden mit der <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />-Option, wenn Sie ein <see cref="T:System.Text.RegularExpressions.Regex" /> Objekt instanziieren oder eine Muster Vergleichsmethode für reguläre Ausdrücke aufrufen.</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Kompilierung und Wiederverwendung</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CompileToAssembly (regexinfos As RegexCompilationInfo(), assemblyname As AssemblyName, attributes As CustomAttributeBuilder())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Ein Array, das die zu kompilierenden regulären Ausdrücke beschreibt.</param>
        <param name="assemblyname">Der Dateiname der Assembly.</param>
        <param name="attributes">Ein Array, das die auf die Assembly anzuwendenden Attribute definiert.</param>
        <summary>Kompiliert ein oder mehrere angegebene <see cref="T:System.Text.RegularExpressions.Regex" />-Objekte in eine benannte Assembly mit den angegebenen Attributen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29>-Methode generiert eine .NET Framework Assembly, in der jeder reguläre Ausdruck, der im `regexinfos` Array definiert ist, durch eine-Klasse dargestellt wird. In der Regel wird die <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29>-Methode von einer separaten Anwendung aufgerufen, die eine Assembly der kompilierten regulären Ausdrücke generiert. Jeder reguläre Ausdruck, der in der Assembly enthalten ist, weist die folgenden Eigenschaften auf:  
  
-   Sie wird von der <xref:System.Text.RegularExpressions.Regex>-Klasse abgeleitet.  
  
-   Ihm wird der voll qualifizierte Name zugewiesen, der durch die `fullnamespace`-und `name` Parameter des entsprechenden <xref:System.Text.RegularExpressions.RegexCompilationInfo> Objekts definiert wird.  
  
-   Es verfügt über einen Standard-Konstruktor (oder einen Parameter losen).  
  
 Normalerweise befindet sich der Code, der den kompilierten regulären Ausdruck instanziiert und verwendet, in einer Assembly oder Anwendung, die von dem Code getrennt ist, der die Assembly erstellt.  
  
 Da die <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> Methode generiert eine .NET Framework-Assembly aus einem Methodenaufruf anstelle einer bestimmten Sprache Class Definition-Schlüsselwort (z. B. `class` in c# oder `Class`...`End Class` in Visual Basic) können .NET Framework Attribute der Assembly nicht mithilfe der Standard Attribut Syntax der Entwicklungssprache zugewiesen werden. Der `attributes`-Parameter stellt eine alternative Methode zum Definieren der Attribute bereit, die auf die Assembly angewendet werden. Führen Sie für jedes Attribut, das Sie auf die Assembly anwenden möchten, folgende Schritte aus:  
  
1.  Erstellen Sie ein Array von <xref:System.Type>-Objekten, die die Parametertypen des Attributkonstruktors darstellen, den Sie aufrufen möchten.  
  
2.  Rufen Sie ein <xref:System.Type> Objekt ab, das die Attribut Klasse darstellt, die Sie auf die neue Assembly anwenden möchten.  
  
3.  Rufen Sie die <xref:System.Type.GetConstructor%2A>-Methode des-Attributs <xref:System.Type>-Objekt auf, um ein <xref:System.Reflection.ConstructorInfo> Objekt abzurufen, das den Attributkonstruktor darstellt, den Sie aufrufen möchten. Übergeben Sie die <xref:System.Type.GetConstructor%2A>-Methode als Array von <xref:System.Type>-Objekten, das die Parametertypen des Konstruktors darstellt.  
  
4.  Erstellen Sie ein <xref:System.Object> Array, das die Parameter definiert, die an den Konstruktor des Attributs übergeben werden.  
  
5.  Instanziieren Sie ein <xref:System.Reflection.Emit.CustomAttributeBuilder> Objekt, indem Sie dessen Konstruktor das in Schritt 3 abgerufene <xref:System.Reflection.ConstructorInfo> Objekt und das in Schritt 4 erstellte <xref:System.Object> Array übergeben.  
  
 Sie können ein Array dieser <xref:System.Reflection.Emit.CustomAttributeBuilder> Objekte anstelle des `attributes`-Parameters an die <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType>-Methode übergeben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Assembly mit dem Namen RegExLib. dll erstellt und das <xref:System.Reflection.AssemblyTitleAttribute>-Attribut darauf angewendet. Die Assembly enthält zwei kompilierte reguläre Ausdrücke. Der erste, `Utilities.RegularExpressions.DuplicatedString`entspricht zwei identischen zusammenhängenden Wörtern. Mit dem zweiten `Utilities.RegularExpressions.EmailAddress`wird überprüft, ob eine Zeichenfolge das richtige Format für eine e-Mail-Adresse hat.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile3.vb#3)]  
  
 Sie können überprüfen, ob das <xref:System.Reflection.AssemblyTitleAttribute>-Attribut auf die Assembly angewendet wurde, indem Sie das Manifest mit einem Reflektionsobjekt wie Ildasm untersuchen.  
  
 Der reguläre Ausdruck, der eine Zeichenfolge auf doppelte Wörter überprüft, wird dann instanziiert und im folgenden Beispiel verwendet.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Die erfolgreiche Kompilierung dieses zweiten Beispiels erfordert, dass ein Verweis auf "RegExLib. dll" (die im ersten Beispiel erstellte Assembly) dem Projekt hinzugefügt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Wert der <see cref="P:System.Reflection.AssemblyName.Name" />-Eigenschaft des <paramref name="assemblyname" />-Parameters ist eine leere oder eine NULL-Zeichenfolge.  
  
Oder 
Das Muster des regulären Ausdrucks eines oder mehrerer Objekte in <paramref name="regexinfos" /> enthält eine ungültige Syntax.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyname" /> oder <paramref name="regexinfos" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Das Erstellen einer Assembly aus kompilierten regulären Ausdrücken wird nicht unterstützt.</exception>
        <block subset="none" type="usage"><para>Wenn Sie auf einem System entwickeln, auf dem [!INCLUDE[net_v45](~/includes/net-v45-md.md)] oder seine Punkt Releases installiert sind, verwenden Sie [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], und Sie verwenden die <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />-Methode, um eine Assembly zu erstellen, die kompilierte reguläre Ausdrücke enthält. Wenn Sie versuchen, einen der regulären Ausdrücke in dieser Assembly auf einem System zu verwenden, das [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] enthält, wird eine Ausnahme ausgelöst. Um dieses Problem zu umgehen, haben Sie die folgenden Möglichkeiten: 
-Erstellen Sie die Assembly, die die kompilierten regulären Ausdrücke enthält, auf einem System, das über [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] verfügt, anstatt spätere Versionen zu installieren.  
  
-Anstatt <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> aufzurufen und den kompilierten regulären Ausdruck aus einer Assembly abzurufen, verwenden Sie entweder statische Methoden oder Instanzen <see cref="T:System.Text.RegularExpressions.Regex" /> Methoden mit der <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />-Option, wenn Sie ein <see cref="T:System.Text.RegularExpressions.Regex" /> Objekt instanziieren oder eine Muster Vergleichsmethode für reguläre Ausdrücke aufrufen.</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Kompilierung und Wiederverwendung</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CompileToAssembly (regexinfos As RegexCompilationInfo(), assemblyname As AssemblyName, attributes As CustomAttributeBuilder(), resourceFile As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes, System::String ^ resourceFile);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] * string -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes, resourceFile)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="resourceFile" Type="System.String" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Ein Array, das die zu kompilierenden regulären Ausdrücke beschreibt.</param>
        <param name="assemblyname">Der Dateiname der Assembly.</param>
        <param name="attributes">Ein Array, das die auf die Assembly anzuwendenden Attribute definiert.</param>
        <param name="resourceFile">Der Name der in die Assembly einzufügenden Win32-Ressourcendatei.</param>
        <summary>Kompiliert ein oder mehrere angegebene <see cref="T:System.Text.RegularExpressions.Regex" />-Objekte und eine angegebene Ressourcendatei in eine benannte Assembly mit den angegebenen Attributen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der [\], AssemblyName, CustomAttributeBuilder\<Xref: System. Text. RegularExpressions. Regex. compileto Assembly% 28system. Text. RegularExpressions. RegexCompilationInfo% 5B% 5D% 2csystem. Reflection. AssemblyName% 2csystem. Reflection. ausgeben. CustomAttributeBuilder% 5B% 5D% 2csystem. String %29 > Methode generiert eine .NET Framework Assembly, in der jeder reguläre Ausdruck, der im `regexinfos` Array definiert ist, durch eine Klasse dargestellt wird In der Regel ist [\], AssemblyName, CustomAttributeBuilder\<Xref: System. Text. RegularExpressions. Regex. compilecomassembly% 28system. Text. RegularExpressions. RegexCompilationInfo% 5B% 5D% 2csystem. Reflection. AssemblyName% 2csystem. Reflection. ausgeben. CustomAttributeBuilder% 5B% 5D% 2csystem. String %29 >-Methode wird von einer separaten Anwendung aufgerufen, die eine Assembly der kompilierten regulären Ausdrücke generiert. Jeder reguläre Ausdruck, der in der Assembly enthalten ist, weist die folgenden Eigenschaften auf:  
  
-   Sie wird von der <xref:System.Text.RegularExpressions.Regex>-Klasse abgeleitet.  
  
-   Ihm wird der voll qualifizierte Name zugewiesen, der durch die `fullnamespace`-und `name` Parameter des entsprechenden <xref:System.Text.RegularExpressions.RegexCompilationInfo> Objekts definiert wird.  
  
-   Es verfügt über einen Standard-Konstruktor (oder einen Parameter losen).  
  
 Normalerweise befindet sich der Code, der den kompilierten regulären Ausdruck instanziiert und verwendet, in einer Assembly oder Anwendung, die von dem Code getrennt ist, der die Assembly erstellt.  
  
 Da die <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> Methode generiert eine .NET Framework-Assembly aus einem Methodenaufruf anstelle einer bestimmten Sprache Class Definition-Schlüsselwort (z. B. `class` in c# oder `Class`...`End Class` in Visual Basic) können .NET Framework Attribute der Assembly nicht mithilfe der Standard Attribut Syntax der Entwicklungssprache zugewiesen werden. Der `attributes`-Parameter stellt eine alternative Methode zum Definieren der Attribute bereit, die auf die Assembly angewendet werden. Führen Sie für jedes Attribut, das Sie auf die Assembly anwenden möchten, folgende Schritte aus:  
  
1.  Erstellen Sie ein Array von <xref:System.Type>-Objekten, die die Parametertypen des Attributkonstruktors darstellen, den Sie aufrufen möchten.  
  
2.  Rufen Sie ein <xref:System.Type> Objekt ab, das die Attribut Klasse darstellt, die Sie auf die neue Assembly anwenden möchten.  
  
3.  Rufen Sie die <xref:System.Type.GetConstructor%2A>-Methode des-Attributs <xref:System.Type>-Objekt auf, um ein <xref:System.Reflection.ConstructorInfo> Objekt abzurufen, das den Attributkonstruktor darstellt, den Sie aufrufen möchten. Übergeben Sie die <xref:System.Type.GetConstructor%2A>-Methode als Array von <xref:System.Type> Objekten, das die Parametertypen des Konstruktors darstellt.  
  
4.  Erstellen Sie ein <xref:System.Object> Array, das die Parameter definiert, die an den Konstruktor des Attributs übergeben werden.  
  
5.  Instanziieren Sie ein <xref:System.Reflection.Emit.CustomAttributeBuilder> Objekt, indem Sie dessen Konstruktor das in Schritt 3 abgerufene <xref:System.Reflection.ConstructorInfo> Objekt und das in Schritt 4 erstellte <xref:System.Object> Array übergeben.  
  
 Sie können ein Array dieser <xref:System.Reflection.Emit.CustomAttributeBuilder> Objekte anstelle des `attributes`-Parameters an den [\], AssemblyName, CustomAttributeBuilder\<Xref: System. Text übergeben. RegularExpressions. Regex. CompileToAssembly% 28system. Text. RegularExpressions. RegexCompilationInfo% 5B% 5D% 2csystem. Reflection. AssemblyName% 2csystem. Reflection. ausgeben. CustomAttributeBuilder% 5B% 5D% 2csystem. String %29 >-Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Wert der <see cref="P:System.Reflection.AssemblyName.Name" />-Eigenschaft des <paramref name="assemblyname" />-Parameters ist eine leere oder eine NULL-Zeichenfolge.  
  
Oder 
Das Muster des regulären Ausdrucks eines oder mehrerer Objekte in <paramref name="regexinfos" /> enthält eine ungültige Syntax.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyname" /> oder <paramref name="regexinfos" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Der <paramref name="resourceFile" />-Parameter legt eine ungültige Win32-Ressourcendatei fest.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die vom <paramref name="resourceFile" />-Parameter angegebene Datei kann nicht gefunden werden.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Das Erstellen einer Assembly aus kompilierten regulären Ausdrücken wird nicht unterstützt.</exception>
        <block subset="none" type="usage"><para>Wenn Sie auf einem System entwickeln, auf dem [!INCLUDE[net_v45](~/includes/net-v45-md.md)] oder seine Punkt Releases installiert sind, verwenden Sie [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], und Sie verwenden die <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />-Methode, um eine Assembly zu erstellen, die kompilierte reguläre Ausdrücke enthält. Wenn Sie versuchen, einen der regulären Ausdrücke in dieser Assembly auf einem System zu verwenden, das [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] enthält, wird eine Ausnahme ausgelöst. Um dieses Problem zu umgehen, haben Sie die folgenden Möglichkeiten: 
-Erstellen Sie die Assembly, die die kompilierten regulären Ausdrücke enthält, auf einem System, das über [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] verfügt, anstatt spätere Versionen zu installieren.  
  
-Anstatt <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> aufzurufen und den kompilierten regulären Ausdruck aus einer Assembly abzurufen, verwenden Sie entweder statische Methoden oder Instanzen <see cref="T:System.Text.RegularExpressions.Regex" /> Methoden mit der <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />-Option, wenn Sie ein <see cref="T:System.Text.RegularExpressions.Regex" /> Objekt instanziieren oder eine Muster Vergleichsmethode für reguläre Ausdrücke aufrufen.</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Kompilierung und Wiederverwendung</related>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="public static string Escape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Escape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Escape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Escape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Escape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Escape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Die Eingabezeichenfolge mit dem zu konvertierenden Text.</param>
        <summary>Versieht einen minimalen Satz an Zeichen (\\, *, +, ?, |, {, [, (,), ^, $,., # und Leerzeichen) mit Escapezeichen, indem diese durch die jeweils entsprechende Escapesequenz ersetzt werden. Damit wird die Engine für reguläre Ausdrücke angewiesen, diese Zeichen als Literale statt als Metazeichen zu interpretieren.</summary>
        <returns>Eine Zeichenfolge, in der Metazeichen in die entsprechenden Escapecodes konvertiert wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Escape%2A> konvertiert eine Zeichenfolge so, dass die Engine für reguläre Ausdrücke alle Metazeichen interpretiert, die Sie möglicherweise als Zeichen Literale enthalten. Stellen Sie sich beispielsweise einen regulären Ausdruck vor, der zum Extrahieren von Kommentaren konzipiert ist, die durch gerade öffnende und schließende eckige Klammern ([und]) von Text getrennt sind. Im folgenden Beispiel wird der reguläre Ausdruck "[(. *?)]" als Zeichenklasse interpretiert. Anstelle von im Eingabetext eingebetteten Kommentaren vergleicht der reguläre Ausdruck jede öffnende oder schließende Klammer, jeden Zeitraum, dieses Sternchen oder dieses Fragezeichen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#1)]  
  
 Wenn die öffnende eckige Klammer jedoch durch die Übergabe an die <xref:System.Text.RegularExpressions.Regex.Escape%2A>-Methode geschützt wird, wird der reguläre Ausdruck beim Abgleichen von Kommentaren, die in die Eingabe Zeichenfolge eingebettet sind, erfolgreich ausgeführt. Dies wird anhand des folgenden Beispiels veranschaulicht.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#2)]  
  
 In einem regulären Ausdruck, der mithilfe von statischem Text definiert wird, können Zeichen, die buchstäblich anstelle von Metazeichen interpretiert werden sollen, mit einem umgekehrten Schrägstrich (\\) und durch Aufrufen der <xref:System.Text.RegularExpressions.Regex.Escape%2A>-Methode versehen werden. In einem regulären Ausdruck, der dynamisch mithilfe von Zeichen definiert wird, die zur Entwurfszeit nicht bekannt sind, ist das Aufrufen der <xref:System.Text.RegularExpressions.Regex.Escape%2A>-Methode besonders wichtig, um sicherzustellen, dass die Engine für reguläre Ausdrücke einzelne Zeichen als Literale anstelle von Metazeichen interpretiert.  
  
> [!NOTE]
>  Wenn ein Muster eines regulären Ausdrucks entweder das Nummern Zeichen (#) oder Literale Leerzeichen enthält, müssen Sie mit Escapezeichen versehen werden, wenn der Eingabetext mit aktivierter <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> Option analysiert wird.  
  
 Während der <xref:System.Text.RegularExpressions.Regex.Escape%2A> -Methode versieht gerade Klammer ([) öffnen und geschweifte Klammer ({)-Zeichen, es ist nicht mit Escapezeichen versehen die entsprechenden Zeichen schließen (] und}). In den meisten Fällen ist das Escapezeichen nicht erforderlich. Wenn eine schließende eckige Klammer oder geschweifte Klammer nicht mit dem entsprechenden öffnenden Zeichen vorangestellt ist, interpretiert die Engine für reguläre Ausdrücke Sie als literalweise. Wenn eine öffnende eckige Klammer oder geschweifte Klammer als Metazeichen interpretiert wird, interpretiert die Engine für reguläre Ausdrücke das erste entsprechende schließende Zeichen als Metazeichen. Wenn dies nicht das gewünschte Verhalten ist, muss die schließende Klammer oder geschweifte Klammer mit Escapezeichen versehen werden, indem der umgekehrte Schrägstrich (\\) explizit vorangestellt wird. Eine Abbildung finden Sie im Beispiel Abschnitt.  
  
   
  
## Examples  
 Im folgenden Beispiel werden Kommentare aus Text extrahiert. Dabei wird davon ausgegangen, dass die Kommentare durch ein Begin Comment-Symbol und ein Symbol für das Ende des Kommentars getrennt sind, das vom Benutzer ausgewählt wird. Da die Kommentar Symbole buchstäblich interpretiert werden sollen, werden Sie an die <xref:System.Text.RegularExpressions.Regex.Escape%2A>-Methode übergeben, um sicherzustellen, dass Sie nicht als Metazeichen interpretiert werden können. Außerdem wird im Beispiel explizit überprüft, ob das vom Benutzer eingegebene Symbol für das Ende des Kommentars eine schließende eckige Klammer (]) oder geschweifte Klammer (}) ist. Wenn dies der Fall ist, wird der Klammer oder der geschweiften Klammer ein umgekehrter Schrägstrich (\\) vorangestellt, sodass Sie buchstäblich interpretiert wird. Beachten Sie, dass im Beispiel auch die <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> Auflistung verwendet wird, um nur den Kommentar anzuzeigen, anstatt den Kommentar mit seinen öffnenden und schließenden Kommentar Symbolen anzuzeigen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> ist <see langword="null" /></exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
        <related type="Article" href="~/docs/standard/base-types/character-escapes-in-regular-expressions.md">Escapezeichen in regulären Ausdrücken</related>
      </Docs>
    </Member>
    <Member MemberName="factory">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexRunnerFactory factory;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Text.RegularExpressions.RegexRunnerFactory factory" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.factory" />
      <MemberSignature Language="VB.NET" Value="Protected Friend factory As RegexRunnerFactory " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexRunnerFactory ^ factory;" />
      <MemberSignature Language="F#" Value="val mutable factory : System.Text.RegularExpressions.RegexRunnerFactory" Usage="System.Text.RegularExpressions.Regex.factory" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexRunnerFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Regex ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="regex.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dieser Member überschreibt <see cref="M:System.Object.Finalize" />. Das zugehörige Thema enthält möglicherweise eine umfassendere Dokumentation.

Gibt einem <see cref="T:System.Object" /> Gelegenheit zu dem Versuch, Ressourcen freizugeben und andere Bereinigungen durchzuführen, bevor das <see cref="T:System.Object" /> von der Garbage Collection freigegeben wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNames">
      <MemberSignature Language="C#" Value="public string[] GetGroupNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetGroupNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetGroupNames();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNames : unit -&gt; string[]" Usage="regex.GetGroupNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Array der Namen von Erfassungsgruppen für den regulären Ausdruck zurück.</summary>
        <returns>Ein Zeichenfolgenarray von Gruppennamen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Auflistung von Gruppennamen enthält den Satz von Zeichen folgen, die zum Benennen von Erfassungs Gruppen im Ausdruck verwendet werden. Selbst wenn Erfassungs Gruppen nicht explizit benannt werden, werden Ihnen automatisch numerische Namen zugewiesen ("0", "1", "2", "3" usw.). Die benannte Gruppe "0" stellt den gesamten Text dar, der mit dem Muster für reguläre Ausdrücke übereinstimmt. Nummerierte Gruppen werden explizit benannten Gruppen in der Auflistung vorangestellt, und benannte Gruppen werden in der Reihenfolge angezeigt, in der Sie im Muster für reguläre Ausdrücke definiert sind.  
  
 Sie können die <xref:System.Array.Length%2A>-Eigenschaft für das von dieser Methode zurückgegebene Array verwenden, um die Anzahl der Gruppen in einem regulären Ausdruck zu ermitteln.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine allgemeine `ShowMatches`-Methode definiert, die die Namen von Gruppen für reguläre Ausdrücke und deren übereinstimmenden Text anzeigt.  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/cs/getgroupnames1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/vb/getgroupnames1.vb" id="Snippet1":::
  
 In diesem Fall soll das Muster für reguläre Ausdrücke `\b(?<FirstWord>\w+)\s?((\w+)\s)*(?<LastWord>\w+)?(?<Punctuation>\p{Po})` einen einfachen Satz analysieren und sein erstes Wort, letztes Wort und endinterpunktions Zeichen identifizieren. In der folgenden Tabelle wird gezeigt, wie das Muster für reguläre Ausdrücke interpretiert wird:  
  
|Muster|BESCHREIBUNG|  
|-------------|-----------------|  
|`\b`|Der Vergleich beginnt an einer Wortgrenze.|  
|`(?<FirstWord>\w+)`|Übereinstimmung mit mindestens einem Wortzeichen. Dies ist der `FirstWord` benannte Gruppe.|  
|\s?|Sucht nach einer Übereinstimmung mit keinem oder einem Leerzeichen.|  
|(\w+)|Übereinstimmung mit mindestens einem Wortzeichen. Dies ist die zweite Erfassungsgruppe.|  
|\s|Entsprechung für ein Leerraumzeichen finden.|  
|((\w+)\s)*|Entsprechung für NULL oder mehr Vorkommen eines oder mehrerer Wort Zeichen, gefolgt von einem Leerzeichen. Dies ist die erste Erfassungsgruppe.|  
|(?\<LastWord > \w +)?|Entspricht keinem oder einem Vorkommen von mindestens einem Wort Zeichen. Dies ist der `LastWord` benannte Gruppe.|  
|(?\<Satzzeichen > \p{Po})|Entsprechung für ein Zeichen, dessen Unicode-Kategorie Interpunktions Zeichen ist. Dies ist der `Punctuation` benannte Gruppe.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md">Gruppierungskonstrukte in regulären Ausdrücken</related>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNumbers">
      <MemberSignature Language="C#" Value="public int[] GetGroupNumbers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] GetGroupNumbers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNumbers () As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ GetGroupNumbers();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNumbers : unit -&gt; int[]" Usage="regex.GetGroupNumbers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Array der Nummern von Erfassungsgruppen zurück, die den Gruppennamen in einem Array entsprechen.</summary>
        <returns>Ein Ganzzahlarray der Gruppennummern.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Zugriff auf unbenannte und benannte Erfassungs Gruppen ist nach Nummer möglich. Unbenannte Gruppen werden von links nach rechts nummeriert, beginnend mit 1. (Die Erfassungs Gruppe im Index 0 (null) stellt die Entsprechung als Ganzes dar.)  Benannte Gruppen werden dann von links nach rechts nummeriert, beginnend mit einer Zahl, die einen Wert größer als die Anzahl der unbenannten Erfassungs Gruppen ist.  
  
 Das verweisen auf eine Gruppe anhand ihrer Zahl anstelle von Zeichen folgen Namen kann einen schnelleren Zugriff ermöglichen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein regulärer Ausdruck (`\b((?<word>\w+)\s*)+(?<end>[.?!])`) definiert, der mit einem Satz übereinstimmt. Der reguläre Ausdruck enthält drei Erfassungs Gruppen: eine unbenannte Gruppe, die ein einzelnes Wort zusammen mit einem Leerzeichen erfasst, das möglicherweise befolgt wird. eine Gruppe mit dem Namen `word`, in der die einzelnen Wörter im Satz erfasst werden. und eine Gruppe mit dem Namen `end`, die die Interpunktions Zeichen erfasst, die den Satz beenden. Das Beispiel ruft die <xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A>-Methode auf, um die Zahlen aller Erfassungs Gruppen zu erhalten, und zeigt dann die erfasste Zeichenfolge an. Außerdem wird die <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A>-Methode verwendet, um anzugeben, ob eine bestimmte nummerierte Gruppe einer benannten Gruppe entspricht.  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/cs/getgroupnumbers1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/vb/getgroupnumbers1.vb" id="Snippet1":::
  
 Das Muster für reguläre Ausdrücke wird entsprechend der folgenden Tabelle interpretiert.  
  
|Muster|BESCHREIBUNG|  
|-------------|-----------------|  
|`\b`|Der Vergleich beginnt an einer Wortgrenze.|  
|`(?<word>\w+)`|Übereinstimmung mit mindestens einem Wort Zeichen und Zuweisen der übereinstimmenden Zeichen folgen zu einer Gruppe mit dem Namen `word`.|  
|`\s*`|Sucht nach 0 (null) oder mehr Leerzeichen.|  
|`((?<word>\w+)\s*)`|Weisen Sie der ersten erfassten Gruppe die `word` erfasste Gruppe gefolgt von aufgezeichneten Leerzeichen zu.|  
|`((?<word>\w+)\s*)+`|Vergleichen Sie das Muster von mindestens einem Wort Zeichen, gefolgt von einem oder mehreren Leerzeichen.|  
|`(?<end>[.?!])`|Übereinstimmung mit einem Punkt, Fragezeichen oder Ausrufezeichen. Weisen Sie das übereinstimmende Zeichen der `end` Erfassungs Gruppe zu.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md">Gruppierungskonstrukte in regulären Ausdrücken</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNameFromNumber">
      <MemberSignature Language="C#" Value="public string GroupNameFromNumber (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GroupNameFromNumber(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNameFromNumber (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GroupNameFromNumber(int i);" />
      <MemberSignature Language="F#" Value="member this.GroupNameFromNumber : int -&gt; string" Usage="regex.GroupNameFromNumber i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Die Gruppennummer, die in den entsprechenden Gruppennamen konvertiert werden soll.</param>
        <summary>Ruft den Gruppennamen ab, der der angegebenen Gruppennummer entspricht.</summary>
        <returns>Eine Zeichenfolge, die den Gruppennamen enthält, der der angegebenen Gruppennummer zugeordnet ist. Wenn kein Gruppenname vorhanden ist, der <paramref name="i" /> entspricht, gibt die Methode <see cref="F:System.String.Empty" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Muster für reguläre Ausdrücke kann entweder benannte oder nummerierte Erfassungs Gruppen enthalten, die Teil Ausdrücke innerhalb einer Muster Übereinstimmung definieren. Nummerierte Gruppen werden durch die*Syntax (Teil*Ausdruck) getrennt, und Ihnen werden basierend auf ihrer Reihenfolge im regulären Ausdruck Zahlen zugewiesen. Benannte Gruppen werden durch die Syntax (?`<`*Name* *`>`Teil*Ausdruck) oder (?) getrennt. *Name*'*Teil*Ausdruck ', wobei *Name* der Name ist, mit dem der Teil Ausdruck identifiziert wird. (Weitere Informationen finden Sie unter [Gruppierungskonstrukte](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md).) Die <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A>-Methode identifiziert sowohl benannte Gruppen als auch nummerierte Gruppen durch ihre Ordinalpositionen im regulären Ausdruck. Die Ordinalposition NULL stellt immer den gesamten regulären Ausdruck dar. Alle nummerierten Gruppen werden dann vor benannten Gruppen gezählt, unabhängig von ihrer tatsächlichen Position im Muster für reguläre Ausdrücke.  
  
 Wenn `i` die Nummer einer benannten Gruppe ist, gibt die Methode den Namen der Gruppe zurück. Wenn `i` die Nummer einer unbenannten Gruppe ist, gibt die Methode die Zeichen folgen Darstellung der Zahl zurück. Wenn `i` z. b. 1 ist, gibt die Methode "1" zurück. Wenn `i` nicht die Nummer einer Erfassungs Gruppe ist, gibt die Methode <xref:System.String.Empty?displayProperty=nameWithType>zurück.  
  
 Wenn eine Muster Übereinstimmung gefunden wird, kann der Wert, der von dieser Methode zurückgegeben wird, verwendet werden, um das <xref:System.Text.RegularExpressions.Group> Objekt, das die erfasste Gruppe darstellt, aus der <xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType>-Eigenschaft abzurufen. Das <xref:System.Text.RegularExpressions.GroupCollection> Objekt wird von der <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType>-Eigenschaft zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Muster für reguläre Ausdrücke definiert, das mit einer Adresszeile übereinstimmt, die einen US-City-Namen, Zustands Amen und eine Postleitzahl enthält. Im Beispiel wird die <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A>-Methode verwendet, um die Namen der Erfassungs Gruppen abzurufen. Anschließend werden diese Namen verwendet, um die entsprechenden erfassten Gruppen für Übereinstimmungen abzurufen.  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/cs/groupnamefromnumberex.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/vb/groupnamefromnumberex.vb" id="Snippet1"::: 
  
 Das Muster für reguläre Ausdrücke wird durch den folgenden Ausdruck definiert:  
  
 `(?<city>[A-Za-z\s]+), (?<state>[A-Za-z]{2}) (?<zip>\d{5}(-\d{4})?)`  
  
 Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.  
  
|Muster|BESCHREIBUNG|  
|-------------|-----------------|  
|`(?<city>[A-Za-z\s]+)`|Entsprechung für ein oder mehrere alphabetische Zeichen oder Leerzeichen. Weisen Sie diese erfasste Gruppe dem Namen `city`zu.|  
|`,`|Entsprechung für ein Komma (,), gefolgt von einem Leerzeichen.|  
|`(?<state>[A-Za-z]{2})`|Entsprechung für zwei alphabetische Zeichen. Weisen Sie diese erfasste Gruppe dem Namen `state`zu. Auf diese Gruppe muss ein Leerzeichen folgen.|  
|`(?<zip>\d{5}(-\d{4})?)`|Vergleichen Sie fünf numerische Ziffern, gefolgt von NULL oder einem Vorkommen eines Bindestrichs, gefolgt von vier Ziffern. Weisen Sie diese erfasste Gruppe dem Namen `zip`zu.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
        <related type="Article" href="~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md">Gruppierungskonstrukte in regulären Ausdrücken</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNumberFromName">
      <MemberSignature Language="C#" Value="public int GroupNumberFromName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GroupNumberFromName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNumberFromName (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GroupNumberFromName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GroupNumberFromName : string -&gt; int" Usage="regex.GroupNumberFromName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Gruppenname, der in die entsprechende Gruppennummer konvertiert werden soll.</param>
        <summary>Gibt die Gruppennummer zurück, die dem angegebenen Gruppennamen entspricht.</summary>
        <returns>Die Gruppennummer, die dem angegebenen Gruppennamen entspricht, oder -1, wenn <paramref name="name" /> kein gültiger Gruppenname ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Muster für reguläre Ausdrücke kann entweder benannte oder nummerierte Erfassungs Gruppen enthalten, die Teil Ausdrücke innerhalb einer Muster Übereinstimmung definieren. Nummerierte Gruppen werden durch die*Syntax (Teil*Ausdruck) getrennt, und Ihnen werden basierend auf ihrer Reihenfolge im regulären Ausdruck Zahlen zugewiesen. Benannte Gruppen werden durch die Syntax (?`<`*Name* *`>`Teil*Ausdruck) oder (?) getrennt. *Name*'*Teil*Ausdruck ', wobei *Name* der Name ist, mit dem der Teil Ausdruck identifiziert wird. (Weitere Informationen finden Sie unter [Gruppierungskonstrukte](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md).) Die <xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A>-Methode identifiziert sowohl benannte Gruppen als auch nummerierte Gruppen durch ihre Ordinalpositionen im regulären Ausdruck. Die Ordinalposition NULL stellt immer den gesamten regulären Ausdruck dar. Alle nummerierten Gruppen werden dann vor benannten Gruppen gezählt, unabhängig von ihrer tatsächlichen Position im Muster für reguläre Ausdrücke.  
  
 Wenn `name` die Zeichen folgen Darstellung einer Gruppennummer ist, die im Muster eines regulären Ausdrucks vorhanden ist, gibt die Methode diese Zahl zurück. Wenn `name` einer benannten Erfassungs Gruppe entspricht, die im Muster für reguläre Ausdrücke vorhanden ist, gibt die Methode die entsprechende Zahl zurück. Beim Vergleich von `name` mit dem Gruppennamen wird die Groß-/Kleinschreibung beachtet. Wenn `name` nicht dem Namen einer Erfassungs Gruppe oder der Zeichen folgen Darstellung der Nummer einer Erfassungs Gruppe entspricht, gibt die Methode-1 zurück.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
        <related type="Article" href="~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md">Gruppierungskonstrukte in regulären Ausdrücken</related>
      </Docs>
    </Member>
    <Member MemberName="InfiniteMatchTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass bei einem Mustervergleichsvorgang kein Timeout angewendet werden sollte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>-Klassenkonstruktor und eine Reihe statischer Vergleichsmethoden verwenden die <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> Konstante, um anzugeben, dass der Versuch, eine Muster Übereinstimmung zu finden, kein Timeout hat.  
  
> [!WARNING]
>  Wenn der Timeout Wert der Engine für reguläre Ausdrücke auf <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> festgelegt wird, kann dies dazu führen, dass reguläre Ausdrücke, die auf einer übermäßigen Rückverfolgung basieren, nicht mehr reagieren, wenn Text verarbeitet wird, der fast mit dem Muster eines regulären Ausdrucks Wenn Sie Timeouts deaktivieren, sollten Sie sicherstellen, dass sich der reguläre Ausdruck nicht auf übermäßige Rückverfolgung verlässt und Text verarbeitet, der fast mit dem Muster des regulären Ausdrucks übereinstimmt.  
>   
>  Weitere Informationen zum Behandeln der Rückverfolgung finden Sie unter [Rückverfolgung](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 Die <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> Konstante kann als Wert des `matchTimeout` Arguments der folgenden Member angegeben werden:  
  
-   <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.RegexCompilationInfo.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.String%2CSystem.String%2CSystem.Boolean%2CSystem.TimeSpan%29?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      </Docs>
    </Member>
    <Member MemberName="InitializeReferences">
      <MemberSignature Language="C#" Value="protected void InitializeReferences ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeReferences() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.InitializeReferences" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeReferences ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeReferences();" />
      <MemberSignature Language="F#" Value="member this.InitializeReferences : unit -&gt; unit" Usage="regex.InitializeReferences " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Verweise wurden bereits initialisiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="internalMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.TimeSpan internalMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend internalMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="protected public: TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="F#" Value="val mutable internalMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.OptionalField(VersionAdded=2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Die maximale Zeit, die ein Mustervergleichsvorgang ausgeführt werden kann, bevor des Timeout eintritt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsMatch">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, ob der reguläre Ausdruck eine Übereinstimmung in der Eingabezeichenfolge findet.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string -&gt; bool" Usage="regex.IsMatch input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <summary>Gibt an, ob der im <see cref="T:System.Text.RegularExpressions.Regex" />-Konstruktor angegebene reguläre Ausdruck eine Übereinstimmung in einer angegebenen Eingabezeichenfolge findet.</summary>
        <returns><see langword="true" />, wenn der reguläre Ausdruck eine Übereinstimmung findet, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>-Methode wird normalerweise verwendet, um eine Zeichenfolge zu validieren oder um sicherzustellen, dass eine Zeichenfolge einem bestimmten Muster entspricht, ohne diese Zeichenfolge für nachfolgende Manipulationen abzurufen. Wenn Sie feststellen möchten, ob eine oder mehrere Zeichen folgen einem Muster für reguläre Ausdrücke entsprechen, und Sie dann für nachfolgende Manipulationen abrufen, rufen Sie die <xref:System.Text.RegularExpressions.Regex.Match%2A> oder <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode auf.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit der übereinstimmenden Operation das vom <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>-Konstruktor angegebene Timeout Intervall überschreitet. Wenn Sie beim Aufruf des Konstruktors kein Timeout Intervall festlegen, wird die Ausnahme ausgelöst, wenn der Vorgang einen Timeout Wert überschreitet, der für die Anwendungsdomäne festgelegt wurde, in der das <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn im <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in den Eigenschaften der Anwendungsdomäne kein Timeout definiert ist, oder wenn der Timeout Wert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>ist, wird keine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29>-Methode, um zu bestimmen, ob eine Zeichenfolge eine gültige Teilenummer ist. Der reguläre Ausdruck geht davon aus, dass die Teilenummer ein bestimmtes Format aufweist, das aus drei Zeichensätzen besteht, die durch Bindestriche voneinander getrennt sind. Der erste Satz, der vier Zeichen enthält, muss aus einem alphanumerischen Zeichen gefolgt von zwei numerischen Zeichen gefolgt von einem alphanumerischen Zeichen bestehen. Der zweite Satz, der aus drei Zeichen besteht, muss numerisch sein. Der dritte Satz, der aus vier Zeichen besteht, muss drei numerische Zeichen gefolgt von einem alphanumerischen Zeichen enthalten.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch2.vb" id="Snippet2":::
  
 Das Muster des regulären Ausdrucks lautet:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.  
  
|Muster|BESCHREIBUNG|  
|-------------|-----------------|  
|`^`|Beginnt die Übereinstimmung am Anfang der Zeile.|  
|`[a-zA-Z0-9]`|Entsprechung für ein einzelnes Alphabetisches Zeichen (`a` durch `z` oder `A` durch `Z`) oder ein numerisches Zeichen.|  
|`\d{2}`|Entsprechung für zwei numerische Zeichen.|  
|`[a-zA-Z0-9]`|Entsprechung für ein einzelnes Alphabetisches Zeichen (`a` durch `z` oder `A` durch `Z`) oder ein numerisches Zeichen.|  
|`-`|Entsprechung für einen Bindestrich finden.|  
|`\d{3}`|Übereinstimmung mit genau drei numerischen Zeichen.|  
|`(-\d{3}){2}`|Suchen Sie nach einem Bindestrich, gefolgt von drei numerischen Zeichen, und vergleichen Sie zwei Vorkommen dieses Musters.|  
|`[a-zA-Z0-9]`|Entsprechung für ein einzelnes Alphabetisches Zeichen (`a` durch `z` oder `A` durch `Z`) oder ein numerisches Zeichen.|  
|`$`|Beenden Sie die Übereinstimmung am Ende der Zeile.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String, startat As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string * int -&gt; bool" Usage="regex.IsMatch (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="startat">Die Zeichenposition, an der mit der Suche begonnen werden soll.</param>
        <summary>Gibt an, ob der im <see cref="T:System.Text.RegularExpressions.Regex" />-Konstruktor angegebene reguläre Ausdruck ab der angegebenen Anfangsposition eine Übereinstimmung in der angegebenen Eingabezeichenfolge findet.</summary>
        <returns><see langword="true" />, wenn der reguläre Ausdruck eine Übereinstimmung findet, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>-Methode wird normalerweise verwendet, um eine Zeichenfolge zu validieren oder um sicherzustellen, dass eine Zeichenfolge einem bestimmten Muster entspricht, ohne diese Zeichenfolge für nachfolgende Manipulationen abzurufen. Wenn Sie feststellen möchten, ob eine oder mehrere Zeichen folgen einem Muster für reguläre Ausdrücke entsprechen, und Sie dann für nachfolgende Manipulationen abrufen, rufen Sie die <xref:System.Text.RegularExpressions.Regex.Match%2A> oder <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode auf.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit der übereinstimmenden Operation das vom <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>-Konstruktor angegebene Timeout Intervall überschreitet. Wenn Sie beim Aufruf des Konstruktors kein Timeout Intervall festlegen, wird die Ausnahme ausgelöst, wenn der Vorgang einen Timeout Wert überschreitet, der für die Anwendungsdomäne festgelegt wurde, in der das <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn im <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in den Eigenschaften der Anwendungsdomäne kein Timeout definiert ist, oder wenn der Timeout Wert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>ist, wird keine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29>-Methode, um zu bestimmen, ob eine Zeichenfolge eine gültige Teilenummer ist. Er sucht nach einer Teil Nummer, die einem Doppelpunkt folgt (:) Zeichen in einer Zeichenfolge. Die <xref:System.String.IndexOf%28System.Char%29>-Methode wird verwendet, um die Position des Doppelpunkt Zeichens zu bestimmen, die dann an die <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29>-Methode weitergegeben wird. Der reguläre Ausdruck geht davon aus, dass die Teilenummer ein bestimmtes Format aufweist, das aus drei Zeichensätzen besteht, die durch Bindestriche voneinander getrennt sind. Der erste Satz, der vier Zeichen enthält, muss aus einem alphanumerischen Zeichen gefolgt von zwei numerischen Zeichen gefolgt von einem alphanumerischen Zeichen bestehen. Der zweite Satz, der aus drei Zeichen besteht, muss numerisch sein. Der dritte Satz, der aus vier Zeichen besteht, muss drei numerische Zeichen gefolgt von einem alphanumerischen Zeichen enthalten.  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch3.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch3.vb" id="Snippet3":::
  
 Das Muster des regulären Ausdrucks lautet:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.  
  
|Muster|BESCHREIBUNG|  
|-------------|-----------------|  
|`[a-zA-Z0-9]`|Entsprechung für ein einzelnes Alphabetisches Zeichen (`a` durch `z` oder `A` durch `Z`) oder ein numerisches Zeichen.|  
|`\d{2}`|Entsprechung für zwei numerische Zeichen.|  
|`[a-zA-Z0-9]`|Entsprechung für ein einzelnes Alphabetisches Zeichen (`a` durch `z` oder `A` durch `Z`) oder ein numerisches Zeichen.|  
|`-`|Entsprechung für einen Bindestrich finden.|  
|`\d{3}`|Übereinstimmung mit genau drei numerischen Zeichen.|  
|`(-\d{3}){2}`|Suchen Sie nach einem Bindestrich, gefolgt von drei numerischen Zeichen, und vergleichen Sie zwei Vorkommen dieses Musters.|  
|`[a-zA-Z0-9]`|Entsprechung für ein einzelnes Alphabetisches Zeichen (`a` durch `z` oder `A` durch `Z`) oder ein numerisches Zeichen.|  
|`$`|Beenden Sie die Übereinstimmung am Ende der Zeile.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> ist kleiner als 0 (null) oder größer als die Länge von <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <summary>Gibt an, ob der reguläre Ausdruck eine Übereinstimmung in der angegebenen Eingabezeichenfolge findet.</summary>
        <returns><see langword="true" />, wenn der reguläre Ausdruck eine Übereinstimmung findet, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>-Methode wird normalerweise verwendet, um eine Zeichenfolge zu validieren oder um sicherzustellen, dass eine Zeichenfolge einem bestimmten Muster entspricht, ohne diese Zeichenfolge für nachfolgende Manipulationen abzurufen. Wenn Sie feststellen möchten, ob eine oder mehrere Zeichen folgen einem Muster für reguläre Ausdrücke entsprechen, und Sie dann für nachfolgende Manipulationen abrufen, rufen Sie die <xref:System.Text.RegularExpressions.Regex.Match%2A> oder <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode auf.  
  
 Die statische <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29>-Methode entspricht der Erstellung eines <xref:System.Text.RegularExpressions.Regex> Objekts mit dem Muster für reguläre Ausdrücke, das durch `pattern` angegeben ist, und der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> Instanzmethode aufrufen. Dieses Muster für reguläre Ausdrücke wird zum schnellen Abruf durch die Engine für reguläre Ausdrücke zwischengespeichert.  
  
 Der `pattern`-Parameter besteht aus Sprachelementen für reguläre Ausdrücke, die die zu Übereinstimmungs enden Zeichen folgen symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [.NET Framework reguläre Ausdrücke](~/docs/standard/base-types/regular-expressions.md) und [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit der übereinstimmenden Operation das Timeout Intervall überschreitet, das für die Anwendungsdomäne festgelegt wurde, in der die-Methode aufgerufen wird. Wenn kein Timeout in den Eigenschaften der Anwendungsdomäne definiert ist, oder wenn der Timeout Wert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>ist, wird keine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29>-Methode, um zu bestimmen, ob eine Zeichenfolge eine gültige Teilenummer ist. Der reguläre Ausdruck geht davon aus, dass die Teilenummer ein bestimmtes Format aufweist, das aus drei Zeichensätzen besteht, die durch Bindestriche voneinander getrennt sind. Der erste Satz, der vier Zeichen enthält, muss aus einem alphanumerischen Zeichen gefolgt von zwei numerischen Zeichen gefolgt von einem alphanumerischen Zeichen bestehen. Der zweite Satz, der aus drei Zeichen besteht, muss numerisch sein. Der dritte Satz, der aus vier Zeichen besteht, muss drei numerische Zeichen gefolgt von einem alphanumerischen Zeichen enthalten.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch1.vb" id="Snippet1":::
  
 Das Muster des regulären Ausdrucks lautet:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.  
  
|Muster|BESCHREIBUNG|  
|-------------|-----------------|  
|`^`|Beginnt die Übereinstimmung am Anfang der Zeile.|  
|`[a-zA-Z0-9]`|Entsprechung für ein einzelnes Alphabetisches Zeichen (`a` durch `z` oder `A` durch `Z`) oder ein numerisches Zeichen.|  
|`\d{2}`|Entsprechung für zwei numerische Zeichen.|  
|`[a-zA-Z0-9]`|Entsprechung für ein einzelnes Alphabetisches Zeichen (`a` durch `z` oder `A` durch `Z`) oder ein numerisches Zeichen.|  
|`-`|Entsprechung für einen Bindestrich finden.|  
|`\d{3}`|Übereinstimmung mit genau drei numerischen Zeichen.|  
|`(-\d{3}){2}`|Suchen Sie nach einem Bindestrich, gefolgt von drei numerischen Zeichen, und vergleichen Sie zwei Vorkommen dieses Musters.|  
|`[a-zA-Z0-9]`|Entsprechung für ein einzelnes Alphabetisches Zeichen (`a` durch `z` oder `A` durch `Z`) oder ein numerisches Zeichen.|  
|`$`|Beenden Sie die Übereinstimmung am Ende der Zeile.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage"><para>Bei dieser Methode kommt es nach einem Intervall zu einem Timeout, das gleich dem Standard Timeout Wert der Anwendungsdomäne ist, in der die Methode aufgerufen wird. Wenn für die Anwendungsdomäne kein Timeout Wert definiert wurde, wird der Wert <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, der verhindert, dass die Methode ein Timeout verursacht, verwendet wird. Die empfohlene statische Methode zum Überprüfen einer Muster Übereinstimmung ist <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, mit der Sie das Timeout Intervall festlegen können.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <summary>Gibt an, ob der angegebene reguläre Ausdruck unter Verwendung der angegebenen Übereinstimmungsoptionen eine Übereinstimmung in der angegebenen Eingabezeichenfolge findet.</summary>
        <returns><see langword="true" />, wenn der reguläre Ausdruck eine Übereinstimmung findet, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>-Methode wird normalerweise verwendet, um eine Zeichenfolge zu validieren oder um sicherzustellen, dass eine Zeichenfolge einem bestimmten Muster entspricht, ohne diese Zeichenfolge für nachfolgende Manipulationen abzurufen. Wenn Sie feststellen möchten, ob eine oder mehrere Zeichen folgen einem Muster für reguläre Ausdrücke entsprechen, und Sie dann für nachfolgende Manipulationen abrufen, rufen Sie die <xref:System.Text.RegularExpressions.Regex.Match%2A> oder <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode auf.  
  
 Die statische <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>-Methode entspricht der Erstellung eines <xref:System.Text.RegularExpressions.Regex> Objekts mit dem Muster für reguläre Ausdrücke, das von `pattern` angegeben wird, und den Optionen für reguläre Ausdrücke, die durch `options` und Aufrufen der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> Instanzmethode angegeben werden. Dieses Muster für reguläre Ausdrücke wird zum schnellen Abruf durch die Engine für reguläre Ausdrücke zwischengespeichert.  
  
 Der `pattern`-Parameter besteht aus Sprachelementen für reguläre Ausdrücke, die die zu Übereinstimmungs enden Zeichen folgen symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [.NET Framework reguläre Ausdrücke](~/docs/standard/base-types/regular-expressions.md) und [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit der übereinstimmenden Operation das Timeout Intervall überschreitet, das für die Anwendungsdomäne festgelegt wurde, in der die-Methode aufgerufen wird. Wenn kein Timeout in den Eigenschaften der Anwendungsdomäne definiert ist, oder wenn der Timeout Wert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>ist, wird keine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29>-Methode, um zu bestimmen, ob eine Zeichenfolge eine gültige Teilenummer ist. Der reguläre Ausdruck geht davon aus, dass die Teilenummer ein bestimmtes Format aufweist, das aus drei Zeichensätzen besteht, die durch Bindestriche voneinander getrennt sind. Der erste Satz, der vier Zeichen enthält, muss aus einem alphanumerischen Zeichen gefolgt von zwei numerischen Zeichen gefolgt von einem alphanumerischen Zeichen bestehen. Der zweite Satz, der aus drei Zeichen besteht, muss numerisch sein. Der dritte Satz, der aus vier Zeichen besteht, muss drei numerische Zeichen gefolgt von einem alphanumerischen Zeichen enthalten.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch4.cs" interactive="try-dotnet" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch4.vb" id="Snippet4":::
  
 Das Muster des regulären Ausdrucks lautet:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.  
  
|Muster|BESCHREIBUNG|  
|-------------|-----------------|  
|`^`|Beginnt die Suche am Anfang der Zeichenfolge.|  
|`[A-Z0-9]`|Eine Entsprechung für ein einzelnes Alphabetisches Zeichen aus `A` durch `Z`oder ein beliebiges numerisches Zeichen.|  
|`\d{2}`|Entsprechung für zwei numerische Zeichen.|  
|`[A-Z0-9]`|Eine Entsprechung für ein einzelnes Alphabetisches Zeichen aus `A` durch `Z`oder ein beliebiges numerisches Zeichen.|  
|`-`|Entsprechung für einen Bindestrich finden.|  
|`\d{3}`|Übereinstimmung mit genau drei numerischen Zeichen.|  
|`(-\d{3}){2}`|Suchen von einem Bindestrich gefolgt von drei Ziffern, und zwei Vorkommen dieses Muster übereinstimmen.|  
|`[A-Z0-9]`|Eine Entsprechung für ein einzelnes Alphabetisches Zeichen aus `A` durch `Z`oder ein beliebiges numerisches Zeichen.|  
|`$`|Beendet die Suche am Ende der Zeichenfolge.|  
  
 Das Aufrufen der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>-Methode mit dem auf <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> festgelegten `options`-Parameter entspricht der Definition des folgenden regulären Ausdrucks:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Einen Vergleich finden Sie im Beispiel für die <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29>-Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> ist kein gültiger <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Wert.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage"><para>Bei dieser Methode wird nach einem Intervall, das gleich dem Standard Timeout Wert der Anwendungsdomäne ist, in der Sie aufgerufen wird, ein Timeout festgestellt. Wenn für die Anwendungsdomäne kein Timeout Wert definiert wurde, wird der Wert <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, der verhindert, dass die Methode ein Timeout verursacht, verwendet wird. Die empfohlene statische Methode zum Überprüfen einer Muster Übereinstimmung ist <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, mit der Sie das Timeout Intervall festlegen können.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <param name="matchTimeout">Ein Timeoutintervall oder <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das angibt, dass die Methode kein Timeout haben sollte.</param>
        <summary>Gibt an, ob der angegebene reguläre Ausdruck unter Verwendung der angegebenen Übereinstimmungsoptionen und des angegebenen Timeoutintervalls eine Übereinstimmung in der angegebenen Eingabezeichenfolge findet.</summary>
        <returns><see langword="true" />, wenn der reguläre Ausdruck eine Übereinstimmung findet, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>-Methode wird normalerweise verwendet, um eine Zeichenfolge zu validieren oder um sicherzustellen, dass eine Zeichenfolge einem bestimmten Muster entspricht, ohne diese Zeichenfolge für nachfolgende Manipulationen abzurufen. Wenn Sie feststellen möchten, ob eine oder mehrere Zeichen folgen einem Muster für reguläre Ausdrücke entsprechen, und Sie dann für nachfolgende Manipulationen abrufen, rufen Sie die <xref:System.Text.RegularExpressions.Regex.Match%2A> oder <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode auf.  
  
 Die statische <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>-Methode entspricht der Erstellung eines <xref:System.Text.RegularExpressions.Regex> Objekts mit dem Muster für reguläre Ausdrücke, das von `pattern` angegeben wird, und den Optionen für reguläre Ausdrücke, die durch `options` und Aufrufen der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> Instanzmethode angegeben werden. Dieses Muster für reguläre Ausdrücke wird zum schnellen Abruf durch die Engine für reguläre Ausdrücke zwischengespeichert.  
  
 Der `pattern`-Parameter besteht aus Sprachelementen für reguläre Ausdrücke, die die zu Übereinstimmungs enden Zeichen folgen symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [.NET Framework reguläre Ausdrücke](~/docs/standard/base-types/regular-expressions.md) und [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht.  
  
 Der `matchTimeout`-Parameter gibt an, wie lange eine Muster Vergleichsmethode versuchen sollte, eine Übereinstimmung zu finden, bevor ein Timeout auftritt. Das Festlegen eines Timeout Intervalls verhindert, dass reguläre Ausdrücke, die auf einer übermäßigen Rückverfolgung basieren, nicht mehr reagieren, wenn Sie Eingaben verarbeiten, die Near-Übereinstimmungen enthalten. Weitere Informationen finden Sie unter [bewährte Methoden für reguläre Ausdrücke](~/docs/standard/base-types/best-practices.md) und [Rückverfolgung](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Wenn in diesem Zeitintervall keine Entsprechung gefunden wird, löst die Methode eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme aus. `matchTimeout` überschreibt jeden Standard Timeout Wert, der für die Anwendungsdomäne definiert ist, in der die Methode ausgeführt wird.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>-Methode, um zu bestimmen, ob eine Zeichenfolge eine gültige Teilenummer ist. Der reguläre Ausdruck geht davon aus, dass die Teilenummer ein bestimmtes Format aufweist, das aus drei Zeichensätzen besteht, die durch Bindestriche voneinander getrennt sind. Der erste Satz, der vier Zeichen enthält, muss aus einem alphanumerischen Zeichen gefolgt von zwei numerischen Zeichen gefolgt von einem alphanumerischen Zeichen bestehen. Der zweite Satz, der aus drei Zeichen besteht, muss numerisch sein. Der dritte Satz, der aus vier Zeichen besteht, muss drei numerische Zeichen gefolgt von einem alphanumerischen Zeichen enthalten. Die Übereinstimmung mit dem Muster für reguläre Ausdrücke sollte die Eingabe Zeichenfolge nur minimal durchsuchen, sodass die-Methode ein Timeout Intervall von 500 Millisekunden festlegt.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch5.cs" interactive="try-dotnet" id="Snippet5":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch5.vb" id="Snippet5":::
  
 Das Muster des regulären Ausdrucks lautet:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.  
  
|Muster|BESCHREIBUNG|  
|-------------|-----------------|  
|`^`|Beginnt die Suche am Anfang der Zeichenfolge.|  
|`[A-Z0-9]`|Eine Entsprechung für ein einzelnes Alphabetisches Zeichen aus `A` durch `Z`oder ein beliebiges numerisches Zeichen.|  
|`\d{2}`|Entsprechung für zwei numerische Zeichen.|  
|`[A-Z0-9]`|Eine Entsprechung für ein einzelnes Alphabetisches Zeichen aus `A` durch `Z`oder ein beliebiges numerisches Zeichen.|  
|`-`|Entsprechung für einen Bindestrich finden.|  
|`\d{3}`|Übereinstimmung mit genau drei numerischen Zeichen.|  
|`(-\d{3}){2}`|Suchen Sie nach einem Bindestrich, gefolgt von drei numerischen Zeichen, und vergleichen Sie zwei Vorkommen dieses Musters.|  
|`[A-Z0-9]`|Eine Entsprechung für ein einzelnes Alphabetisches Zeichen aus `A` durch `Z`oder ein beliebiges numerisches Zeichen.|  
|`$`|Beendet die Suche am Ende der Zeichenfolge.|  
  
 Das Aufrufen der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>-Methode mit dem auf <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> festgelegten `options`-Parameter entspricht der Definition des folgenden regulären Ausdrucks:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Einen Vergleich finden Sie im Beispiel für die <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29>-Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> ist kein gültiger <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Wert.  
  
Oder 
 <paramref name="matchTimeout" /> ist negativ, null oder größer als ca. 24 Tage.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten.</exception>
        <block subset="none" type="usage"><para>Es wird empfohlen, den <paramref name="matchTimeout" />-Parameter auf einen geeigneten Wert, z. b. zwei Sekunden, festzulegen. Wenn Sie Timeouts durch Angeben von <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />deaktivieren, bietet die Engine für reguläre Ausdrücke eine etwas bessere Leistung. Timeouts sollten jedoch nur unter den folgenden Bedingungen deaktiviert werden: 
: Wenn die von einem regulären Ausdruck verarbeitete Eingabe von einer bekannten und vertrauenswürdigen Quelle abgeleitet ist oder aus statischem Text besteht. Dies schließt Text aus, der von Benutzern dynamisch eingegeben wurde.  
  
: Wenn das Muster für reguläre Ausdrücke gründlich getestet wurde, um sicherzustellen, dass es Übereinstimmungen, nicht-Übereinstimmungen und NEAR-Übereinstimmungen effizient behandelt.  
  
-Wenn das Muster für reguläre Ausdrücke keine Sprachelemente enthält, die bekanntermaßen eine übermäßige Rückverfolgung verursachen, wenn eine nahe Übereinstimmung verarbeitet wird.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Match">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Durchsucht eine Eingabezeichenfolge nach einer Teilzeichenfolge, die mit einem Muster eines regulären Ausdrucks übereinstimmt, und gibt das erste Vorkommen als einzelnes <see cref="T:System.Text.RegularExpressions.Match" />-Objekt zurück.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Match : string -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <summary>Durchsucht die angegebene Eingabezeichenfolge nach dem ersten Vorkommen des im <see cref="T:System.Text.RegularExpressions.Regex" />-Konstruktor angegebenen regulären Ausdrucks.</summary>
        <returns>Ein Objekt, das Informationen zur Übereinstimmung enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>-Methode gibt die erste Teil Zeichenfolge zurück, die einem Muster eines regulären Ausdrucks in einer Eingabe Zeichenfolge entspricht. Informationen zu den Sprachelementen, die zum Erstellen eines Musters für reguläre Ausdrücke verwendet werden, finden Sie unter [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht.  
  
 Sie können bestimmen, ob das Muster für reguläre Ausdrücke in der Eingabe Zeichenfolge gefunden wurde, indem Sie den Wert der <xref:System.Text.RegularExpressions.Group.Success%2A>-Eigenschaft des zurückgegebenen <xref:System.Text.RegularExpressions.Match> Objekts überprüfen. Wenn eine Übereinstimmung gefunden wird, enthält die <xref:System.Text.RegularExpressions.Capture.Value%2A>-Eigenschaft des zurückgegebenen <xref:System.Text.RegularExpressions.Match> Objekts die Teil Zeichenfolge aus `input`, die mit dem Muster für reguläre Ausdrücke übereinstimmt. Wenn keine Entsprechung gefunden wird, wird der Wert <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Diese Methode gibt die erste Teil Zeichenfolge in `input` zurück, die mit dem Muster für reguläre Ausdrücke übereinstimmt. Sie können nachfolgende Übereinstimmungen abrufen, indem Sie wiederholt die <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> Methode des zurückgegebenen <xref:System.Text.RegularExpressions.Match> Objekts aufrufen. Sie können auch alle Übereinstimmungen in einem einzelnen Methodenaufruf abrufen, indem Sie die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType>-Methode aufrufen.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit der übereinstimmenden Operation das vom <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>-Konstruktor angegebene Timeout Intervall überschreitet. Wenn Sie beim Aufruf des Konstruktors kein Timeout Intervall festlegen, wird die Ausnahme ausgelöst, wenn der Vorgang einen Timeout Wert überschreitet, der für die Anwendungsdomäne festgelegt wurde, in der das <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn im <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in den Eigenschaften der Anwendungsdomäne kein Timeout definiert ist, oder wenn der Timeout Wert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>ist, wird keine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel werden Muster Übereinstimmungen von regulären Ausdrücken in einer Zeichenfolge gesucht und dann die übereinstimmenden Gruppen, Erfassungen und Erfassungs Positionen aufgelistet.  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp" id="Snippet8":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs" interactive="try-dotnet" id="Snippet8":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb" id="Snippet8":::
  
 Das Muster für reguläre Ausdrücke `(\w+)\s+(car)` dem Vorkommen des Worts "Car" zusammen mit dem Wort, das ihm vorangestellt ist, entspricht. Es wird wie in der folgenden Tabelle dargestellt interpretiert.  
  
|Muster|BESCHREIBUNG|  
|-------------|-----------------|  
|`(\w+)`|Übereinstimmung mit mindestens einem Wortzeichen. Dies ist die erste Erfassungsgruppe.|  
|`\s+`|Entspricht einem oder mehreren Leerzeichen.|  
|Fahrzeug|Entspricht der Literalzeichenfolge "Auto". Dies ist die zweite Erfassungsgruppe.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, startat As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="startat">Die nullbasierte Zeichenposition, an der mit der Suche begonnen werden soll.</param>
        <summary>Durchsucht die Eingabezeichenfolge nach dem ersten Vorkommen eines regulären Ausdrucks ab der angegebenen Anfangsposition in der Zeichenfolge.</summary>
        <returns>Ein Objekt, das Informationen zur Übereinstimmung enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29>-Methode gibt die erste Teil Zeichenfolge zurück, die einem Muster für reguläre Ausdrücke entspricht, beginnend bei oder nach der `startat` Zeichenposition in einer Eingabe Zeichenfolge. Informationen zu den Sprachelementen, die zum Erstellen eines Musters für reguläre Ausdrücke verwendet werden, finden Sie unter [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht.  
  
 Das Muster für reguläre Ausdrücke, für das die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29>-Methode durchsucht wird, wird durch den-Befehl eines der <xref:System.Text.RegularExpressions.Regex> Klassenkonstruktoren definiert. Weitere Informationen zu den Elementen, die ein Muster für reguläre Ausdrücke bilden können, finden Sie unter [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht.  
  
 Sie können optional eine Startposition in der Zeichenfolge angeben, indem Sie den `startat`-Parameter verwenden. Wenn die Engine für reguläre Ausdrücke von links nach rechts (Standard) analysiert wird, wird die Entsprechung und die Überprüfung nach rechts verschoben, beginnend bei dem in `startat`angegebenen Zeichen. Wenn die Engine für reguläre Ausdrücke von rechts nach links analysiert (wenn das Muster für reguläre Ausdrücke mit der <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType>-Option erstellt wird), werden die Übereinstimmungs-und Scanvorgänge in umgekehrter Richtung verschoben und beginnen mit dem Zeichen bei `startat`-1. Wenn Sie keine Startposition angeben, beginnt die Suche an der standardmäßigen `startat` Position. Wenn der reguläre Ausdruck von links nach rechts durchsucht, befindet sich die Standard `startat` Position am linken Ende `input`. bei der Suche von rechts nach links befindet sich die Standard `startat` Position rechts neben `input`.  
  
 Wenn Sie eine Entsprechung so einschränken möchten, dass Sie an einer bestimmten Zeichenposition in der Zeichenfolge beginnt und das Modul für reguläre Ausdrücke den Rest der Zeichenfolge für eine Entsprechung nicht scannt, verankern Sie den regulären Ausdruck mit einem `\G` (auf der linken Seite für ein Muster von links nach rechts oder von rechts nach links). Dadurch wird die Übereinstimmung eingeschränkt, sodass Sie genau bei `startat`beginnen muss.  
  
 Sie können bestimmen, ob das Muster für reguläre Ausdrücke in der Eingabe Zeichenfolge gefunden wurde, indem Sie den Wert der <xref:System.Text.RegularExpressions.Group.Success%2A>-Eigenschaft des zurückgegebenen <xref:System.Text.RegularExpressions.Match> Objekts überprüfen. Wenn eine Übereinstimmung gefunden wird, enthält die <xref:System.Text.RegularExpressions.Capture.Value%2A>-Eigenschaft des zurückgegebenen <xref:System.Text.RegularExpressions.Match> Objekts die Teil Zeichenfolge aus `input`, die mit dem Muster für reguläre Ausdrücke übereinstimmt. Wenn keine Entsprechung gefunden wird, wird der Wert <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Diese Methode gibt die erste Teil Zeichenfolge zurück, die an oder nach der `startat` Zeichenposition in `input` gefunden wird, die dem Muster für reguläre Ausdrücke entspricht. Sie können nachfolgende Übereinstimmungen abrufen, indem Sie wiederholt die <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> Methode des zurückgegebenen <xref:System.Text.RegularExpressions.Match> Objekts aufrufen. Sie können auch alle Übereinstimmungen in einem einzelnen Methodenaufruf abrufen, indem Sie die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>-Methode aufrufen.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit der übereinstimmenden Operation das vom <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>-Konstruktor angegebene Timeout Intervall überschreitet. Wenn Sie beim Aufruf des Konstruktors kein Timeout Intervall festlegen, wird die Ausnahme ausgelöst, wenn der Vorgang einen Timeout Wert überschreitet, der für die Anwendungsdomäne festgelegt wurde, in der das <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn im <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in den Eigenschaften der Anwendungsdomäne kein Timeout definiert ist, oder wenn der Timeout Wert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>ist, wird keine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> ist kleiner als 0 (null) oder größer als die Länge von <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Match : string * string -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <summary>Durchsucht die angegebene Eingabezeichenfolge nach dem ersten Vorkommen des angegebenen regulären Ausdrucks.</summary>
        <returns>Ein Objekt, das Informationen zur Übereinstimmung enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29>-Methode gibt die erste Teil Zeichenfolge zurück, die einem Muster eines regulären Ausdrucks in einer Eingabe Zeichenfolge entspricht. Informationen zu den Sprachelementen, die zum Erstellen eines Musters für reguläre Ausdrücke verwendet werden, finden Sie unter [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht.  
  
 Die statische <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29>-Methode entspricht dem Erstellen eines <xref:System.Text.RegularExpressions.Regex> Objekts mit dem angegebenen Muster für reguläre Ausdrücke und dem Aufrufen der-Instanz <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>-Methode. In diesem Fall speichert das Modul für reguläre Ausdrücke das Muster für reguläre Ausdrücke zwischen.  
  
 Der `pattern`-Parameter besteht aus Sprachelementen für reguläre Ausdrücke, die die zu Übereinstimmungs enden Zeichen folgen symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [.NET Framework reguläre Ausdrücke](~/docs/standard/base-types/regular-expressions.md) und [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht.  
  
 Sie können bestimmen, ob das Muster für reguläre Ausdrücke in der Eingabe Zeichenfolge gefunden wurde, indem Sie den Wert der <xref:System.Text.RegularExpressions.Group.Success%2A>-Eigenschaft des zurückgegebenen <xref:System.Text.RegularExpressions.Match> Objekts überprüfen. Wenn eine Übereinstimmung gefunden wird, enthält die <xref:System.Text.RegularExpressions.Capture.Value%2A>-Eigenschaft des zurückgegebenen <xref:System.Text.RegularExpressions.Match> Objekts die Teil Zeichenfolge aus `input`, die mit dem Muster für reguläre Ausdrücke übereinstimmt. Wenn keine Entsprechung gefunden wird, wird der Wert <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Diese Methode gibt die erste Teil Zeichenfolge in `input` zurück, die mit dem Muster für reguläre Ausdrücke übereinstimmt. Sie können nachfolgende Übereinstimmungen abrufen, indem Sie wiederholt die <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> Methode des zurückgegebenen <xref:System.Text.RegularExpressions.Match> Objekts aufrufen. Sie können auch alle Übereinstimmungen in einem einzelnen Methodenaufruf abrufen, indem Sie die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType>-Methode aufrufen.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit der übereinstimmenden Operation das Timeout Intervall überschreitet, das für die Anwendungsdomäne festgelegt wurde, in der die-Methode aufgerufen wird. Wenn kein Timeout in den Eigenschaften der Anwendungsdomäne definiert ist, oder wenn der Timeout Wert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>ist, wird keine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29>-Methode aufgerufen, um das erste Wort zu suchen, das mindestens ein `z` Zeichen enthält, und dann die <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>-Methode aufruft, um weitere Übereinstimmungen zu suchen.  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match1.vb" id="Snippet1":::  
  
 Das Muster für reguläre Ausdrücke `\b\w*z+\w*\b` wird entsprechend der folgenden Tabelle interpretiert:  
  
|Muster|BESCHREIBUNG|  
|-------------|-----------------|  
|`\b`|Der Vergleich beginnt an einer Wortgrenze.|  
|`\w*`|Entspricht keinem, einem oder mehreren Wort Zeichen.|  
|`z+`|Entsprechung für ein oder mehrere Vorkommen des `z` Zeichens.|  
|`\w*`|Entspricht keinem, einem oder mehreren Wort Zeichen.|  
|`\b`|Der Vergleich endet an einer Wortgrenze.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage"><para>Bei dieser Methode wird nach einem Intervall, das gleich dem Standard Timeout Wert der Anwendungsdomäne ist, in der Sie aufgerufen wird, ein Timeout festgestellt. Wenn für die Anwendungsdomäne kein Timeout Wert definiert wurde, wird der Wert <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, der verhindert, dass die Methode ein Timeout verursacht, verwendet wird. Die empfohlene statische Methode zum Abrufen einer Muster Übereinstimmung ist <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, mit dem Sie das Timeout Intervall festlegen können.</para></block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int beginning, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 beginning, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, beginning As Integer, length As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int beginning, int length);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, beginning, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="beginning" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="beginning">Die nullbasierte Zeichenposition in der Eingabezeichenfolge, die die am weitesten links stehende Position definiert, die gesucht werden soll.</param>
        <param name="length">Die Anzahl der Zeichen der Teilzeichenfolge, die in die Suche einbezogen werden soll.</param>
        <summary>Sucht beginnend an der angegebenen Anfangsposition in der Eingabezeichenfolge nach dem ersten Vorkommen eines regulären Ausdrucks und sucht nur nach der angegebenen Anzahl von Zeichen.</summary>
        <returns>Ein Objekt, das Informationen zur Übereinstimmung enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29>-Methode gibt die erste Teil Zeichenfolge zurück, die einem Muster für reguläre Ausdrücke in einem Teil einer Eingabe Zeichenfolge entspricht. Informationen zu den Sprachelementen, die zum Erstellen eines Musters für reguläre Ausdrücke verwendet werden, finden Sie unter [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht.  
  
 Das Muster für reguläre Ausdrücke, für das die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29>-Methode durchsucht wird, wird durch den-Befehl eines der <xref:System.Text.RegularExpressions.Regex> Klassenkonstruktoren definiert. Weitere Informationen zu den Elementen, die ein Muster für reguläre Ausdrücke bilden können, finden Sie unter [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht.  
  
 Die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29>-Methode durchsucht den Teil `input`, der vom `beginning` und `length`-Parametern für das Muster für reguläre Ausdrücke definiert wird. `beginning` definiert immer den Index des am weitesten links stehenden Zeichens, das in die Suche eingeschlossen werden soll, und `length` die maximale Anzahl der zu durchsuchenden Zeichen definiert. Dabei definieren Sie den Suchbereich. Wenn die Suche von links nach rechts (Standard) fortgesetzt wird, sucht die Engine für reguläre Ausdrücke vom Zeichen an der Index `beginning` zum Zeichen bei Index `beginning` + `length`-1. Wenn die Engine für reguläre Ausdrücke mithilfe der Option <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> instanziiert wurde, sodass die Suche von rechts nach links verläuft, sucht die Engine für reguläre Ausdrücke vom Zeichen bei Index `beginning` + `length`-1 bis zum Zeichen bei Index `beginning`. Diese Methode gibt die erste Übereinstimmung zurück, die in diesem Bereich gefunden wird. Sie können nachfolgende Übereinstimmungen abrufen, indem Sie wiederholt die <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> Methode des zurückgegebenen <xref:System.Text.RegularExpressions.Match> Objekts aufrufen.  
  
 Sie können bestimmen, ob das Muster für reguläre Ausdrücke in der Eingabe Zeichenfolge gefunden wurde, indem Sie den Wert der <xref:System.Text.RegularExpressions.Group.Success%2A>-Eigenschaft des zurückgegebenen <xref:System.Text.RegularExpressions.Match> Objekts überprüfen. Wenn eine Übereinstimmung gefunden wird, enthält die <xref:System.Text.RegularExpressions.Capture.Value%2A>-Eigenschaft des zurückgegebenen <xref:System.Text.RegularExpressions.Match> Objekts die Teil Zeichenfolge aus `input`, die mit dem Muster für reguläre Ausdrücke übereinstimmt. Wenn keine Entsprechung gefunden wird, wird der Wert <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit der übereinstimmenden Operation das vom <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>-Konstruktor angegebene Timeout Intervall überschreitet. Wenn Sie beim Aufruf des Konstruktors keinen Timeout Wert festlegen, wird die Ausnahme ausgelöst, wenn der Vorgang einen Timeout Wert überschreitet, der für die Anwendungsdomäne festgelegt wurde, in der das <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn im <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in den Eigenschaften der Anwendungsdomäne kein Timeout definiert ist, oder wenn der Timeout Wert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>ist, wird keine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="beginning" /> ist kleiner als 0 (null) oder größer als die Länge von <paramref name="input" />.  
  
Oder 
 <paramref name="length" /> ist kleiner als 0 (null) oder größer als die Länge von <paramref name="input" />.  
  
Oder 
 <paramref name="beginning" /><see langword="+" /><paramref name="length" /><see langword="-1" /> gibt eine Position außerhalb des Bereichs von <paramref name="input" /> an.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <summary>Durchsucht die angegebene Eingabezeichenfolge unter Verwendung der angegebenen Übereinstimmungsoptionen nach dem ersten Vorkommen des angegebenen regulären Ausdrucks.</summary>
        <returns>Ein Objekt, das Informationen zur Übereinstimmung enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>-Methode gibt die erste Teil Zeichenfolge zurück, die einem Muster eines regulären Ausdrucks in einer Eingabe Zeichenfolge entspricht. Informationen zu den Sprachelementen, die zum Erstellen eines Musters für reguläre Ausdrücke verwendet werden, finden Sie unter [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht.  
  
 Die statische <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>-Methode entspricht dem Erstellen eines <xref:System.Text.RegularExpressions.Regex> Objekts mit dem <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29>-Konstruktor und dem Aufrufen der-Instanz <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>-Methode.  
  
 Der `pattern`-Parameter besteht aus Sprachelementen für reguläre Ausdrücke, die die zu Übereinstimmungs enden Zeichen folgen symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [.NET Framework reguläre Ausdrücke](~/docs/standard/base-types/regular-expressions.md) und [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht.  
  
 Sie können bestimmen, ob das Muster für reguläre Ausdrücke in der Eingabe Zeichenfolge gefunden wurde, indem Sie den Wert der <xref:System.Text.RegularExpressions.Group.Success%2A>-Eigenschaft des zurückgegebenen <xref:System.Text.RegularExpressions.Match> Objekts überprüfen. Wenn eine Übereinstimmung gefunden wird, enthält die <xref:System.Text.RegularExpressions.Capture.Value%2A>-Eigenschaft des zurückgegebenen <xref:System.Text.RegularExpressions.Match> Objekts die Teil Zeichenfolge aus `input`, die mit dem Muster für reguläre Ausdrücke übereinstimmt. Wenn keine Entsprechung gefunden wird, wird der Wert <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Diese Methode gibt die erste in `input` gefundene Teil Zeichenfolge zurück, die mit dem Muster des regulären Ausdrucks übereinstimmt. Sie können nachfolgende Übereinstimmungen abrufen, indem Sie wiederholt die <xref:System.Text.RegularExpressions.Match.NextMatch%2A> Methode des zurückgegebenen <xref:System.Text.RegularExpressions.Match> Objekts aufrufen. Sie können auch alle Übereinstimmungen in einem einzelnen Methodenaufruf abrufen, indem Sie die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>-Methode aufrufen.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit der übereinstimmenden Operation das Timeout Intervall überschreitet, das für die Anwendungsdomäne festgelegt wurde, in der die-Methode aufgerufen wird. Wenn kein Timeout in den Eigenschaften der Anwendungsdomäne definiert ist, oder wenn der Timeout Wert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>ist, wird keine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein regulärer Ausdruck definiert, der mit dem Buchstaben "a" beginnt. Er verwendet die <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>-Option, um sicherzustellen, dass der reguläre Ausdruck Wörter findet, die mit dem Großbuchstaben "a" und dem Kleinbuchstaben "a" beginnen.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match2.vb" id="Snippet2":::
  
 Das Muster für reguläre Ausdrücke `\ba\w*\b` wird entsprechend der folgenden Tabelle interpretiert:  
  
|Muster|BESCHREIBUNG|  
|-------------|-----------------|  
|`\b`|Der Vergleich beginnt an einer Wortgrenze.|  
|`a`|Entsprechung für das Zeichen "a".|  
|`\w*`|Entspricht keinem, einem oder mehreren Wort Zeichen.|  
|`\b`|Der Vergleich endet an einer Wortgrenze.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage"><para>Bei dieser Methode wird nach einem Intervall, das gleich dem Standard Timeout Wert der Anwendungsdomäne ist, in der Sie aufgerufen wird, ein Timeout festgestellt. Wenn für die Anwendungsdomäne kein Timeout Wert definiert wurde, wird der Wert <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, der verhindert, dass die Methode ein Timeout verursacht, verwendet wird. Die empfohlene statische Methode zum Abrufen einer Muster Übereinstimmung ist <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, mit dem Sie das Timeout Intervall festlegen können.</para></block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <param name="matchTimeout">Ein Timeoutintervall oder <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das angibt, dass die Methode kein Timeout haben sollte.</param>
        <summary>Durchsucht die Eingabezeichenfolge unter Verwendung der angegebenen Übereinstimmungsoptionen und des angegebenen Timeoutintervalls nach dem ersten Vorkommen des angegebenen regulären Ausdrucks.</summary>
        <returns>Ein Objekt, das Informationen zur Übereinstimmung enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>-Methode gibt die erste Teil Zeichenfolge zurück, die einem Muster eines regulären Ausdrucks in einer Eingabe Zeichenfolge entspricht. Informationen zu den Sprachelementen, die zum Erstellen eines Musters für reguläre Ausdrücke verwendet werden, finden Sie unter [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht.  
  
 Die statische <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>-Methode entspricht dem Erstellen eines <xref:System.Text.RegularExpressions.Regex> Objekts mit dem <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>-Konstruktor und dem Aufrufen der-Instanz <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>-Methode.  
  
 Der `pattern`-Parameter besteht aus Sprachelementen für reguläre Ausdrücke, die die zu Übereinstimmungs enden Zeichen folgen symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [.NET Framework reguläre Ausdrücke](~/docs/standard/base-types/regular-expressions.md) und [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht.  
  
 Sie können bestimmen, ob das Muster für reguläre Ausdrücke in der Eingabe Zeichenfolge gefunden wurde, indem Sie den Wert der <xref:System.Text.RegularExpressions.Group.Success%2A>-Eigenschaft des zurückgegebenen <xref:System.Text.RegularExpressions.Match> Objekts überprüfen. Wenn eine Übereinstimmung gefunden wird, enthält die <xref:System.Text.RegularExpressions.Capture.Value%2A>-Eigenschaft des zurückgegebenen <xref:System.Text.RegularExpressions.Match> Objekts die Teil Zeichenfolge aus `input`, die mit dem Muster für reguläre Ausdrücke übereinstimmt. Wenn keine Entsprechung gefunden wird, wird der Wert <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Diese Methode gibt die erste in `input` gefundene Teil Zeichenfolge zurück, die mit dem Muster des regulären Ausdrucks übereinstimmt. Sie können nachfolgende Übereinstimmungen abrufen, indem Sie wiederholt die <xref:System.Text.RegularExpressions.Match.NextMatch%2A> Methode des zurückgegebenen <xref:System.Text.RegularExpressions.Match> Objekts aufrufen. Sie können auch alle Übereinstimmungen in einem einzelnen Methodenaufruf abrufen, indem Sie die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>-Methode aufrufen.  
  
 Der `matchTimeout`-Parameter gibt an, wie lange eine Muster Vergleichsmethode versuchen sollte, eine Übereinstimmung zu finden, bevor ein Timeout auftritt. Das Festlegen eines Timeout Intervalls verhindert, dass reguläre Ausdrücke, die auf einer übermäßigen Rückverfolgung basieren, nicht mehr reagieren, wenn Sie Eingaben verarbeiten, die Near-Übereinstimmungen enthalten. Weitere Informationen finden Sie unter [bewährte Methoden für reguläre Ausdrücke](~/docs/standard/base-types/best-practices.md) und [Rückverfolgung](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Wenn in diesem Zeitintervall keine Entsprechung gefunden wird, löst die Methode eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme aus. `matchTimeout` überschreibt jeden Standard Timeout Wert, der für die Anwendungsdomäne definiert ist, in der die Methode ausgeführt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.  
  
Oder 
 <paramref name="matchTimeout" /> ist negativ, null oder größer als ca. 24 Tage.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage"><para>Es wird empfohlen, den <paramref name="matchTimeout" />-Parameter auf einen geeigneten Wert, z. b. zwei Sekunden, festzulegen. Wenn Sie Timeouts durch Angeben von <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />deaktivieren, bietet die Engine für reguläre Ausdrücke eine etwas bessere Leistung. Timeouts sollten jedoch nur unter den folgenden Bedingungen deaktiviert werden: 
: Wenn die von einem regulären Ausdruck verarbeitete Eingabe von einer bekannten und vertrauenswürdigen Quelle abgeleitet ist oder aus statischem Text besteht. Dies schließt Text aus, der von Benutzern dynamisch eingegeben wurde.  
  
: Wenn das Muster für reguläre Ausdrücke gründlich getestet wurde, um sicherzustellen, dass es Übereinstimmungen, nicht-Übereinstimmungen und NEAR-Übereinstimmungen effizient behandelt.  
  
-Wenn das Muster für reguläre Ausdrücke keine Sprachelemente enthält, die bekanntermaßen eine übermäßige Rückverfolgung verursachen, wenn eine nahe Übereinstimmung verarbeitet wird.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Matches">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Durchsucht eine Eingabezeichenfolge nach allen Vorkommen eines regulären Ausdrucks und gibt alle Übereinstimmungen zurück.</summary>
        <block subset="none" type="usage"><para>Wenn ein Übereinstimmungs Versuch durch Aufrufen der <see cref="Overload:System.Text.RegularExpressions.Regex.Matches" />-Methode wiederholt wird, gibt die Engine für reguläre Ausdrücke eine leere Übereinstimmung mit einer speziellen Behandlung Normalerweise beginnt die Engine für reguläre Ausdrücke mit der Suche nach der nächsten Übereinstimmung genau dort, wo die vorherige Übereinstimmung ausgelassen wurde. Nach einer leeren Entsprechung wird die Engine für reguläre Ausdrücke jedoch um ein Zeichen fortgesetzt, bevor die nächste Übereinstimmung versucht wird. Durch dieses Verhalten wird sichergestellt, dass die Engine für reguläre Ausdrücke die Zeichenfolge durchläuft. Da eine leere Übereinstimmung nicht zu einer Vorwärtsbewegung führt, würde die nächste Übereinstimmung an derselben Stelle wie die vorherige Übereinstimmung beginnen und dieselbe leere Zeichenfolge wiederholt zuordnen.  
  
Im folgenden Beispiel sucht das Muster für reguläre Ausdrücke <c>a *</c> nach 0 (null) oder mehr Vorkommen des Buchstabens "a" in der Zeichenfolge "abaabb". Wie die Ausgabe des Beispiels zeigt, enthält das resultierende <see cref="T:System.Text.RegularExpressions.MatchCollection" /> Objekt sechs <see cref="T:System.Text.RegularExpressions.Match" /> Objekte. Der erste Übereinstimmungs Versuch findet das erste "a". Die zweite Übereinstimmung beginnt genau mit dem Ende der ersten Übereinstimmung vor dem ersten b. Es findet keine Vorkommen von "a" und gibt eine leere Zeichenfolge zurück. Die dritte Übereinstimmung beginnt nicht genau, wo die zweite Übereinstimmung endet, da die zweite Übereinstimmung eine leere Zeichenfolge zurückgegeben hat. Stattdessen beginnt ein Zeichen später nach dem ersten "b". Die dritte Entsprechung findet zwei Vorkommen von "a" und gibt "AA" zurück. Der vierte Übereinstimmungs Versuch beginnt mit dem Ende der dritten Übereinstimmung vor dem zweiten "b" und gibt eine leere Zeichenfolge zurück. Der fünfte Übereinstimmungs Versuch verschiebt ein Zeichen so weiter, dass es vor dem dritten "b" beginnt, und gibt eine leere Zeichenfolge zurück. Die sechste Entsprechung beginnt nach dem letzten "b" und gibt erneut eine leere Zeichenfolge zurück.  
  
[! Code-csharp[System. Text. RegularExpressions. Regex. Matches # 9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/emptymatches1.cs#9)] [! Code-vb[System. Text. RegularExpressions. Regex. Matches # 9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/emptymatches1.vb#9)]</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Matches : string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <summary>Durchsucht die angegebene Eingabezeichenfolge nach allen Vorkommen eines regulären Ausdrucks.</summary>
        <returns>Eine Auflistung der im Suchvorgang gefundenen <see cref="T:System.Text.RegularExpressions.Match" />-Objekte. Wenn keine Übereinstimmungen gefunden werden, gibt die Methode ein leeres Auflistungsobjekt zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29>-Methode ähnelt der <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>-Methode, mit der Ausnahme, dass Sie Informationen zu allen in der Eingabe Zeichenfolge gefundenen Übereinstimmungen anstelle einer einzelnen Übereinstimmung zurückgibt. Dies entspricht dem folgenden Code:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#5)]  
  
 Die Auflistung enthält nur Übereinstimmungen und endet bei der ersten nicht Übereinstimmung.  
  
 Das Muster für reguläre Ausdrücke, für das die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29>-Methode durchsucht wird, wird durch den-Befehl eines der <xref:System.Text.RegularExpressions.Regex> Klassenkonstruktoren definiert. Weitere Informationen zu den Elementen, die ein Muster für reguläre Ausdrücke bilden können, finden Sie unter [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht.  
  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%2A>-Methode verwendet die verzögerte Auswertung, um das zurückgegebene <xref:System.Text.RegularExpressions.MatchCollection>-Objekt aufzufüllen. Der Zugriff auf Member dieser Auflistung, z. b. <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> und <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> bewirkt, dass die Auflistung sofort aufgefüllt wird. Um verzögerte Auswertung nutzen zu können, sollten Sie die Auflistung durchlaufen, mit einem Konstrukt wie `foreach` in C# geschrieben und `For Each`...`Next` in Visual Basic.  
  
 Aufgrund der verzögerten Auswertung löst der Aufruf der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29>-Methode keine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>-Ausnahme aus. Allerdings wird die Ausnahme ausgelöst, wenn ein Vorgang für das von dieser Methode zurückgegebene <xref:System.Text.RegularExpressions.MatchCollection> Objekt ausgeführt wird, wenn die <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A>-Eigenschaft nicht <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ist und ein Abgleichsvorgang das Timeout Intervall überschreitet.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29>-Methode verwendet, um Wörter in einem Satz zu identifizieren, die mit "es" enden.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches1.vb" id="Snippet1"::: 
  
 Das Muster für reguläre Ausdrücke `\b\w+es\b` wird entsprechend der folgenden Tabelle definiert:  
  
|Muster|BESCHREIBUNG|  
|-------------|-----------------|  
|`\b`|Der Vergleich beginnt an einer Wortgrenze.|  
|`\w+`|Übereinstimmung mit mindestens einem Wortzeichen.|  
|`es`|Entspricht der Literalzeichenfolge "es".|  
|`\b`|Der Vergleich endet an einer Wortgrenze.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ist <see langword="null" /></exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String, startat As Integer) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Matches : string * int -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="startat">Die Zeichenposition in der Eingabezeichenfolge, an der mit der Suche begonnen werden soll.</param>
        <summary>Durchsucht die angegebene Eingabezeichenfolge nach allen Vorkommen eines regulären Ausdrucks ab der angegebenen Anfangsposition in der Zeichenfolge.</summary>
        <returns>Eine Auflistung der im Suchvorgang gefundenen <see cref="T:System.Text.RegularExpressions.Match" />-Objekte. Wenn keine Übereinstimmungen gefunden werden, gibt die Methode ein leeres Auflistungsobjekt zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29>-Methode ähnelt der <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29>-Methode, mit der Ausnahme, dass Sie Informationen zu allen in der Eingabe Zeichenfolge gefundenen Übereinstimmungen anstelle einer einzelnen Übereinstimmung zurückgibt. Dies entspricht dem folgenden Code:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#6)]  
  
 Das Muster für reguläre Ausdrücke, für das die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29>-Methode durchsucht wird, wird durch den-Befehl eines der <xref:System.Text.RegularExpressions.Regex> Klassenkonstruktoren definiert. Weitere Informationen zu den Elementen, die ein Muster für reguläre Ausdrücke bilden können, finden Sie unter [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht.  
  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%2A>-Methode verwendet die verzögerte Auswertung, um das zurückgegebene <xref:System.Text.RegularExpressions.MatchCollection>-Objekt aufzufüllen. Der Zugriff auf Member dieser Auflistung, z. b. <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> und <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> bewirkt, dass die Auflistung sofort aufgefüllt wird. Um verzögerte Auswertung nutzen zu können, sollten Sie die Auflistung durchlaufen, mit einem Konstrukt wie `foreach` in C# geschrieben und `For Each`...`Next` in Visual Basic.  
  
 Aufgrund der verzögerten Auswertung löst der Aufruf der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29>-Methode keine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>-Ausnahme aus. Allerdings wird die Ausnahme ausgelöst, wenn ein Vorgang für das von dieser Methode zurückgegebene <xref:System.Text.RegularExpressions.MatchCollection> Objekt ausgeführt wird, wenn die <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A>-Eigenschaft nicht <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> ist und ein Abgleichsvorgang das Timeout Intervall überschreitet. 
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>-Methode verwendet, um das erste Wort in einem Satz zu suchen, der auf "es" endet, und dann die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29>-Methode aufrufen, um alle zusätzlichen Wörter zu identifizieren, die mit "es" enden.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches3.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches3.vb" id="Snippet3"::: 
  
 Das Muster für reguläre Ausdrücke `\b\w+es\b` wird entsprechend der folgenden Tabelle definiert:  
  
|Muster|BESCHREIBUNG|  
|-------------|-----------------|  
|`\b`|Der Vergleich beginnt an einer Wortgrenze.|  
|`\w+`|Übereinstimmung mit mindestens einem Wortzeichen.|  
|`es`|Entspricht der Literalzeichenfolge "es".|  
|`\b`|Der Vergleich endet an einer Wortgrenze.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> ist kleiner als 0 (null) oder größer als die Länge von <paramref name="input" />.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <summary>Durchsucht die angegebene Eingabezeichenfolge nach allen Vorkommen eines angegebenen regulären Ausdrucks.</summary>
        <returns>Eine Auflistung der im Suchvorgang gefundenen <see cref="T:System.Text.RegularExpressions.Match" />-Objekte. Wenn keine Übereinstimmungen gefunden werden, gibt die Methode ein leeres Auflistungsobjekt zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29>-Methode ähnelt der <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29>-Methode, mit der Ausnahme, dass Sie Informationen zu allen in der Eingabe Zeichenfolge gefundenen Übereinstimmungen anstelle einer einzelnen Übereinstimmung zurückgibt. Dies entspricht dem folgenden Code:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#7)]  
  
 Die statischen `Matches` Methoden entsprechen dem Erstellen eines <xref:System.Text.RegularExpressions.Regex> Objekts mit dem angegebenen Muster für reguläre Ausdrücke und dem Aufrufen der Instanzmethode `Matches`.  
  
 Der `pattern`-Parameter besteht aus Sprachelementen für reguläre Ausdrücke, die die zu Übereinstimmungs enden Zeichen folgen symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [.NET Framework reguläre Ausdrücke](~/docs/standard/base-types/regular-expressions.md) und [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht.  
  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%2A>-Methode verwendet die verzögerte Auswertung, um das zurückgegebene <xref:System.Text.RegularExpressions.MatchCollection>-Objekt aufzufüllen. Der Zugriff auf Member dieser Auflistung, z. b. <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> und <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> bewirkt, dass die Auflistung sofort aufgefüllt wird. Um verzögerte Auswertung nutzen zu können, sollten Sie die Auflistung durchlaufen, mit einem Konstrukt wie `foreach` in C# geschrieben und `For Each`...`Next` in Visual Basic.  
  
 Aufgrund der verzögerten Auswertung löst der Aufruf der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29>-Methode keine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>-Ausnahme aus. Allerdings wird die Ausnahme ausgelöst, wenn ein Vorgang für das von dieser Methode zurückgegebene <xref:System.Text.RegularExpressions.MatchCollection> Objekt ausgeführt wird, wenn ein Timeout Intervall durch die Eigenschaft "REGEX_DEFAULT_MATCH_TIMEOUT" der aktuellen Anwendungsdomäne definiert wird und ein Abgleichsvorgang dieses Timeout Intervall überschreitet.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29>-Methode verwendet, um ein beliebiges Wort in einem Satz zu identifizieren, der auf "es" endet.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches2.vb" id="Snippet2"::: 
  
 Das Muster für reguläre Ausdrücke `\b\w+es\b` wird entsprechend der folgenden Tabelle definiert:  
  
|Muster|BESCHREIBUNG|  
|-------------|-----------------|  
|`\b`|Der Vergleich beginnt an einer Wortgrenze.|  
|`\w+`|Übereinstimmung mit mindestens einem Wortzeichen.|  
|`es`|Entspricht der Literalzeichenfolge "es".|  
|`\b`|Der Vergleich endet an einer Wortgrenze.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Bei dieser Methode wird nach einem Intervall, das gleich dem Standard Timeout Wert der Anwendungsdomäne ist, in der Sie aufgerufen wird, ein Timeout festgestellt. Wenn für die Anwendungsdomäne kein Timeout Wert definiert wurde, wird der Wert <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, der verhindert, dass die Methode ein Timeout verursacht, verwendet wird. Die empfohlene statische Methode zum Abrufen mehrerer Muster Übereinstimmungen ist <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, mit der Sie das Timeout Intervall angeben können.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <summary>Durchsucht die angegebene Eingabezeichenfolge unter Verwendung der angegebenen Übereinstimmungsoptionen nach allen Vorkommen des angegebenen regulären Ausdrucks.</summary>
        <returns>Eine Auflistung der im Suchvorgang gefundenen <see cref="T:System.Text.RegularExpressions.Match" />-Objekte. Wenn keine Übereinstimmungen gefunden werden, gibt die Methode ein leeres Auflistungsobjekt zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>-Methode ähnelt der <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>-Methode, mit der Ausnahme, dass Sie Informationen zu allen in der Eingabe Zeichenfolge gefundenen Übereinstimmungen anstelle einer einzelnen Übereinstimmung zurückgibt. Dies entspricht dem folgenden Code:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#8)]  
  
 Die statischen `Matches` Methoden entsprechen dem Erstellen eines <xref:System.Text.RegularExpressions.Regex> Objekts mit dem angegebenen Muster für reguläre Ausdrücke und dem Aufrufen der Instanzmethode `Matches`.  
  
 Der `pattern`-Parameter besteht aus Sprachelementen für reguläre Ausdrücke, die die zu Übereinstimmungs enden Zeichen folgen symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [.NET Framework reguläre Ausdrücke](~/docs/standard/base-types/regular-expressions.md) und [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht.  
  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%2A>-Methode verwendet die verzögerte Auswertung, um das zurückgegebene <xref:System.Text.RegularExpressions.MatchCollection>-Objekt aufzufüllen. Der Zugriff auf Member dieser Auflistung, z. b. <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> und <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> bewirkt, dass die Auflistung sofort aufgefüllt wird. Um verzögerte Auswertung nutzen zu können, sollten Sie die Auflistung durchlaufen, mit einem Konstrukt wie `foreach` in C# geschrieben und `For Each`...`Next` in Visual Basic.  
  
 Aufgrund der verzögerten Auswertung löst der Aufruf der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29>-Methode keine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>-Ausnahme aus. Allerdings wird die Ausnahme ausgelöst, wenn ein Vorgang für das von dieser Methode zurückgegebene <xref:System.Text.RegularExpressions.MatchCollection> Objekt ausgeführt wird, wenn ein Timeout Intervall durch die Eigenschaft "REGEX_DEFAULT_MATCH_TIMEOUT" der aktuellen Anwendungsdomäne definiert wird und ein Abgleichsvorgang dieses Timeout Intervall überschreitet.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29>-Methode aufgerufen, um jedes Wort in einem Satz zu identifizieren, der mit "es" endet, und dann die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>-Methode aufruft, um einen Vergleich des Musters mit der Eingabe Zeichenfolge ohne Beachtung der Groß-/Kleinschreibung zu Wie die Ausgabe zeigt, geben die beiden Methoden unterschiedliche Ergebnisse zurück.  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches4.cs" interactive="try-dotnet" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches4.vb" id="Snippet4":::
  
 Das Muster für reguläre Ausdrücke `\b\w+es\b` wird entsprechend der folgenden Tabelle definiert:  
  
|Muster|BESCHREIBUNG|  
|-------------|-----------------|  
|`\b`|Der Vergleich beginnt an einer Wortgrenze.|  
|`\w+`|Übereinstimmung mit mindestens einem Wortzeichen.|  
|`es`|Entspricht der Literalzeichenfolge "es".|  
|`\b`|Der Vergleich endet an einer Wortgrenze.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.</exception>
        <block subset="none" type="usage"><para>Bei dieser Methode wird nach einem Intervall, das gleich dem Standard Timeout Wert der Anwendungsdomäne ist, in der Sie aufgerufen wird, ein Timeout festgestellt. Wenn für die Anwendungsdomäne kein Timeout Wert definiert wurde, wird der Wert <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, der verhindert, dass die Methode ein Timeout verursacht, verwendet wird. Die empfohlene statische Methode zum Abrufen mehrerer Muster Übereinstimmungen ist <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, mit dem Sie das Timeout Intervall festlegen können.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <param name="matchTimeout">Ein Timeoutintervall oder <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das angibt, dass die Methode kein Timeout haben sollte.</param>
        <summary>Durchsucht die angegebene Eingabezeichenfolge unter Verwendung der angegebenen Übereinstimmungsoptionen und des angegebenen Timeoutintervalls nach allen Vorkommen des angegebenen regulären Ausdrucks.</summary>
        <returns>Eine Auflistung der im Suchvorgang gefundenen <see cref="T:System.Text.RegularExpressions.Match" />-Objekte. Wenn keine Übereinstimmungen gefunden werden, gibt die Methode ein leeres Auflistungsobjekt zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>-Methode ähnelt der <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>-Methode, mit der Ausnahme, dass Sie Informationen zu allen in der Eingabe Zeichenfolge gefundenen Übereinstimmungen anstelle einer einzelnen Übereinstimmung zurückgibt. Dies entspricht dem folgenden Code:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#10)]  
  
 Die statischen `Matches` Methoden entsprechen dem Erstellen eines <xref:System.Text.RegularExpressions.Regex> Objekts mit dem angegebenen Muster für reguläre Ausdrücke und dem Aufrufen der Instanzmethode `Matches`.  
  
 Der `pattern`-Parameter besteht aus Sprachelementen für reguläre Ausdrücke, die die zu Übereinstimmungs enden Zeichen folgen symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [.NET Framework reguläre Ausdrücke](~/docs/standard/base-types/regular-expressions.md) und [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht.  
  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%2A>-Methode verwendet die verzögerte Auswertung, um das zurückgegebene <xref:System.Text.RegularExpressions.MatchCollection>-Objekt aufzufüllen. Der Zugriff auf Member dieser Auflistung, z. b. <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> und <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> bewirkt, dass die Auflistung sofort aufgefüllt wird. Um verzögerte Auswertung nutzen zu können, sollten Sie die Auflistung durchlaufen, mit einem Konstrukt wie `foreach` in C# geschrieben und `For Each`...`Next` in Visual Basic.  
  
 Aufgrund der verzögerten Auswertung löst der Aufruf der <xref:System.Text.RegularExpressions.Regex.Matches%2A>-Methode keine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>-Ausnahme aus. Eine-Ausnahme wird jedoch ausgelöst, wenn ein Vorgang für das von dieser Methode zurückgegebene <xref:System.Text.RegularExpressions.MatchCollection> Objekt ausgeführt wird, wenn ein übereinstimmender Vorgang dieses Timeout Intervall überschreitet, das durch den`matchTimeout`-Parameter angegeben wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>-Methode aufgerufen, um einen Vergleich mit Berücksichtigung der Groß-/Kleinschreibung durchzuführen, der mit jedem Wort eines Satzes übereinstimmt, der auf "es" Anschließend wird die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>-Methode aufgerufen, um einen Vergleich des Musters mit der Eingabe Zeichenfolge ohne Beachtung der Groß-und Kleinschreibung auszuführen. In beiden Fällen wird das Timeout Intervall auf eine Sekunde festgelegt. Wie die Ausgabe zeigt, geben die beiden Methoden unterschiedliche Ergebnisse zurück.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches5.cs" interactive="try-dotnet" id="Snippet11":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches5.vb" id="Snippet11":::
  
 Das Muster für reguläre Ausdrücke `\b\w+es\b` wird entsprechend der folgenden Tabelle definiert:  
  
|Muster|BESCHREIBUNG|  
|-------------|-----------------|  
|`\b`|Der Vergleich beginnt an einer Wortgrenze.|  
|`\w+`|Übereinstimmung mit mindestens einem Wortzeichen.|  
|`es`|Entspricht der Literalzeichenfolge "es".|  
|`\b`|Der Vergleich endet an einer Wortgrenze.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.  
  
Oder 
 <paramref name="matchTimeout" /> ist negativ, null oder größer als ca. 24 Tage.</exception>
        <block subset="none" type="usage"><para>Es wird empfohlen, den <paramref name="matchTimeout" />-Parameter auf einen geeigneten Wert, z. b. zwei Sekunden, festzulegen. Wenn Sie Timeouts durch Angeben von <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />deaktivieren, bietet die Engine für reguläre Ausdrücke eine etwas bessere Leistung. Timeouts sollten jedoch nur unter den folgenden Bedingungen deaktiviert werden: 
: Wenn die von einem regulären Ausdruck verarbeitete Eingabe von einer bekannten und vertrauenswürdigen Quelle abgeleitet ist oder aus statischem Text besteht. Dies schließt Text aus, der von Benutzern dynamisch eingegeben wurde.  
  
: Wenn das Muster für reguläre Ausdrücke gründlich getestet wurde, um sicherzustellen, dass es Übereinstimmungen, nicht-Übereinstimmungen und NEAR-Übereinstimmungen effizient behandelt.  
  
-Wenn das Muster für reguläre Ausdrücke keine Sprachelemente enthält, die bekanntermaßen eine übermäßige Rückverfolgung verursachen, wenn eine nahe Übereinstimmung verarbeitet wird.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="MatchTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan MatchTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MatchTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MatchTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MatchTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Laufzeitintervall der aktuellen Instanz ab.</summary>
        <value>Das maximale Zeitintervall, das in einem Mustervergleichsvorgang verstreichen kann, bevor eine <see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" />-Ausnahme ausgelöst wird, oder <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, wenn Timeouts deaktiviert sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A>-Eigenschaft definiert das ungefähre maximale Zeitintervall für eine <xref:System.Text.RegularExpressions.Regex> Instanz, um einen einzelnen übereinstimmenden Vorgang auszuführen, bevor ein Timeout des Vorgangs auftritt. Die Engine für reguläre Ausdrücke löst während der nächsten zeitlichen Prüfung eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme aus, nachdem das Timeout Intervall abgelaufen ist. Dadurch wird verhindert, dass die Engine für reguläre Ausdrücke Eingabe Zeichenfolgen verarbeitet, die übermäßige Rückverfolgung erfordern. Weitere Informationen finden Sie unter [Rückverfolgung](~/docs/standard/base-types/backtracking-in-regular-expressions.md) und [bewährte Methoden für reguläre Ausdrücke](~/docs/standard/base-types/best-practices.md).  
  
 Diese Eigenschaft ist schreibgeschützt. Sie können den Wert für ein einzelnes <xref:System.Text.RegularExpressions.Regex> Objekt explizit festlegen, indem Sie den <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>-Konstruktor aufrufen. Außerdem können Sie den Wert für alle <xref:System.Text.RegularExpressions.Regex> abgleichsvorgänge in einer Anwendungsdomäne festlegen, indem Sie die <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType>-Methode aufrufen und einen <xref:System.TimeSpan> Wert für die Eigenschaft "REGEX_DEFAULT_MATCH_TIMEOUT" bereitstellen, wie im folgenden Beispiel veranschaulicht.  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/cs/regexmatchtimeout1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/vb/regexmatchtimeout1.vb" id="Snippet1":::
  
 Wenn Sie ein Timeout Intervall nicht explizit festlegen, wird der Standardwert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> verwendet, und für übereinstimmende Vorgänge ist kein Timeout festgelegt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.RegexOptions Options { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.RegularExpressions.RegexOptions Options" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Options" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Options As RegexOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::RegularExpressions::RegexOptions Options { System::Text::RegularExpressions::RegexOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.Options : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.Options" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Optionen ab, die an den <see cref="T:System.Text.RegularExpressions.Regex" />-Konstruktor übergeben wurden.</summary>
        <value>Mindestens ein Member der <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Enumeration, der Optionen darstellt, die dem <see cref="T:System.Text.RegularExpressions.Regex" />-Konstruktor übergeben wurden</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert der <xref:System.Text.RegularExpressions.Regex.Options%2A>-Eigenschaft besteht aus einem oder mehreren Membern der <xref:System.Text.RegularExpressions.RegexOptions>-Enumeration. Wenn im <xref:System.Text.RegularExpressions.Regex> Klassenkonstruktor keine Optionen definiert wurden, wird der Wert <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>. Die verfügbaren Optionen werden im Thema Optionen für [reguläre Ausdrücke](~/docs/standard/base-types/regular-expression-options.md) ausführlich erläutert.  
  
 Beachten Sie, dass die <xref:System.Text.RegularExpressions.Regex.Options%2A>-Eigenschaft keine Inline Optionen widerspiegelt, die im Muster für reguläre Ausdrücke definiert sind.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> ist die Basisklasse regulärer Ausdrücke, die von der <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Methode erstellt werden. Diese kompilierten regulären Ausdrücke verwenden die Basisklassen Implementierung der <see cref="P:System.Text.RegularExpressions.Regex.Options" />-Eigenschaft. Wenn Sie von einer abgeleiteten Klasse aufgerufen wird, gibt die <see cref="P:System.Text.RegularExpressions.Regex.Options" />-Eigenschaft die Optionen zurück, die an den <paramref name="options" />-Parameter des <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" />-Klassenkonstruktors übergeben wurden, der zum Definieren des regulären Ausdrucks verwendet wurde.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-options.md">Optionen für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="pattern">
      <MemberSignature Language="C#" Value="protected internal string pattern;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string pattern" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.pattern" />
      <MemberSignature Language="VB.NET" Value="Protected Friend pattern As String " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::String ^ pattern;" />
      <MemberSignature Language="F#" Value="val mutable pattern : string" Usage="System.Text.RegularExpressions.Regex.pattern" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge die mit dem Muster für den regulären Ausdruck übereinstimmenden Zeichenfolgen durch eine angegebene Ersetzungszeichenfolge.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
        <related type="Article" href="~/docs/standard/base-types/substitutions-in-regular-expressions.md">Ersetzungen in regulären Ausdrücken</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="regex.Replace (input, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="replacement">Die Ersatzzeichenfolge.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge alle mit dem Muster für den regulären Ausdruck übereinstimmenden Zeichenfolgen durch eine angegebene Ersetzungszeichenfolge.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Die Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn keine Entsprechung für das reguläre Ausdrucksmuster in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche nach Übereinstimmungen beginnt am Anfang der `input` Zeichenfolge. Der reguläre Ausdruck ist das Muster, das vom Konstruktor für das aktuelle <xref:System.Text.RegularExpressions.Regex> Objekt definiert wird.  
  
 Der `replacement`-Parameter gibt die Zeichenfolge an, mit der die einzelnen Treffer in `input`ersetzt werden sollen. `replacement` kann aus einer beliebigen Kombination aus Literaltext und [Substitutionen](~/docs/standard/base-types/substitutions-in-regular-expressions.md)bestehen. Das Ersetzungs Muster `a*${test}b` z. b. die Zeichenfolge "a *", gefolgt von der Teil Zeichenfolge, die mit der `test` Erfassungs Gruppe übereinstimmt, sofern vorhanden, gefolgt von der Zeichenfolge "b". Das Zeichen "*" wird nicht als Metazeichen innerhalb eines Ersetzungs Musters erkannt.  
  
> [!NOTE]
>  Ersetzungen sind die einzigen Sprachelemente für reguläre Ausdrücke, die in einem Ersetzungs Muster erkannt werden. Alle anderen Sprachelemente für reguläre Ausdrücke, einschließlich [Escapezeichen](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sind nur in Mustern für reguläre Ausdrücke zulässig und werden nicht in Ersetzungs Mustern erkannt.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit des Ersetzungs Vorgangs das vom <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>-Konstruktor angegebene Timeout Intervall überschreitet. Wenn Sie beim Aufruf des Konstruktors kein Timeout Intervall festlegen, wird die Ausnahme ausgelöst, wenn der Vorgang einen Timeout Wert überschreitet, der für die Anwendungsdomäne festgelegt wurde, in der das <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn im <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in den Eigenschaften der Anwendungsdomäne kein Timeout definiert ist, oder wenn der Timeout Wert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>ist, wird keine Ausnahme ausgelöst.  
  
 Da die Methode `input` unverändert zurückgibt, wenn keine Entsprechung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>-Methode verwenden, um zu bestimmen, ob die Methode eine Ersetzung an der Eingabe Zeichenfolge vorgenommen hat.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein regulärer Ausdruck (`\s+`) definiert, der mit einem oder mehreren Leerzeichen übereinstimmt. Die Ersetzungs Zeichenfolge "" ersetzt Sie durch ein einzelnes Leerzeichen.  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample5.cs" interactive="try-dotnet" id="Snippet5":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample5.vb" id="Snippet5":::
  
 Im folgenden Beispiel werden ein regulärer Ausdruck, `(\p{Sc}\s?)?(\d+\.?((?<=\.)\d+)?)(?(1)|\s?\p{Sc})?`und ein Ersetzungs Muster definiert, `$2`, das entweder ein führendes oder ein nach gestelltes Währungssymbol aus einem numerischen Wert entfernt.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample7.cs" interactive="try-dotnet" id="Snippet7":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample7.vb" id="Snippet7"::: 
  
 Der reguläre Ausdruck wird entsprechend der Darstellung in der folgenden Tabelle interpretiert.  
  
|Muster|BESCHREIBUNG|  
|-------------|-----------------|  
|`\p{Sc}`|Entsprechung für ein Währungssymbol. `{Sc}` bezeichnet jedes Zeichen, das ein Member des Unicode-Symbols, Currency Category ist.|  
|`\s?`|Übereinstimmung mit keinem oder einem Leerzeichen.|  
|`(\p{Sc}\s?)?`|Entspricht keinem oder einem Vorkommen der Kombination eines Währungs Symbols, gefolgt von keinem oder einem Leerzeichen. Dies ist die erste Erfassungsgruppe.|  
|`\d+`|Entsprechung für mindestens eine Dezimalstelle finden.|  
|`\.?`|Entsprechung für NULL oder ein Vorkommen eines Zeitraums (als Dezimaltrennzeichen verwendet).|  
|`((?<=\.)\d+)?`|Wenn ein Punkt das vorherige Zeichen ist, finden Sie eine Entsprechung für eine oder mehrere Dezimalstellen. Dieses Muster kann entweder NULL oder einmal abgeglichen werden.|  
|`(\d+\.?((?<=\.)\d+)?)`|Entsprechung für das Muster von einer oder mehreren Dezimalziffern, gefolgt von einem optionalen Zeitraum und zusätzlichen Dezimalziffern. Dies ist die zweite Erfassungsgruppe. Beim Abrufen der <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29>-Methode wird die gesamte Entsprechung durch den Wert dieser erfassten Gruppe ersetzt.|  
|<code>(?(1)&#124;\s?\p{Sc})?</code>|Wenn die erste erfasste Gruppe vorhanden ist, wird eine leere Zeichenfolge gefunden. Andernfalls entspricht NULL oder ein Leerzeichen, gefolgt von einem Währungssymbol.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> oder <paramref name="replacement" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
        <related type="Article" href="~/docs/standard/base-types/substitutions-in-regular-expressions.md">Ersetzungen in regulären Ausdrücken</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="regex.Replace (input, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="evaluator">Eine benutzerdefinierte Methode, die jede Übereinstimmung überprüft und entweder die ursprüngliche entsprechende Zeichenfolge oder eine Ersatzzeichenfolge zurückgibt.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge alle mit einem angegebenen regulären Ausdruck übereinstimmenden Zeichenfolgen durch eine von einem <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />-Delegaten zurückgegebene Zeichenfolge.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Eine Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn keine Entsprechung für das reguläre Ausdrucksmuster in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType>-Methode ist nützlich, um eine Entsprechung für reguläre Ausdrücke zu ersetzen, wenn eine der folgenden Bedingungen zutrifft:  
  
-   Die Ersetzungs Zeichenfolge kann nicht ohne weiteres durch ein Ersatz Muster für reguläre Ausdrücke angegeben werden.  
  
-   Die Ersetzungs Zeichenfolge ergibt sich aus der Verarbeitung der übereinstimmenden Zeichenfolge.  
  
-   Die Ersetzungs Zeichenfolge führt zu einer bedingten Verarbeitung.  
  
 Die-Methode entspricht dem Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType>-Methode und der Übergabe der einzelnen <xref:System.Text.RegularExpressions.Match> Objekte in der zurückgegebenen <xref:System.Text.RegularExpressions.MatchCollection> Collection an den `evaluator` Delegaten.  
  
 Der reguläre Ausdruck ist das Muster, das vom Konstruktor für das aktuelle <xref:System.Text.RegularExpressions.Regex> Objekt definiert wird.  
  
 Der `evaluator`-Parameter ist der Delegat für eine benutzerdefinierte Methode, die Sie definieren und die jede Übereinstimmung untersucht. Die benutzerdefinierte Methode muss die folgende Signatur aufweisen, um mit der <xref:System.Text.RegularExpressions.MatchEvaluator>-Delegaten zu vergleichen.  
 
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
   
 Die benutzerdefinierte Methode gibt eine Zeichenfolge zurück, die die übereinstimmende Eingabe ersetzt.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit des Ersetzungs Vorgangs das vom <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>-Konstruktor angegebene Timeout Intervall überschreitet. Wenn Sie beim Aufruf des Konstruktors kein Timeout Intervall festlegen, wird die Ausnahme ausgelöst, wenn der Vorgang einen Timeout Wert überschreitet, der für die Anwendungsdomäne festgelegt wurde, in der das <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn im <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in den Eigenschaften der Anwendungsdomäne kein Timeout definiert ist, oder wenn der Timeout Wert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>ist, wird keine Ausnahme ausgelöst.  
  
 Da die Methode `input` unverändert zurückgibt, wenn keine Entsprechung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>-Methode verwenden, um zu bestimmen, ob die Methode eine Ersetzung an der Eingabe Zeichenfolge vorgenommen hat.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine ursprüngliche Zeichenfolge angezeigt, die mit den einzelnen Wörtern in der ursprünglichen Zeichenfolge übereinstimmt, das erste Zeichen jeder Übereinstimmung in einen Großbuchstaben konvertiert und dann die konvertierte Zeichenfolge angezeigt.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Regex.Replace-Instance/cs/sample.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex.Replace-Instance/vb/sample.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> oder <paramref name="evaluator" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="~/docs/standard/base-types/substitutions-in-regular-expressions.md">Ersetzungen in regulären Ausdrücken</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int -&gt; string" Usage="regex.Replace (input, replacement, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="replacement">Die Ersatzzeichenfolge.</param>
        <param name="count">Die maximale Anzahl der Ersetzungen.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge eine angegebene Höchstanzahl von Zeichenfolgen, die mit dem Muster eines regulären Ausdrucks übereinstimmen, durch eine angegebene Ersetzungszeichenfolge.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Die Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn keine Entsprechung für das reguläre Ausdrucksmuster in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche nach Übereinstimmungen beginnt am Anfang der `input` Zeichenfolge. Der reguläre Ausdruck ist das Muster, das vom Konstruktor für das aktuelle <xref:System.Text.RegularExpressions.Regex> Objekt definiert wird. Wenn `count` negativ ist, werden die Ersetzungen bis zum Ende der Zeichenfolge fortgesetzt. Wenn `count` die Anzahl der Übereinstimmungen überschreitet, werden alle Übereinstimmungen ersetzt.  
  
 Der `replacement`-Parameter gibt die Zeichenfolge an, mit der die ersten `count` Übereinstimmungen in `input`ersetzt werden. `replacement` kann aus einer beliebigen Kombination aus Literaltext und [Substitutionen](~/docs/standard/base-types/substitutions-in-regular-expressions.md)bestehen. Das Ersetzungs Muster `a*${test}b` z. b. die Zeichenfolge "a *", gefolgt von der Teil Zeichenfolge, die mit der `test` Erfassungs Gruppe übereinstimmt, sofern vorhanden, gefolgt von der Zeichenfolge "b". Das Zeichen "*" wird nicht als Metazeichen innerhalb eines Ersetzungs Musters erkannt.  
  
> [!NOTE]
>  Ersetzungen sind die einzigen Sprachelemente für reguläre Ausdrücke, die in einem Ersetzungs Muster erkannt werden. Alle anderen Sprachelemente für reguläre Ausdrücke, einschließlich [Escapezeichen](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sind nur in Mustern für reguläre Ausdrücke zulässig und werden nicht in Ersetzungs Mustern erkannt.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit des Ersetzungs Vorgangs das vom <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>-Konstruktor angegebene Timeout Intervall überschreitet. Wenn Sie beim Aufruf des Konstruktors kein Timeout Intervall festlegen, wird die Ausnahme ausgelöst, wenn der Vorgang einen Timeout Wert überschreitet, der für die Anwendungsdomäne festgelegt wurde, in der das <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn im <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in den Eigenschaften der Anwendungsdomäne kein Timeout definiert ist, oder wenn der Timeout Wert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>ist, wird keine Ausnahme ausgelöst.  
  
 Da die Methode `input` unverändert zurückgibt, wenn keine Entsprechung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>-Methode verwenden, um zu bestimmen, ob die Methode eine Ersetzung an der Eingabe Zeichenfolge vorgenommen hat.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die ersten fünf Vorkommen doppelter Zeichen durch ein einzelnes Zeichen ersetzt. Das Muster für reguläre Ausdrücke `(\w)\1` entspricht aufeinander folgenden Vorkommen eines einzelnen Zeichens und weist das erste Vorkommen der ersten Erfassungs Gruppe zu. Das Ersetzungs Muster `$1` ersetzt die gesamte Übereinstimmung mit der ersten erfassten Gruppe.  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample8.cs" interactive="try-dotnet" id="Snippet8":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample8.vb" id="Snippet8":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> oder <paramref name="replacement" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
        <related type="Article" href="~/docs/standard/base-types/substitutions-in-regular-expressions.md">Ersetzungen in regulären Ausdrücken</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="replacement">Die Ersatzzeichenfolge.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge alle mit einem angegebenen regulären Ausdruck übereinstimmenden Zeichenfolgen durch eine angegebene Ersetzungszeichenfolge.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Die Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn für <paramref name="pattern" /> keine Übereinstimmung in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die statischen `Replace` Methoden entsprechen dem Erstellen eines <xref:System.Text.RegularExpressions.Regex> Objekts mit dem angegebenen Muster für reguläre Ausdrücke und dem Aufrufen der Instanzmethode `Replace`.  
  
 Der `pattern`-Parameter besteht aus Sprachelementen für reguläre Ausdrücke, die die zu Übereinstimmungs enden Zeichen folgen symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [.NET Framework reguläre Ausdrücke](~/docs/standard/base-types/regular-expressions.md) und [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht. Die Suche nach Übereinstimmungen beginnt am Anfang der `input` Zeichenfolge.  
  
 Der `replacement`-Parameter gibt die Zeichenfolge an, mit der die einzelnen Treffer in `input`ersetzt werden sollen. `replacement` kann aus einer beliebigen Kombination aus Literaltext und [Substitutionen](~/docs/standard/base-types/substitutions-in-regular-expressions.md)bestehen. Das Ersetzungs Muster `a*${test}b` z. b. die Zeichenfolge "a *", gefolgt von der Teil Zeichenfolge, die mit der `test` Erfassungs Gruppe übereinstimmt, sofern vorhanden, gefolgt von der Zeichenfolge "b". Das Zeichen "*" wird nicht als Metazeichen innerhalb eines Ersetzungs Musters erkannt.  
  
> [!NOTE]
>  Ersetzungen sind die einzigen Sprachelemente für reguläre Ausdrücke, die in einem Ersetzungs Muster erkannt werden. Alle anderen Sprachelemente für reguläre Ausdrücke, einschließlich [Escapezeichen](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sind nur in Mustern für reguläre Ausdrücke zulässig und werden nicht in Ersetzungs Mustern erkannt.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit des Ersetzungs Vorgangs das Timeout Intervall überschreitet, das für die Anwendungsdomäne festgelegt wurde, in der die-Methode aufgerufen wird. Wenn kein Timeout in den Eigenschaften der Anwendungsdomäne definiert ist, oder wenn der Timeout Wert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>ist, wird keine Ausnahme ausgelöst.  
  
 Da die Methode `input` unverändert zurückgibt, wenn keine Entsprechung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>-Methode verwenden, um zu bestimmen, ob die Methode eine Ersetzung an der Eingabe Zeichenfolge vorgenommen hat.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein regulärer Ausdruck (`\s+`) definiert, der mit einem oder mehreren Leerzeichen übereinstimmt. Die Ersetzungs Zeichenfolge "" ersetzt Sie durch ein einzelnes Leerzeichen.  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample6.cs" interactive="try-dotnet" id="Snippet6":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample6.vb" id="Snippet6"::: 
  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29>-Methode verwendet, um den lokalen Computer und die Laufwerks Namen in einem UNC-Pfad durch einen lokalen Dateipfad zu ersetzen. Der reguläre Ausdruck verwendet die <xref:System.Environment.MachineName%2A?displayProperty=nameWithType>-Eigenschaft, um den Namen des lokalen Computers einzuschließen, und die <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType>-Methode, um die Namen der logischen Laufwerke einzubeziehen. Um das Beispiel erfolgreich auszuführen, sollten Sie die Literalzeichenfolge "MyMachine" durch den Namen Ihres lokalen Computers ersetzen.  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace3.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace3.vb" id="Snippet3":::
  
 Das Muster für reguläre Ausdrücke wird durch den folgenden Ausdruck definiert:  
  
 `"\\\\(?i:" + Environment.MachineName + ")(?:\.\w+)*\\((?i:[" + driveNames + "]))\$"`  
  
 Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.  
  
|Muster|BESCHREIBUNG|  
|-------------|-----------------|  
|`\\\\`|Entsprechung für zwei aufeinanderfolgende umgekehrte Schrägstriche (`\`). Da der umgekehrte Schrägstrich als Escapezeichen interpretiert wird, muss jeder umgekehrte Schrägstrich mit einem anderen umgekehrten Schrägstrich versehen werden.|  
|`(?i:" + Environment.MachineName + ")`|Beachten Sie, dass die Zeichenfolge, die von der <xref:System.Environment.MachineName%2A?displayProperty=nameWithType>-Eigenschaft zurückgegeben wird, nicht beachtet wird.|  
|`(?:\.\w+)*`|Vergleichen Sie den Zeitraum (`.`), gefolgt von einem oder mehreren Wort Zeichen. Diese Entsprechung kann NULL oder mehrmals vorkommen. Der übereinstimmende Teil Ausdruck wird nicht erfasst.|  
|`\\`|Entsprechung für einen umgekehrten Schrägstrich (`\`).|  
|`((?i:[" + driveNames + "]))`|Führen Sie die Groß-/Kleinschreibung der Zeichenklasse aus, die aus den einzelnen Laufwerk Buchstaben besteht. Diese Entsprechung ist der erste erfasste Teil Ausdruck.|  
|`\$`|Entsprechung für das Literale Dollarzeichen (`$`).|  
  
 Das Ersetzungs Muster `$1` ersetzt die gesamte Entsprechung durch den ersten erfassten Teil Ausdruck. Das heißt, dass der UNC-Computer und der Laufwerks Name durch den Laufwerk Buchstaben ersetzt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" /> oder <paramref name="replacement" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage"><para>Bei dieser Methode wird nach einem Intervall, das gleich dem Standard Timeout Wert der Anwendungsdomäne ist, in der Sie aufgerufen wird, ein Timeout festgestellt. Wenn für die Anwendungsdomäne kein Timeout Wert definiert wurde, wird der Wert <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, der verhindert, dass die Methode ein Timeout verursacht, verwendet wird. Die empfohlene statische Methode zum Ersetzen einer Muster Übereinstimmung ist <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, mit der Sie das Timeout Intervall festlegen können.</para></block>
        <related type="Article" href="~/docs/standard/base-types/substitutions-in-regular-expressions.md">Ersetzungen in regulären Ausdrücken</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="evaluator">Eine benutzerdefinierte Methode, die jede Übereinstimmung überprüft und entweder die ursprüngliche entsprechende Zeichenfolge oder eine Ersatzzeichenfolge zurückgibt.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge alle mit einem angegebenen regulären Ausdruck übereinstimmenden Zeichenfolgen durch eine von einem <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />-Delegaten zurückgegebene Zeichenfolge.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Eine Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn für <paramref name="pattern" /> keine Übereinstimmung in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType>-Methode ist nützlich, um eine Entsprechung für reguläre Ausdrücke zu ersetzen, wenn eine der folgenden Bedingungen zutrifft:  
  
-   Die Ersetzungs Zeichenfolge kann nicht ohne weiteres durch ein Ersatz Muster für reguläre Ausdrücke angegeben werden.  
  
-   Die Ersetzungs Zeichenfolge ergibt sich aus der Verarbeitung der übereinstimmenden Zeichenfolge.  
  
-   Die Ersetzungs Zeichenfolge führt zu einer bedingten Verarbeitung.  
  
 Die-Methode entspricht dem Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType>-Methode und der Übergabe der einzelnen <xref:System.Text.RegularExpressions.Match> Objekte in der zurückgegebenen <xref:System.Text.RegularExpressions.MatchCollection> Collection an den `evaluator` Delegaten.  
  
 Der `pattern`-Parameter besteht aus Sprachelementen für reguläre Ausdrücke, die die zu Übereinstimmungs enden Zeichen folgen symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [.NET Framework reguläre Ausdrücke](~/docs/standard/base-types/regular-expressions.md) und [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht.  
  
 Der `evaluator`-Parameter ist der Delegat für eine benutzerdefinierte Methode, die Sie definieren und die jede Übereinstimmung untersucht. Die benutzerdefinierte Methode muss die folgende Signatur aufweisen, um mit der <xref:System.Text.RegularExpressions.MatchEvaluator>-Delegaten zu vergleichen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Die benutzerdefinierte Methode gibt eine Zeichenfolge zurück, die die übereinstimmende Eingabe ersetzt.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit des Ersetzungs Vorgangs das Timeout Intervall überschreitet, das für die Anwendungsdomäne festgelegt wurde, in der die-Methode aufgerufen wird. Wenn kein Timeout in den Eigenschaften der Anwendungsdomäne definiert ist, oder wenn der Timeout Wert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>ist, wird keine Ausnahme ausgelöst.  
  
 Da die Methode `input` unverändert zurückgibt, wenn keine Entsprechung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>-Methode verwenden, um zu bestimmen, ob die Methode eine Ersetzung an der Eingabe Zeichenfolge vorgenommen hat.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein regulärer Ausdruck verwendet, um die einzelnen Wörter aus einer Zeichenfolge zu extrahieren, und dann wird ein <xref:System.Text.RegularExpressions.MatchEvaluator> Delegaten verwendet, um eine Methode mit dem Namen `WordScramble` aufzurufen, die die einzelnen Buchstaben im Wort abruft. Zu diesem Zweck erstellt die `WordScramble`-Methode ein Array, das die Zeichen in der Entsprechung enthält. Außerdem wird ein paralleles Array erstellt, das mit zufälligen Gleit Komma Zahlen aufgefüllt wird. Die Arrays werden durch Aufrufen der <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>-Methode sortiert, und das sortierte Array wird als Argument für einen <xref:System.String> Klassenkonstruktor bereitgestellt. Diese neu erstellte Zeichenfolge wird dann von der `WordScramble`-Methode zurückgegeben. Das Muster für reguläre Ausdrücke `\w+` mit einem oder mehreren Wort Zeichen übereinstimmt. die Engine für reguläre Ausdrücke fügt der Entsprechung weiterhin Zeichen hinzu, bis ein nicht-Wort Zeichen (z. b. ein Leerzeichen) gefunden wird.  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace5.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace5.vb" id="Snippet2":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" /> oder <paramref name="evaluator" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage"><para>Bei dieser Methode wird nach einem Intervall, das gleich dem Standard Timeout Wert der Anwendungsdomäne ist, in der Sie aufgerufen wird, ein Timeout festgestellt. Wenn für die Anwendungsdomäne kein Timeout Wert definiert wurde, wird der Wert <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, der verhindert, dass die Methode ein Timeout verursacht, verwendet wird. Die empfohlene statische Methode zum Auswerten und Ersetzen einer Muster Übereinstimmung ist <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, mit dem Sie das Timeout Intervall festlegen können.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="~/docs/standard/base-types/substitutions-in-regular-expressions.md">Ersetzungen in regulären Ausdrücken</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int -&gt; string" Usage="regex.Replace (input, evaluator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="evaluator">Eine benutzerdefinierte Methode, die jede Übereinstimmung überprüft und entweder die ursprüngliche entsprechende Zeichenfolge oder eine Ersatzzeichenfolge zurückgibt.</param>
        <param name="count">Die maximale Anzahl der Ersetzungen.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge eine angegebene Höchstanzahl von Zeichenfolgen, die mit dem Muster eines regulären Ausdrucks übereinstimmen, durch eine von einem <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />-Delegaten zurückgegebene Zeichenfolge.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Eine Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn keine Entsprechung für das reguläre Ausdrucksmuster in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType>-Methode ist nützlich, um eine Entsprechung für reguläre Ausdrücke zu ersetzen, wenn eine der folgenden Bedingungen zutrifft:  
  
-   Die Ersetzungs Zeichenfolge kann nicht ohne weiteres durch ein Ersatz Muster für reguläre Ausdrücke angegeben werden.  
  
-   Die Ersetzungs Zeichenfolge ergibt sich aus der Verarbeitung der übereinstimmenden Zeichenfolge.  
  
-   Die Ersetzungs Zeichenfolge führt zu einer bedingten Verarbeitung.  
  
 Die-Methode entspricht dem Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType>-Methode und der Übergabe der ersten `count`<xref:System.Text.RegularExpressions.Match>-Objekten in der zurückgegebenen <xref:System.Text.RegularExpressions.MatchCollection> Auflistung an den `evaluator` Delegaten.  
  
 Der reguläre Ausdruck ist das Muster, das vom Konstruktor für das aktuelle <xref:System.Text.RegularExpressions.Regex> Objekt definiert wird.  
  
 Der `evaluator`-Parameter ist der Delegat für eine benutzerdefinierte Methode, die Sie definieren und die jede Übereinstimmung untersucht. Die benutzerdefinierte Methode muss die folgende Signatur aufweisen, um mit der <xref:System.Text.RegularExpressions.MatchEvaluator>-Delegaten zu vergleichen.  

 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
    
 Die benutzerdefinierte Methode gibt eine Zeichenfolge zurück, die die übereinstimmende Eingabe ersetzt.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit des Ersetzungs Vorgangs das vom <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>-Konstruktor angegebene Timeout Intervall überschreitet. Wenn Sie beim Aufruf des Konstruktors kein Timeout Intervall festlegen, wird die Ausnahme ausgelöst, wenn der Vorgang einen Timeout Wert überschreitet, der für die Anwendungsdomäne festgelegt wurde, in der das <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn im <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in den Eigenschaften der Anwendungsdomäne kein Timeout definiert ist, oder wenn der Timeout Wert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>ist, wird keine Ausnahme ausgelöst.  
  
 Da die Methode `input` unverändert zurückgibt, wenn keine Entsprechung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>-Methode verwenden, um zu bestimmen, ob die Methode eine Ersetzung an der Eingabe Zeichenfolge vorgenommen hat.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein regulärer Ausdruck verwendet, um die Hälfte der Wörter in einer Liste absichtlich falsch zu benennen. Er verwendet den regulären Ausdruck `\w*(ie|ei)\w*`, um die Wörter abzugleichen, die die Zeichen "IE" oder "Ei" enthalten. Sie übergibt die erste Hälfte der übereinstimmenden Wörter an die `ReverseLetter`-Methode, die wiederum die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>-Methode verwendet, um "i" und "e" in der übereinstimmenden Zeichenfolge umzukehren. Die restlichen Wörter bleiben unverändert.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace7.cs" interactive="try-dotnet" id="Snippet11":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace7.vb" id="Snippet11":::  
  
 Der reguläre Ausdruck `\w*(ie|ei)\w*` wird entsprechend der Darstellung in der folgenden Tabelle definiert:  
  
|Muster|BESCHREIBUNG|  
|-------------|-----------------|  
|`\w*`|Übereinstimmung mit keinem oder mehreren Wortzeichen.|  
|<code>(ie&#124;ei)</code>|Entspricht "IE" oder "Ei".|  
|`\w*`|Übereinstimmung mit keinem oder mehreren Wortzeichen.|  
  
 Das Muster für reguläre Ausdrücke, das in der `ReverseLetter`-Methode `([ie])([ie])` wird, stimmt mit dem ersten "i" oder "e" in der Diphthong "IE" oder "Ei" überein und weist den Buchstaben der ersten Erfassungs Gruppe zu. Sie entspricht dem zweiten "i" oder "e" und weist den Buchstaben der zweiten Erfassungs Gruppe zu. Anschließend werden die beiden Zeichen umgekehrt, indem die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29>-Methode mit dem Ersetzungs Muster `$2$1`aufgerufen wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> oder <paramref name="evaluator" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="~/docs/standard/base-types/substitutions-in-regular-expressions.md">Ersetzungen in regulären Ausdrücken</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; string" Usage="regex.Replace (input, replacement, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="replacement">Die Ersatzzeichenfolge.</param>
        <param name="count">Die maximale Anzahl der Ersetzungen.</param>
        <param name="startat">Die Zeichenposition in der Eingabezeichenfolge, an der mit der Suche begonnen wird.</param>
        <summary>Ersetzt in einer angegebenen Eingabeteilzeichenfolge eine angegebene Höchstanzahl von Zeichenfolgen, die mit dem Muster eines regulären Ausdrucks übereinstimmen, durch eine angegebene Ersetzungszeichenfolge.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Die Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn keine Entsprechung für das reguläre Ausdrucksmuster in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche nach Übereinstimmungen beginnt in der `input` Zeichenfolge an der Position, die durch den `startat`-Parameter angegeben wird. Der reguläre Ausdruck ist das Muster, das vom Konstruktor für das aktuelle <xref:System.Text.RegularExpressions.Regex> Objekt definiert wird. Wenn `count` negativ ist, werden die Ersetzungen bis zum Ende der Zeichenfolge fortgesetzt. Wenn `count` die Anzahl der Übereinstimmungen überschreitet, werden alle Übereinstimmungen ersetzt.  
  
 Der `replacement`-Parameter gibt die Zeichenfolge an, mit der die einzelnen Treffer in `input`ersetzt werden sollen. `replacement` kann aus einer beliebigen Kombination aus Literaltext und [Substitutionen](~/docs/standard/base-types/substitutions-in-regular-expressions.md)bestehen. Das Ersetzungs Muster `a*${test}b` z. b. die Zeichenfolge "a *", gefolgt von der Teil Zeichenfolge, die mit der `test` Erfassungs Gruppe übereinstimmt, sofern vorhanden, gefolgt von der Zeichenfolge "b". Das Zeichen "*" wird nicht als Metazeichen innerhalb eines Ersetzungs Musters erkannt.  
  
> [!NOTE]
>  Ersetzungen sind die einzigen Sprachelemente für reguläre Ausdrücke, die in einem Ersetzungs Muster erkannt werden. Alle anderen Sprachelemente für reguläre Ausdrücke, einschließlich [Escapezeichen](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sind nur in Mustern für reguläre Ausdrücke zulässig und werden nicht in Ersetzungs Mustern erkannt.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit des Ersetzungs Vorgangs das vom <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>-Konstruktor angegebene Timeout Intervall überschreitet. Wenn Sie beim Aufruf des Konstruktors kein Timeout Intervall festlegen, wird die Ausnahme ausgelöst, wenn der Vorgang einen Timeout Wert überschreitet, der für die Anwendungsdomäne festgelegt wurde, in der das <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn im <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in den Eigenschaften der Anwendungsdomäne kein Timeout definiert ist, oder wenn der Timeout Wert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>ist, wird keine Ausnahme ausgelöst.  
  
 Da die Methode `input` unverändert zurückgibt, wenn keine Entsprechung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>-Methode verwenden, um zu bestimmen, ob die Methode eine Ersetzung an der Eingabe Zeichenfolge vorgenommen hat.  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle außer der ersten Zeile einer Zeichenfolge mit zwei Leerzeichen dargestellt. Er definiert ein Muster für reguläre Ausdrücke, `^.*$`, das mit einer Textzeile übereinstimmt, ruft die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29>-Methode auf, um die erste Zeile der Zeichenfolge abzugleichen, und verwendet die Eigenschaften `Match.Index` und `Match.Count`, um die Anfangsposition der zweiten Zeile zu ermitteln.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample9.cs" interactive="try-dotnet" id="Snippet9":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample9.vb" id="Snippet9"::: 
  
 Das Muster für reguläre Ausdrücke `^.*$` wird entsprechend der folgenden Tabelle definiert:  
  
|Muster|BESCHREIBUNG|  
|-------------|-----------------|  
|`^`|Übereinstimmung mit dem Anfang einer Zeile. (Beachten Sie, dass das <xref:System.Text.RegularExpressions.Regex> Objekt mit der <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>-Option instanziiert wurde. andernfalls entspricht diese Zeichenklasse nur dem Anfang der Eingabe Zeichenfolge.)|  
|`.*`|Übereinstimmung mit keinem oder mehreren beliebigen Zeichen.|  
|`$`|Übereinstimmung mit dem Ende einer Zeile. (Beachten Sie, dass das <xref:System.Text.RegularExpressions.Regex> Objekt mit der <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>-Option instanziiert wurde. andernfalls entspricht diese Zeichenklasse nur dem Anfang der Eingabe Zeichenfolge.)|  
  
 Die Ersetzungs Zeichenfolge (`vbCrLf + "$&"` in Visual Basic C#, `"\n$&"` in) fügt vor der übereinstimmenden Zeichenfolge eine neue Zeile hinzu. Beachten Sie, dass `\n` C# im Beispiel vom C# Compiler als Zeilen Zeilenzeichen interpretiert wird. Es stellt keinen Escapezeichen für reguläre Ausdrücke dar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> oder <paramref name="replacement" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> ist kleiner als 0 (null) oder größer als die Länge von <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <related type="Article" href="~/docs/standard/base-types/substitutions-in-regular-expressions.md">Ersetzungen in regulären Ausdrücken</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="replacement">Die Ersatzzeichenfolge.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge alle mit einem angegebenen regulären Ausdruck übereinstimmenden Zeichenfolgen durch eine angegebene Ersetzungszeichenfolge. Durch angegebene Optionen wird die Suche nach Übereinstimmungen geändert.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Die Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn für <paramref name="pattern" /> keine Übereinstimmung in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die statischen `Replace` Methoden entsprechen dem Erstellen eines <xref:System.Text.RegularExpressions.Regex> Objekts mit dem angegebenen Muster für reguläre Ausdrücke und dem Aufrufen der Instanzmethode `Replace`.  
  
 Der `pattern`-Parameter besteht aus Sprachelementen für reguläre Ausdrücke, die die zu Übereinstimmungs enden Zeichen folgen symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [.NET Framework reguläre Ausdrücke](~/docs/standard/base-types/regular-expressions.md) und [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht. Wenn Sie <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> für den Parameter `options` angeben, beginnt die Suche nach Übereinstimmungen am Ende der Eingabe Zeichenfolge und verschiebt nach links. Andernfalls beginnt die Suche am Anfang der Eingabe Zeichenfolge und wird nach rechts verschoben.  
  
 Der `replacement`-Parameter gibt die Zeichenfolge an, mit der die einzelnen Treffer in `input`ersetzt werden sollen. `replacement` kann aus einer beliebigen Kombination aus Literaltext und [Substitutionen](~/docs/standard/base-types/substitutions-in-regular-expressions.md)bestehen. Das Ersetzungs Muster `a*${test}b` z. b. die Zeichenfolge "a *", gefolgt von der Teil Zeichenfolge, die mit der `test` Erfassungs Gruppe übereinstimmt, sofern vorhanden, gefolgt von der Zeichenfolge "b". Das Zeichen "*" wird nicht als Metazeichen innerhalb eines Ersetzungs Musters erkannt.  
  
> [!NOTE]
>  Ersetzungen sind die einzigen Sprachelemente für reguläre Ausdrücke, die in einem Ersetzungs Muster erkannt werden. Alle anderen Sprachelemente für reguläre Ausdrücke, einschließlich [Escapezeichen](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sind nur in Mustern für reguläre Ausdrücke zulässig und werden nicht in Ersetzungs Mustern erkannt.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit des Ersetzungs Vorgangs das Timeout Intervall überschreitet, das für die Anwendungsdomäne festgelegt wurde, in der die-Methode aufgerufen wird. Wenn kein Timeout in den Eigenschaften der Anwendungsdomäne definiert ist, oder wenn der Timeout Wert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>ist, wird keine Ausnahme ausgelöst.  
  
 Da die Methode `input` unverändert zurückgibt, wenn keine Entsprechung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>-Methode verwenden, um zu bestimmen, ob die Methode eine Ersetzung an der Eingabe Zeichenfolge vorgenommen hat.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29>-Methode verwendet, um den lokalen Computer und die Laufwerks Namen in einem UNC-Pfad durch einen lokalen Dateipfad zu ersetzen. Der reguläre Ausdruck verwendet die <xref:System.Environment.MachineName%2A?displayProperty=nameWithType>-Eigenschaft, um den Namen des lokalen Computers einzuschließen, und die <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType>-Methode, um die Namen der logischen Laufwerke einzubeziehen. Bei allen Vergleichen von Zeichen folgen für reguläre Ausdrücke wird die groß-/klein Um das Beispiel erfolgreich auszuführen, sollten Sie die Literalzeichenfolge "MyMachine" durch den Namen Ihres lokalen Computers ersetzen.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace4.cs" interactive="try-dotnet" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace4.vb" id="Snippet4":::
  
 Das Muster für reguläre Ausdrücke wird durch den folgenden Ausdruck definiert:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.  
  
|Muster|BESCHREIBUNG|  
|-------------|-----------------|  
|`\\\\`|Entsprechung für zwei aufeinanderfolgende umgekehrte Schrägstriche (`\`). Da der umgekehrte Schrägstrich als Escapezeichen interpretiert wird, muss jeder umgekehrte Schrägstrich mit einem anderen umgekehrten Schrägstrich versehen werden.|  
|`+ Environment.MachineName +`|Vergleichen Sie die Zeichenfolge, die von der <xref:System.Environment.MachineName%2A?displayProperty=nameWithType>-Eigenschaft zurückgegeben wird.|  
|`(?:\.\w+)*`|Vergleichen Sie den Zeitraum (`.`), gefolgt von einem oder mehreren Wort Zeichen. Diese Entsprechung kann NULL oder mehrmals vorkommen. Der übereinstimmende Teil Ausdruck wird nicht erfasst.|  
|`\\`|Entsprechung für einen umgekehrten Schrägstrich (`\`).|  
|`([" + driveNames + "])`|Vergleichen Sie die Zeichenklasse, die aus den einzelnen Laufwerk Buchstaben besteht. Diese Entsprechung ist der erste erfasste Teil Ausdruck.|  
|`\$`|Entsprechung für das Literale Dollarzeichen (`$`).|  
  
 Das Ersetzungs Muster `$1` ersetzt die gesamte Entsprechung durch den ersten erfassten Teil Ausdruck. Das heißt, dass der UNC-Computer und der Laufwerks Name durch den Laufwerk Buchstaben ersetzt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" /> oder <paramref name="replacement" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage"><para>Bei dieser Methode wird nach einem Intervall, das gleich dem Standard Timeout Wert der Anwendungsdomäne ist, in der Sie aufgerufen wird, ein Timeout festgestellt. Wenn für die Anwendungsdomäne kein Timeout Wert definiert wurde, wird der Wert <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, der verhindert, dass die Methode ein Timeout verursacht, verwendet wird. Die empfohlene statische Methode zum Ersetzen einer Muster Übereinstimmung ist <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, mit der Sie das Timeout Intervall festlegen können.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="~/docs/standard/base-types/substitutions-in-regular-expressions.md">Ersetzungen in regulären Ausdrücken</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="evaluator">Eine benutzerdefinierte Methode, die jede Übereinstimmung überprüft und entweder die ursprüngliche entsprechende Zeichenfolge oder eine Ersatzzeichenfolge zurückgibt.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge alle mit einem angegebenen regulären Ausdruck übereinstimmenden Zeichenfolgen durch eine von einem <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />-Delegaten zurückgegebene Zeichenfolge. Durch angegebene Optionen wird die Suche nach Übereinstimmungen geändert.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Eine Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn für <paramref name="pattern" /> keine Übereinstimmung in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>-Methode ist nützlich, um eine Entsprechung für reguläre Ausdrücke in zu ersetzen, wenn eine der folgenden Bedingungen zutrifft:  
  
-   Die Ersetzungs Zeichenfolge kann nicht ohne weiteres durch ein Ersatz Muster für reguläre Ausdrücke angegeben werden.  
  
-   Die Ersetzungs Zeichenfolge ergibt sich aus der Verarbeitung der übereinstimmenden Zeichenfolge.  
  
-   Die Ersetzungs Zeichenfolge führt zu einer bedingten Verarbeitung.  
  
 Die-Methode entspricht dem Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>-Methode und der Übergabe der einzelnen <xref:System.Text.RegularExpressions.Match> Objekte in der zurückgegebenen <xref:System.Text.RegularExpressions.MatchCollection> Collection an den `evaluator` Delegaten.  
  
 Der `pattern`-Parameter besteht aus Sprachelementen für reguläre Ausdrücke, die die zu Übereinstimmungs enden Zeichen folgen symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [.NET Framework reguläre Ausdrücke](~/docs/standard/base-types/regular-expressions.md) und [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht.  
  
 Der `evaluator`-Parameter ist der Delegat für eine benutzerdefinierte Methode, die Sie definieren und die jede Übereinstimmung untersucht. Die benutzerdefinierte Methode muss die folgende Signatur aufweisen, um mit der <xref:System.Text.RegularExpressions.MatchEvaluator>-Delegaten zu vergleichen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
   
 Die benutzerdefinierte Methode gibt eine Zeichenfolge zurück, die die übereinstimmende Eingabe ersetzt.  
  
 Wenn Sie <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> für den Parameter `options` angeben, beginnt die Suche nach Übereinstimmungen am Ende der Eingabe Zeichenfolge und verschiebt nach links. Andernfalls beginnt die Suche am Anfang der Eingabe Zeichenfolge und wird nach rechts verschoben.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit des Ersetzungs Vorgangs das Timeout Intervall überschreitet, das für die Anwendungsdomäne festgelegt wurde, in der die-Methode aufgerufen wird. Wenn kein Timeout in den Eigenschaften der Anwendungsdomäne definiert ist, oder wenn der Timeout Wert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>ist, wird keine Ausnahme ausgelöst.  
  
 Da die Methode `input` unverändert zurückgibt, wenn keine Entsprechung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>-Methode verwenden, um zu bestimmen, ob die Methode eine Ersetzung an der Eingabe Zeichenfolge vorgenommen hat.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein regulärer Ausdruck verwendet, um die einzelnen Wörter aus einer Zeichenfolge zu extrahieren, und dann wird ein <xref:System.Text.RegularExpressions.MatchEvaluator> Delegaten verwendet, um eine Methode mit dem Namen `WordScramble` aufzurufen, die die einzelnen Buchstaben im Wort abruft. Zu diesem Zweck erstellt die `WordScramble`-Methode ein Array, das die Zeichen in der Entsprechung enthält. Außerdem wird ein paralleles Array erstellt, das mit zufälligen Gleit Komma Zahlen aufgefüllt wird. Die Arrays werden durch Aufrufen der <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>-Methode sortiert, und das sortierte Array wird als Argument für einen <xref:System.String> Klassenkonstruktor bereitgestellt. Diese neu erstellte Zeichenfolge wird dann von der `WordScramble`-Methode zurückgegeben. Das Muster für reguläre Ausdrücke `\w+` mit einem oder mehreren Wort Zeichen übereinstimmt. die Engine für reguläre Ausdrücke fügt der Entsprechung weiterhin Zeichen hinzu, bis ein nicht-Wort Zeichen (z. b. ein Leerzeichen) gefunden wird. Der aufzurufende <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> Methode enthält die <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>-Option, sodass der Kommentar im Muster für reguläre Ausdrücke `\w+  # Matches all the characters in a word.` von der Engine für reguläre Ausdrücke ignoriert wird.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace6.cs" interactive="try-dotnet" id="Snippet10":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace6.vb" id="Snippet10"::: 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" /> oder <paramref name="evaluator" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="~/docs/standard/base-types/substitutions-in-regular-expressions.md">Ersetzungen in regulären Ausdrücken</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int * int -&gt; string" Usage="regex.Replace (input, evaluator, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="evaluator">Eine benutzerdefinierte Methode, die jede Übereinstimmung überprüft und entweder die ursprüngliche entsprechende Zeichenfolge oder eine Ersatzzeichenfolge zurückgibt.</param>
        <param name="count">Die maximale Anzahl der Ersetzungen.</param>
        <param name="startat">Die Zeichenposition in der Eingabezeichenfolge, an der mit der Suche begonnen wird.</param>
        <summary>Ersetzt in einer angegebenen Eingabeteilzeichenfolge eine angegebene Höchstanzahl von Zeichenfolgen, die mit dem Muster eines regulären Ausdrucks übereinstimmen, durch eine von einem <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />-Delegaten zurückgegebene Zeichenfolge.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Eine Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn keine Entsprechung für das reguläre Ausdrucksmuster in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>-Methode ist nützlich, um eine Entsprechung für reguläre Ausdrücke zu ersetzen, wenn eine der folgenden Bedingungen zutrifft:  
  
-   Die Ersetzungs Zeichenfolge kann nicht ohne weiteres durch ein Ersatz Muster für reguläre Ausdrücke angegeben werden.  
  
-   Die Ersetzungs Zeichenfolge ergibt sich aus der Verarbeitung der übereinstimmenden Zeichenfolge.  
  
-   Die Ersetzungs Zeichenfolge führt zu einer bedingten Verarbeitung.  
  
 Die-Methode entspricht dem Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>-Methode und der Übergabe der ersten `count`<xref:System.Text.RegularExpressions.Match>-Objekten in der zurückgegebenen <xref:System.Text.RegularExpressions.MatchCollection> Auflistung an den `evaluator` Delegaten.  
  
 Der reguläre Ausdruck ist das Muster, das vom Konstruktor für das aktuelle <xref:System.Text.RegularExpressions.Regex> Objekt definiert wird.  
  
 Der `evaluator`-Parameter ist der Delegat für eine benutzerdefinierte Methode, die Sie definieren und die jede Übereinstimmung untersucht. Die benutzerdefinierte Methode muss die folgende Signatur aufweisen, um mit der <xref:System.Text.RegularExpressions.MatchEvaluator>-Delegaten zu vergleichen.  
 
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
   
 Die benutzerdefinierte Methode gibt eine Zeichenfolge zurück, die die übereinstimmende Eingabe ersetzt.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit des Ersetzungs Vorgangs das vom <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>-Konstruktor angegebene Timeout Intervall überschreitet. Wenn Sie beim Aufruf des Konstruktors kein Timeout Intervall festlegen, wird die Ausnahme ausgelöst, wenn der Vorgang einen Timeout Wert überschreitet, der für die Anwendungsdomäne festgelegt wurde, in der das <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn im <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in den Eigenschaften der Anwendungsdomäne kein Timeout definiert ist, oder wenn der Timeout Wert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>ist, wird keine Ausnahme ausgelöst.  
  
 Da die Methode `input` unverändert zurückgibt, wenn keine Entsprechung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>-Methode verwenden, um zu bestimmen, ob die Methode eine Ersetzung an der Eingabe Zeichenfolge vorgenommen hat.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> oder <paramref name="evaluator" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> ist kleiner als 0 (null) oder größer als die Länge von <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="~/docs/standard/base-types/substitutions-in-regular-expressions.md">Ersetzungen in regulären Ausdrücken</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="replacement" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="4" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="replacement">Die Ersatzzeichenfolge.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <param name="matchTimeout">Ein Timeoutintervall oder <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das angibt, dass die Methode kein Timeout haben sollte.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge alle mit einem angegebenen regulären Ausdruck übereinstimmenden Zeichenfolgen durch eine angegebene Ersetzungszeichenfolge. Zusätzliche Parameter geben die Optionen an, die den entsprechenden Vorgang und ein Timeoutintervall ändern, wenn keine Übereinstimmung gefunden wird.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Die Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn für <paramref name="pattern" /> keine Übereinstimmung in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die statischen `Replace` Methoden entsprechen dem Erstellen eines <xref:System.Text.RegularExpressions.Regex> Objekts mit dem angegebenen Muster für reguläre Ausdrücke und dem Aufrufen der Instanzmethode `Replace`.  
  
 Der `pattern`-Parameter besteht aus Sprachelementen für reguläre Ausdrücke, die die zu Übereinstimmungs enden Zeichen folgen symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [.NET Framework reguläre Ausdrücke](~/docs/standard/base-types/regular-expressions.md) und [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht. Wenn Sie <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> für den Parameter `options` angeben, beginnt die Suche nach Übereinstimmungen am Ende der Eingabe Zeichenfolge und verschiebt nach links. Andernfalls beginnt die Suche am Anfang der Eingabe Zeichenfolge und wird nach rechts verschoben.  
  
 Der `replacement`-Parameter gibt die Zeichenfolge an, mit der die einzelnen Treffer in `input`ersetzt werden sollen. `replacement` kann aus einer beliebigen Kombination aus Literaltext und [Substitutionen](~/docs/standard/base-types/substitutions-in-regular-expressions.md)bestehen. Das Ersetzungs Muster `a*${test}b` z. b. die Zeichenfolge "a *", gefolgt von der Teil Zeichenfolge, die mit der `test` Erfassungs Gruppe übereinstimmt, sofern vorhanden, gefolgt von der Zeichenfolge "b". Das Zeichen "*" wird nicht als Metazeichen innerhalb eines Ersetzungs Musters erkannt.  
  
> [!NOTE]
>  Ersetzungen sind die einzigen Sprachelemente für reguläre Ausdrücke, die in einem Ersetzungs Muster erkannt werden. Alle anderen Sprachelemente für reguläre Ausdrücke, einschließlich [Escapezeichen](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sind nur in Mustern für reguläre Ausdrücke zulässig und werden nicht in Ersetzungs Mustern erkannt.  
  
 Der `matchTimeout`-Parameter gibt an, wie lange eine Muster Vergleichsmethode versuchen sollte, eine Übereinstimmung zu finden, bevor ein Timeout auftritt. Das Festlegen eines Timeout Intervalls verhindert, dass reguläre Ausdrücke, die auf einer übermäßigen Rückverfolgung basieren, nicht mehr reagieren, wenn Sie Eingaben verarbeiten, die Near-Übereinstimmungen enthalten. Weitere Informationen finden Sie unter [bewährte Methoden für reguläre Ausdrücke](~/docs/standard/base-types/best-practices.md) und [Rückverfolgung](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Wenn in diesem Zeitintervall keine Entsprechung gefunden wird, löst die Methode eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme aus. `matchTimeout` überschreibt jeden Standard Timeout Wert, der für die Anwendungsdomäne definiert ist, in der die Methode ausgeführt wird.  
  
 Da die Methode `input` unverändert zurückgibt, wenn keine Entsprechung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>-Methode verwenden, um zu bestimmen, ob die Methode eine Ersetzung an der Eingabe Zeichenfolge vorgenommen hat.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>-Methode verwendet, um den lokalen Computer und die Laufwerks Namen in einem UNC-Pfad durch einen lokalen Dateipfad zu ersetzen. Der reguläre Ausdruck verwendet die <xref:System.Environment.MachineName%2A?displayProperty=nameWithType>-Eigenschaft, um den Namen des lokalen Computers einzuschließen, und die <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType>-Methode, um die Namen der logischen Laufwerke einzubeziehen. Bei allen Vergleichen von Zeichen folgen mit regulärem Ausdruck wird die Groß-/Kleinschreibung nicht beachtet, und bei jedem einzelnen Ersetzungs Vorgang wird ein Timeout festgestellt, wenn in 0,5 Um das Beispiel erfolgreich auszuführen, sollten Sie die Literalzeichenfolge "MyMachine" durch den Namen Ihres lokalen Computers ersetzen.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace12.cs" interactive="try-dotnet" id="Snippet12":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace12.vb" id="Snippet12"::: 
  
 Das Muster für reguläre Ausdrücke wird durch den folgenden Ausdruck definiert:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.  
  
|Muster|BESCHREIBUNG|  
|-------------|-----------------|  
|`\\\\`|Entsprechung für zwei aufeinanderfolgende umgekehrte Schrägstriche (`\`). Da der umgekehrte Schrägstrich als Escapezeichen interpretiert wird, muss jeder umgekehrte Schrägstrich mit einem anderen umgekehrten Schrägstrich versehen werden.|  
|`+ Environment.MachineName +`|Vergleichen Sie die Zeichenfolge, die von der <xref:System.Environment.MachineName%2A?displayProperty=nameWithType>-Eigenschaft zurückgegeben wird.|  
|`(?:\.\w+)*`|Vergleichen Sie den Zeitraum (`.`), gefolgt von einem oder mehreren Wort Zeichen. Diese Entsprechung kann NULL oder mehrmals vorkommen. Der übereinstimmende Teil Ausdruck wird nicht erfasst.|  
|`\\`|Entsprechung für einen umgekehrten Schrägstrich (`\`).|  
|`([" + driveNames + "])`|Vergleichen Sie die Zeichenklasse, die aus den einzelnen Laufwerk Buchstaben besteht. Diese Entsprechung ist der erste erfasste Teil Ausdruck.|  
|`\$`|Entsprechung für das Literale Dollarzeichen (`$`).|  
  
 Das Ersetzungs Muster `$1` ersetzt die gesamte Entsprechung durch den ersten erfassten Teil Ausdruck. Das heißt, dass der UNC-Computer und der Laufwerks Name durch den Laufwerk Buchstaben ersetzt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" /> oder <paramref name="replacement" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.  
  
Oder 
 <paramref name="matchTimeout" /> ist negativ, null oder größer als ca. 24 Tage.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage"><para>Es wird empfohlen, den <paramref name="matchTimeout" />-Parameter auf einen geeigneten Wert, z. b. zwei Sekunden, festzulegen. Wenn Sie Timeouts durch Angeben von <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />deaktivieren, bietet die Engine für reguläre Ausdrücke eine etwas bessere Leistung. Timeouts sollten jedoch nur unter den folgenden Bedingungen deaktiviert werden: 
: Wenn die von einem regulären Ausdruck verarbeitete Eingabe von einer bekannten und vertrauenswürdigen Quelle abgeleitet ist oder aus statischem Text besteht. Dies schließt Text aus, der von Benutzern dynamisch eingegeben wurde.  
  
: Wenn das Muster für reguläre Ausdrücke gründlich getestet wurde, um sicherzustellen, dass es Übereinstimmungen, nicht-Übereinstimmungen und NEAR-Übereinstimmungen effizient behandelt.  
  
-Wenn das Muster für reguläre Ausdrücke keine Sprachelemente enthält, die bekanntermaßen eine übermäßige Rückverfolgung verursachen, wenn eine nahe Übereinstimmung verarbeitet wird.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="~/docs/standard/base-types/substitutions-in-regular-expressions.md">Ersetzungen in regulären Ausdrücken</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
        <related type="Article" href="~/docs/standard/base-types/backtracking-in-regular-expressions.md">Backtracking in regulären Ausdrücken</related>
        <related type="Article" href="~/docs/standard/base-types/best-practices.md">Empfohlene Vorgehensweisen für die Verwendung von regulären Ausdrücken in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="4" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="evaluator">Eine benutzerdefinierte Methode, die jede Übereinstimmung überprüft und entweder die ursprüngliche entsprechende Zeichenfolge oder eine Ersatzzeichenfolge zurückgibt.</param>
        <param name="options">Eine bitweise Kombination von Enumerationswerten, die Optionen für Vergleiche angeben.</param>
        <param name="matchTimeout">Ein Timeoutintervall oder <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das angibt, dass die Methode kein Timeout haben sollte.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge alle mit einem angegebenen regulären Ausdruck übereinstimmenden Teilzeichenfolgen durch eine von einem <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />-Delegaten zurückgegebene Zeichenfolge. Zusätzliche Parameter geben die Optionen an, die den entsprechenden Vorgang und ein Timeoutintervall ändern, wenn keine Übereinstimmung gefunden wird.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Die Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn für <paramref name="pattern" /> keine Übereinstimmung in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>-Methode ist nützlich, um eine Entsprechung für reguläre Ausdrücke zu ersetzen, wenn eine der folgenden Bedingungen zutrifft:  
  
-   , Wenn die Ersetzungs Zeichenfolge nicht leicht durch ein Ersatz Muster für reguläre Ausdrücke angegeben werden kann.  
  
-   , Wenn die Ersetzungs Zeichenfolge aus der Verarbeitung der übereinstimmenden Zeichenfolge resultiert.  
  
-   , Wenn die Ersetzungs Zeichenfolge aus der bedingten Verarbeitung resultiert.  
  
 Die-Methode entspricht dem Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>-Methode und der Übergabe der einzelnen <xref:System.Text.RegularExpressions.Match> Objekte in der zurückgegebenen <xref:System.Text.RegularExpressions.MatchCollection> Collection an den `evaluator` Delegaten.  
  
 Der `pattern`-Parameter besteht aus Sprachelementen für reguläre Ausdrücke, die die zu Übereinstimmungs enden Zeichen folgen symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [.NET Framework reguläre Ausdrücke](~/docs/standard/base-types/regular-expressions.md) und [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht.  
  
 Der `evaluator`-Parameter ist der Delegat für eine benutzerdefinierte Methode, die Sie definieren und die jede Übereinstimmung untersucht. Die benutzerdefinierte Methode muss die folgende Signatur aufweisen, um mit der <xref:System.Text.RegularExpressions.MatchEvaluator>-Delegaten zu vergleichen.  
 
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
   
 Die benutzerdefinierte Methode gibt eine Zeichenfolge zurück, die die übereinstimmende Eingabe ersetzt.  
  
 Wenn Sie <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> für den Parameter `options` angeben, beginnt die Suche nach Übereinstimmungen am Ende der Eingabe Zeichenfolge und verschiebt nach links. Andernfalls beginnt die Suche am Anfang der Eingabe Zeichenfolge und wird nach rechts verschoben.  
  
 Der `matchTimeout`-Parameter gibt an, wie lange eine Muster Vergleichsmethode versuchen sollte, eine Übereinstimmung zu finden, bevor ein Timeout auftritt. Das Festlegen eines Timeout Intervalls verhindert, dass reguläre Ausdrücke, die auf übermäßiger Rückverfolgung basieren, nicht mehr reagieren, wenn Sie Eingaben verarbeiten, die Near-Übereinstimmungen enthalten. Weitere Informationen finden Sie unter [bewährte Methoden für reguläre Ausdrücke](~/docs/standard/base-types/best-practices.md) und [Rückverfolgung](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Wenn in diesem Zeitintervall keine Entsprechung gefunden wird, löst die Methode eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme aus. `matchTimeout` überschreibt jeden Standard Timeout Wert, der für die Anwendungsdomäne definiert ist, in der die Methode ausgeführt wird.  
  
 Da die Methode `input` unverändert zurückgibt, wenn keine Entsprechung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>-Methode verwenden, um zu bestimmen, ob die Methode eine Ersetzung an der Eingabe Zeichenfolge vorgenommen hat.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein regulärer Ausdruck verwendet, um die einzelnen Wörter aus einer Zeichenfolge zu extrahieren, und dann wird ein <xref:System.Text.RegularExpressions.MatchEvaluator> Delegaten verwendet, um eine Methode mit dem Namen `WordScramble` aufzurufen, die die einzelnen Buchstaben im Wort abruft. Zu diesem Zweck erstellt die `WordScramble`-Methode ein Array, das die Zeichen in der Entsprechung enthält. Außerdem wird ein paralleles Array erstellt, das mit zufälligen Gleit Komma Zahlen aufgefüllt wird. Die Arrays werden durch Aufrufen der <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>-Methode sortiert, und das sortierte Array wird als Argument für einen <xref:System.String> Klassenkonstruktor bereitgestellt. Diese neu erstellte Zeichenfolge wird dann von der `WordScramble`-Methode zurückgegeben. Das Muster für reguläre Ausdrücke `\w+` mit einem oder mehreren Wort Zeichen übereinstimmt. die Engine für reguläre Ausdrücke fügt der Entsprechung weiterhin Zeichen hinzu, bis ein nicht-Wort Zeichen (z. b. ein Leerzeichen) gefunden wird. Der aufzurufende <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> Methode enthält die <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>-Option, sodass der Kommentar im Muster für reguläre Ausdrücke `\w+  # Matches all the characters in a word.` von der Engine für reguläre Ausdrücke ignoriert wird.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace13.cs" interactive="try-dotnet" id="Snippet13":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace13.vb" id="Snippet13"::: 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" /> oder <paramref name="evaluator" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.  
  
Oder 
 <paramref name="matchTimeout" /> ist negativ, null oder größer als ca. 24 Tage.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage"><para>Es wird empfohlen, den <paramref name="matchTimeout" />-Parameter auf einen geeigneten Wert, z. b. zwei Sekunden, festzulegen. Wenn Sie Timeouts durch Angeben von <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />deaktivieren, bietet die Engine für reguläre Ausdrücke eine etwas bessere Leistung. Timeouts sollten jedoch nur unter den folgenden Bedingungen deaktiviert werden: 
: Wenn die von einem regulären Ausdruck verarbeitete Eingabe von einer bekannten und vertrauenswürdigen Quelle abgeleitet ist oder aus statischem Text besteht. Dies schließt Text aus, der von Benutzern dynamisch eingegeben wurde.  
  
: Wenn das Muster für reguläre Ausdrücke gründlich getestet wurde, um sicherzustellen, dass es Übereinstimmungen, nicht-Übereinstimmungen und NEAR-Übereinstimmungen effizient behandelt.  
  
-Wenn das Muster für reguläre Ausdrücke keine Sprachelemente enthält, die bekanntermaßen eine übermäßige Rückverfolgung verursachen, wenn eine nahe Übereinstimmung verarbeitet wird.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="~/docs/standard/base-types/substitutions-in-regular-expressions.md">Ersetzungen in regulären Ausdrücken</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
        <related type="Article" href="~/docs/standard/base-types/backtracking-in-regular-expressions.md">Backtracking in regulären Ausdrücken</related>
        <related type="Article" href="~/docs/standard/base-types/best-practices.md">Empfohlene Vorgehensweisen für die Verwendung von regulären Ausdrücken in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : bool" Usage="System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der reguläre Ausdruck von rechts nach links sucht.</summary>
        <value><see langword="true" />, wenn der reguläre Ausdruck von rechts nach links sucht, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.RightToLeft%2A> ist `true`, wenn die <xref:System.Text.RegularExpressions.Regex> Instanz mit der <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft>-Option erstellt wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="roptions">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexOptions roptions;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.Text.RegularExpressions.RegexOptions roptions" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.roptions" />
      <MemberSignature Language="VB.NET" Value="Protected Friend roptions As RegexOptions " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexOptions roptions;" />
      <MemberSignature Language="F#" Value="val mutable roptions : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.roptions" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Unterteilt eine Eingabezeichenfolge in eine Abfolge von Teilzeichenfolgen, und zwar an den Positionen, die vom Übereinstimmungsmuster für reguläre Ausdrücke festgelegt wurden.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Split : string -&gt; string[]" Usage="regex.Split input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die zu teilende Zeichenfolge.</param>
        <summary>Teilt die angegebene Eingabezeichenfolge an den Positionen in ein Array von Teilzeichenfolgen auf, die durch ein im <see cref="T:System.Text.RegularExpressions.Regex" />-Konstruktor angegebenes Muster für einen regulären Ausdruck definiert werden.</summary>
        <returns>Ein Array der Zeichenfolgen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>-Methoden ähneln der <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType>-Methode, mit dem Unterschied, dass <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> die Zeichenfolge bei einem Trennzeichen unterteilt, das durch einen regulären Ausdruck bestimmt wird, anstelle eines Zeichensatzes. Die Zeichenfolge wird so oft wie möglich aufgeteilt. Wenn kein Trennzeichen gefunden wird, enthält der Rückgabewert ein Element, dessen Wert der ursprünglichen Eingabe Zeichenfolge entspricht.  
  
 Wenn mehrere Übereinstimmungen nebeneinander nebeneinander liegen, wird eine leere Zeichenfolge in das Array eingefügt. Beispielsweise bewirkt das Aufteilen einer Zeichenfolge in einem einzelnen Bindestrich, dass das zurückgegebene Array eine leere Zeichenfolge an der Position enthält, an der zwei angrenzende Bindestriche gefunden werden, wie der folgende Code zeigt.  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split1.vb" id="Snippet1"::: 
  
 Wenn eine Entsprechung am Anfang oder am Ende der Eingabe Zeichenfolge gefunden wird, wird am Anfang oder Ende des zurückgegebenen Arrays eine leere Zeichenfolge eingefügt. Im folgenden Beispiel wird das Muster für reguläre Ausdrücke `\d+` verwendet, um eine Eingabe Zeichenfolge auf numerische Zeichen aufzuteilen. Da die Zeichenfolge mit übereinstimmenden numerischen Zeichen beginnt und endet, wird der Wert des ersten und des letzten Elements des zurückgegebenen Arrays <xref:System.String.Empty?displayProperty=nameWithType>.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split21.cs" interactive="try-dotnet" id="Snippet21":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split21.vb" id="Snippet21"::: 
  
 Wenn das Erfassen von Klammern in einem <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Ausdruck verwendet wird, wird der erfasste Text in das resultierende Zeichen folgen Array eingeschlossen. Wenn Sie z. b. die Zeichenfolge "Plum-Birnen" auf einen Bindestrich aufteilen, der in den Erfassungs Klammern platziert ist, enthält das zurückgegebene Array ein Zeichen folgen Element, das den Bindestrich enthält.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split2.vb" id="Snippet2":::
  
 Wenn das Muster für reguläre Ausdrücke jedoch mehrere Sätze von Erfassungs Klammern enthält, hängt das Verhalten dieser Methode von der Version der .NET Framework ab. Wenn in den .NET Framework 1,0 und 1,1 eine Entsprechung nicht innerhalb des ersten Satzes von Erfassungs Klammern gefunden wird, ist erfasster Text aus zusätzlichen Erfassungs Klammern nicht im zurückgegebenen Array enthalten. Beginnend mit dem .NET Framework 2,0 wird der gesamte erfasste Text dem zurückgegebenen Array ebenfalls hinzugefügt. Im folgenden Code werden z. b. zwei Sätze von Erfassungs Klammern verwendet, um die Elemente eines Datums, einschließlich der Datums Trennzeichen, aus einer Datums Zeichenfolge zu extrahieren. Der erste Satz von Erfassungs Klammern erfasst den Bindestrich, und der zweite Satz erfasst den Schrägstrich. Wenn der Beispielcode kompiliert und unter dem .NET Framework 1,0 oder 1,1 ausgeführt wird, werden die Schrägstriche ausgeschlossen. Wenn Sie kompiliert und unter dem .NET Framework 2,0 oder höheren Versionen ausgeführt wird, enthält Sie Sie.  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split3.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split3.vb" id="Snippet3"::: 
  
 Wenn der reguläre Ausdruck mit der leeren Zeichenfolge abgeglichen werden kann, teilt <xref:System.Text.RegularExpressions.Regex.Split%28System.String%29> die Zeichenfolge in ein Array von Zeichen folgen mit nur einem Zeichen auf, da sich das leere Zeichen folgen Trennzeichen an jedem Speicherort befindet. Beispiel:  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split11.cs" interactive="try-dotnet" id="Snippet11":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split11.vb" id="Snippet11"::: 
  
 Beachten Sie, dass das zurückgegebene Array auch eine leere Zeichenfolge am Anfang und am Ende des Arrays enthält.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit des Split-Vorgangs das vom <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>-Konstruktor angegebene Timeout Intervall überschreitet. Wenn Sie beim Aufruf des Konstruktors kein Timeout Intervall festlegen, wird die Ausnahme ausgelöst, wenn der Vorgang einen Timeout Wert überschreitet, der für die Anwendungsdomäne festgelegt wurde, in der das <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn im <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in den Eigenschaften der Anwendungsdomäne kein Timeout definiert ist, oder wenn der Timeout Wert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>ist, wird keine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int -&gt; string[]" Usage="regex.Split (input, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die aufzuteilende Zeichenfolge.</param>
        <param name="count">Die maximale Anzahl der Teilungen.</param>
        <summary>Teilt die angegebene Eingabezeichenfolge höchstens die angegebene Anzahl von Malen an den Positionen in ein Array von Teilzeichenfolgenketten auf, die durch einen im <see cref="T:System.Text.RegularExpressions.Regex" />-Konstruktor angegebenen regulären Ausdruck definiert werden.</summary>
        <returns>Ein Array der Zeichenfolgen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>-Methoden ähneln der <xref:System.String.Split%2A?displayProperty=nameWithType>-Methode, mit dem Unterschied, dass <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> die Zeichenfolge bei einem Trennzeichen unterteilt, das durch einen regulären Ausdruck bestimmt wird, anstelle eines Zeichensatzes. Der `count`-Parameter gibt die maximale Anzahl von Teil Zeichenfolgen an, in die die `input` Zeichenfolge aufgeteilt werden kann. die letzte Zeichenfolge enthält den ungeteilten Rest der Zeichenfolge. Ein `count` Wert von 0 (null) stellt das Standardverhalten der Aufteilung so oft wie möglich dar.  
  
 Wenn mehrere Übereinstimmungen nebeneinander liegen oder wenn am Anfang oder Ende `input`eine Übereinstimmung gefunden wird und die Anzahl der gefundenen Übereinstimmungen mindestens zwei kleiner als `count`ist, wird eine leere Zeichenfolge in das Array eingefügt. Das heißt, dass leere Zeichen folgen, die sich aus benachbarten Übereinstimmungen oder Übereinstimmungen am Anfang oder Ende der Eingabe Zeichenfolge ergeben, bei der Bestimmung gezählt werden, ob die Anzahl der übereinstimmenden Teil Zeichenfolgen `count`entspricht Im folgenden Beispiel wird der `/d+` für reguläre Ausdrücke verwendet, um eine Eingabe Zeichenfolge mit einer oder mehreren Dezimalziffern in maximal drei Teil Zeichenfolgen aufzuteilen. Da der Anfang der Eingabe Zeichenfolge mit dem Muster des regulären Ausdrucks übereinstimmt, enthält das erste Array Element <xref:System.String.Empty?displayProperty=nameWithType>, das zweite Element den ersten Satz von alphabetischen Zeichen in der Eingabe Zeichenfolge, und das dritte enthält den Rest der Zeichenfolge, die auf die dritte Übereinstimmung folgt.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split25.cs" interactive="try-dotnet" id="Snippet25":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split25.vb" id="Snippet25":::  
  
 Wenn die Erfassung von Klammern in einem regulären Ausdruck verwendet wird, werden alle aufgezeichneten Text in das Array von geteilten Zeichen folgen eingefügt. Alle Array Elemente, die erfassten Text enthalten, werden jedoch nicht gezählt, um zu bestimmen, ob die Anzahl der Übereinstimmungen `count`erreicht wurde. Wenn Sie z. b. die Zeichenfolge "Apple-Apricot-Plum-Birnen-Banane" in maximal vier Teil Zeichenfolgen aufteilen, ergibt sich ein Array mit sieben Elementen, wie im folgenden Code gezeigt.  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split4.cs" interactive="try-dotnet" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split4.vb" id="Snippet4":::
  
 Wenn das Muster für reguläre Ausdrücke jedoch mehrere Sätze von Erfassungs Klammern enthält, hängt das Verhalten dieser Methode von der Version der .NET Framework ab. In den .NET Framework 1,0 und 1,1 ist nur erfasster Text aus dem ersten Satz von Erfassungs Klammern im zurückgegebenen Array enthalten. Beginnend mit dem .NET Framework 2,0 wird der gesamte erfasste Text dem zurückgegebenen Array hinzugefügt. Elemente im zurückgegebenen Array, die erfassten Text enthalten, werden jedoch nicht gezählt, um zu bestimmen, ob die Anzahl der übereinstimmenden Teil Zeichenfolgen `count`entspricht. Im folgenden Code werden z. b. in einem regulären Ausdruck zwei Sätze von Erfassungs Klammern verwendet, um die Elemente eines Datums aus einer Datums Zeichenfolge zu extrahieren. Der erste Satz von Erfassungs Klammern erfasst den Bindestrich, und der zweite Satz erfasst den Schrägstrich. Der-Befehl für die <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29>-Methode gibt dann maximal zwei Elemente im zurückgegebenen Array an. Wenn der Beispielcode kompiliert und unter dem .NET Framework 1,0 oder 1,1 ausgeführt wird, gibt die Methode ein Zeichen folgen Array mit zwei Elementen zurück. Wenn Sie kompiliert und unter dem .NET Framework 2,0 oder höheren Versionen ausgeführt wird, gibt die Methode ein Zeichen folgen Array mit drei Elementen zurück.  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split5.cs" interactive="try-dotnet" id="Snippet5":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split5.vb" id="Snippet5":::
  
 Wenn der reguläre Ausdruck mit der leeren Zeichenfolge abgeglichen werden kann, teilt <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> die Zeichenfolge in ein Array von Zeichen folgen mit nur einem Zeichen auf, da sich das leere Zeichen folgen Trennzeichen an jedem Speicherort befindet. Im folgenden Beispiel wird die Zeichenfolge "characters" in so viele Elemente aufgeteilt, wie Sie in der Eingabe Zeichenfolge enthalten sind. Da die NULL-Zeichenfolge mit dem Anfang der Eingabe Zeichenfolge übereinstimmt, wird am Anfang des zurückgegebenen Arrays eine NULL-Zeichenfolge eingefügt. Dies bewirkt, dass das zehnte Element aus den beiden Zeichen am Ende der Eingabe Zeichenfolge besteht.  
  
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split12.vb" id="Snippet12":::  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit des Split-Vorgangs das vom <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>-Konstruktor angegebene Timeout Intervall überschreitet. Wenn Sie beim Aufruf des Konstruktors kein Timeout Intervall festlegen, wird die Ausnahme ausgelöst, wenn der Vorgang einen Timeout Wert überschreitet, der für die Anwendungsdomäne festgelegt wurde, in der das <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn im <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in den Eigenschaften der Anwendungsdomäne kein Timeout definiert ist, oder wenn der Timeout Wert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>ist, wird keine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Split : string * string -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die zu teilende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <summary>Teilt eine Eingabezeichenfolge an den durch ein reguläres Ausdrucksmuster definierten Positionen in ein Array von Teilzeichenfolgen auf.</summary>
        <returns>Ein Array der Zeichenfolgen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>-Methoden ähneln der <xref:System.String.Split%2A?displayProperty=nameWithType>-Methode, mit dem Unterschied, dass <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> die Zeichenfolge bei einem Trennzeichen unterteilt, das durch einen regulären Ausdruck bestimmt wird, anstelle eines Zeichensatzes. Die `input` Zeichenfolge wird so oft wie möglich aufgeteilt. Wenn `pattern` nicht in der `input` Zeichenfolge gefunden wird, enthält der Rückgabewert ein Element, dessen Wert die ursprüngliche `input` Zeichenfolge ist.  
  
 Der `pattern`-Parameter besteht aus Sprachelementen für reguläre Ausdrücke, die die zu Übereinstimmungs enden Zeichen folgen symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [.NET Framework reguläre Ausdrücke](~/docs/standard/base-types/regular-expressions.md) und [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht.  
  
> [!IMPORTANT]
>  Kompilierte reguläre Ausdrücke, die in Aufrufen von statischen <xref:System.Text.RegularExpressions.Regex.Split%2A> Methoden verwendet werden, werden automatisch zwischengespeichert. Wenn Sie die Lebensdauer kompilierter regulärer Ausdrücke selbst verwalten möchten, verwenden Sie die Instanz <xref:System.Text.RegularExpressions.Regex.Split%2A> Methoden.  
  
 Wenn mehrere Übereinstimmungen nebeneinander nebeneinander liegen, wird eine leere Zeichenfolge in das Array eingefügt. Beispielsweise bewirkt das Aufteilen einer Zeichenfolge in einem einzelnen Bindestrich, dass das zurückgegebene Array eine leere Zeichenfolge an der Position enthält, an der zwei angrenzende Bindestriche gefunden werden, wie der folgende Code zeigt.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split8.cs" interactive="try-dotnet" id="Snippet8":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split8.vb" id="Snippet8":::  
  
 Wenn eine Entsprechung am Anfang oder am Ende der Eingabe Zeichenfolge gefunden wird, wird am Anfang oder Ende des zurückgegebenen Arrays eine leere Zeichenfolge eingefügt. Im folgenden Beispiel wird das Muster für reguläre Ausdrücke `\d+` verwendet, um eine Eingabe Zeichenfolge auf numerische Zeichen aufzuteilen. Da die Zeichenfolge mit übereinstimmenden numerischen Zeichen beginnt und endet, wird der Wert des ersten und des letzten Elements des zurückgegebenen Arrays <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split22.cs" interactive="try-dotnet" id="Snippet22":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split22.vb" id="Snippet22"::: 
  
 Wenn das Erfassen von Klammern in einem <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Ausdruck verwendet wird, wird der erfasste Text in das resultierende Zeichen folgen Array eingeschlossen. Wenn Sie z. b. die Zeichenfolge "Plum-Birnen" auf einen Bindestrich aufteilen, der in den Erfassungs Klammern platziert ist, enthält das zurückgegebene Array ein Zeichen folgen Element, das den Bindestrich enthält.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs" interactive="try-dotnet" id="Snippet9":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb" id="Snippet9":::
  
 Wenn das Muster für reguläre Ausdrücke jedoch mehrere Sätze von Erfassungs Klammern enthält, hängt das Verhalten dieser Methode von der Version der .NET Framework ab. Wenn in den .NET Framework 1,0 und 1,1 eine Entsprechung nicht innerhalb des ersten Satzes von Erfassungs Klammern gefunden wird, ist erfasster Text aus zusätzlichen Erfassungs Klammern nicht im zurückgegebenen Array enthalten. Beginnend mit dem .NET Framework 2,0 wird der gesamte erfasste Text dem zurückgegebenen Array ebenfalls hinzugefügt. Im folgenden Code werden z. b. zwei Sätze von Erfassungs Klammern verwendet, um die Elemente eines Datums, einschließlich der Datums Trennzeichen, aus einer Datums Zeichenfolge zu extrahieren. Der erste Satz von Erfassungs Klammern erfasst den Bindestrich, und der zweite Satz erfasst den Schrägstrich. Wenn der Beispielcode kompiliert und unter dem .NET Framework 1,0 oder 1,1 ausgeführt wird, werden die Schrägstriche ausgeschlossen. Wenn Sie kompiliert und unter dem .NET Framework 2,0 oder höheren Versionen ausgeführt wird, enthält Sie Sie.  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs" interactive="try-dotnet" id="Snippet10":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb" id="Snippet10":::
  
 Wenn der reguläre Ausdruck mit der leeren Zeichenfolge abgeglichen werden kann, teilt <xref:System.Text.RegularExpressions.Regex.Split%2A> die Zeichenfolge in ein Array von Zeichen folgen mit nur einem Zeichen auf, da sich das leere Zeichen folgen Trennzeichen an jedem Speicherort befindet. Beispiel:  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split13.cs" interactive="try-dotnet" id="Snippet13":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split13.vb" id="Snippet13":::
  
 Beachten Sie, dass das zurückgegebene Array auch eine leere Zeichenfolge am Anfang und am Ende des Arrays enthält.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit des Split-Vorgangs das Timeout Intervall überschreitet, das für die Anwendungsdomäne festgelegt wurde, in der die-Methode aufgerufen wird. Wenn kein Timeout in den Eigenschaften der Anwendungsdomäne definiert ist, oder wenn der Timeout Wert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>ist, wird keine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage"><para>Bei dieser Methode kommt es nach einem Intervall zu einem Timeout, das gleich dem Standard Timeout Wert der Anwendungsdomäne ist, in der die Methode aufgerufen wird. Wenn für die Anwendungsdomäne kein Timeout Wert definiert wurde, wird der Wert <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, der verhindert, dass die Methode ein Timeout verursacht, verwendet wird. Die empfohlene statische Methode zum Aufteilen von Text in einer Muster Übereinstimmung ist <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, mit der Sie das Timeout Intervall festlegen können.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer, startat As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * int -&gt; string[]" Usage="regex.Split (input, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die aufzuteilende Zeichenfolge.</param>
        <param name="count">Die maximale Anzahl der Teilungen.</param>
        <param name="startat">Die Zeichenposition in der Eingabezeichenfolge, an der mit der Suche begonnen wird.</param>
        <summary>Teilt die angegebene Eingabezeichenfolge höchstens die angegebene Anzahl von Malen an den Positionen in ein Array von Teilzeichenfolgenketten auf, die durch einen im <see cref="T:System.Text.RegularExpressions.Regex" />-Konstruktor angegebenen regulären Ausdruck definiert werden. Die Suche nach dem Muster des regulären Ausdrucks beginnt bei einer angegebenen Zeichenposition in der Eingabezeichenfolge.</summary>
        <returns>Ein Array der Zeichenfolgen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>-Methoden ähneln der <xref:System.String.Split%2A?displayProperty=nameWithType>-Methode, mit dem Unterschied, dass <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> die Zeichenfolge bei einem Trennzeichen unterteilt, das durch einen regulären Ausdruck bestimmt wird, anstelle eines Zeichensatzes. Der `count`-Parameter gibt die maximale Anzahl von Teil Zeichenfolgen an, in die die `input` Zeichenfolge aufgeteilt ist. die letzte Zeichenfolge enthält den ungeteilten Rest der Zeichenfolge. Ein `count` Wert von 0 (null) stellt das Standardverhalten der Aufteilung so oft wie möglich dar. Der `startat`-Parameter definiert den Punkt, an dem die Suche nach dem ersten Trennzeichen beginnt (Dies kann zum Überspringen von führenden Leerzeichen verwendet werden).  
  
 Wenn aus der `count`+ 1-Position in der Zeichenfolge keine Übereinstimmungen gefunden werden, gibt die-Methode ein Array mit einem Element zurück, das die `input` Zeichenfolge enthält. Wenn eine oder mehrere Übereinstimmungen gefunden werden, enthält das erste Element des zurückgegebenen Arrays den ersten Teil der Zeichenfolge vom ersten Zeichen bis zu einem Zeichen vor der Übereinstimmung.  
  
 Wenn mehrere Übereinstimmungen nebeneinander liegen und die Anzahl der gefundenen Übereinstimmungen mindestens zwei kleiner als `count`ist, wird eine leere Zeichenfolge in das Array eingefügt. Wenn eine Entsprechung bei `startat`gefunden wird, bei der es sich um das erste Zeichen in der Zeichenfolge handelt, ist das erste Element des zurückgegebenen Arrays eine leere Zeichenfolge. Das heißt, leere Zeichen folgen, die sich aus benachbarten Übereinstimmungen ergeben, werden gezählt, um zu bestimmen, ob die Anzahl übereinstimmender Teil Zeichenfolgen `count` Im folgenden Beispiel wird der `\d+` für reguläre Ausdrücke verwendet, um die Anfangsposition der ersten Teil Zeichenfolge von numerischen Zeichen in einer Zeichenfolge zu finden, und dann die Zeichenfolge maximal dreimal an dieser Position zu teilen. Da das Muster für reguläre Ausdrücke mit dem Anfang der Eingabe Zeichenfolge übereinstimmt, besteht das zurückgegebene Zeichen folgen Array aus einer leeren Zeichenfolge, einer Zeichenfolge mit fünf Zeichen und dem Rest der Zeichenfolge.  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split26.cs" interactive="try-dotnet" id="Snippet26":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split26.vb" id="Snippet26":::  
  
 Wenn die Erfassung von Klammern in einem regulären Ausdruck verwendet wird, werden alle aufgezeichneten Text in das Array von geteilten Zeichen folgen eingefügt. Alle Array Elemente, die erfassten Text enthalten, werden jedoch nicht gezählt, um zu bestimmen, ob die Anzahl der Übereinstimmungen `count`erreicht wurde. Wenn Sie z. b. die Zeichenfolge "Apple-Apricot-Plum-Birnen-pomegranat-Ananas-Peach" in maximal vier Teil Zeichenfolgen beginnend mit dem Zeichen 15 in der Zeichenfolge aufteilen, ergibt sich ein Array mit sieben Elementen, wie im folgenden Code gezeigt.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split6.cs" interactive="try-dotnet" id="Snippet6"::: 
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split6.vb" id="Snippet6"::: 
  
 Wenn das Muster für reguläre Ausdrücke jedoch mehrere Sätze von Erfassungs Klammern enthält, hängt das Verhalten dieser Methode von der Version der .NET Framework ab. Wenn in .NET Framework 1,0 und 1,1 innerhalb des ersten Satzes der Erfassungs Klammern keine Entsprechung gefunden wird, ist erfasster Text aus zusätzlichen Erfassungs Klammern nicht im zurückgegebenen Array enthalten. Beginnend mit dem .NET Framework 2,0 wird der gesamte erfasste Text dem zurückgegebenen Array ebenfalls hinzugefügt. Im folgenden Code werden z. b. zwei Sätze von Erfassungs Klammern verwendet, um die einzelnen Wörter in einer Zeichenfolge zu extrahieren. Der erste Satz von Erfassungs Klammern erfasst den Bindestrich, und der zweite Satz erfasst den vertikalen Balken. Wenn der Beispielcode kompiliert und unter dem .NET Framework 1,0 oder 1,1 ausgeführt wird, schließt er die senkrechten Strich Zeichen aus. Wenn Sie kompiliert und unter dem .NET Framework 2,0 oder höheren Versionen ausgeführt wird, enthält Sie Sie.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split7.cs" interactive="try-dotnet" id="Snippet7":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split7.vb" id="Snippet7"::: 
  
 Wenn der reguläre Ausdruck mit der leeren Zeichenfolge abgeglichen werden kann, teilt <xref:System.Text.RegularExpressions.Regex.Split%2A> die Zeichenfolge in ein Array von Zeichen folgen mit nur einem Zeichen auf, da sich das leere Zeichen folgen Trennzeichen an jedem Speicherort befindet. Im folgenden Beispiel wird die Zeichenfolge "characters" in so viele Elemente wie die Eingabe Zeichenfolge aufgeteilt, beginnend mit dem Zeichen "a". Da die NULL-Zeichenfolge mit dem Ende der Eingabe Zeichenfolge übereinstimmt, wird am Ende des zurückgegebenen Arrays eine NULL-Zeichenfolge eingefügt.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split14.cs" interactive="try-dotnet" id="Snippet14":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split14.vb" id="Snippet14"::: 
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit des Split-Vorgangs das vom <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>-Konstruktor angegebene Timeout Intervall überschreitet. Wenn Sie beim Aufruf des Konstruktors kein Timeout Intervall festlegen, wird die Ausnahme ausgelöst, wenn der Vorgang einen Timeout Wert überschreitet, der für die Anwendungsdomäne festgelegt wurde, in der das <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn im <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in den Eigenschaften der Anwendungsdomäne kein Timeout definiert ist, oder wenn der Timeout Wert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>ist, wird keine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" /> ist kleiner als 0 (null) oder größer als die Länge von <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Die zu teilende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <summary>Teilt eine Eingabezeichenfolge an den durch ein angegebenes reguläres Ausdrucksmuster definierten Positionen in ein Array von Teilzeichenfolgen auf. Durch angegebene Optionen wird die Suche nach Übereinstimmungen geändert.</summary>
        <returns>Ein Array der Zeichenfolgen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>-Methoden ähneln der <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType>-Methode, mit dem Unterschied, dass <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> die Zeichenfolge bei einem Trennzeichen unterteilt, das durch einen regulären Ausdruck bestimmt wird, anstelle eines Zeichensatzes. Die Zeichenfolge wird so oft wie möglich aufgeteilt. Wenn kein Trennzeichen gefunden wird, enthält der Rückgabewert ein Element, dessen Wert die ursprüngliche `input` Zeichenfolge ist.  
  
 Der `pattern`-Parameter besteht aus Sprachelementen für reguläre Ausdrücke, die die zu Übereinstimmungs enden Zeichen folgen symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [.NET Framework reguläre Ausdrücke](~/docs/standard/base-types/regular-expressions.md) und [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht.  
  
> [!IMPORTANT]
>  Kompilierte reguläre Ausdrücke, die in Aufrufen von statischen <xref:System.Text.RegularExpressions.Regex.Split%2A> Methoden verwendet werden, werden automatisch zwischengespeichert. Wenn Sie die Lebensdauer kompilierter regulärer Ausdrücke selbst verwalten möchten, verwenden Sie die Instanz <xref:System.Text.RegularExpressions.Regex.Split%2A> Methoden.  
  
 Wenn mehrere Übereinstimmungen nebeneinander nebeneinander liegen, wird eine leere Zeichenfolge in das Array eingefügt. Beispielsweise bewirkt das Aufteilen einer Zeichenfolge in einem einzelnen Bindestrich, dass das zurückgegebene Array an der Position, an der zwei angrenzende Bindestriche gefunden werden, eine leere Zeichenfolge enthält.  
  
 Wenn eine Entsprechung am Anfang oder am Ende der Eingabe Zeichenfolge gefunden wird, wird am Anfang oder Ende des zurückgegebenen Arrays eine leere Zeichenfolge eingefügt. Im folgenden Beispiel wird das Muster für reguläre Ausdrücke `[a-z]+` verwendet, um eine Eingabe Zeichenfolge in Großbuchstaben oder in Kleinbuchstaben aufzuteilen. Da die Zeichenfolge mit übereinstimmenden alphabetischen Zeichen beginnt und endet, wird der Wert des ersten und des letzten Elements des zurückgegebenen Arrays <xref:System.String.Empty?displayProperty=nameWithType>.  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split24.cs" interactive="try-dotnet" id="Snippet24":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split24.vb" id="Snippet24"::: 
  
 Wenn das Erfassen von Klammern in einem <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Ausdruck verwendet wird, wird der erfasste Text in das resultierende Zeichen folgen Array eingeschlossen. Wenn Sie z. b. die Zeichenfolge "Plum-Birnen" auf einen Bindestrich aufteilen, der in den Erfassungs Klammern platziert ist, enthält das zurückgegebene Array ein Zeichen folgen Element, das den Bindestrich enthält.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs" interactive="try-dotnet" id="Snippet9":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb" id="Snippet9"::: 
  
 Wenn das Muster für reguläre Ausdrücke jedoch mehrere Sätze von Erfassungs Klammern enthält, hängt das Verhalten dieser Methode von der Version der .NET Framework ab. Wenn in den .NET Framework 1,0 und 1,1 eine Entsprechung nicht innerhalb des ersten Satzes von Erfassungs Klammern gefunden wird, ist erfasster Text aus zusätzlichen Erfassungs Klammern nicht im zurückgegebenen Array enthalten. Beginnend mit dem .NET Framework 2,0 wird der gesamte erfasste Text dem zurückgegebenen Array ebenfalls hinzugefügt. Im folgenden Code werden z. b. zwei Sätze von Erfassungs Klammern verwendet, um die Elemente eines Datums, einschließlich der Datums Trennzeichen, aus einer Datums Zeichenfolge zu extrahieren. Der erste Satz von Erfassungs Klammern erfasst den Bindestrich, und der zweite Satz erfasst den Schrägstrich. Wenn der Beispielcode kompiliert und unter dem .NET Framework 1,0 oder 1,1 ausgeführt wird, werden die Schrägstriche ausgeschlossen. Wenn Sie kompiliert und unter dem .NET Framework 2,0 oder höheren Versionen ausgeführt wird, enthält Sie Sie.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs" interactive="try-dotnet" id="Snippet10":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb" id="Snippet10":::  
  
 Wenn der reguläre Ausdruck mit der leeren Zeichenfolge abgeglichen werden kann, teilt <xref:System.Text.RegularExpressions.Regex.Split%2A> die Zeichenfolge in ein Array von Zeichen folgen mit nur einem Zeichen auf, da sich das leere Zeichen folgen Trennzeichen an jedem Speicherort befindet.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit des Split-Vorgangs das Timeout Intervall überschreitet, das für die Anwendungsdomäne festgelegt wurde, in der die-Methode aufgerufen wird. Wenn kein Timeout in den Eigenschaften der Anwendungsdomäne definiert ist, oder wenn der Timeout Wert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>ist, wird keine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage"><para>Bei dieser Methode kommt es nach einem Intervall zu einem Timeout, das gleich dem Standard Timeout Wert der Anwendungsdomäne ist, in der die Methode aufgerufen wird. Wenn für die Anwendungsdomäne kein Timeout Wert definiert wurde, wird der Wert <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, der verhindert, dass die Methode ein Timeout verursacht, verwendet wird. Die empfohlene statische Methode zum Aufteilen von Text in einer Muster Übereinstimmung ist <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, mit der Sie das Timeout Intervall festlegen können.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Die zu teilende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <param name="matchTimeout">Ein Timeoutintervall oder <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das angibt, dass die Methode kein Timeout haben sollte.</param>
        <summary>Teilt eine Eingabezeichenfolge an den durch ein angegebenes reguläres Ausdrucksmuster definierten Positionen in ein Array von Teilzeichenfolgen auf. Zusätzliche Parameter geben die Optionen an, die den entsprechenden Vorgang und ein Timeoutintervall ändern, wenn keine Übereinstimmung gefunden wird.</summary>
        <returns>Ein Zeichenfolgenarray.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>-Methoden ähneln der <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType>-Methode, mit dem Unterschied, dass <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> die Zeichenfolge bei einem Trennzeichen unterteilt, das durch einen regulären Ausdruck bestimmt wird, anstelle eines Zeichensatzes. Die Zeichenfolge wird so oft wie möglich aufgeteilt. Wenn kein Trennzeichen gefunden wird, enthält der Rückgabewert ein Element, dessen Wert die ursprüngliche `input` Zeichenfolge ist.  
  
 Der `pattern`-Parameter besteht aus Sprachelementen für reguläre Ausdrücke, die die zu Übereinstimmungs enden Zeichen folgen symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [.NET Framework reguläre Ausdrücke](~/docs/standard/base-types/regular-expressions.md) und [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht.  
  
> [!IMPORTANT]
>  Kompilierte reguläre Ausdrücke, die in Aufrufen von statischen <xref:System.Text.RegularExpressions.Regex.Split%2A> Methoden verwendet werden, werden automatisch zwischengespeichert. Wenn Sie die Lebensdauer kompilierter regulärer Ausdrücke selbst verwalten möchten, verwenden Sie die Instanz <xref:System.Text.RegularExpressions.Regex.Split%2A> Methoden.  
  
 Wenn mehrere Übereinstimmungen nebeneinander nebeneinander liegen, wird eine leere Zeichenfolge in das Array eingefügt. Beispielsweise bewirkt das Aufteilen einer Zeichenfolge in einem einzelnen Bindestrich, dass das zurückgegebene Array an der Position, an der zwei angrenzende Bindestriche gefunden werden, eine leere Zeichenfolge enthält.  
  
 Wenn eine Entsprechung am Anfang oder am Ende der Eingabe Zeichenfolge gefunden wird, wird am Anfang oder Ende des zurückgegebenen Arrays eine leere Zeichenfolge eingefügt. Im folgenden Beispiel wird das Muster für reguläre Ausdrücke `[a-z]+` verwendet, um eine Eingabe Zeichenfolge in Großbuchstaben oder in Kleinbuchstaben aufzuteilen. Da die Zeichenfolge mit übereinstimmenden alphabetischen Zeichen beginnt und endet, wird der Wert des ersten und des letzten Elements des zurückgegebenen Arrays <xref:System.String.Empty?displayProperty=nameWithType>.  

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split23.cs" interactive="try-dotnet" id="Snippet23":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split23.vb" id="Snippet23":::
  
 Wenn das Erfassen von Klammern in einem <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Ausdruck verwendet wird, wird der erfasste Text in das resultierende Zeichen folgen Array eingeschlossen. Wenn Sie z. b. die Zeichenfolge "Plum-Birnen" auf einen Bindestrich aufteilen, der in den Erfassungs Klammern platziert ist, enthält das zurückgegebene Array ein Zeichen folgen Element, das den Bindestrich enthält.  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs" interactive="try-dotnet" id="Snippet9":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb" id="Snippet9":::  
  
 Wenn das Muster für reguläre Ausdrücke jedoch mehrere Sätze von Erfassungs Klammern enthält, hängt das Verhalten dieser Methode von der Version der .NET Framework ab. Wenn in den .NET Framework 1,0 und 1,1 eine Entsprechung nicht innerhalb des ersten Satzes von Erfassungs Klammern gefunden wird, ist erfasster Text aus zusätzlichen Erfassungs Klammern nicht im zurückgegebenen Array enthalten. Beginnend mit dem .NET Framework 2,0 wird der gesamte erfasste Text dem zurückgegebenen Array ebenfalls hinzugefügt. Im folgenden Code werden z. b. zwei Sätze von Erfassungs Klammern verwendet, um die Elemente eines Datums, einschließlich der Datums Trennzeichen, aus einer Datums Zeichenfolge zu extrahieren. Der erste Satz von Erfassungs Klammern erfasst den Bindestrich, und der zweite Satz erfasst den Schrägstrich. Wenn der Beispielcode kompiliert und unter dem .NET Framework 1,0 oder 1,1 ausgeführt wird, werden die Schrägstriche ausgeschlossen. Wenn Sie kompiliert und unter dem .NET Framework 2,0 oder höheren Versionen ausgeführt wird, enthält Sie Sie.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs" interactive="try-dotnet" id="Snippet10":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb" id="Snippet10"::: 
  
 Wenn der reguläre Ausdruck mit der leeren Zeichenfolge abgeglichen werden kann, teilt <xref:System.Text.RegularExpressions.Regex.Split%2A> die Zeichenfolge in ein Array von Zeichen folgen mit nur einem Zeichen auf, da sich das leere Zeichen folgen Trennzeichen an jedem Speicherort befindet.  
  
 Der `matchTimeout`-Parameter gibt an, wie lange eine Muster Vergleichsmethode versuchen sollte, eine Übereinstimmung zu finden, bevor ein Timeout auftritt. Das Festlegen eines Timeout Intervalls verhindert, dass reguläre Ausdrücke, die auf einer übermäßigen Rückverfolgung basieren, nicht mehr reagieren, wenn Sie Eingaben verarbeiten, die Near-Übereinstimmungen enthalten. Weitere Informationen finden Sie unter [bewährte Methoden für reguläre Ausdrücke](~/docs/standard/base-types/best-practices.md) und [Rückverfolgung](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Wenn in diesem Zeitintervall keine Entsprechung gefunden wird, löst die Methode eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme aus. `matchTimeout` überschreibt jeden Standard Timeout Wert, der für die Anwendungsdomäne definiert ist, in der die Methode ausgeführt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.  
  
Oder 
 <paramref name="matchTimeout" /> ist negativ, null oder größer als ca. 24 Tage.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage"><para>Es wird empfohlen, den <paramref name="matchTimeout" />-Parameter auf einen geeigneten Wert, z. b. zwei Sekunden, festzulegen. Wenn Sie Timeouts durch Angeben von <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />deaktivieren, bietet die Engine für reguläre Ausdrücke eine etwas bessere Leistung. Timeouts sollten jedoch nur unter den folgenden Bedingungen deaktiviert werden: 
: Wenn die von einem regulären Ausdruck verarbeitete Eingabe von einer bekannten und vertrauenswürdigen Quelle abgeleitet ist oder aus statischem Text besteht. Dies schließt Text aus, der von Benutzern dynamisch eingegeben wurde.  
  
: Wenn das Muster für reguläre Ausdrücke gründlich getestet wurde, um sicherzustellen, dass es Übereinstimmungen, nicht-Übereinstimmungen und NEAR-Übereinstimmungen effizient behandelt.  
  
-Wenn das Muster für reguläre Ausdrücke keine Sprachelemente enthält, die bekanntermaßen eine übermäßige Rückverfolgung verursachen, wenn eine nahe Übereinstimmung verarbeitet wird.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.Serialization.ISerializable.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.System.Runtime.Serialization.ISerializable.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="regex.System.Runtime.Serialization.ISerializable.GetObjectData (si, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="si">Das Objekt, das mit Serialisierungsinformationen aufgefüllt werden soll.</param>
        <param name="context">Der Ort zum Speichern und Abrufen von serialisierten Daten. Dieser Parameter ist für die zukünftige Verwendung reserviert.</param>
        <summary>Füllt ein <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt mit den Daten, die erforderlich sind, um das aktuelle <see cref="T:System.Text.RegularExpressions.Regex" />-Objekt zu deserialisieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Alle Objekte, die in der <xref:System.Runtime.Serialization.SerializationInfo> enthalten sind, werden vom Formatierer automatisch nachverfolgt und serialisiert.   
 Code, der <xref:System.Runtime.Serialization.ISerializable.GetObjectData%2A> aufruft, erfordert die <xref:System.Security.Permissions.SecurityPermission>, um Serialisierungsdienste bereitzustellen. Zugeordnete Enumeration: <xref:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter?displayProperty=nameWithType>   
 > [!NOTE] 
 >  Es ist nicht garantiert, dass diese Methode nur einmal pro Objektinstanz während der Serialisierung aufgerufen wird. Daher sollte die-Methode so implementiert werden, dass Ihr Verhalten unabhängig von der Häufigkeit, mit der Sie aufgerufen wird, identisch ist.   
 
          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="regex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt das Muster eines regulären Ausdrucks zurück, das an den <see langword="Regex" />-Konstruktor übergeben wurde.</summary>
        <returns>Der an den <paramref name="pattern" />-Konstruktor übergebene <see langword="Regex" />-Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `pattern`-Parameter besteht aus Sprachelementen für reguläre Ausdrücke, die die zu Übereinstimmungs enden Zeichen folgen symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [.NET Framework reguläre Ausdrücke](~/docs/standard/base-types/regular-expressions.md) und [Sprache für reguläre Ausdrücke-kurz](~/docs/standard/base-types/regular-expression-language-quick-reference.md)Übersicht.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> ist die Basisklasse regulärer Ausdrücke, die von der <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Methode erstellt werden. Diese kompilierten regulären Ausdrücke verwenden die <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> Implementierung der Basisklasse. Wenn Sie von einer abgeleiteten Klasse aufgerufen wird, gibt die <see cref="M:System.Text.RegularExpressions.Regex.ToString" />-Methode die Zeichenfolge zurück, die an den <paramref name="pattern" />-Parameter des <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" />-Klassenkonstruktors übergeben wurde, der zum Definieren des regulären Ausdrucks verwendet wurde.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="public static string Unescape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Unescape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unescape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Unescape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Unescape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Unescape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Die Eingabezeichenfolge mit dem zu konvertierenden Text.</param>
        <summary>Konvertiert alle Escapezeichen in der Eingabezeichenfolge.</summary>
        <returns>Eine Zeichenfolge, in der alle Escapezeichen in die entsprechende Form ohne Escapezeichen konvertiert wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Unescape%2A>-Methode führt eine der beiden folgenden Transformationen aus:  
  
-   Sie kehrt die Transformation um, die durch die <xref:System.Text.RegularExpressions.Regex.Escape%2A>-Methode durchgeführt wird, indem das Escapezeichen ("\\") aus jedem Zeichen entfernt wird, das durch die-Methode geschützt Hierzu gehören die Zeichen \\, *, +,?, &#124; , {, [, (,), ^, $,., # und Leerzeichen. Außerdem werden durch die <xref:System.Text.RegularExpressions.Regex.Unescape%2A>-Methode Escapezeichen für die schließende Klammer (]) und schließende geschweifte Klammer (}) entkaptet.  
  
> [!NOTE]
>  <xref:System.Text.RegularExpressions.Regex.Unescape%2A> kann eine Escapezeichenfolge nicht vollständig umkehren  
  
-   Die hexadezimal Werte werden in ausführlichen Zeichenfolgenliteralen durch die eigentlichen druckbaren Zeichen ersetzt. Beispielsweise wird @"\x07" durch "\a" ersetzt, oder @"\x0A" durch "\n". Es konvertiert in unterstützte Escapezeichen, wie z. b. \a, \b, \e, \n, \r, \f, \t, \v und alphanumerische Zeichen.
  
 Wenn die <xref:System.Text.RegularExpressions.Regex.Unescape%2A>-Methode andere Escapesequenzen trifft, die nicht konvertiert werden können, z. b. \w oder \s, wird ein <xref:System.ArgumentException>ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="str" /> schließt eine nicht erkannte Escapesequenz ein.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> ist <see langword="null" /></exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <Member MemberName="UseOptionC">
      <MemberSignature Language="C#" Value="protected bool UseOptionC ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionC() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionC" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionC () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionC();" />
      <MemberSignature Language="F#" Value="member this.UseOptionC : unit -&gt; bool" Usage="regex.UseOptionC " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <returns><see langword="true" />, wenn die <see cref="P:System.Text.RegularExpressions.Regex.Options" />-Eigenschaft die <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />-Option enthält, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseOptionR">
      <MemberSignature Language="C#" Value="protected internal bool UseOptionR ();" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance bool UseOptionR() cil managed" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionR" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function UseOptionR () As Boolean" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; bool UseOptionR();" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="F#" Value="member this.UseOptionR : unit -&gt; bool" Usage="regex.UseOptionR " />
      <MemberSignature Language="C#" Value="protected bool UseOptionR ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionR() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionR () As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionR();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <returns><see langword="true" />, wenn die <see cref="P:System.Text.RegularExpressions.Regex.Options" />-Eigenschaft die <see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" />-Option enthält, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal static void ValidateMatchTimeout (TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig void ValidateMatchTimeout(valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Sub ValidateMatchTimeout (matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static void ValidateMatchTimeout(TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member ValidateMatchTimeout : TimeSpan -&gt; unit" Usage="System.Text.RegularExpressions.Regex.ValidateMatchTimeout matchTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="matchTimeout">Das zu überprüfende Timeoutintervall.</param>
        <summary>Überprüft, ob ein Timeoutintervall innerhalb eines akzeptablen Bereichs liegt.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Das angegebene Timeout liegt nicht in einem gültigen Bereich.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
