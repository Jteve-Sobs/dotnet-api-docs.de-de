<Type Name="Regex" FullName="System.Text.RegularExpressions.Regex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f5b1b16e45086d2dbf7c8f1afa213b88dfe4f122" />
    <Meta Name="ms.sourcegitcommit" Value="9f18ecaf63382fa565dfaeb7274bc1a9e81c35e9" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/19/2018" />
    <Meta Name="ms.locfileid" Value="36208847" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Regex : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Regex extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.Regex" />
  <TypeSignature Language="VB.NET" Value="Public Class Regex&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Regex : System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt einen unveränderlichen regulären Ausdruck dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex> Klasse stellt das .NET Framework-Modul für reguläre Ausdrücke dar. Es kann verwendet werden: schnelle Auswertung großer Textmengen zur Suche nach speziellen Zeichenmustern; zum Extrahieren, bearbeiten, ersetzen oder Löschen von Textzeichenfolgen; und hinzufügen die extrahierten Zeichenfolgen zu einer Auflistung, um einen Bericht zu generieren.  
  
> [!NOTE]
>  Wenn Ihr Hauptinteresse ist, überprüfen eine Zeichenfolge, indem Sie bestimmen, ob es zu einem bestimmten Muster entspricht, können Sie mithilfe der <xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType> Klasse.  
  
 Um reguläre Ausdrücke zu verwenden, definieren Sie das Muster, das in einen Textstream zu identifizieren, indem Sie mit der Syntax in dokumentiert werden sollen [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Als Nächstes können Sie optional Instanziieren einer <xref:System.Text.RegularExpressions.Regex> Objekt. Zum Schluss rufen Sie eine Methode, die einen Vorgang, z. B. beim Ersetzen von Text, der das Muster des regulären Ausdrucks übereinstimmt oder identifizieren einen Mustervergleich ausführt.  
  
> [!NOTE]
>  Einige allgemeine Muster für reguläre Ausdrücke finden Sie unter [Beispiele für reguläre Ausdrücke](~/docs/standard/base-types/regular-expression-examples.md). Es gibt auch eine Reihe von online-Bibliotheken der Muster für reguläre Ausdrücke, wie z. B. das Element an [reguläre Expressions.info](https://www.regular-expressions.info/examples.html).  
  
<a name="remarks"></a> Weitere Informationen zum Verwenden der <xref:System.Text.RegularExpressions.Regex> Klasse, finden Sie unter den folgenden Abschnitten in diesem Thema:  
  
-   [Regex-im Vergleich zu String-Methoden](#regex_vs_string)  
  
-   [Statische im Vergleich zu Instanzmethoden](#static_vs_instance)  
  
-   [Ausführen von Vorgängen für reguläre Ausdrücke](#regex_ops)  
  
-   [Definieren einen Timeoutwert](#define_timeout)  
  
 Weitere Informationen über die Sprache für reguläre Ausdrücke finden Sie unter [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Sie können auch eine der folgenden Broschüren herunterladen und ausdrucken:  
  
 [Kurzübersicht im Word-Format (.docx)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)  
 [Kurzübersicht im PDF-Format (.pdf)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)  
  
<a name="regex_vs_string"></a>   
## <a name="regex-vs-string-methods"></a>Regex-im Vergleich zu String-Methoden  
 Die <xref:System.String?displayProperty=nameWithType> Klasse enthält mehrere Methoden für den Such- und Vergleich, mit denen Sie Mustervergleiche mit Text ausführen können. Z. B. die <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.EndsWith%2A?displayProperty=nameWithType>, und <xref:System.String.StartsWith%2A?displayProperty=nameWithType> Methoden zu ermitteln, ob eine Zeichenfolgeninstanz mit eine angegebene Teilzeichenfolge; enthält und die <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, <xref:System.String.IndexOfAny%2A?displayProperty=nameWithType>, <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>, und <xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType> Methoden geben die Anfangsposition einer angegebenen Teilzeichenfolge in einer Zeichenfolge zurück. Verwenden Sie die Methoden der <xref:System.String?displayProperty=nameWithType> Klasse, wenn Sie nach einer bestimmten Zeichenfolge suchen. Verwenden der <xref:System.Text.RegularExpressions.Regex> Klasse, wenn Sie ein bestimmtes Muster in einer Zeichenfolge suchen. Weitere Informationen und Beispiele finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md).  
  
 [Zurück zu "Hinweise"](#remarks)  
  
<a name="static_vs_instance"></a>   
## <a name="static-vs-instance-methods"></a>Statische im Vergleich zu Instanzmethoden  
 Nach dem Muster eines regulären Ausdrucks definieren, können Sie es für das Modul für reguläre Ausdrücke in eine von zwei Arten bereitstellen:  
  
-   Durch Instanziieren einer <xref:System.Text.RegularExpressions.Regex> -Objekt, das den regulären Ausdruck darstellt. Zu diesem Zweck, übergeben Sie das Muster eines regulären Ausdrucks eine <xref:System.Text.RegularExpressions.Regex.%23ctor%2A> Konstruktor. Ein <xref:System.Text.RegularExpressions.Regex> -Objekt unveränderlich ist; beim Instanziieren einer <xref:System.Text.RegularExpressions.Regex> -Objekt mit einem regulären Ausdruck, dass der reguläre Ausdruck des Objekts kann nicht geändert werden.  
  
-   Durch Angabe des regulären Ausdrucks und der Text, der zum Suchen einer `static` (`Shared` in Visual Basic) <xref:System.Text.RegularExpressions.Regex> Methode. Dadurch können Sie einen regulären Ausdruck verwenden, ohne Sie explizit erstellen eine <xref:System.Text.RegularExpressions.Regex> Objekt.  
  
 Alle <xref:System.Text.RegularExpressions.Regex> Muster Kennung Methoden umfassen sowohl statische und Überladungen-Instanz.  
  
 Das Modul für reguläre Ausdrücke muss ein bestimmtes Muster kompilieren, bevor das Muster verwendet werden kann. Da <xref:System.Text.RegularExpressions.Regex> Objekte sind unveränderlich, dies ist eine einmalige Prozedur, die auftritt, wenn eine <xref:System.Text.RegularExpressions.Regex> -Klassenkonstruktor oder eine statische Methode wird aufgerufen. Zur Vermeidung von einem einzelnen regulären Ausdruck wiederholt kompiliert werden muss, speichert das Modul für reguläre Ausdrücke die kompilierte reguläre Ausdrücke in statischen Methodenaufrufen verwendet. Daher bieten reguläre Mustervergleichsmethoden vergleichbare Leistung für statische und Instanzenmethoden.  
  
> [!IMPORTANT]
>  In der .NET Framework-Versionen 1.0 und 1.1, alle kompilierten regulären Ausdrücken klicken Sie, ob sie in der Instanz oder eine statische Methode verwendet wurden aufruft, zwischengespeichert wurden. Beginnend mit .NET Framework 2.0, werden nur in statischen Methodenaufrufen verwendete reguläre Ausdrücke zwischengespeichert.  
  
 Allerdings kann das Zwischenspeichern Leistung in den folgenden zwei Fällen beeinträchtigen:  
  
-   Wenn Sie statische Methodenaufrufe mit einer großen Anzahl von regulären Ausdrücken verwenden. Standardmäßig speichert das Modul für reguläre Ausdrücke die 15 zuletzt verwendeten statischen regulären Ausdrücken. Wenn Ihre Anwendung mehr als 15 statische reguläre Ausdrücken verwendet, müssen einige reguläre Ausdrücke neu kompiliert werden. Um diese Neukompilierung zu verhindern, erhöhen Sie die <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> Eigenschaft.  
  
-   Beim neuen instanziieren <xref:System.Text.RegularExpressions.Regex> Objekte mit regulären Ausdrücken, die zuvor kompiliert wurden. Der folgende Code definiert z. B. einen regulären Ausdruck, um doppelte Wörter in einen Textstream gesucht werden soll. Obwohl das Beispiel einen einzelnen regulären Ausdruck verwendet wird, instanziiert es ein neues <xref:System.Text.RegularExpressions.Regex> Objekt, um jede Textzeile zu verarbeiten. Dies führt dazu, dass die Neukompilierung des regulären Ausdrucks mit jeder Iteration der Schleife.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#1)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#1)]  
  
     Um zu verhindern, dass die Neukompilierung instanziieren Sie ein einzelnes <xref:System.Text.RegularExpressions.Regex> Objekt, das ist für alle Code, der notwendig ist, wie im folgenden umgeschriebenen Beispiel gezeigt.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#2)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#2)]  
  
 [Zurück zu "Hinweise"](#remarks)  
  
<a name="regex_ops"></a>   
## <a name="performing-regular-expression-operations"></a>Ausführen von Vorgängen für reguläre Ausdrücke  
 Entscheidung, ob beim Instanziieren einer <xref:System.Text.RegularExpressions.Regex> Objekt und seine Methoden aufrufen oder statische Methoden, die <xref:System.Text.RegularExpressions.Regex> Klasse bietet folgende Funktionen Mustervergleich:  
  
-   Überprüfung der Übereinstimmung. Rufen Sie die <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Methode, um zu bestimmen, ob eine Übereinstimmung vorhanden ist.  
  
-   Abrufen von einer einzelnen Übereinstimmung. Rufen Sie die <xref:System.Text.RegularExpressions.Regex.Match%2A> Methode zum Abrufen einer <xref:System.Text.RegularExpressions.Match> Objekt, das die erste Übereinstimmung in einer Zeichenfolge oder einem Teil einer Zeichenfolge darstellt. Nachfolgende Übereinstimmungen abgerufen werden können, durch Aufrufen der <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> Methode.  
  
-   Abrufen von alle Übereinstimmungen. Rufen Sie die <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode zum Abrufen einer <xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType> Objekt, das alle Übereinstimmungen gefunden, in einer Zeichenfolge oder einem Teil einer Zeichenfolge darstellt.  
  
-   Ersetzen des übereinstimmenden Texts. Rufen Sie die <xref:System.Text.RegularExpressions.Regex.Replace%2A> Methode, um den entsprechenden Text ersetzen. Der Ersetzungstext kann auch von einem regulären Ausdruck definiert werden. Darüber hinaus werden einige der <xref:System.Text.RegularExpressions.Regex.Replace%2A> erfolgen eine <xref:System.Text.RegularExpressions.MatchEvaluator> Parameter, der Ihnen ermöglicht, die den Ersetzungstext programmgesteuert definieren.  
  
-   Die Erstellung eines Zeichenfolgenarrays, die aus Teilen einer Eingabezeichenfolge gebildet wird. Rufen Sie die <xref:System.Text.RegularExpressions.Regex.Split%2A> Methode, um eine Eingabezeichenfolge an den Positionen aufgeteilt, die mit dem regulären Ausdruck definiert sind.  
  
 Zusätzlich zu seiner Mustervergleichsmethoden die <xref:System.Text.RegularExpressions.Regex> Klasse enthält mehrere spezielle Methoden:  
  
-   Die <xref:System.Text.RegularExpressions.Regex.Escape%2A> Methode schützt alle Zeichen, die als Operatoren für reguläre Ausdrücke in einem regulären Ausdruck oder eine Eingabezeichenfolge interpretiert werden können.  
  
-   Die <xref:System.Text.RegularExpressions.Regex.Unescape%2A> -Methode entfernt diese Escapezeichen.  
  
-   Die <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> Methode erstellt eine Assembly, die vordefinierte reguläre Ausdrücke enthält. .NET Framework enthält Beispiele für diese zweckgebundene Assemblys in der <xref:System.Web.RegularExpressions?displayProperty=nameWithType> Namespace.  
  
 [Zurück zu "Hinweise"](#remarks)  
  
<a name="define_timeout"></a>   
## <a name="defining-a-time-out-value"></a>Definieren einen Timeoutwert  
 .NET Framework unterstützt eine Sprache für reguläre Ausdrücke mit umfassenden, die erhebliche Leistungsfähigkeit und Flexibilität Mustervergleich bereitstellt. Jedoch die Leistungsfähigkeit und Flexibilität zu Kosten stammen: das Risiko, dass eine schlechte Leistung. Reguläre Ausdrücke, die Verschlechterung der Leistung sind erstaunlich einfach zu erstellen. In einigen Fällen können reguläre Vorgänge, bei denen übermäßige rückverfolgung angezeigt werden, nicht mehr reagiert, wenn sie Text zu verarbeiten, die annähernd Muster des regulären Ausdrucks übereinstimmen. Weitere Informationen zu den .NET Framework-Modul für reguläre Ausdrücke, finden Sie unter [Details zum Verhalten regulärer Ausdrücke](~/docs/standard/base-types/details-of-regular-expression-behavior.md). Weitere Informationen über eine übermäßige rückverfolgung finden Sie unter [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], können Sie ein anderes Timeoutintervall für reguläre Ausdrücke Übereinstimmungen definieren. Wenn das Modul für reguläre Ausdrücke eine Übereinstimmung innerhalb dieses Zeitintervalls ermitteln kann, der entsprechende Vorgang löst eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme. In den meisten Fällen verhindert, dass dies das Modul für reguläre Ausdrücke verarbeitungsleistung auszugeben, indem versucht wird, zu suchen, die annähernd Muster des regulären Ausdrucks übereinstimmen. Es kann auch, allerdings hinweisen, dass das Timeoutintervall zu niedrig festgelegt wurde oder die Auslastung des aktuellen Computers eine allgemeine Beeinträchtigung der Leistung verursacht hat.  
  
 Wie Sie die Ausnahme zu behandeln, hängt von der Ursache der Ausnahme ab. Wenn die Ausnahme tritt auf, weil das Timeoutintervall zu niedrig festgelegt ist oder aufgrund übermäßiger Computer laden, können Sie das Timeoutintervall erhöhen und den Vergleichsvorgang erneut ausführen. Wenn die Ausnahme tritt auf, weil der reguläre Ausdruck auf eine übermäßige rückverfolgung angewiesen ist, können Sie davon ausgehen, dass eine Übereinstimmung ist nicht vorhanden, und, optional, Sie können Protokollinformationen, mit denen Sie das Muster des regulären Ausdrucks zu ändern.  
  
 Sie können ein anderes Timeoutintervall festlegen, durch Aufrufen der <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Konstruktor beim Instanziieren von Objekt eines regulären Ausdrucks. Sie können ein anderes Timeoutintervall für statische Methoden festlegen, durch Aufruf einer Überladung von einer übereinstimmenden Methode, die eine `matchTimeout` Parameter. Wenn Sie nicht explizit einen Timeoutwert festlegen, wird der Standardtimeoutwert wie folgt bestimmt:  
  
-   Vorhanden ist-Wert, wenn ein, das anwendungsweite Timeout mit. Dadurch kann jeder Timeoutwert, der für die Anwendungsdomäne, in denen gilt die <xref:System.Text.RegularExpressions.Regex> Objekt instanziiert wird oder die statische Methode aufgerufen wird. Sie können die anwendungsweite Timeoutwert festlegen, durch den Aufruf der <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> Methode zum Zuweisen der Zeichenfolgendarstellung einer <xref:System.TimeSpan> Wert für die Eigenschaft "REGEX_DEFAULT_MATCH_TIMEOUT".  
  
-   Mit dem Wert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>, wenn kein Timeoutwert anwendungsweite festgelegt wurde.  
  
> [!IMPORTANT]
>  Es wird empfohlen, dass Sie einen Timeoutwert in alle reguläre Mustervergleich Vorgänge festgelegt. Weitere Informationen finden Sie unter [bewährte Methoden für reguläre Ausdrücke](~/docs/standard/base-types/best-practices.md).  
  
 [Zurück zu "Hinweise"](#remarks)  
  
   
  
## Examples  
 Im folgenden Beispiel wird einen regulären Ausdruck, um wiederholte Vorkommen von Wörtern in einer Zeichenfolge zu überprüfen. Der reguläre Ausdruck `\b(?<word>\w+)\s+(\k<word>)\b` wie in der folgenden Tabelle dargestellt interpretiert werden kann.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\b`|Beginnt den Abgleich an einer Wortgrenze.|  
|`(?<word>\w+)`|Übereinstimmung mit mindestens einem Wortzeichen bis zu einer Wortgrenze. Nennen Sie diese erfasste Gruppe `word`.|  
|`\s+`|Entspricht mindestens ein Leerzeichen an.|  
|`(\k<word>)`|Übereinstimmung mit der erfassten Gruppe mit dem Namen `word`.|  
|`\b`|Übereinstimmung mit einer Wortgrenze.|  
  
 [!code-cpp[Regex_Words#0](~/samples/snippets/cpp/VS_Snippets_CLR/Regex_Words/CPP/words.cpp#0)]
 [!code-csharp[Regex_Words#0](~/samples/snippets/csharp/VS_Snippets_CLR/Regex_Words/CS/words.cs#0)]
 [!code-vb[Regex_Words#0](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex_Words/VB/words.vb#0)]  
  
 Das folgende Beispiel veranschaulicht die Verwendung eines regulären Ausdrucks zu überprüfen, ob eine Zeichenfolge einen Währungswert darstellt oder das richtige Format aufweist um eine Currency-Wert darzustellen. In diesem Fall der reguläre Ausdruck wird dynamisch erstellt, aus der <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, und <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> Eigenschaften für die aktuelle Kultur des Benutzers. Wenn das System aktuelle's Kultur "En-US" ist, wird des resultierenden regulären Ausdrucks `^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`. Wie in der folgenden Tabelle gezeigt, kann dieser reguläre Ausdruck interpretiert werden.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`^`|Beginnen Sie am Anfang der Zeichenfolge.|  
|`\s*`|Sucht nach 0 (null) oder mehr Leerzeichen.|  
|`[\+-]?`|Übereinstimmung mit keinem oder einem Vorkommen entweder das positiven Vorzeichen oder das Minuszeichen.|  
|`\s?`|Übereinstimmung mit keinem oder einem Leerzeichen.|  
|`\$?`|Übereinstimmung mit keinem oder einem Vorkommen der Dollarzeichen.|  
|`\s?`|Übereinstimmung mit keinem oder einem Leerzeichen.|  
|`\d*`|0 (null) oder mehr Dezimalstellen sollen übereinstimmen.|  
|`\.?`|Übereinstimmung mit keinem oder einem Dezimaltrennzeichen.|  
|`\d{2}?`|Entsprechung für zwei Dezimalstellen nicht oder einmal.|  
|`(\d*\.?\d{2}?){1}`|Übereinstimmung mit dem Muster ganzheitlichen Zahlen sowie Nachkommastellen Ziffern getrennt durch ein Dezimaltrennzeichensymbol mindestens einmal aus.|  
|`$`|Übereinstimmung mit dem Ende der Zeichenfolge.|  
  
 In diesem Fall wird der reguläre Ausdruck davon ausgegangen, dass eine gültige Währungszeichenfolge keine Gruppe für Trennzeichensymbole enthält und dass er keine Dezimalstellen oder die Anzahl der Dezimalstellen, die von der aktuellen Kultur definiert hat <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A> Eigenschaft.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/cs/regex_example1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/vb/regex_example1.vb#1)]  
  
 Da der reguläre Ausdruck in diesem Beispiel wird dynamisch erstellt werden, wissen nicht zur Entwurfszeit wir, ob das Währungssymbol der aktuellen Kultur, Dezimaltrennzeichen oder positiven und negativen Vorzeichen durch das Modul für reguläre Ausdrücke als reguläre Sprachoperatoren fehlinterpretiert werden können. Um zu verhindern, dass jede Fehlinterpretation, das Beispiel übergibt jedes dynamisch generierte Zeichenfolge, die die <xref:System.Text.RegularExpressions.Regex.Escape%2A> Methode.  
  
 ]]></format>
    </remarks>
    <threadsafe>Die <see cref="T:System.Text.RegularExpressions.Regex" /> Klasse ist unveränderlich (schreibgeschützt) und threadsicher. <see cref="T:System.Text.RegularExpressions.Regex" /> Objekte können auf einem beliebigen Thread erstellt und mehreren Threads gemeinsam verwendet werden. Weitere Informationen finden Sie unter [Safety](~/docs/standard/base-types/thread-safety-in-regular-expressions.md) Thread.</threadsafe>
    <altmember cref="T:System.Configuration.RegexStringValidator" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.RegularExpressions.Regex" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.RegularExpressions.Regex" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass dieser Konstruktor ist geschützt. Es kann nur von von abgeleiteten Klassen aufgerufen werden der <xref:System.Text.RegularExpressions.Regex> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.RegularExpressions.Regex" />-Klasse für den angegebenen regulären Ausdruck.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `pattern` Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter der [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md) Themen.  
  
 Aufrufen der <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29> Konstruktor entspricht dem Aufrufen der <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Konstruktor mit einem Wert von <xref:System.Text.RegularExpressions.RegexOptions.None> für die `options` Argument.  
  
 Ein <xref:System.Text.RegularExpressions.Regex> -Objekt unveränderlich ist, was bedeutet, dass er nur für den Mustervergleich kann Sie verwendet werden bei der Erstellung definieren. Es kann jedoch beliebig oft ohne erneute Kompilierung verwendet.  
  
 Dieser Konstruktor instanziiert Objekt eines regulären Ausdrucks, der versucht, Groß-/ Kleinschreibung von alphabetischen Zeichen in definierten `pattern`. Verwenden Sie für eine Übereinstimmung Groß-/Kleinschreibung der <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> Konstruktor.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie dieser Konstruktor verwendet einen regulären Ausdruck instanziiert, der mit einem beliebigen Wort übereinstimmt, die mit den Buchstaben beginnt "a" oder "t".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/constructors1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/constructors1.vb#1)]  
  
 Beachten Sie, dass das Muster des regulären Ausdrucks das Wort übereinstimmen darf nicht "The" am Anfang des Texts, da Vergleiche standardmäßig Groß-und Kleinschreibung. Ein Beispiel für Groß-und Kleinschreibung unterschieden, finden Sie unter der <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Konstruktor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Dieser Konstruktor erstellt ein <see cref="T:System.Text.RegularExpressions.Regex" /> -Objekt, das den Standardtimeoutwert der Anwendungsdomäne verwendet, in dem es erstellt wird. Wenn Sie ein Timeoutwert für die Anwendungsdomäne nicht definiert wurde die <see cref="T:System.Text.RegularExpressions.Regex" /> Objekt verwendet den Wert <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, wodurch verhindert wird, den Vorgang ein Timeout auftritt. Die empfohlene Konstruktor zum Erstellen einer <see cref="T:System.Text.RegularExpressions.Regex" /> Objekt <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, und Sie können Sie das Timeoutintervall festgelegt.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Das Objekt, das ein serialisiertes Muster und <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Informationen enthält.</param>
        <param name="context">Das Ziel dieser Serialisierung. (Dieser Parameter wird nicht verwendet, geben Sie <see langword="null" /> an.)</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.RegularExpressions.Regex" />-Klasse mithilfe von serialisierten Daten.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">Das Muster, das diese <paramref name="info" /> enthält, ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="info" /> enthält ein ungültiges <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Flag.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die den regulären Ausdruck ändern.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.RegularExpressions.Regex" />-Klasse für den angegebenen regulären Ausdruck mit Optionen zum Verändern des Musters.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `pattern` Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter der [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md) Themen.  
  
 Ein <xref:System.Text.RegularExpressions.Regex> -Objekt unveränderlich ist, was bedeutet, dass es nur für die übereinstimmungsparameter können Sie definieren verwendet werden, wenn Sie ihn erstellen. Es kann jedoch beliebig oft ohne erneute Kompilierung verwendet.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie dieser Konstruktor verwendet einen regulären Ausdruck instanziiert, der mit einem beliebigen Wort übereinstimmt, die mit den Buchstaben beginnt "a" oder "t".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/Constructors2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/Constructors2.vb#2)]  
  
 Beachten Sie, dass die Match-Auflistung des Worts "The", die der Text beginnt enthält, da die `options` Parameter Groß-/Kleinschreibung Vergleiche definiert wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> enthält ein ungültiges Flag.</exception>
        <block subset="none" type="usage">
          <para>Dieser Konstruktor erstellt ein <see cref="T:System.Text.RegularExpressions.Regex" /> -Objekt, das den Standardtimeoutwert der Anwendungsdomäne verwendet, in dem es erstellt wird. Wenn Sie ein Timeoutwert für die Anwendungsdomäne nicht definiert wurde die <see cref="T:System.Text.RegularExpressions.Regex" /> Objekt verwendet den Wert <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, wodurch verhindert wird, den Vorgang ein Timeout auftritt. Die empfohlene Konstruktor zum Erstellen einer <see cref="T:System.Text.RegularExpressions.Regex" /> Objekt <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, und Sie können Sie das Timeoutintervall festgelegt.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions, matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die den regulären Ausdruck ändern.</param>
        <param name="matchTimeout">Ein Timeoutintervall oder <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das angibt, dass die Methode kein Timeout haben sollte.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.RegularExpressions.Regex" />-Klasse für den angegebenen regulären Ausdruck mit Optionen, die das Muster und einen Wert ändern, der angibt, wie lange eine Mustervergleichsmethode versuchen sollte, eine Übereinstimmung zu finden, bevor ein Timeout eintritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `pattern` Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter der [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md) Themen.  
  
 Ein <xref:System.Text.RegularExpressions.Regex> -Objekt unveränderlich ist, was bedeutet, dass er nur für den Mustervergleich verwendet werden kann, von Ihnen definierten beim Erstellen. Es kann jedoch beliebig oft ohne erneute Kompilierung verwendet.  
  
 Die `matchTimeout` Parameter gibt an, wie lange eine Mustervergleich Methode sollten versuchen, eine Übereinstimmung zu finden, bevor ein Timeout eintritt. Wenn in diesem Zeitraum keine Übereinstimmung gefunden wird, löst die Methode Mustervergleich eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme. `matchTimeout` überschreibt alle Standard-Timeoutwert für die Anwendungsdomäne, in denen definiert die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Die Instanz Mustervergleichsmethoden das berücksichtigt die `matchTimeout` Timeoutintervall umfassen Folgendes:  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%2A>  
  
-   <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>  
  
 Ein Timeoutintervall Einstellung wird verhindert, dass reguläre Ausdrücken, die übermäßige rückverfolgung nicht angezeigt wird, nicht mehr reagiert, wenn diese Eingaben verarbeiten, die in der Nähe von Übereinstimmungen enthält. Weitere Informationen finden Sie unter [bewährte Methoden für reguläre Ausdrücke](~/docs/standard/base-types/best-practices.md) und [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Um einen angemessenen Timeoutintervall festzulegen, Faktoren Sie die folgenden:  
  
-   Die Länge und Komplexität der Muster des regulären Ausdrucks. Längere und komplexe reguläre Ausdrücke benötigen mehr Zeit als kürzer und einfacher.  
  
-   Die Auslastung des erwarteten Computers. Die Verarbeitung dauert länger auf Systemen mit hoher Auslastung von CPU und Arbeitsspeicher.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Konstruktor zum Instanziieren einer <xref:System.Text.RegularExpressions.Regex> Objekt mit einem Timeoutwert von einer Sekunde. Das Muster des regulären Ausdrucks `(a+)+$`, das mit mindestens einer Sequenz von einem oder mehreren "a"-Zeichen am Ende einer Zeile übereinstimmt, unterliegt übermäßiger Rückverfolgung. Wenn eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wird ausgelöst, im Beispiel wird der Timeoutwert bis zum Höchstwert von drei Sekunden erhöht. Andernfalls wird der Versuch, das Muster abzugleichen abgebrochen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> ist kein gültiger <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Wert.  Oder:  <paramref name="matchTimeout" /> ist negativ, null oder größer als ca. 24 Tage.</exception>
        <block subset="none" type="usage">
          <para>Es wird empfohlen, Sie legen die <paramref name="matchTimeout" /> Parameter auf einen geeigneten Wert, z. B. zwei Sekunden. Wenn Sie Timeouts durch Angabe deaktivieren <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das Modul für reguläre Ausdrücke bietet eine etwas bessere Leistung. Sie sollten jedoch deaktivieren, Timeouts nur unter folgenden Bedingungen:: Wenn die Eingabe verarbeitet, die von einem regulären Ausdruck aus einer bekannten und vertrauenswürdigen Quelle stammt oder statischer Text besteht. Dies schließt Text, der Eingaben von Benutzern dynamisch wurde.  – Wenn Sie Muster des regulären Ausdrucks gründlich getestet wurden, um sicherzustellen, dass er effizient verarbeitet übereinstimmt, nicht-Übereinstimmungen und Naher übereinstimmt.  – Wenn Muster für reguläre Ausdrücke keine Language-Elemente enthält, die bekanntermaßen dazu führen, dass eine übermäßige rückverfolgung, bei der Verarbeitung einer Nahen Übereinstimmung.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CacheSize">
      <MemberSignature Language="C#" Value="public static int CacheSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CacheSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CacheSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CacheSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Anzahl von Einträgen im aktuellen statischen Cache für die kompilierten regulären Ausdrücke ab oder legt diese fest.</summary>
        <value>Die maximale Anzahl von Einträgen im statischen Cache.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex> Klasse unterhält einen internen Cache von kompilierten regulären Ausdrücken, die in statischen Methodenaufrufen verwendet. Wenn in einem Set-Vorgang angegebene Wert kleiner als die aktuelle Cachegröße ist, werden Einträge im Cache verworfen, bis die Cachegröße auf den angegebenen Wert entspricht.  
  
 Standardmäßig enthält der Cache 15 statische reguläre Ausdrücken kompiliert. Die Anwendung müssen in der Regel nicht die Größe des Caches zu ändern. Verwenden der <xref:System.Text.RegularExpressions.Regex.CacheSize%2A> Eigenschaft nur, wenn Sie caching oder wenn Ihnen einen ungewöhnlich großen Cache deaktivieren möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert in einem Set-Vorgang ist kleiner als 0 (null).</exception>
        <block subset="none" type="usage">
          <para>In .NET Framework vor der [! Include[net_v20SP1_short](~/Includes/NET-v20sp1-Short-MD.MD)], reguläre Ausdrücke verwendet werden, in statische und Instanzmethoden zwischengespeichert wurden. Beginnend mit dem [! Include[net_v20SP1_short](~/Includes/NET-v20sp1-Short-MD.MD)], nur reguläre Ausdrücke in statische Methode, die Aufrufe zwischengespeichert werden.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="capnames">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable capnames;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable capnames" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capnames" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capnames As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ capnames;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CapNames">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary CapNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary CapNames" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CapNames" />
      <MemberSignature Language="VB.NET" Value="Protected Property CapNames As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ CapNames { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Wörterbuch ab, das Erfassungsgruppen ihren Indexwerten zuordnet, oder legt es fest.</summary>
        <value>Ein Wörterbuch, das Erfassungsgruppen ihren Indexwerten zuordnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass diese Eigenschaft geschützt ist. Er kann nur von einer abgeleiteten Klasse zugegriffen werden die <xref:System.Text.RegularExpressions.Regex> Klasse.  
  
 Ein Set-Vorgang versucht, den Wert der Eigenschaft um zugewiesen zu konvertieren einer <xref:System.Collections.Hashtable> Objekt; Wenn diese Konvertierung ein Fehler auftritt, ruft es die <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> Konstruktor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der einer <see cref="P:System.Text.RegularExpressions.Regex.CapNames" />-Eigenschaft zugeordnete Wert in einer festgelegten Operation ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="caps">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable caps;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable caps" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.caps" />
      <MemberSignature Language="VB.NET" Value="Protected Friend caps As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ caps;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Caps">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary Caps { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Caps" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Caps" />
      <MemberSignature Language="VB.NET" Value="Protected Property Caps As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ Caps { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Wörterbuch ab oder legt es fest, das nummerierte Erfassungsgruppen ihren Indexwerten zuordnet.</summary>
        <value>Ein Wörterbuch, das nummerierte Erfassungsgruppen ihren Indexwerten zuordnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass diese Eigenschaft geschützt ist. Er kann nur von einer abgeleiteten Klasse zugegriffen werden die <xref:System.Text.RegularExpressions.Regex> Klasse.  
  
 Ein Set-Vorgang versucht, den Wert der Eigenschaft um zugewiesen zu konvertieren einer <xref:System.Collections.Hashtable> Objekt; Wenn diese Konvertierung ein Fehler auftritt, ruft es die <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> Konstruktor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der einer <see cref="P:System.Text.RegularExpressions.Regex.Caps" />-Eigenschaft zugeordnete Wert in einer festgelegten Operation ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="capsize">
      <MemberSignature Language="C#" Value="protected internal int capsize;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly int32 capsize" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capsize" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capsize As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected public: int capsize;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="capslist">
      <MemberSignature Language="C#" Value="protected internal string[] capslist;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string[] capslist" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capslist" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capslist As String() " />
      <MemberSignature Language="C++ CLI" Value="protected public: cli::array &lt;System::String ^&gt; ^ capslist;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompileToAssembly">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kompiliert reguläre Ausdrücke und speichert diese in einer einzelnen Assembly auf der Festplatte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Auf .NET Core, Aufrufe von der `Regex.CompileToAssembly` Methode löst eine <xref:System.PlatformNotSupportedException>; Schreiben einer Assemblys wird nicht unterstützt.
  
       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Ein Array, das die zu kompilierenden regulären Ausdrücke beschreibt.</param>
        <param name="assemblyname">Der Dateiname der Assembly.</param>
        <summary>Kompiliert ein oder mehrere angegebene <see cref="T:System.Text.RegularExpressions.Regex" />-Objekte in eine benannte Assembly.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> Methode generiert eine .NET Framework-Assembly in der jeder reguläre Ausdruck definiert, der `regexinfos` Array wird durch eine Klasse dargestellt. In der Regel die <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> Methode wird aufgerufen, in einer separaten Anwendung, die eine Assembly aus kompilierten regulären Ausdrücken generiert. Jeder reguläre Ausdruck, der in der Assembly enthalten weist folgende Merkmale auf:  
  
-   Stammt aus dem <xref:System.Text.RegularExpressions.Regex> Klasse.  
  
-   Ihm zugewiesenen den vollqualifizierten Namen, die von definiert ist die `fullnamespace` und `name` Parameter des entsprechenden <xref:System.Text.RegularExpressions.RegexCompilationInfo> Objekt.  
  
-   Es hat einen Standardwert (oder parameterlosen) Konstruktor.  
  
 Normalerweise ist der Code, der instanziiert und verwendet den kompilierten regulären Ausdruck gefunden, in eine Assembly oder Anwendung, die aus dem Code getrennt ist, die die Assembly erstellt.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Assembly mit dem Namen RegexLib.dll erstellt. Die Assembly enthält zwei kompilierte reguläre Ausdrücke. Die erste `Utilities.RegularExpressions.DuplicatedString`, zwei identische aufeinander folgende Wörter übereinstimmt. Die zweite `Utilities.RegularExpressions.EmailAddress`, überprüft, ob eine Zeichenfolge das richtige Format auf eine e-Mail-Adresse aufweist.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile1.vb#1)]  
  
 Der reguläre Ausdruck, der eine Zeichenfolge für doppelte Wörter überprüft dann instanziiert und im folgenden Beispiel verwendet.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Erfolgreicher Kompilierung dieses zweite Beispiel erfordert einen Verweis auf RegexLib.dll erstellt (die Assembly, die im ersten Beispiel erstellt wird), zu dem Projekt hinzugefügt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Wert der <see cref="P:System.Reflection.AssemblyName.Name" />-Eigenschaft des <paramref name="assemblyname" />-Parameters ist eine leere oder eine NULL-Zeichenfolge.  Oder:  Das Muster des regulären Ausdrucks von mindestens einem Objekt in <paramref name="regexinfos" /> enthält eine ungültige Syntax.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyname" /> oder <paramref name="regexinfos" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Das Erstellen einer Assembly aus kompilierten regulären Ausdrücken wird nicht unterstützt.</exception>
        <block subset="none" type="usage">
          <para>Wenn Sie auf einem System entwickeln, die hat [! Include[net_v45](~/Includes/NET-V45-MD.MD)] oder dessen punktreleases installiert, Sie als Ziel [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)], und Sie verwenden die <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> Methode, um eine Assembly zu erstellen, enthält kompilierte reguläre Ausdrücke. Versuchen, die regulären Ausdrücke zu verwenden, in dieser Assembly auf einem System, das verfügt über [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] löst eine Ausnahme aus. Um dieses Problem zu umgehen, führen Sie eines der folgenden:-Erstellen Sie die Assembly, die die kompilierte reguläre Ausdrücke auf einem System mit ist [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] installiert stattdessen der höheren Versionen.  -Anstelle eines Aufrufs <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> und verwenden Sie entweder eine statische oder Instanzmethode beschreibt, das Abrufen des kompilierten regulären Ausdrucks aus einer Assembly, <see cref="T:System.Text.RegularExpressions.Regex" /> Methoden mit den <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> option beim Instanziieren einer <see cref="T:System.Text.RegularExpressions.Regex" /> -Objekt oder einen regulären Ausdruck aufrufen Mustervergleichsmethode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Ein Array, das die zu kompilierenden regulären Ausdrücke beschreibt.</param>
        <param name="assemblyname">Der Dateiname der Assembly.</param>
        <param name="attributes">Ein Array, das die auf die Assembly anzuwendenden Attribute definiert.</param>
        <summary>Kompiliert ein oder mehrere angegebene <see cref="T:System.Text.RegularExpressions.Regex" />-Objekte in eine benannte Assembly mit den angegebenen Attributen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> Methode generiert eine .NET Framework-Assembly in der jeder reguläre Ausdruck definiert, der `regexinfos` Array wird durch eine Klasse dargestellt. In der Regel die <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> Methode wird aufgerufen, in einer separaten Anwendung, die eine Assembly aus kompilierten regulären Ausdrücken generiert. Jeder reguläre Ausdruck, der in der Assembly enthalten weist folgende Merkmale auf:  
  
-   Stammt aus dem <xref:System.Text.RegularExpressions.Regex> Klasse.  
  
-   Ihm zugewiesenen den vollqualifizierten Namen, die von definiert ist die `fullnamespace` und `name` Parameter des entsprechenden <xref:System.Text.RegularExpressions.RegexCompilationInfo> Objekt.  
  
-   Es hat einen Standardwert (oder parameterlosen) Konstruktor.  
  
 Normalerweise ist der Code, der instanziiert und verwendet den kompilierten regulären Ausdruck gefunden, in eine Assembly oder Anwendung, die aus dem Code getrennt ist, die die Assembly erstellt.  
  
 Da die <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> Methode generiert eine .NET Framework-Assembly aus einem Methodenaufruf anstelle einer bestimmten Sprache Class Definition-Schlüsselwort (z. B. `class` in c# oder `Class`...`End Class` in Visual Basic) lässt .NET Framework-Attribute, die Assembly zugewiesen werden soll, mithilfe der Entwicklungssprache standard Attributsyntax nicht. Die `attributes` Parameter stellt eine alternative Methode für die, die auf die Assembly anzuwendenden Attribute definiert. Führen Sie für jedes Attribut, das auf die Assembly angewendet werden sollen folgende Schritte aus:  
  
1.  Erstellt ein Array von <xref:System.Type> -Objekten zurück, die Parametertypen des Attributkonstruktors, die Sie aufrufen möchten darstellen.  
  
2.  Abrufen einer <xref:System.Type> Objekt, das die Attributklasse, die Sie auf die neue Assembly anwenden möchten darstellt.  
  
3.  Rufen Sie die <xref:System.Type.GetConstructor%2A> Methode des Attributs <xref:System.Type> Objekt zum Abrufen einer <xref:System.Reflection.ConstructorInfo> Objekt, das den Konstruktor des Attributs, die Sie aufrufen möchten darstellt. Übergeben Sie die <xref:System.Type.GetConstructor%2A> Methode das Array von <xref:System.Type> Objekte, die Parametertypen des Konstruktors darstellt.  
  
4.  Erstellen einer <xref:System.Object> Array, das die Parameter zur Übergabe an den Konstruktor des Attributs definiert.  
  
5.  Instanziieren einer <xref:System.Reflection.Emit.CustomAttributeBuilder> -Objekt durch Übergeben des Konstruktors die <xref:System.Reflection.ConstructorInfo> in Schritt 3-Objekt abgerufen und die <xref:System.Object> in Schritt 4 erstellten Array.  
  
 Sie können dann ein Array dieser übergeben <xref:System.Reflection.Emit.CustomAttributeBuilder> Objekte anstelle von der `attributes` Parameter an die <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Assembly mit dem Namen RegexLib.dll erstellt und wendet die <xref:System.Reflection.AssemblyTitleAttribute> -Attribut darauf. Die Assembly enthält zwei kompilierte reguläre Ausdrücke. Die erste `Utilities.RegularExpressions.DuplicatedString`, zwei identische aufeinander folgende Wörter übereinstimmt. Die zweite `Utilities.RegularExpressions.EmailAddress`, überprüft, ob eine Zeichenfolge das richtige Format auf eine e-Mail-Adresse aufweist.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile3.vb#3)]  
  
 Sie können sicherstellen, dass die <xref:System.Reflection.AssemblyTitleAttribute> -Attribut auf die Assembly angewendet wurde, durch das Manifest mit einem Reflektionshilfsprogramm wie z. B. "Ildasm" untersuchen.  
  
 Der reguläre Ausdruck, der eine Zeichenfolge für doppelte Wörter überprüft dann instanziiert und im folgenden Beispiel verwendet.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Erfolgreicher Kompilierung dieses zweite Beispiel erfordert einen Verweis auf RegexLib.dll erstellt (die Assembly, die im ersten Beispiel erstellt wird), zu dem Projekt hinzugefügt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Wert der <see cref="P:System.Reflection.AssemblyName.Name" />-Eigenschaft des <paramref name="assemblyname" />-Parameters ist eine leere oder eine NULL-Zeichenfolge.  Oder:  Das Muster des regulären Ausdrucks von mindestens einem Objekt in <paramref name="regexinfos" /> enthält eine ungültige Syntax.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyname" /> oder <paramref name="regexinfos" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Das Erstellen einer Assembly aus kompilierten regulären Ausdrücken wird nicht unterstützt.</exception>
        <block subset="none" type="usage">
          <para>Wenn Sie auf einem System entwickeln, die hat [! Include[net_v45](~/Includes/NET-V45-MD.MD)] oder dessen punktreleases installiert, Sie als Ziel [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)], und Sie verwenden die <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> Methode, um eine Assembly zu erstellen, enthält kompilierte reguläre Ausdrücke. Versuchen, die regulären Ausdrücke zu verwenden, in dieser Assembly auf einem System, das verfügt über [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] löst eine Ausnahme aus. Um dieses Problem zu umgehen, führen Sie eines der folgenden:-Erstellen Sie die Assembly, die die kompilierte reguläre Ausdrücke auf einem System mit ist [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] installiert stattdessen der höheren Versionen.  -Anstelle eines Aufrufs <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> und verwenden Sie entweder eine statische oder Instanzmethode beschreibt, das Abrufen des kompilierten regulären Ausdrucks aus einer Assembly, <see cref="T:System.Text.RegularExpressions.Regex" /> Methoden mit den <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> option beim Instanziieren einer <see cref="T:System.Text.RegularExpressions.Regex" /> -Objekt oder einen regulären Ausdruck aufrufen Mustervergleichsmethode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes, System::String ^ resourceFile);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
        <Parameter Name="resourceFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Ein Array, das die zu kompilierenden regulären Ausdrücke beschreibt.</param>
        <param name="assemblyname">Der Dateiname der Assembly.</param>
        <param name="attributes">Ein Array, das die auf die Assembly anzuwendenden Attribute definiert.</param>
        <param name="resourceFile">Der Name der in die Assembly einzufügenden Win32-Ressourcendatei.</param>
        <summary>Kompiliert ein oder mehrere angegebene <see cref="T:System.Text.RegularExpressions.Regex" />-Objekte und eine angegebene Ressourcendatei in eine benannte Assembly mit den angegebenen Attributen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName% 2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 >-Methode generiert eine .NET Framework-Assembly in der jeder reguläre Ausdruck definiert, der `regexinfos` Array wird durch eine Klasse dargestellt. In der Regel die [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D% 2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 >-Methode wird aufgerufen, in einer separaten Anwendung, die eine Assembly aus kompilierten regulären Ausdrücken generiert. Jeder reguläre Ausdruck, der in der Assembly enthalten weist folgende Merkmale auf:  
  
-   Stammt aus dem <xref:System.Text.RegularExpressions.Regex> Klasse.  
  
-   Ihm zugewiesenen den vollqualifizierten Namen, die von definiert ist die `fullnamespace` und `name` Parameter des entsprechenden <xref:System.Text.RegularExpressions.RegexCompilationInfo> Objekt.  
  
-   Es hat einen Standardwert (oder parameterlosen) Konstruktor.  
  
 Normalerweise ist der Code, der instanziiert und verwendet den kompilierten regulären Ausdruck gefunden, in eine Assembly oder Anwendung, die aus dem Code getrennt ist, die die Assembly erstellt.  
  
 Da die <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> Methode generiert eine .NET Framework-Assembly aus einem Methodenaufruf anstelle einer bestimmten Sprache Class Definition-Schlüsselwort (z. B. `class` in c# oder `Class`...`End Class` in Visual Basic) lässt .NET Framework-Attribute, die Assembly zugewiesen werden soll, mithilfe der Entwicklungssprache standard Attributsyntax nicht. Die `attributes` Parameter stellt eine alternative Methode für die, die auf die Assembly anzuwendenden Attribute definiert. Führen Sie für jedes Attribut, das auf die Assembly angewendet werden sollen folgende Schritte aus:  
  
1.  Erstellt ein Array von <xref:System.Type> -Objekten zurück, die Parametertypen des Attributkonstruktors, die Sie aufrufen möchten darstellen.  
  
2.  Abrufen einer <xref:System.Type> Objekt, das die Attributklasse, die Sie auf die neue Assembly anwenden möchten darstellt.  
  
3.  Rufen Sie die <xref:System.Type.GetConstructor%2A> Methode des Attributs <xref:System.Type> Objekt zum Abrufen einer <xref:System.Reflection.ConstructorInfo> Objekt, das den Konstruktor des Attributs, die Sie aufrufen möchten darstellt. Übergeben der <xref:System.Type.GetConstructor%2A> Methode das Array von <xref:System.Type> Objekte, die Parametertypen des Konstruktors darstellt.  
  
4.  Erstellen einer <xref:System.Object> Array, das die Parameter zur Übergabe an den Konstruktor des Attributs definiert.  
  
5.  Instanziieren einer <xref:System.Reflection.Emit.CustomAttributeBuilder> -Objekt durch Übergeben des Konstruktors die <xref:System.Reflection.ConstructorInfo> in Schritt 3-Objekt abgerufen und die <xref:System.Object> in Schritt 4 erstellten Array.  
  
 Sie können dann ein Array dieser übergeben <xref:System.Reflection.Emit.CustomAttributeBuilder> Objekte anstelle von der `attributes` Parameter für die [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly% 28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 >-Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Wert der <see cref="P:System.Reflection.AssemblyName.Name" />-Eigenschaft des <paramref name="assemblyname" />-Parameters ist eine leere oder eine NULL-Zeichenfolge.  Oder:  Das Muster des regulären Ausdrucks von mindestens einem Objekt in <paramref name="regexinfos" /> enthält eine ungültige Syntax.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyname" /> oder <paramref name="regexinfos" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Der <paramref name="resourceFile" />-Parameter legt eine ungültige Win32-Ressourcendatei fest.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die vom <paramref name="resourceFile" />-Parameter angegebene Datei kann nicht gefunden werden.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Das Erstellen einer Assembly aus kompilierten regulären Ausdrücken wird nicht unterstützt.</exception>
        <block subset="none" type="usage">
          <para>Wenn Sie auf einem System entwickeln, die hat [! Include[net_v45](~/Includes/NET-V45-MD.MD)] oder dessen punktreleases installiert, Sie als Ziel [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)], und Sie verwenden die <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> Methode, um eine Assembly zu erstellen, enthält kompilierte reguläre Ausdrücke. Versuchen, die regulären Ausdrücke zu verwenden, in dieser Assembly auf einem System, das verfügt über [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] löst eine Ausnahme aus. Um dieses Problem zu umgehen, führen Sie eines der folgenden:-Erstellen Sie die Assembly, die die kompilierte reguläre Ausdrücke auf einem System mit ist [! Include[net_v40_short](~/Includes/NET-V40-Short-MD.MD)] installiert stattdessen der höheren Versionen.  -Anstelle eines Aufrufs <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> und verwenden Sie entweder eine statische oder Instanzmethode beschreibt, das Abrufen des kompilierten regulären Ausdrucks aus einer Assembly, <see cref="T:System.Text.RegularExpressions.Regex" /> Methoden mit den <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> option beim Instanziieren einer <see cref="T:System.Text.RegularExpressions.Regex" /> -Objekt oder einen regulären Ausdruck aufrufen Mustervergleichsmethode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="public static string Escape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Escape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Escape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Escape(System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Die Eingabezeichenfolge mit dem zu konvertierenden Text.</param>
        <summary>Versieht einen minimalen Satz an Zeichen (\\, *, +, ?, |, {, [, (,), ^, $,., # und Leerzeichen) mit Escapezeichen, indem diese durch die jeweils entsprechende Escapesequenz ersetzt werden. Damit wird die Engine für reguläre Ausdrücke angewiesen, diese Zeichen als Literale statt als Metazeichen zu interpretieren.</summary>
        <returns>Eine Zeichenfolge, in der Metazeichen in die entsprechenden Escapecodes konvertiert wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Escape%2A> Konvertiert eine Zeichenfolge an, damit, dass das Modul für reguläre Ausdrücke alle Metazeichen interpretiert, die es als Zeichenliterale enthalten kann. Betrachten Sie beispielsweise einen regulären Ausdruck, der entworfen wurde, um Kommentare zu extrahieren, die gerade öffnende bzw. schließende Klammern ([und]) aus Text begrenzt werden. Im folgenden Beispiel werden dem regulären Ausdruck "[(.*?)]" wird als eine Zeichenklasse interpretiert. Anstelle der übereinstimmenden Kommentare im Eingabetext eingebettet, entspricht dem regulären Ausdruck an jeder öffnende oder schließende Klammer, Punkt, Sternchen oder Fragezeichen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#1)]  
  
 Jedoch, wenn für die öffnende spitze Klammer mit Escapezeichen versehen werden, durch Übergabe an die <xref:System.Text.RegularExpressions.Regex.Escape%2A> -Methode der reguläre Ausdruck ist erfolgreich, bei der Zuordnung von Kommentaren, die in der Eingabezeichenfolge eingebettet sind. Dies wird anhand des folgenden Beispiels veranschaulicht.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#2)]  
  
 In einem regulären Ausdruck, der mithilfe von statischen Text definiert ist, als Literale statt als Metazeichen interpretiert werden Zeichen können mit Escapezeichen versehen werden durch einen umgekehrten Schrägstrich voranstellen (\\) sowie als durch Aufrufen der <xref:System.Text.RegularExpressions.Regex.Escape%2A> Methode. In einem regulären Ausdruck, der dynamisch mit Zeichen, die nicht zur Entwurfszeit bekanntermaßen definiert ist Aufrufen der <xref:System.Text.RegularExpressions.Regex.Escape%2A> Methode ist besonders wichtig, um sicherzustellen, dass das Modul für reguläre Ausdrücke einzelne Zeichen als Literale statt interpretiert als Metazeichen.  
  
> [!NOTE]
>  Wenn Muster eines regulären Ausdrucks das Nummernzeichen (#) oder der literale Leerzeichen enthält, sie müssen mit Escapezeichen versehen werden, wenn Eingabetext analysiert wird, mit der <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> Option aktiviert ist.  
  
 Während der <xref:System.Text.RegularExpressions.Regex.Escape%2A> -Methode versieht gerade Klammer ([) öffnen und geschweifte Klammer ({)-Zeichen, es ist nicht mit Escapezeichen versehen die entsprechenden Zeichen schließen (] und}). In den meisten Fällen ist das Escapezeichen nicht erforderlich. Wenn Sie eine schließende Klammer oder geschweiften Klammer nicht das entsprechende öffnende Zeichen vorangestellt wird, interpretiert das Modul für reguläre Ausdrücke als solcher. Wenn eine öffnende Braket oder eine geschweifte Klammer als Metazeichen interpretiert wird, interpretiert das Modul für reguläre Ausdrücke der ersten schließenden Zeichen als Metazeichen entspricht. Wenn dies nicht das gewünschte Verhalten ist, die schließende Klammer oder geschweiften Klammer sollten das Escapezeichen vorangestellt explizit den umgekehrten Schrägstrich (\\) Zeichen. Eine Veranschaulichung finden Sie im Beispielabschnitt.  
  
   
  
## Examples  
 Im folgende Beispiel werden Kommentare aus Text extrahiert. Es wird davon ausgegangen, dass die Kommentare getrennt sind, durch eine Begin Kommentarsymbol und eine End-Kommentarsymbol, die vom Benutzer ausgewählt wird. Da die Kommentarsymbole sind interpretiert werden sollen, sie übergeben die <xref:System.Text.RegularExpressions.Regex.Escape%2A> Methode, um sicherzustellen, dass sie als Metazeichen fehlinterpretiert werden können. Darüber hinaus überprüft das Beispiel explizit, ob das Ende Kommentarsymbol, die vom Benutzer eingegebenen eine schließende Klammer (]) oder eine geschweifte Klammer (}). Wenn es sich handelt, einen umgekehrten Schrägstrich (\\) wird der Klammer oder geschweiften Klammern vorangestellt, damit es als solches interpretiert wird. Beachten Sie, die das Beispiel außerdem verwendet die <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> Sammlung nur den Kommentar statt der Kommentar zusammen mit der öffnenden und schließenden Kommentarzeichen angezeigt.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="factory">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexRunnerFactory factory;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Text.RegularExpressions.RegexRunnerFactory factory" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.factory" />
      <MemberSignature Language="VB.NET" Value="Protected Friend factory As RegexRunnerFactory " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexRunnerFactory ^ factory;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexRunnerFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNames">
      <MemberSignature Language="C#" Value="public string[] GetGroupNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetGroupNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetGroupNames();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Array der Namen von Erfassungsgruppen für den regulären Ausdruck zurück.</summary>
        <returns>Ein Zeichenfolgenarray von Gruppennamen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Auflistung von Gruppennamen enthält den Satz von Zeichenfolgen verwendet, um die Benennung von Erfassungsgruppen im Ausdruck. Erfassungsgruppen nicht explizit benannt werden, sie werden automatisch zugewiesen, selbst wenn numerische Namen ("0", "1", "2", "3" usw.). Die "0" benannte Gruppe stellt alle Text mit dem regulären Ausdrucksmuster übereinstimmen. Nummerierte Gruppen explizit benannten Gruppen voraus, in der Auflistung und benannte Gruppen angezeigt, in der Reihenfolge, in der sie im Muster regulären Ausdrucks definiert sind.  
  
 Sie können die <xref:System.Array.Length%2A> Eigenschaft im Array, das von dieser Methode, um zu bestimmen, die Anzahl der Gruppen in einem regulären Ausdruck zurückgegeben.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine allgemeine `ShowMatches` Methode, die die Namen der reguläre Ausdruck Gruppen und ihre entsprechenden Text anzeigt.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/cs/getgroupnames1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/vb/getgroupnames1.vb#1)]  
  
 In diesem Fall ist das reguläre Ausdrucksmuster `\b(?<FirstWord>\w+)\s?((\w+)\s)*(?<LastWord>\w+)?(?<Punctuation>\p{Po})` ist dazu vorgesehen, einen einfachen Satz zu analysieren und um die erste Wort, das letzte Wort und Endwert Satzzeichen zu identifizieren. Die folgende Tabelle zeigt, wie das Muster des regulären Ausdrucks interpretiert wird:  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\b`|Der Vergleich beginnt an einer Wortgrenze.|  
|`(?<FirstWord>\w+)`|Übereinstimmung mit mindestens einem Wortzeichen. Dies ist die `FirstWord` Gruppe namens.|  
|\s?|Sucht nach einer Übereinstimmung mit keinem oder einem Leerzeichen.|  
|(\w+)|Übereinstimmung mit mindestens einem Wortzeichen. Dies ist die zweite Erfassungsgruppe.|  
|\s|Entsprechung für ein Leerraumzeichen finden.|  
|((\w+)\s)*|Übereinstimmung mit NULL oder mehr Vorkommen von mindestens einem Wortzeichen gefolgt von einem Leerzeichen. Dies ist die erste Erfassungsgruppe.|  
|(? \<LastWord > \w+)?|Übereinstimmung mit keinem oder einem Vorkommen mindestens einem Wortzeichen. Dies ist die `LastWord` Gruppe namens.|  
|(? \<Satzzeichen > \p{Po})|Übereinstimmung mit einem Zeichen, dessen Unicode-Kategorie Interpunktion wird, andere. Dies ist die `Punctuation` Gruppe namens.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
      </Docs>
    </Member>
    <Member MemberName="GetGroupNumbers">
      <MemberSignature Language="C#" Value="public int[] GetGroupNumbers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] GetGroupNumbers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNumbers () As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ GetGroupNumbers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Array der Nummern von Erfassungsgruppen zurück, die den Gruppennamen in einem Array entsprechen.</summary>
        <returns>Ein Ganzzahlarray der Gruppennummern.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unbenannte und benannte Erfassungsgruppen nach Nummer möglich. Unbenannte Gruppen werden von links nach rechts beginnend mit 1 nummeriert. (Die Erfassungsgruppe in Index 0 (null) gibt die Übereinstimmung als Ganzes.)  Benannte Gruppen werden dann nummeriert von links nach rechts beginnend mit einer Zahl, der eins größer ist als die Anzahl der unbenannten Erfassungsgruppen.  
  
 Verweisen auf eine Gruppe von der Anzahl anstelle der Zeichenfolge namentlich bieten schnelleren Zugriff.  
  
   
  
## Examples  
 Das folgende Beispiel definiert einen regulären Ausdruck `\b((?<word>\w+)\s*)+(?<end>[.?!])`, mit einen Satz übereinstimmt. Der reguläre Ausdruck umfasst drei Erfassungsgruppen: eine unbenannte Gruppe, die ein einzelnes Wort zusammen mit einem Leerzeichen aufzeichnet, die; folgen kann eine Gruppe namens `word` , die die einzelnen Wörter des Satzes; erfasst und eine Gruppe mit dem Namen `end` erfasst das Satzzeichen, die den Satz endet. Im Beispiel wird die <xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A> Methode zum Abrufen der Nummern der alle erfassen gruppiert, und zeigt dann die erfasste Zeichenfolge. Darüber hinaus die <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> Methode wird verwendet, um anzugeben, ob eine benannte Gruppe eine bestimmte, nummerierte Gruppe entspricht.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/cs/getgroupnumbers1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/vb/getgroupnumbers1.vb#1)]  
  
 Das Muster für reguläre Ausdrücke wird entsprechend der folgenden Tabelle interpretiert.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\b`|Der Vergleich beginnt an einer Wortgrenze.|  
|`(?<word>\w+)`|Übereinstimmung mit mindestens einem Wortzeichen, und weisen Sie die übereinstimmenden Zeichenfolgen zu einer Gruppe mit dem Namen `word`.|  
|`\s*`|Sucht nach 0 (null) oder mehr Leerzeichen.|  
|`((?<word>\w+)\s*)`|Weisen Sie die `word` gefolgt von einer Erfassungsgruppe erfasst, Leerzeichen, der zuerst erfassten Gruppe.|  
|`((?<word>\w+)\s*)+`|Übereinstimmung mit dem Muster mindestens Wortzeichen gefolgt von alle Leerraumzeichen ein- oder mehrmals.|  
|`(?<end>[.?!])`|Übereinstimmung mit einem Punkt, Fragezeichen oder Ausrufezeichen. Weisen Sie das übereinstimmenden Zeichen der `end` Erfassungsgruppe.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
      </Docs>
    </Member>
    <Member MemberName="GroupNameFromNumber">
      <MemberSignature Language="C#" Value="public string GroupNameFromNumber (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GroupNameFromNumber(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNameFromNumber (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GroupNameFromNumber(int i);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Die Gruppennummer, die in den entsprechenden Gruppennamen konvertiert werden soll.</param>
        <summary>Ruft den Gruppennamen ab, der der angegebenen Gruppennummer entspricht.</summary>
        <returns>Eine Zeichenfolge, die den Gruppennamen enthält, der der angegebenen Gruppennummer zugeordnet ist. Wenn kein Gruppenname vorhanden ist, der <paramref name="i" /> entspricht, gibt die Methode <see cref="F:System.String.Empty" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Muster eines regulären Ausdrucks kann entweder benannte oder nummerierte Erfassungsgruppen enthalten die Teilausdrücke innerhalb einer Musterübereinstimmung skizziert. Nummerierte Gruppen werden durch die Syntax begrenzt (*Teilausdruck*) und Zahlen auf Grundlage ihrer Reihenfolge im regulären Ausdruck zugewiesen werden. Benannte Gruppen werden durch die Syntax begrenzt (?`<` *Namen*`>`*Teilausdruck*) oder (? " *Namen*"*Teilausdruck*), wobei *Namen* ist der Name, mit denen der Teilausdruck identifiziert werden. (Weitere Informationen finden Sie unter [Gruppierungskonstrukte](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md).) Die <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> Methode identifiziert, benannte Gruppen und nummerierten Gruppen durch ihre Ordnungsposition in der regulären Ausdruck. Die Ordnungsposition 0 (null) stellt immer den gesamten regulären Ausdruck dar. Alle nummerierten Gruppen werden dann gezählt, bevor Sie benannte Gruppen, unabhängig von ihrer tatsächlichen Position im Muster regulären Ausdrucks.  
  
 Wenn `i` ist die Anzahl von einer benannten Gruppe die-Methode gibt den Namen der Gruppe zurück. Wenn `i` ist die Anzahl einer unbenannten Gruppe gibt die Methode eine Zeichenfolgendarstellung der Zahl zurück. Z. B. wenn `i` 1 ist, gibt die Methode "1" zurück. Wenn `i` ist nicht die Nummer einer Erfassungsgruppe der Methodenrückgabe <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Wenn eine Musterübereinstimmung gefunden wird, von dieser Methode zurückgegebene Wert kann dann verwendet werden zum Abrufen der <xref:System.Text.RegularExpressions.Group> Objekt, das der Erfassungsgruppe aus darstellt der <xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType> Eigenschaft. Die <xref:System.Text.RegularExpressions.GroupCollection> -Objekt zurück, die <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel definiert das Muster eines regulären Ausdrucks, das eine Adresszeile, enthält eine USA-Ortsnamen, Statusname und Postleitzahl entspricht. Im Beispiel wird die <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> Methode, um die Namen von Erfassungsgruppen abzurufen. Dann wird diese Namen verwendet, um die entsprechenden Erfassungsgruppen nach Übereinstimmungen abzurufen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/cs/groupnamefromnumberex.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/vb/groupnamefromnumberex.vb#1)]  
  
 Das Muster eines regulären Ausdrucks wird durch den folgenden Ausdruck definiert:  
  
 `(?<city>[A-Za-z\s]+), (?<state>[A-Za-z]{2}) (?<zip>\d{5}(-\d{4})?)`  
  
 Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`(?<city>[A-Za-z\s]+)`|Übereinstimmung mit mindestens ein alphabetisches oder ein Leerzeichen Zeichen. Weisen Sie diese erfasste Gruppe `city`.|  
|`,`|Übereinstimmung mit einem Komma (,), gefolgt von einem Leerzeichen.|  
|`(?<state>[A-Za-z]{2})`|Übereinstimmung mit zwei alphabetischen Zeichen. Weisen Sie diese erfasste Gruppe `state`. Diese Gruppe sollte ein Leerstellenzeichen folgen.|  
|`(?<zip>\d{5}(-\d{4})?)`|Mit übereinstimmen Sie fünf Ziffern gefolgt von entweder keinem oder einem Vorkommen von einem Bindestrich gefolgt von vier Ziffern. Weisen Sie diese erfasste Gruppe `zip`.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      </Docs>
    </Member>
    <Member MemberName="GroupNumberFromName">
      <MemberSignature Language="C#" Value="public int GroupNumberFromName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GroupNumberFromName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNumberFromName (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GroupNumberFromName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Gruppenname, der in die entsprechende Gruppennummer konvertiert werden soll.</param>
        <summary>Gibt die Gruppennummer zurück, die dem angegebenen Gruppennamen entspricht.</summary>
        <returns>Die Gruppennummer, die dem angegebenen Gruppennamen entspricht, oder -1, wenn <paramref name="name" /> kein gültiger Gruppenname ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Muster eines regulären Ausdrucks kann entweder benannte oder nummerierte Erfassungsgruppen enthalten die Teilausdrücke innerhalb einer Musterübereinstimmung skizziert. Nummerierte Gruppen werden durch die Syntax begrenzt (*Teilausdruck*) und Zahlen auf Grundlage ihrer Reihenfolge im regulären Ausdruck zugewiesen werden. Benannte Gruppen werden durch die Syntax begrenzt (?`<` *Namen*`>`*Teilausdruck*) oder (? " *Namen*"*Teilausdruck*), wobei *Namen* ist der Name, mit denen der Teilausdruck identifiziert werden. (Weitere Informationen finden Sie unter [Gruppierungskonstrukte](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md).) Die <xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A> Methode identifiziert, benannte Gruppen und nummerierten Gruppen durch ihre Ordnungsposition in der regulären Ausdruck. Die Ordnungsposition 0 (null) stellt immer den gesamten regulären Ausdruck dar. Alle nummerierten Gruppen werden dann gezählt, bevor Sie benannte Gruppen, unabhängig von ihrer tatsächlichen Position im Muster regulären Ausdrucks.  
  
 Wenn `name` die angegebene Zeichenfolgendarstellung einer Gruppennummer, die im Muster für reguläre Ausdrücke, die Methode gibt vorhanden ist, die Zahl ist. Wenn `name` entspricht einer benannten Erfassungsgruppe, die im Muster regulären Ausdrucks vorhanden ist, gibt die Methode die entsprechende Anzahl. Beim Vergleich von `name` mit der Gruppe namens Groß-/Kleinschreibung beachtet wird. Wenn `name` entspricht nicht den Namen einer Erfassungsgruppe oder die Zeichenfolgendarstellung der Nummer einer Erfassungsgruppe, die Methode gibt-1 zurück.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteMatchTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteMatchTimeout;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass bei einem Mustervergleichsvorgang kein Timeout angewendet werden sollte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> -Konstruktor und eine Anzahl von statischen übereinstimmende Methoden verwenden das <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> Konstante, um anzugeben, dass beim Suchen einer Musterübereinstimmung kein Timeout haben sollte.  
  
> [!WARNING]
>  Festlegen des Moduls für reguläre Ausdrücke Timeoutwert auf <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> können dazu führen, dass reguläre Ausdrücken, die übermäßige rückverfolgung angezeigt werden sollen, nicht mehr reagiert, bei der Verarbeitung von Text, der fast Muster des regulären Ausdrucks übereinstimmt. Wenn Sie Timeouts deaktivieren, müssen Sie sicherstellen, dass den reguläre Ausdruck nicht auf eine übermäßige rückverfolgung angewiesen ist, und, dass sie Text behandelt, die annähernd Muster des regulären Ausdrucks übereinstimmen.  
>   
>  Weitere Informationen zur Behandlung von rückverfolgung finden Sie unter [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 Die <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> Konstante angegeben werden, dass als Wert für die `matchTimeout` Argument der folgenden Elemente:  
  
-   <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.RegexCompilationInfo.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.String%2CSystem.String%2CSystem.Boolean%2CSystem.TimeSpan%29?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      </Docs>
    </Member>
    <Member MemberName="InitializeReferences">
      <MemberSignature Language="C#" Value="protected void InitializeReferences ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeReferences() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.InitializeReferences" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeReferences ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeReferences();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Verweise wurden bereits initialisiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="internalMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.TimeSpan internalMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend internalMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="protected public: TimeSpan internalMatchTimeout;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.OptionalField(VersionAdded=2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Die maximale Zeit, die ein Mustervergleichsvorgang ausgeführt werden kann, bevor des Timeout eintritt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsMatch">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, ob der reguläre Ausdruck eine Übereinstimmung in der Eingabezeichenfolge findet.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <summary>Gibt an, ob der im <see cref="T:System.Text.RegularExpressions.Regex" />-Konstruktor angegebene reguläre Ausdruck eine Übereinstimmung in einer angegebenen Eingabezeichenfolge findet.</summary>
        <returns>
          <see langword="true" />, wenn der reguläre Ausdruck eine Übereinstimmung findet, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Methode wird normalerweise verwendet, um eine Zeichenfolge zu überprüfen oder um sicherzustellen, dass eine Zeichenfolge mit einem bestimmten Muster entspricht, ohne diese Zeichenfolge für die Bearbeitung von nachfolgenden abrufen. Wenn Sie bestimmen, ob eine oder mehrere Zeichenfolgen Muster eines regulären Ausdrucks übereinstimmen, und klicken Sie dann für die Bearbeitung von nachfolgenden Aufruf abrufen möchten die <xref:System.Text.RegularExpressions.Regex.Match%2A> oder <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit von den entsprechenden Vorgang das Timeoutintervall gemäß überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie ein anderes Timeoutintervall nicht festlegen, wenn Sie den Konstruktor aufrufen, wird die Ausnahme ausgelöst, wenn der Vorgang alle für die Anwendungsdomäne eingerichtet, in dem Timeoutwert überschreitet die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> Methode, um zu bestimmen, ob eine Zeichenfolge eine gültige Teilenummer. Der reguläre Ausdruck wird davon ausgegangen, dass die Teilenummer ein bestimmtes Format aufweist, das besteht aus drei Gruppen von Zeichen, die durch Bindestriche getrennt. Die erste Menge, die vier Zeichen enthält, muss aus einem alphanumerischen Zeichen, gefolgt von zwei numerischen Zeichen, gefolgt von einem alphanumerischen Zeichen bestehen. Der zweite Satz, der aus drei Zeichen besteht, muss numerisch sein. Der dritte Satz, der aus vier Zeichen besteht, muss drei numerische Zeichen, gefolgt von einem alphanumerischen Zeichen haben.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch2.vb#2)]  
  
 Das Muster des regulären Ausdrucks lautet:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`^`|Starten Sie den Abgleich am Anfang der Zeile.|  
|`[a-zA-Z0-9]`|Ein einzelnes alphabetisches Zeichen entsprechen (`a` über `z` oder `A` über `Z`) oder ein numerisches Zeichen.|  
|`\d{2}`|Übereinstimmung mit zwei numerischen Zeichen.|  
|`[a-zA-Z0-9]`|Ein einzelnes alphabetisches Zeichen entsprechen (`a` über `z` oder `A` über `Z`) oder ein numerisches Zeichen.|  
|`-`|Entsprechung für einen Bindestrich finden.|  
|`\d{3}`|Übereinstimmung mit genau drei numerischen Zeichen.|  
|`(-\d{3}){2}`|Suchen von einem Bindestrich gefolgt von drei Ziffern, und zwei Vorkommen dieses Muster übereinstimmen.|  
|`[a-zA-Z0-9]`|Ein einzelnes alphabetisches Zeichen entsprechen (`a` über `z` oder `A` über `Z`) oder ein numerisches Zeichen.|  
|`$`|Ende des Abgleichs am Ende der Zeile.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String, startat As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="startat">Die Zeichenposition, an der mit der Suche begonnen werden soll.</param>
        <summary>Gibt an, ob der im <see cref="T:System.Text.RegularExpressions.Regex" />-Konstruktor angegebene reguläre Ausdruck ab der angegebenen Anfangsposition eine Übereinstimmung in der angegebenen Eingabezeichenfolge findet.</summary>
        <returns>
          <see langword="true" />, wenn der reguläre Ausdruck eine Übereinstimmung findet, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Methode wird normalerweise verwendet, um eine Zeichenfolge zu überprüfen oder um sicherzustellen, dass eine Zeichenfolge mit einem bestimmten Muster entspricht, ohne diese Zeichenfolge für die Bearbeitung von nachfolgenden abrufen. Wenn Sie bestimmen, ob eine oder mehrere Zeichenfolgen Muster eines regulären Ausdrucks übereinstimmen, und klicken Sie dann für die Bearbeitung von nachfolgenden Aufruf abrufen möchten die <xref:System.Text.RegularExpressions.Regex.Match%2A> oder <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit von den entsprechenden Vorgang das Timeoutintervall gemäß überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie ein anderes Timeoutintervall nicht festlegen, wenn Sie den Konstruktor aufrufen, wird die Ausnahme ausgelöst, wenn der Vorgang alle für die Anwendungsdomäne eingerichtet, in dem Timeoutwert überschreitet die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> Methode, um zu bestimmen, ob eine Zeichenfolge eine gültige Teilenummer. Es sucht eine Teilenummer, die einen Doppelpunkt (:) in einer Zeichenfolge folgt. Die <xref:System.String.IndexOf%28System.Char%29> Methode wird verwendet, um die Position des Doppelpunktzeichens feststellen, welche die dann an die <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> Methode. Der reguläre Ausdruck wird davon ausgegangen, dass die Teilenummer ein bestimmtes Format aufweist, das besteht aus drei Gruppen von Zeichen, die durch Bindestriche getrennt. Die erste Menge, die vier Zeichen enthält, muss aus einem alphanumerischen Zeichen, gefolgt von zwei numerischen Zeichen, gefolgt von einem alphanumerischen Zeichen bestehen. Der zweite Satz, der aus drei Zeichen besteht, muss numerisch sein. Der dritte Satz, der aus vier Zeichen besteht, muss drei numerische Zeichen, gefolgt von einem alphanumerischen Zeichen haben.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch3.vb#3)]  
  
 Das Muster des regulären Ausdrucks lautet:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`[a-zA-Z0-9]`|Ein einzelnes alphabetisches Zeichen entsprechen (`a` über `z` oder `A` über `Z`) oder ein numerisches Zeichen.|  
|`\d{2}`|Übereinstimmung mit zwei numerischen Zeichen.|  
|`[a-zA-Z0-9]`|Ein einzelnes alphabetisches Zeichen entsprechen (`a` über `z` oder `A` über `Z`) oder ein numerisches Zeichen.|  
|`-`|Entsprechung für einen Bindestrich finden.|  
|`\d{3}`|Übereinstimmung mit genau drei numerischen Zeichen.|  
|`(-\d{3}){2}`|Suchen von einem Bindestrich gefolgt von drei Ziffern, und zwei Vorkommen dieses Muster übereinstimmen.|  
|`[a-zA-Z0-9]`|Ein einzelnes alphabetisches Zeichen entsprechen (`a` über `z` oder `A` über `Z`) oder ein numerisches Zeichen.|  
|`$`|Ende des Abgleichs am Ende der Zeile.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> ist kleiner als 0 (null) oder größer als die Länge von <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <summary>Gibt an, ob der reguläre Ausdruck eine Übereinstimmung in der angegebenen Eingabezeichenfolge findet.</summary>
        <returns>
          <see langword="true" />, wenn der reguläre Ausdruck eine Übereinstimmung findet, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Methode wird normalerweise verwendet, um eine Zeichenfolge zu überprüfen oder um sicherzustellen, dass eine Zeichenfolge mit einem bestimmten Muster entspricht, ohne diese Zeichenfolge für die Bearbeitung von nachfolgenden abrufen. Wenn Sie bestimmen, ob eine oder mehrere Zeichenfolgen Muster eines regulären Ausdrucks übereinstimmen, und klicken Sie dann für die Bearbeitung von nachfolgenden Aufruf abrufen möchten die <xref:System.Text.RegularExpressions.Regex.Match%2A> oder <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode.  
  
 Die statische <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> Methode entspricht dem Erstellen einer <xref:System.Text.RegularExpressions.Regex> Objekt mit dem Muster eines regulären Ausdrucks vom angegebenen `pattern` und Aufrufen der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> -Instanzmethode. Dieses Muster eines regulären Ausdrucks werden für den schnellen Abruf vom Modul für reguläre Ausdrücke zwischengespeichert.  
  
 Die `pattern` Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit von den entsprechenden Vorgang überschreitet das Timeoutintervall angegeben, für die Anwendungsdomäne, in dem die Methode aufgerufen wird. Wenn kein Timeout erfolgt in der Anwendungsdomäne Eigenschaften definiert ist, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> Methode, um zu bestimmen, ob eine Zeichenfolge eine gültige Teilenummer. Der reguläre Ausdruck wird davon ausgegangen, dass die Teilenummer ein bestimmtes Format aufweist, das besteht aus drei Gruppen von Zeichen, die durch Bindestriche getrennt. Die erste Menge, die vier Zeichen enthält, muss aus einem alphanumerischen Zeichen, gefolgt von zwei numerischen Zeichen, gefolgt von einem alphanumerischen Zeichen bestehen. Der zweite Satz, der aus drei Zeichen besteht, muss numerisch sein. Der dritte Satz, der aus vier Zeichen besteht, muss drei numerische Zeichen, gefolgt von einem alphanumerischen Zeichen haben.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch1.vb#1)]  
  
 Das Muster des regulären Ausdrucks lautet:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`^`|Starten Sie den Abgleich am Anfang der Zeile.|  
|`[a-zA-Z0-9]`|Ein einzelnes alphabetisches Zeichen entsprechen (`a` über `z` oder `A` über `Z`) oder ein numerisches Zeichen.|  
|`\d{2}`|Übereinstimmung mit zwei numerischen Zeichen.|  
|`[a-zA-Z0-9]`|Ein einzelnes alphabetisches Zeichen entsprechen (`a` über `z` oder `A` über `Z`) oder ein numerisches Zeichen.|  
|`-`|Entsprechung für einen Bindestrich finden.|  
|`\d{3}`|Übereinstimmung mit genau drei numerischen Zeichen.|  
|`(-\d{3}){2}`|Suchen von einem Bindestrich gefolgt von drei Ziffern, und zwei Vorkommen dieses Muster übereinstimmen.|  
|`[a-zA-Z0-9]`|Ein einzelnes alphabetisches Zeichen entsprechen (`a` über `z` oder `A` über `Z`) oder ein numerisches Zeichen.|  
|`$`|Ende des Abgleichs am Ende der Zeile.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage">
          <para>Diese Methode ein Timeout eintritt, nach einem bestimmten Zeitintervall, die den Standardtimeoutwert der Anwendungsdomäne gleich ist, in dem die Methode aufgerufen wird. Wenn Sie ein Timeoutwert für die Anwendungsdomäne, die den Wert nicht definiert wurde <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, die die Methode ein Timeout eintritt, verhindert wird verwendet. Ist die empfohlene statische Methode zum Überprüfen einer Musterübereinstimmung <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, und Sie können Sie das Timeoutintervall festgelegt.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <summary>Gibt an, ob der angegebene reguläre Ausdruck unter Verwendung der angegebenen Übereinstimmungsoptionen eine Übereinstimmung in der angegebenen Eingabezeichenfolge findet.</summary>
        <returns>
          <see langword="true" />, wenn der reguläre Ausdruck eine Übereinstimmung findet, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Methode wird normalerweise verwendet, um eine Zeichenfolge zu überprüfen oder um sicherzustellen, dass eine Zeichenfolge mit einem bestimmten Muster entspricht, ohne diese Zeichenfolge für die Bearbeitung von nachfolgenden abrufen. Wenn Sie bestimmen, ob eine oder mehrere Zeichenfolgen Muster eines regulären Ausdrucks übereinstimmen, und klicken Sie dann für die Bearbeitung von nachfolgenden Aufruf abrufen möchten die <xref:System.Text.RegularExpressions.Regex.Match%2A> oder <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode.  
  
 Die statische <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Methode entspricht dem Erstellen einer <xref:System.Text.RegularExpressions.Regex> Objekt mit dem Muster eines regulären Ausdrucks vom angegebenen `pattern` und Optionen für reguläre Ausdrücke, die vom angegebenen `options` und Aufrufen der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> Instanz Methode. Dieses Muster eines regulären Ausdrucks werden für den schnellen Abruf vom Modul für reguläre Ausdrücke zwischengespeichert.  
  
 Die `pattern` Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit von den entsprechenden Vorgang überschreitet das Timeoutintervall angegeben, für die Anwendungsdomäne, in dem die Methode aufgerufen wird. Wenn kein Timeout erfolgt in der Anwendungsdomäne Eigenschaften definiert ist, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> Methode, um zu bestimmen, ob eine Zeichenfolge eine gültige Teilenummer. Der reguläre Ausdruck wird davon ausgegangen, dass die Teilenummer ein bestimmtes Format aufweist, das besteht aus drei Gruppen von Zeichen, die durch Bindestriche getrennt. Die erste Menge, die vier Zeichen enthält, muss aus einem alphanumerischen Zeichen, gefolgt von zwei numerischen Zeichen, gefolgt von einem alphanumerischen Zeichen bestehen. Der zweite Satz, der aus drei Zeichen besteht, muss numerisch sein. Der dritte Satz, der aus vier Zeichen besteht, muss drei numerische Zeichen, gefolgt von einem alphanumerischen Zeichen haben.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch4.vb#4)]  
  
 Das Muster des regulären Ausdrucks lautet:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`^`|Beginnt die Suche am Anfang der Zeichenfolge.|  
|`[A-Z0-9]`|Übereinstimmung mit beliebigem einzelnes alphabetisches Zeichen aus `A` über `Z`, oder ein beliebiges numerisches Zeichen.|  
|`\d{2}`|Übereinstimmung mit zwei numerischen Zeichen.|  
|`[A-Z0-9]`|Übereinstimmung mit beliebigem einzelnes alphabetisches Zeichen aus `A` über `Z`, oder ein beliebiges numerisches Zeichen.|  
|`-`|Entsprechung für einen Bindestrich finden.|  
|`\d{3}`|Übereinstimmung mit genau drei numerischen Zeichen.|  
|`(-\d{3}){2}`|Suchen von einem Bindestrich gefolgt von drei Ziffern, und zwei Vorkommen dieses Muster übereinstimmen..|  
|`[A-Z0-9]`|Übereinstimmung mit beliebigem einzelnes alphabetisches Zeichen aus `A` über `Z`, oder ein beliebiges numerisches Zeichen.|  
|`$`|Beendet die Suche am Ende der Zeichenfolge.|  
  
 Aufrufen der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Methode mit der `options` Parametersatz auf <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> ist gleichbedeutend mit den folgenden regulären Ausdruck definieren:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Vergleich finden Sie im Beispiel für die <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> ist kein gültiger <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Wert.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage">
          <para>Diese Methode ein Timeout eintritt, nach einem bestimmten Zeitintervall, das den Standardtimeoutwert der Anwendungsdomäne gleich in welcher er aufgerufen wird. Wenn Sie ein Timeoutwert für die Anwendungsdomäne, die den Wert nicht definiert wurde <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, die die Methode ein Timeout eintritt, verhindert wird verwendet. Ist die empfohlene statische Methode zum Überprüfen einer Musterübereinstimmung <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, und Sie können Sie das Timeoutintervall festgelegt.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <param name="matchTimeout">Ein Timeoutintervall oder <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das angibt, dass die Methode kein Timeout haben sollte.</param>
        <summary>Gibt an, ob der angegebene reguläre Ausdruck unter Verwendung der angegebenen Übereinstimmungsoptionen und des angegebenen Timeoutintervalls eine Übereinstimmung in der angegebenen Eingabezeichenfolge findet.</summary>
        <returns>
          <see langword="true" />, wenn der reguläre Ausdruck eine Übereinstimmung findet, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Methode wird normalerweise verwendet, um eine Zeichenfolge zu überprüfen oder um sicherzustellen, dass eine Zeichenfolge mit einem bestimmten Muster entspricht, ohne diese Zeichenfolge für die Bearbeitung von nachfolgenden abrufen. Wenn Sie bestimmen, ob eine oder mehrere Zeichenfolgen Muster eines regulären Ausdrucks übereinstimmen, und klicken Sie dann für die Bearbeitung von nachfolgenden Aufruf abrufen möchten die <xref:System.Text.RegularExpressions.Regex.Match%2A> oder <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode.  
  
 Die statische <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Methode entspricht dem Erstellen einer <xref:System.Text.RegularExpressions.Regex> Objekt mit dem Muster eines regulären Ausdrucks vom angegebenen `pattern` und Optionen für reguläre Ausdrücke, die vom angegebenen `options` und Aufrufen der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> Instanz Methode. Dieses Muster eines regulären Ausdrucks werden für den schnellen Abruf vom Modul für reguläre Ausdrücke zwischengespeichert.  
  
 Die `pattern` Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die `matchTimeout` Parameter gibt an, wie lange eine Mustervergleich Methode sollten versuchen, eine Übereinstimmung zu finden, bevor ein Timeout eintritt. Ein Timeoutintervall Einstellung wird verhindert, dass reguläre Ausdrücken, die übermäßige rückverfolgung nicht angezeigt wird, nicht mehr reagiert, wenn diese Eingaben verarbeiten, die in der Nähe von Übereinstimmungen enthält. Weitere Informationen finden Sie unter [bewährte Methoden für reguläre Ausdrücke](~/docs/standard/base-types/best-practices.md) und [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Wenn in diesem Zeitraum keine Übereinstimmung gefunden wird, löst die Methode eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme. `matchTimeout` überschreibt alle Standard-Timeoutwert definiert, die für die Anwendungsdomäne, in der die Methode ausgeführt wird.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Methode, um zu bestimmen, ob eine Zeichenfolge eine gültige Teilenummer. Der reguläre Ausdruck wird davon ausgegangen, dass die Teilenummer ein bestimmtes Format aufweist, das besteht aus drei Gruppen von Zeichen, die durch Bindestriche getrennt. Die erste Menge, die vier Zeichen enthält, muss aus einem alphanumerischen Zeichen, gefolgt von zwei numerischen Zeichen, gefolgt von einem alphanumerischen Zeichen bestehen. Der zweite Satz, der aus drei Zeichen besteht, muss numerisch sein. Der dritte Satz, der aus vier Zeichen besteht, muss drei numerische Zeichen, gefolgt von einem alphanumerischen Zeichen haben. Gemäß dem Muster für reguläre Ausdrücke sollten umfassen minimale Durchsuchen der Eingabezeichenfolge, sodass die Methode mit einem Timeoutintervall von 500 Millisekunden festlegt.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch5.vb#5)]  
  
 Das Muster des regulären Ausdrucks lautet:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`^`|Beginnt die Suche am Anfang der Zeichenfolge.|  
|`[A-Z0-9]`|Übereinstimmung mit beliebigem einzelnes alphabetisches Zeichen aus `A` über `Z`, oder ein beliebiges numerisches Zeichen.|  
|`\d{2}`|Übereinstimmung mit zwei numerischen Zeichen.|  
|`[A-Z0-9]`|Übereinstimmung mit beliebigem einzelnes alphabetisches Zeichen aus `A` über `Z`, oder ein beliebiges numerisches Zeichen.|  
|`-`|Entsprechung für einen Bindestrich finden.|  
|`\d{3}`|Übereinstimmung mit genau drei numerischen Zeichen.|  
|`(-\d{3}){2}`|Suchen von einem Bindestrich gefolgt von drei Ziffern, und zwei Vorkommen dieses Muster übereinstimmen.|  
|`[A-Z0-9]`|Übereinstimmung mit beliebigem einzelnes alphabetisches Zeichen aus `A` über `Z`, oder ein beliebiges numerisches Zeichen.|  
|`$`|Beendet die Suche am Ende der Zeichenfolge.|  
  
 Aufrufen der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Methode mit der `options` Parametersatz auf <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> ist gleichbedeutend mit den folgenden regulären Ausdruck definieren:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Vergleich finden Sie im Beispiel für die <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> ist kein gültiger <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Wert.  Oder:  <paramref name="matchTimeout" /> ist negativ, null oder größer als ca. 24 Tage.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten.</exception>
        <block subset="none" type="usage">
          <para>Es wird empfohlen, Sie legen die <paramref name="matchTimeout" /> Parameter auf einen geeigneten Wert, z. B. zwei Sekunden. Wenn Sie Timeouts durch Angabe deaktivieren <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das Modul für reguläre Ausdrücke bietet eine etwas bessere Leistung. Sie sollten jedoch deaktivieren, Timeouts nur unter folgenden Bedingungen:: Wenn die Eingabe verarbeitet, die von einem regulären Ausdruck aus einer bekannten und vertrauenswürdigen Quelle stammt oder statischer Text besteht. Dies schließt Text, der Eingaben von Benutzern dynamisch wurde.  – Wenn Sie Muster des regulären Ausdrucks gründlich getestet wurden, um sicherzustellen, dass er effizient verarbeitet übereinstimmt, nicht-Übereinstimmungen und Naher übereinstimmt.  – Wenn Muster für reguläre Ausdrücke keine Language-Elemente enthält, die bekanntermaßen dazu führen, dass eine übermäßige rückverfolgung, bei der Verarbeitung einer Nahen Übereinstimmung.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Match">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Durchsucht eine Eingabezeichenfolge nach einer Teilzeichenfolge, die mit einem Muster eines regulären Ausdrucks übereinstimmt, und gibt das erste Vorkommen als einzelnes <see cref="T:System.Text.RegularExpressions.Match" />-Objekt zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <summary>Durchsucht die angegebene Eingabezeichenfolge nach dem ersten Vorkommen des im <see cref="T:System.Text.RegularExpressions.Regex" />-Konstruktor angegebenen regulären Ausdrucks.</summary>
        <returns>Ein Objekt, das Informationen zur Übereinstimmung enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> Methode gibt die erste Teilzeichenfolge, die Muster eines regulären Ausdrucks in einer Eingabezeichenfolge übereinstimmt. Informationen über die Sprachelemente, die zum Erstellen des Muster eines regulären Ausdrucks verwendet, finden Sie unter [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Sie können bestimmen, ob das reguläre Ausdrucksmuster in der Eingabezeichenfolge gefunden wurde, durch Überprüfung des Werts des zurückgegebenen <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Group.Success%2A> Eigenschaft. Wenn eine Übereinstimmung gefunden wird, das zurückgegebene <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Capture.Value%2A> Eigenschaft enthält die Teilzeichenfolge aus `input` , die mit das Muster eines regulären Ausdrucks übereinstimmt. Wenn keine Übereinstimmung gefunden wird, wird sein Wert <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Diese Methode gibt die erste Teilzeichenfolge in `input` , die mit das Muster eines regulären Ausdrucks übereinstimmt. Sie können die nachfolgende Übereinstimmungen abrufen, indem Sie wiederholt aufrufen das zurückgegebene <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> Methode. Sie können auch alle Übereinstimmungen in einem einzelnen Methodenaufruf abrufen, durch Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> Methode.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit von den entsprechenden Vorgang das Timeoutintervall gemäß überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie ein anderes Timeoutintervall nicht festlegen, wenn Sie den Konstruktor aufrufen, wird die Ausnahme ausgelöst, wenn der Vorgang alle für die Anwendungsdomäne eingerichtet, in dem Timeoutwert überschreitet die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Das folgende Beispiel sucht nach Muster eines regulären Ausdrucks in einer Zeichenfolge entspricht und anschließend eine Liste der übereinstimmenden Gruppen erfasst und Erfassung Positionen.  
  
 [!code-cpp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp#8)]
 [!code-csharp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs#8)]
 [!code-vb[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb#8)]  
  
 Muster für reguläre Ausdrücke `(\w+)\s+(car)` Vorkommen des Worts "Car" zusammen mit dem Wort, das ihm vorausgeht. Er ist wie in der folgenden Tabelle dargestellt interpretiert.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`(\w+)`|Übereinstimmung mit mindestens einem Wortzeichen. Dies ist die erste Erfassungsgruppe.|  
|`\s+`|Entspricht mindestens ein Leerzeichen an.|  
|(Auto)|Entspricht der literalen Zeichenfolge "Car". Dies ist die zweite Erfassungsgruppe.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, startat As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="startat">Die nullbasierte Zeichenposition, an der mit der Suche begonnen werden soll.</param>
        <summary>Durchsucht die Eingabezeichenfolge nach dem ersten Vorkommen eines regulären Ausdrucks ab der angegebenen Anfangsposition in der Zeichenfolge.</summary>
        <returns>Ein Objekt, das Informationen zur Übereinstimmung enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> Methode gibt die erste Teilzeichenfolge zurück, das Muster eines regulären Ausdrucks, wobei am oder nach entspricht der `startat` Zeichenposition in einer Eingabezeichenfolge. Informationen über die Sprachelemente, die zum Erstellen des Muster eines regulären Ausdrucks verwendet, finden Sie unter [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Das Muster des regulären Ausdrucks für die die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> Methode sucht wird definiert, durch den Aufruf eines der <xref:System.Text.RegularExpressions.Regex> Klassenkonstruktoren. Weitere Informationen zu den Elementen, die Muster eines regulären Ausdrucks bilden können, finden Sie unter [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Sie können optional eine Startposition in der Zeichenfolge angeben, mit der `startat` Parameter. Wenn das Modul für reguläre Ausdrücke von links nach rechts (Standard) analysiert, die übereinstimmen und die Überprüfung verschieben rightward, beginnend mit dem Zeichen im angegebenen `startat`. Wenn das Modul für reguläre Ausdrücke analysiert, von rechts nach links (wenn Muster des regulären Ausdrucks mit erstellt die <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> Option), die Übereinstimmung und die Überprüfung in die entgegengesetzte Richtung zu verschieben, und beginnen mit dem Zeichen am `startat` -1. Wenn Sie eine Startposition nicht angeben, die Suche beginnt an Standardeinstellung `startat` Position. Wenn der reguläre Ausdruck von links nach rechts und von der Standardeinstellung sucht `startat` Position befindet sich am linken Ende der `input`; wenn er sucht, von rechts nach links, die Standardeinstellung `startat` Position befindet sich am rechten Ende `input`.  
  
 Wenn eine Übereinstimmung zu beschränken, damit er an einer bestimmten Zeichenposition in der Zeichenfolge beginnt und das Modul für reguläre Ausdrücke den Rest der Zeichenfolge nicht nach einer Übereinstimmung überprüft werden sollen, verankern Sie den regulären Ausdruck mit einem `\G` (auf der linken Seite für eine von links nach rechts Muster oder rechts für rechts-nach-links-Muster). Dadurch wird die Übereinstimmung, damit sie genau um beginnen muss `startat`.  
  
 Sie können bestimmen, ob das reguläre Ausdrucksmuster in der Eingabezeichenfolge gefunden wurde, durch Überprüfung des Werts des zurückgegebenen <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Group.Success%2A> Eigenschaft. Wenn eine Übereinstimmung gefunden wird, das zurückgegebene <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Capture.Value%2A> Eigenschaft enthält die Teilzeichenfolge aus `input` , die mit das Muster eines regulären Ausdrucks übereinstimmt. Wenn keine Übereinstimmung gefunden wird, wird sein Wert <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Diese Methode gibt die erste Teilzeichenfolge gefunden wird, um oder nach der `startat` Zeichenposition in `input` , die mit das Muster eines regulären Ausdrucks übereinstimmt. Sie können die nachfolgende Übereinstimmungen abrufen, indem Sie wiederholt aufrufen das zurückgegebene <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> Methode. Sie können auch alle Übereinstimmungen in einem einzelnen Methodenaufruf abrufen, durch Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> Methode.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit von den entsprechenden Vorgang das Timeoutintervall gemäß überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie ein anderes Timeoutintervall nicht festlegen, wenn Sie den Konstruktor aufrufen, wird die Ausnahme ausgelöst, wenn der Vorgang überschreitet die maximal für die Anwendungsdomäne, in dem alle Timeoutwert hergestellt der <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> ist kleiner als 0 (null) oder größer als die Länge von <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <summary>Durchsucht die angegebene Eingabezeichenfolge nach dem ersten Vorkommen des angegebenen regulären Ausdrucks.</summary>
        <returns>Ein Objekt, das Informationen zur Übereinstimmung enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> Methode gibt die erste Teilzeichenfolge, die Muster eines regulären Ausdrucks in einer Eingabezeichenfolge übereinstimmt. Informationen über die Sprachelemente, die zum Erstellen des Muster eines regulären Ausdrucks verwendet, finden Sie unter [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die statische <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> Methode entspricht dem Erstellen einer <xref:System.Text.RegularExpressions.Regex> -Objekt mit dem angegebenen regulären Ausdrucksmuster und Aufrufen der <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> Methode. In diesem Fall wird das Modul für reguläre Ausdrücke Muster für reguläre Ausdrücke zwischengespeichert.  
  
 Die `pattern` Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Sie können bestimmen, ob das reguläre Ausdrucksmuster in der Eingabezeichenfolge gefunden wurde, durch Überprüfung des Werts des zurückgegebenen <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Group.Success%2A> Eigenschaft. Wenn eine Übereinstimmung gefunden wird, das zurückgegebene <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Capture.Value%2A> Eigenschaft enthält die Teilzeichenfolge aus `input` , die mit das Muster eines regulären Ausdrucks übereinstimmt. Wenn keine Übereinstimmung gefunden wird, wird sein Wert <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Diese Methode gibt die erste Teilzeichenfolge in `input` , die mit das Muster eines regulären Ausdrucks übereinstimmt. Sie können die nachfolgende Übereinstimmungen abrufen, indem Sie wiederholt aufrufen das zurückgegebene <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> Methode. Sie können auch alle Übereinstimmungen in einem einzelnen Methodenaufruf abrufen, durch Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> Methode.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit von den entsprechenden Vorgang überschreitet das Timeoutintervall angegeben, für die Anwendungsdomäne, in dem die Methode aufgerufen wird. Wenn kein Timeout erfolgt in der Anwendungsdomäne Eigenschaften definiert ist, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> Methode, um das erste Wort zu ermitteln, die über mindestens einen enthält `z` Zeichen, und ruft dann die <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> Methode, um zusätzlichen Übereinstimmungen zu ermitteln.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match1.vb#1)]  
  
 Das Muster für reguläre Ausdrücke `\b\w*z+\w*\b` wird entsprechend der folgenden Tabelle interpretiert:  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\b`|Der Vergleich beginnt an einer Wortgrenze.|  
|`\w*`|Entspricht 0 (null), einer oder mehrere Wortzeichen.|  
|`z+`|Übereinstimmung mit mindestens der `z` Zeichen.|  
|`\w*`|Entspricht 0 (null), einer oder mehrere Wortzeichen.|  
|`\b`|Der Vergleich endet an einer Wortgrenze.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage">
          <para>Diese Methode ein Timeout eintritt, nach einem bestimmten Zeitintervall, das den Standardtimeoutwert der Anwendungsdomäne gleich in welcher er aufgerufen wird. Wenn Sie ein Timeoutwert für die Anwendungsdomäne, die den Wert nicht definiert wurde <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, die die Methode ein Timeout eintritt, verhindert wird verwendet. Ist die empfohlene statische Methode zum Abrufen einer Musterübereinstimmung <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, und Sie können Sie das Timeoutintervall festgelegt.</para>
        </block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int beginning, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 beginning, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, beginning As Integer, length As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int beginning, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="beginning" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="beginning">Die nullbasierte Zeichenposition in der Eingabezeichenfolge, die die am weitesten links stehende Position definiert, die gesucht werden soll.</param>
        <param name="length">Die Anzahl der Zeichen der Teilzeichenfolge, die in die Suche einbezogen werden soll.</param>
        <summary>Sucht beginnend an der angegebenen Anfangsposition in der Eingabezeichenfolge nach dem ersten Vorkommen eines regulären Ausdrucks und sucht nur nach der angegebenen Anzahl von Zeichen.</summary>
        <returns>Ein Objekt, das Informationen zur Übereinstimmung enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> Methode gibt die erste Teilzeichenfolge, die Muster eines regulären Ausdrucks in einem Teil einer Eingabezeichenfolge entspricht. Informationen über die Sprachelemente, die zum Erstellen des Muster eines regulären Ausdrucks verwendet, finden Sie unter [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Das Muster des regulären Ausdrucks für die die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> Methode sucht wird definiert, durch den Aufruf eines der <xref:System.Text.RegularExpressions.Regex> Klassenkonstruktoren. Weitere Informationen zu den Elementen, die Muster eines regulären Ausdrucks bilden können, finden Sie unter [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> Methode durchsucht, die Teil des `input` definiert, indem Sie die `beginning` und `length` Parameter nach dem Muster des regulären Ausdrucks. `beginning` immer definiert den Index des ersten Zeichens in die Suche eingeschlossen werden sollen und `length` definiert die maximale Anzahl der zu suchenden Zeichen. Zusammen definieren sie den Bereich der Suche. Wenn die Suche von links nach rechts (Standard) wird fortgesetzt, sucht das Modul für reguläre Ausdrücke vom Zeichen am Index `beginning` auf das Zeichen am Index `beginning`  +  `length` – 1. Wenn das Modul für reguläre Ausdrücke, mithilfe instanziiert wurde der <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> auswählen, sodass die Suche von rechts nach von links geht, die Suche von regulären Ausdrücken Modul vom Zeichen am Index `beginning`  +  `length` – 1 an den Zeichen am Index `beginning`. Diese Methode gibt die erste Übereinstimmung, die in diesen Bereich gefunden. Sie können die nachfolgende Übereinstimmungen abrufen, indem Sie wiederholt aufrufen das zurückgegebene <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> Methode.  
  
 Sie können bestimmen, ob das reguläre Ausdrucksmuster in der Eingabezeichenfolge gefunden wurde, durch Überprüfung des Werts des zurückgegebenen <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Group.Success%2A> Eigenschaft. Wenn eine Übereinstimmung gefunden wird, das zurückgegebene <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Capture.Value%2A> Eigenschaft enthält die Teilzeichenfolge aus `input` , die mit das Muster eines regulären Ausdrucks übereinstimmt. Wenn keine Übereinstimmung gefunden wird, wird sein Wert <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit von den entsprechenden Vorgang das Timeoutintervall gemäß überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie beim Aufruf des Konstruktors keinen Timeoutwert festlegen, wird die Ausnahme ausgelöst, wenn der Vorgang alle für die Anwendungsdomäne eingerichtet, in dem Timeoutwert überschreitet die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="beginning" /> ist kleiner als 0 (null) oder größer als die Länge von <paramref name="input" />.  <paramref name="length" /> ist kleiner als 0 (null) oder größer als die Länge von <paramref name="input" />.  Oder: <paramref name="beginning" /><see langword="+" /><paramref name="length" /><see langword="–1" /> gibt eine Position außerhalb des Bereichs von <paramref name="input" /> an.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <summary>Durchsucht die angegebene Eingabezeichenfolge unter Verwendung der angegebenen Übereinstimmungsoptionen nach dem ersten Vorkommen des angegebenen regulären Ausdrucks.</summary>
        <returns>Ein Objekt, das Informationen zur Übereinstimmung enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Methode gibt die erste Teilzeichenfolge, die Muster eines regulären Ausdrucks in einer Eingabezeichenfolge übereinstimmt. Informationen über die Sprachelemente, die zum Erstellen des Muster eines regulären Ausdrucks verwendet, finden Sie unter [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die statische <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Methode entspricht dem Erstellen einer <xref:System.Text.RegularExpressions.Regex> -Objekt mit den <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Konstruktor und die Instanz aufrufen <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> Methode.  
  
 Die `pattern` Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Sie können bestimmen, ob das reguläre Ausdrucksmuster in der Eingabezeichenfolge gefunden wurde, durch Überprüfung des Werts des zurückgegebenen <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Group.Success%2A> Eigenschaft. Wenn eine Übereinstimmung gefunden wird, das zurückgegebene <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Capture.Value%2A> Eigenschaft enthält die Teilzeichenfolge aus `input` , die mit das Muster eines regulären Ausdrucks übereinstimmt. Wenn keine Übereinstimmung gefunden wird, wird sein Wert <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Diese Methode gibt die erste Teilzeichenfolge gefunden `input` , die mit das Muster eines regulären Ausdrucks übereinstimmt. Sie können die nachfolgende Übereinstimmungen abrufen, indem Sie wiederholt aufrufen das zurückgegebene <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Match.NextMatch%2A> Methode. Sie können auch alle Übereinstimmungen in einem einzelnen Methodenaufruf abrufen, durch Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> Methode.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit von den entsprechenden Vorgang überschreitet das Timeoutintervall angegeben, für die Anwendungsdomäne, in dem die Methode aufgerufen wird. Wenn kein Timeout erfolgt in der Anwendungsdomäne Eigenschaften definiert ist, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Das folgende Beispiel definiert einen regulären Ausdruck, die Wörter mit dem Buchstaben "a". Er verwendet die <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> Option, um sicherzustellen, dass der reguläre Ausdruck Wörtern, die mit einem großen "a" und einem Kleinbuchstaben beginnen sucht "a".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match2.vb#2)]  
  
 Das Muster für reguläre Ausdrücke `\ba\w*\b` wird entsprechend der folgenden Tabelle interpretiert:  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\b`|Der Vergleich beginnt an einer Wortgrenze.|  
|`a`|Übereinstimmung mit den Zeichen "a".|  
|`\w*`|Entspricht 0 (null), einer oder mehrere Wortzeichen.|  
|`\b`|Der Vergleich endet an einer Wortgrenze.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage">
          <para>Diese Methode ein Timeout eintritt, nach einem bestimmten Zeitintervall, das den Standardtimeoutwert der Anwendungsdomäne gleich in welcher er aufgerufen wird. Wenn Sie ein Timeoutwert für die Anwendungsdomäne, die den Wert nicht definiert wurde <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, die die Methode ein Timeout eintritt, verhindert wird verwendet. Ist die empfohlene statische Methode zum Abrufen einer Musterübereinstimmung <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, und Sie können Sie das Timeoutintervall festgelegt.</para>
        </block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <param name="matchTimeout">Ein Timeoutintervall oder <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das angibt, dass die Methode kein Timeout haben sollte.</param>
        <summary>Durchsucht die Eingabezeichenfolge unter Verwendung der angegebenen Übereinstimmungsoptionen und des angegebenen Timeoutintervalls nach dem ersten Vorkommen des angegebenen regulären Ausdrucks.</summary>
        <returns>Ein Objekt, das Informationen zur Übereinstimmung enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Methode gibt die erste Teilzeichenfolge, die Muster eines regulären Ausdrucks in einer Eingabezeichenfolge übereinstimmt. Informationen über die Sprachelemente, die zum Erstellen des Muster eines regulären Ausdrucks verwendet, finden Sie unter [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die statische <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Methode entspricht dem Erstellen einer <xref:System.Text.RegularExpressions.Regex> -Objekt mit den <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Konstruktor und die Instanz aufrufen <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> Methode.  
  
 Die `pattern` Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Sie können bestimmen, ob das reguläre Ausdrucksmuster in der Eingabezeichenfolge gefunden wurde, durch Überprüfung des Werts des zurückgegebenen <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Group.Success%2A> Eigenschaft. Wenn eine Übereinstimmung gefunden wird, das zurückgegebene <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Capture.Value%2A> Eigenschaft enthält die Teilzeichenfolge aus `input` , die mit das Muster eines regulären Ausdrucks übereinstimmt. Wenn keine Übereinstimmung gefunden wird, wird sein Wert <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Diese Methode gibt die erste Teilzeichenfolge gefunden `input` , die mit das Muster eines regulären Ausdrucks übereinstimmt. Sie können die nachfolgende Übereinstimmungen abrufen, indem Sie wiederholt aufrufen das zurückgegebene <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Match.NextMatch%2A> Methode. Sie können auch alle Übereinstimmungen in einem einzelnen Methodenaufruf abrufen, durch Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> Methode.  
  
 Die `matchTimeout` Parameter gibt an, wie lange eine Mustervergleich Methode sollten versuchen, eine Übereinstimmung zu finden, bevor ein Timeout eintritt. Ein Timeoutintervall Einstellung wird verhindert, dass reguläre Ausdrücken, die übermäßige rückverfolgung nicht angezeigt wird, nicht mehr reagiert, wenn diese Eingaben verarbeiten, die in der Nähe von Übereinstimmungen enthält. Weitere Informationen finden Sie unter [bewährte Methoden für reguläre Ausdrücke](~/docs/standard/base-types/best-practices.md) und [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Wenn in diesem Zeitraum keine Übereinstimmung gefunden wird, löst die Methode eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme. `matchTimeout` überschreibt alle Standard-Timeoutwert definiert, die für die Anwendungsdomäne, in der die Methode ausgeführt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.  Oder:  <paramref name="matchTimeout" /> ist negativ, null oder größer als ca. 24 Tage.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage">
          <para>Es wird empfohlen, Sie legen die <paramref name="matchTimeout" /> Parameter auf einen geeigneten Wert, z. B. zwei Sekunden. Wenn Sie Timeouts durch Angabe deaktivieren <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das Modul für reguläre Ausdrücke bietet eine etwas bessere Leistung. Sie sollten jedoch deaktivieren, Timeouts nur unter folgenden Bedingungen:: Wenn die Eingabe verarbeitet, die von einem regulären Ausdruck aus einer bekannten und vertrauenswürdigen Quelle stammt oder statischer Text besteht. Dies schließt Text, der Eingaben von Benutzern dynamisch wurde.  – Wenn Sie Muster des regulären Ausdrucks gründlich getestet wurden, um sicherzustellen, dass er effizient verarbeitet übereinstimmt, nicht-Übereinstimmungen und Naher übereinstimmt.  – Wenn Muster für reguläre Ausdrücke keine Language-Elemente enthält, die bekanntermaßen dazu führen, dass eine übermäßige rückverfolgung, bei der Verarbeitung einer Nahen Übereinstimmung.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Matches">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Durchsucht eine Eingabezeichenfolge nach allen Vorkommen eines regulären Ausdrucks und gibt alle Übereinstimmungen zurück.</summary>
        <block subset="none" type="usage">
          <para>Wenn ein Versuch wird wiederholt durch Aufrufen der <see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /> -Methode, das Modul für reguläre Ausdrücke kann leere Übereinstimmungen besondere Behandlung. Das Modul für reguläre Ausdrücke beginnt in der Regel die Suche nach der nächsten Übereinstimmung genau, wo die vorherige Übereinstimmung angehalten wurde. Nachdem eine leere Übereinstimmung wird das Modul für reguläre Ausdrücke, bevor die nächste Übereinstimmung versucht jedoch um ein Zeichen verschiebt. Dieses Verhalten garantiert, dass das Modul für reguläre Ausdrücke durch die Zeichenfolge ausgeführt wird. Andernfalls, da eine leere Übereinstimmung nicht in jeder vorwärtsbewegung führt, startet die nächste Übereinstimmung in genau dieselbe Stelle ein wie die vorherige Übereinstimmung und dieselbe leere Zeichenfolge würde wiederholt überein.  Im folgenden Beispiel mit dem Muster des regulären Ausdrucks <c>eine *</c> sucht nach 0 (null) oder mehr Vorkommen des Buchstabens "a" in der Zeichenfolge "Abaabb". Wie die Ausgabe des Beispiels zeigt, das resultierende <see cref="T:System.Text.RegularExpressions.MatchCollection" /> Objekt enthält sechs <see cref="T:System.Text.RegularExpressions.Match" /> Objekte. Der erste Versuch sucht das erste "a". Der zweite Übereinstimmung beginnt, in dem die erste exakt endet, vor der ersten b. Es findet keine Vorkommen von "a" und eine leere Zeichenfolge zurückgegeben. Die dritte Übereinstimmung beginnt nun nicht genau, wo der zweiten Vergleich beendet wurde, da die zweite Übereinstimmung eine leere Zeichenfolge zurückgegeben wurde. Stattdessen werden ein Zeichen später, nach der ersten "b" beginnt. Der dritte Übereinstimmung sucht nach zwei Vorkommen von "a" und "aa" zurückgegeben. Der vierte Versuch beginnt, in dem der dritten Vergleich beendet wurde, bevor Sie die zweite "b", und eine leere Zeichenfolge zurückgegeben. Der fünfte Versuch setzt erneut ein Zeichen, damit vor der dritten "b" beginnt und eine leere Zeichenfolge zurückgegeben. Der sechste Übereinstimmung beginnt nach der letzten "b" und erneut eine leere Zeichenfolge zurückgegeben.  [! code-csharp[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/emptymatches1.cs#9)] [! code-vb[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/emptymatches1.vb#9)]</para>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <summary>Durchsucht die angegebene Eingabezeichenfolge nach allen Vorkommen eines regulären Ausdrucks.</summary>
        <returns>Eine Auflistung der im Suchvorgang gefundenen <see cref="T:System.Text.RegularExpressions.Match" />-Objekte. Wenn keine Übereinstimmungen gefunden werden, gibt die Methode ein leeres Auflistungsobjekt zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> Methode ist vergleichbar mit der <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> Methode, mit der Ausnahme, Informationen zu allen Übereinstimmungen zurückgegeben in der Eingabezeichenfolge, anstelle einer einzelnen Übereinstimmung gefunden. Dies entspricht dem folgenden Code:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#5)]  
  
 Die Auflistung enthält nur Übereinstimmungen und endet bei der ersten nicht-Übereinstimmung.  
  
 Das Muster des regulären Ausdrucks für die die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> Methode sucht wird definiert, durch den Aufruf eines der <xref:System.Text.RegularExpressions.Regex> Klassenkonstruktoren. Weitere Informationen zu den Elementen, die Muster eines regulären Ausdrucks bilden können, finden Sie unter [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode verwendet verzögerten Auswertung zum Auffüllen der zurückgegebenen <xref:System.Text.RegularExpressions.MatchCollection> Objekt. Z. B. Zugriff auf Mitglieder dieser Sammlung <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> und <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> bewirkt, dass den Auflistung sofort aufgefüllt werden. Um verzögerte Auswertung nutzen zu können, sollten Sie die Auflistung durchlaufen, mit einem Konstrukt wie `foreach` in C# geschrieben und `For Each`...`Next` in Visual Basic.  
  
 Aufgrund der verzögerten Auswertung Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> Methode löst eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme. Allerdings wird die Ausnahme ausgelöst, wenn ein Vorgang ausgeführt wird, auf die <xref:System.Text.RegularExpressions.MatchCollection> Objekt, das von dieser Methode zurückgegeben wird, wenn die <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> Eigenschaft ist nicht <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> und ein Abgleichsvorgang überschreitet das Timeoutintervall.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> Methode, um alle Wörter in einem Satz zu identifizieren, die auf "es"endenden"enden.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches1.vb#1)]  
  
 Das Muster für reguläre Ausdrücke `\b\w+es\b` wird entsprechend der folgenden Tabelle definiert:  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\b`|Der Vergleich beginnt an einer Wortgrenze.|  
|`\w+`|Übereinstimmung mit mindestens einem Wortzeichen.|  
|`es`|Mit die literale Zeichenfolge ""es endenden"übereinstimmen.|  
|`\b`|Der Vergleich endet an einer Wortgrenze.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String, startat As Integer) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="startat">Die Zeichenposition in der Eingabezeichenfolge, an der mit der Suche begonnen werden soll.</param>
        <summary>Durchsucht die angegebene Eingabezeichenfolge nach allen Vorkommen eines regulären Ausdrucks ab der angegebenen Anfangsposition in der Zeichenfolge.</summary>
        <returns>Eine Auflistung der im Suchvorgang gefundenen <see cref="T:System.Text.RegularExpressions.Match" />-Objekte. Wenn keine Übereinstimmungen gefunden werden, gibt die Methode ein leeres Auflistungsobjekt zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> Methode ist vergleichbar mit der <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> Methode, mit der Ausnahme, Informationen zu allen Übereinstimmungen zurückgegeben in der Eingabezeichenfolge, anstelle einer einzelnen Übereinstimmung gefunden. Dies entspricht dem folgenden Code:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#6)]  
  
 Das Muster des regulären Ausdrucks für die die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> Methode sucht wird definiert, durch den Aufruf eines der <xref:System.Text.RegularExpressions.Regex> Klassenkonstruktoren. Weitere Informationen zu den Elementen, die Muster eines regulären Ausdrucks bilden können, finden Sie unter [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode verwendet verzögerten Auswertung zum Auffüllen der zurückgegebenen <xref:System.Text.RegularExpressions.MatchCollection> Objekt. Z. B. Zugriff auf Mitglieder dieser Sammlung <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> und <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> bewirkt, dass den Auflistung sofort aufgefüllt werden. Um verzögerte Auswertung nutzen zu können, sollten Sie die Auflistung durchlaufen, mit einem Konstrukt wie `foreach` in C# geschrieben und `For Each`...`Next` in Visual Basic.  
  
 Aufgrund der verzögerten Auswertung Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> Methode löst eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme. Allerdings wird die Ausnahme ausgelöst, wenn ein Vorgang ausgeführt wird, auf die <xref:System.Text.RegularExpressions.MatchCollection> Objekt, das von dieser Methode zurückgegeben wird, wenn die <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> Eigenschaft ist nicht <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> und ein Abgleichsvorgang überschreitet das Timeoutintervall..  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> Methode, um das erste Wort in einem Satz zu ermitteln, die in "es"endenden"endet, und ruft dann die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> Methode, um alle weiteren Wörter identifizieren, die auf"es "endenden" enden.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches3.vb#3)]  
  
 Das Muster für reguläre Ausdrücke `\b\w+es\b` wird entsprechend der folgenden Tabelle definiert:  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\b`|Der Vergleich beginnt an einer Wortgrenze.|  
|`\w+`|Übereinstimmung mit mindestens einem Wortzeichen.|  
|`es`|Mit die literale Zeichenfolge ""es endenden"übereinstimmen.|  
|`\b`|Der Vergleich endet an einer Wortgrenze.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> ist kleiner als 0 (null) oder größer als die Länge von <paramref name="input" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <summary>Durchsucht die angegebene Eingabezeichenfolge nach allen Vorkommen eines angegebenen regulären Ausdrucks.</summary>
        <returns>Eine Auflistung der im Suchvorgang gefundenen <see cref="T:System.Text.RegularExpressions.Match" />-Objekte. Wenn keine Übereinstimmungen gefunden werden, gibt die Methode ein leeres Auflistungsobjekt zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> Methode ist vergleichbar mit der <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> Methode, mit der Ausnahme, Informationen zu allen Übereinstimmungen zurückgegeben in der Eingabezeichenfolge, anstelle einer einzelnen Übereinstimmung gefunden. Dies entspricht dem folgenden Code:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#7)]  
  
 Die statische `Matches` Methoden sind gleichwertig, für das Erstellen einer <xref:System.Text.RegularExpressions.Regex> -Objekt mit dem angegebenen regulären Ausdrucksmuster und Aufrufen der Instanzmethode `Matches`.  
  
 Die `pattern` Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode verwendet verzögerten Auswertung zum Auffüllen der zurückgegebenen <xref:System.Text.RegularExpressions.MatchCollection> Objekt. Z. B. Zugriff auf Mitglieder dieser Sammlung <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> und <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> bewirkt, dass den Auflistung sofort aufgefüllt werden. Um verzögerte Auswertung nutzen zu können, sollten Sie die Auflistung durchlaufen, mit einem Konstrukt wie `foreach` in C# geschrieben und `For Each`...`Next` in Visual Basic.  
  
 Aufgrund der verzögerten Auswertung Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> Methode löst eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme. Allerdings wird die Ausnahme ausgelöst, wenn ein Vorgang ausgeführt wird, auf die <xref:System.Text.RegularExpressions.MatchCollection> Objekt, die von dieser Methode zurückgegeben wird, wenn ein Timeoutintervall, durch die Eigenschaft "REGEX_DEFAULT_MATCH_TIMEOUT" von der aktuellen Anwendungsdomäne und einen Abgleichsvorgang definiert ist überschreitet das Timeoutintervall an.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> Methode, um alle Wörter, die in einem Satz zu identifizieren, die mit "es"endenden"endet.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches2.vb#2)]  
  
 Das Muster für reguläre Ausdrücke `\b\w+es\b` wird entsprechend der folgenden Tabelle definiert:  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\b`|Der Vergleich beginnt an einer Wortgrenze.|  
|`\w+`|Übereinstimmung mit mindestens einem Wortzeichen.|  
|`es`|Mit die literale Zeichenfolge ""es endenden"übereinstimmen.|  
|`\b`|Der Vergleich endet an einer Wortgrenze.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Diese Methode ein Timeout eintritt, nach einem bestimmten Zeitintervall, das den Standardtimeoutwert der Anwendungsdomäne gleich in welcher er aufgerufen wird. Wenn Sie ein Timeoutwert für die Anwendungsdomäne, die den Wert nicht definiert wurde <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, die die Methode ein Timeout eintritt, verhindert wird verwendet. Die empfohlene statische Methode für das Abrufen mehrerer Muster entspricht ist <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, dem Sie das Timeoutintervall angeben können.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <summary>Durchsucht die angegebene Eingabezeichenfolge unter Verwendung der angegebenen Übereinstimmungsoptionen nach allen Vorkommen des angegebenen regulären Ausdrucks.</summary>
        <returns>Eine Auflistung der im Suchvorgang gefundenen <see cref="T:System.Text.RegularExpressions.Match" />-Objekte. Wenn keine Übereinstimmungen gefunden werden, gibt die Methode ein leeres Auflistungsobjekt zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Methode ist vergleichbar mit der <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Methode, mit der Ausnahme, Informationen zu allen Übereinstimmungen zurückgegeben in der Eingabezeichenfolge, anstelle einer einzelnen Übereinstimmung gefunden. Dies entspricht dem folgenden Code:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#8)]  
  
 Die statische `Matches` Methoden sind gleichwertig, für das Erstellen einer <xref:System.Text.RegularExpressions.Regex> -Objekt mit dem angegebenen regulären Ausdrucksmuster und Aufrufen der Instanzmethode `Matches`.  
  
 Die `pattern` Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode verwendet verzögerten Auswertung zum Auffüllen der zurückgegebenen <xref:System.Text.RegularExpressions.MatchCollection> Objekt. Z. B. Zugriff auf Mitglieder dieser Sammlung <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> und <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> bewirkt, dass den Auflistung sofort aufgefüllt werden. Um verzögerte Auswertung nutzen zu können, sollten Sie die Auflistung durchlaufen, mit einem Konstrukt wie `foreach` in C# geschrieben und `For Each`...`Next` in Visual Basic.  
  
 Aufgrund der verzögerten Auswertung Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> Methode löst eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme. Allerdings wird die Ausnahme ausgelöst, wenn ein Vorgang ausgeführt wird, auf die <xref:System.Text.RegularExpressions.MatchCollection> Objekt, die von dieser Methode zurückgegeben wird, wenn ein Timeoutintervall, durch die Eigenschaft "REGEX_DEFAULT_MATCH_TIMEOUT" von der aktuellen Anwendungsdomäne und einen Abgleichsvorgang definiert ist überschreitet das Timeoutintervall an.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> Methode, um alle Wörter, die in einem Satz zu identifizieren, die in "es"endenden"endet, und ruft anschließend die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Methode zum Ausführen des Musters mit der Eingabezeichenfolge Groß-und Kleinschreibung unterschieden. Wie die Ausgabe zeigt, werden die beiden Methoden unterschiedliche Ergebnisse zurück.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches4.vb#4)]  
  
 Das Muster für reguläre Ausdrücke `\b\w+es\b` wird entsprechend der folgenden Tabelle definiert:  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\b`|Der Vergleich beginnt an einer Wortgrenze.|  
|`\w+`|Übereinstimmung mit mindestens einem Wortzeichen.|  
|`es`|Mit die literale Zeichenfolge ""es endenden"übereinstimmen.|  
|`\b`|Der Vergleich endet an einer Wortgrenze.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.</exception>
        <block subset="none" type="usage">
          <para>Diese Methode ein Timeout eintritt, nach einem bestimmten Zeitintervall, das den Standardtimeoutwert der Anwendungsdomäne gleich in welcher er aufgerufen wird. Wenn Sie ein Timeoutwert für die Anwendungsdomäne, die den Wert nicht definiert wurde <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, die die Methode ein Timeout eintritt, verhindert wird verwendet. Die empfohlene statische Methode für das Abrufen mehrerer Muster entspricht ist <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, und Sie können Sie das Timeoutintervall festgelegt.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <param name="matchTimeout">Ein Timeoutintervall oder <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das angibt, dass die Methode kein Timeout haben sollte.</param>
        <summary>Durchsucht die angegebene Eingabezeichenfolge unter Verwendung der angegebenen Übereinstimmungsoptionen und des angegebenen Timeoutintervalls nach allen Vorkommen des angegebenen regulären Ausdrucks.</summary>
        <returns>Eine Auflistung der im Suchvorgang gefundenen <see cref="T:System.Text.RegularExpressions.Match" />-Objekte. Wenn keine Übereinstimmungen gefunden werden, gibt die Methode ein leeres Auflistungsobjekt zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Methode ist vergleichbar mit der <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Methode, mit der Ausnahme, Informationen zu allen Übereinstimmungen zurückgegeben in der Eingabezeichenfolge, anstelle einer einzelnen Übereinstimmung gefunden. Dies entspricht dem folgenden Code:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#10)]  
  
 Die statische `Matches` Methoden sind gleichwertig, für das Erstellen einer <xref:System.Text.RegularExpressions.Regex> -Objekt mit dem angegebenen regulären Ausdrucksmuster und Aufrufen der Instanzmethode `Matches`.  
  
 Die `pattern` Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode verwendet verzögerten Auswertung zum Auffüllen der zurückgegebenen <xref:System.Text.RegularExpressions.MatchCollection> Objekt. Z. B. Zugriff auf Mitglieder dieser Sammlung <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> und <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> bewirkt, dass den Auflistung sofort aufgefüllt werden. Um verzögerte Auswertung nutzen zu können, sollten Sie die Auflistung durchlaufen, mit einem Konstrukt wie `foreach` in C# geschrieben und `For Each`...`Next` in Visual Basic.  
  
 Aufgrund der verzögerten Auswertung Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode löst eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme. Allerdings wird eine Ausnahme ausgelöst, wenn ein Vorgang ausgeführt wird, auf die <xref:System.Text.RegularExpressions.MatchCollection> Objekt, das von dieser Methode zurückgegeben wird, überschreitet eine Suche nach Übereinstimmungen mit diesem Timeoutintervall gemäß der`matchTimeout` Parameter.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Methode, um ein Groß-/ kleinschreibungsvergleich auszuführen, die mit einem beliebigen Wort in einem Satz übereinstimmt, die mit "es"endenden"endet. Er ruft dann die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Methode zum Ausführen des Musters mit der Eingabezeichenfolge Groß-und Kleinschreibung unterschieden. In beiden Fällen wird das Timeoutintervall auf eine Sekunde festgelegt. Wie die Ausgabe zeigt, werden die beiden Methoden unterschiedliche Ergebnisse zurück.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches5.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches5.vb#11)]  
  
 Das Muster für reguläre Ausdrücke `\b\w+es\b` wird entsprechend der folgenden Tabelle definiert:  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\b`|Der Vergleich beginnt an einer Wortgrenze.|  
|`\w+`|Übereinstimmung mit mindestens einem Wortzeichen.|  
|`es`|Mit die literale Zeichenfolge ""es endenden"übereinstimmen.|  
|`\b`|Der Vergleich endet an einer Wortgrenze.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.  Oder:  <paramref name="matchTimeout" /> ist negativ, null oder größer als ca. 24 Tage.</exception>
        <block subset="none" type="usage">
          <para>Es wird empfohlen, Sie legen die <paramref name="matchTimeout" /> Parameter auf einen geeigneten Wert, z. B. zwei Sekunden. Wenn Sie Timeouts durch Angabe deaktivieren <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das Modul für reguläre Ausdrücke bietet eine etwas bessere Leistung. Sie sollten jedoch deaktivieren, Timeouts nur unter folgenden Bedingungen:: Wenn die Eingabe verarbeitet, die von einem regulären Ausdruck aus einer bekannten und vertrauenswürdigen Quelle stammt oder statischer Text besteht. Dies schließt Text, der Eingaben von Benutzern dynamisch wurde.  – Wenn Sie Muster des regulären Ausdrucks gründlich getestet wurden, um sicherzustellen, dass er effizient verarbeitet übereinstimmt, nicht-Übereinstimmungen und Naher übereinstimmt.  – Wenn Muster für reguläre Ausdrücke keine Language-Elemente enthält, die bekanntermaßen dazu führen, dass eine übermäßige rückverfolgung, bei der Verarbeitung einer Nahen Übereinstimmung.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="MatchTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan MatchTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MatchTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MatchTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MatchTimeout { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Laufzeitintervall der aktuellen Instanz ab.</summary>
        <value>Das maximale Zeitintervall, das in einem Mustervergleichsvorgang verstreichen kann, bevor eine <see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" />-Ausnahme ausgelöst wird, oder <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, wenn Timeouts deaktiviert sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> Eigenschaft definiert die ungefähre maximale Zeitintervall für einen <xref:System.Text.RegularExpressions.Regex> Instanz ein einzelnes übereinstimmendes Vorgangs ausgeführt, bevor der Vorgang ein Timeout eintritt. Löst das Modul für reguläre Ausdrücke eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme während der nächsten Überprüfung der zeitlichen Steuerung nach Ablauf des Timeoutintervalls. Dadurch wird verhindert, dass das Modul für reguläre Ausdrücke, die eine übermäßige rückverfolgung erfordern Eingabezeichenfolgen verarbeiten. Weitere Informationen finden Sie unter [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md) und [bewährte Methoden für reguläre Ausdrücke](~/docs/standard/base-types/best-practices.md).  
  
 Diese Eigenschaft ist schreibgeschützt. Können legen Sie den Wert explizit für ein einzelnes <xref:System.Text.RegularExpressions.Regex> Objekt durch Aufrufen der <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor; und Sie können den Wert für alle festgelegt <xref:System.Text.RegularExpressions.Regex> Abgleichen von Vorgängen in einer Anwendungsdomäne durch Aufrufen der <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> Methode und das Bereitstellen einer <xref:System.TimeSpan> Wert für die Eigenschaft "REGEX_DEFAULT_MATCH_TIMEOUT", wie im folgenden Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/cs/regexmatchtimeout1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/vb/regexmatchtimeout1.vb#1)]  
  
 Wenn Sie ein Timeoutintervall, der Standardwert nicht explizit festgelegt <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> wird verwendet, und die entsprechenden Vorgänge Timeoutgrenze nicht.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.RegexOptions Options { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.RegularExpressions.RegexOptions Options" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Options" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Options As RegexOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::RegularExpressions::RegexOptions Options { System::Text::RegularExpressions::RegexOptions get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Optionen ab, die an den <see cref="T:System.Text.RegularExpressions.Regex" />-Konstruktor übergeben wurden.</summary>
        <value>Mindestens ein Member der <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Enumeration, der Optionen darstellt, die dem <see cref="T:System.Text.RegularExpressions.Regex" />-Konstruktor übergeben wurden</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert von der <xref:System.Text.RegularExpressions.Regex.Options%2A> Eigenschaft besteht aus mindestens Mitglied der <xref:System.Text.RegularExpressions.RegexOptions> Enumeration. Wenn keine Optionen, in definiert wurden der <xref:System.Text.RegularExpressions.Regex> Klassenkonstruktor, ihr Wert ist <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>. Die verfügbaren Optionen sind in im Detail besprochen der [Optionen für reguläre Ausdrücke](~/docs/standard/base-types/regular-expression-options.md) Thema.  
  
 Beachten Sie, dass die <xref:System.Text.RegularExpressions.Regex.Options%2A> -Eigenschaft reflektiert nicht die Inlineoptionen im regulären Ausdruck definiert Muster selbst.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> ist die Basisklasse von regulären Ausdrücken, die erstellt, indem die <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> Methode. Diese kompilierte reguläre Ausdrücke verwenden Sie die basisklassenimplementierung der <see cref="P:System.Text.RegularExpressions.Regex.Options" /> Eigenschaft. Bei einem Aufruf in einer abgeleiteten Klasse die <see cref="P:System.Text.RegularExpressions.Regex.Options" /> Eigenschaft gibt die Optionen, die übergeben wurden, die <paramref name="options" /> Parameter von der <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> Klassenkonstruktor, die mit den regulären Ausdruck definiert wurde.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="pattern">
      <MemberSignature Language="C#" Value="protected internal string pattern;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string pattern" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.pattern" />
      <MemberSignature Language="VB.NET" Value="Protected Friend pattern As String " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::String ^ pattern;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge die mit dem Muster für den regulären Ausdruck übereinstimmenden Zeichenfolgen durch eine angegebene Ersetzungszeichenfolge.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="replacement">Die Ersatzzeichenfolge.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge alle mit dem Muster für den regulären Ausdruck übereinstimmenden Zeichenfolgen durch eine angegebene Ersetzungszeichenfolge.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Die Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn keine Entsprechung für das reguläre Ausdrucksmuster in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche nach Übereinstimmungen beginnt, am Anfang der `input` Zeichenfolge. Der reguläre Ausdruck wird vom Konstruktor für den aktuellen definierten Muster <xref:System.Text.RegularExpressions.Regex> Objekt.  
  
 Die `replacement` Parameter gibt die Zeichenfolge, die jede Übereinstimmung in ersetzt `input`. `replacement` kann eine beliebige Kombination von literalen Text bestehen und [substitutionen](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Z. B. das Ersetzungsmuster `a*${test}b` fügt die Zeichenfolge "eine *" gefolgt von der Teilzeichenfolge, die durch die Übereinstimmung wird die `test` Erfassungsgruppe, ggf. gefolgt von der Zeichenfolge "b". Die * Zeichen wird nicht als Metazeichen in einem Ersetzungsmuster erkannt.  
  
> [!NOTE]
>  Ersetzungen sind die nur für reguläre Ausdrücke Sprachelemente, die in einem Ersetzungsmuster erkannt werden. Alle anderen Sprachelemente für reguläre Ausdrücke, einschließlich [Zeichen Escapezeichen](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sind in Mustern von regulären Ausdrücken nur zulässig und werden nicht in Ersetzungsmustern erkannt.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit der Ersetzung des Timeoutintervalls gemäß überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie ein anderes Timeoutintervall nicht festlegen, wenn Sie den Konstruktor aufrufen, wird die Ausnahme ausgelöst, wenn der Vorgang alle für die Anwendungsdomäne eingerichtet, in dem Timeoutwert überschreitet die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst  
  
 Da der Methodenrückgabe `input` unverändert, wenn keine Übereinstimmung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methode, um zu bestimmen, ob die Methode auf die Eingabezeichenfolge von Ersetzungen durchgeführt wurden.  
  
   
  
## Examples  
 Das folgende Beispiel definiert einen regulären Ausdruck `\s+`, eine oder mehrere Leerzeichen entspricht. Die Ersatzzeichenfolge "", durch ein einzelnes Leerzeichen ersetzt.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample5.vb#5)]  
  
 Das folgende Beispiel definiert einen regulären Ausdruck `(\p{Sc}\s?)?(\d+\.?((?<=\.)\d+)?)(?(1)|\s?\p{Sc})?`, auch ein Ersetzungsmuster `$2`, entfernt, die führende oder nachfolgende Währungssymbol aus einem numerischen Wert.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample7.vb#7)]  
  
 Der reguläre Ausdruck wird entsprechend der Darstellung in der folgenden Tabelle interpretiert.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\p{Sc}`|Übereinstimmung mit einem Währungssymbol. `{Sc}` Gibt alle Zeichen, die ein Mitglied der Unicode-Kategorie Symbol, Währung ist.|  
|`\s?`|Übereinstimmung mit keinem oder einem Leerzeichen.|  
|`(\p{Sc}\s?)?`|Übereinstimmung mit 0 (null) oder der Kombination aus ein Währungssymbol gefolgt von keinem oder einem Leerzeichen. Dies ist die erste Erfassungsgruppe.|  
|`\d+`|Entsprechung für mindestens eine Dezimalstelle finden.|  
|`\.?`|Übereinstimmung mit 0 (null) oder einem Vorkommen eines Punkts, der (als Dezimaltrennzeichenzeichen verwendet).|  
|`((?<=\.)\d+)?`|Wenn Sie ein Zeitraum auf das vorherige Zeichen ist, entsprechen Sie mindestens eine Dezimalstelle finden. Dieses Muster kann entweder nicht oder einmal zugeordnet werden.|  
|`(\d+\.?((?<=\.)\d+)?)`|Übereinstimmung mit dem Muster mindestens eine Dezimalstelle, gefolgt von einem optionalen Punkt und nachfolgende Dezimalziffern. Dies ist die zweite Erfassungsgruppe. Der Aufruf der <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29> -Methode die gesamte Übereinstimmung mit dem Wert, der diese erfasste Gruppe ersetzt.|  
|`(?(1)&#124;\s?\p{Sc})?`|Wenn die erste erfasste Gruppe vorhanden ist, entsprechen Sie eine leere Zeichenfolge. Andernfalls abgeglichen Sie 0 (null) oder einem Leerstellenzeichen gefolgt von einem Währungssymbol werden.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="replacement" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="evaluator">Eine benutzerdefinierte Methode, die jede Übereinstimmung überprüft und entweder die ursprüngliche entsprechende Zeichenfolge oder eine Ersatzzeichenfolge zurückgibt.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge alle mit einem angegebenen regulären Ausdruck übereinstimmenden Zeichenfolgen durch eine von einem <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />-Delegaten zurückgegebene Zeichenfolge.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Eine Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn keine Entsprechung für das reguläre Ausdrucksmuster in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> Methode eignet sich für die Übereinstimmung mit einem regulären Ausdruck ersetzt, wenn eine der folgenden Bedingungen zutrifft:  
  
-   Die Ersatzzeichenfolge kann nicht ohne weiteres von Ersatz-Muster eines regulären Ausdrucks angegeben werden.  
  
-   Die Ersetzungszeichenfolge ergibt sich aus der Verarbeitung auf die übereinstimmende Zeichenfolge.  
  
-   Die Ersetzungszeichenfolge ergibt sich aus bedingte Verarbeitung.  
  
 Die Methode entspricht dem Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> -Methode und übergeben jede <xref:System.Text.RegularExpressions.Match> Objekt im zurückgegebenen <xref:System.Text.RegularExpressions.MatchCollection> -Auflistung, um die `evaluator` delegieren.  
  
 Der reguläre Ausdruck wird vom Konstruktor für den aktuellen definierten Muster <xref:System.Text.RegularExpressions.Regex> Objekt.  
  
 Die `evaluator` Parameter wird der Delegat für eine benutzerdefinierte Methode, die Sie definieren und, die jede Übereinstimmung überprüft. Die benutzerdefinierte-Methode benötigen die folgende Signatur entsprechend der <xref:System.Text.RegularExpressions.MatchEvaluator> delegieren.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Die benutzerdefinierte Methode gibt eine Zeichenfolge, die die übereinstimmende Eingabe ersetzt.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit der Ersetzung des Timeoutintervalls gemäß überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie ein anderes Timeoutintervall nicht festlegen, wenn Sie den Konstruktor aufrufen, wird die Ausnahme ausgelöst, wenn der Vorgang alle für die Anwendungsdomäne eingerichtet, in dem Timeoutwert überschreitet die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst  
  
 Da der Methodenrückgabe `input` unverändert, wenn keine Übereinstimmung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methode, um zu bestimmen, ob die Methode auf die Eingabezeichenfolge von Ersetzungen durchgeführt wurden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine ursprüngliche Zeichenfolge zeigt, stimmt mit jedem Wort in der ursprünglichen Zeichenfolge, konvertiert das erste Zeichen der jede Übereinstimmung in Großbuchstaben, zeigt die konvertierte Zeichenfolge.  
  
 [!code-csharp[Regex.Replace-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Regex.Replace-Instance/cs/sample.cs#1)]
 [!code-vb[Regex.Replace-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex.Replace-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="evaluator" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="replacement">Die Ersatzzeichenfolge.</param>
        <param name="count">Die maximale Anzahl der Ersetzungen.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge eine angegebene Höchstanzahl von Zeichenfolgen, die mit dem Muster eines regulären Ausdrucks übereinstimmen, durch eine angegebene Ersetzungszeichenfolge.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Die Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn keine Entsprechung für das reguläre Ausdrucksmuster in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche nach Übereinstimmungen beginnt, am Anfang der `input` Zeichenfolge. Der reguläre Ausdruck ist das Muster, das durch den Konstruktor für den aktuellen definiert ist <xref:System.Text.RegularExpressions.Regex> Objekt. Wenn `count` negativ ist, Ersetzungen bis zum Ende der Zeichenfolge fortgesetzt. Wenn `count` überschreitet die Anzahl der Übereinstimmungen, die alle Übereinstimmungen werden ersetzt.  
  
 Die `replacement` Parameter gibt die Zeichenfolge, die die erste ersetzen `count` findet in `input`. `replacement` kann eine beliebige Kombination von literalen Text bestehen und [substitutionen](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Z. B. das Ersetzungsmuster `a*${test}b` fügt die Zeichenfolge "eine *" gefolgt von der Teilzeichenfolge, die durch die Übereinstimmung wird die `test` Erfassungsgruppe, ggf. gefolgt von der Zeichenfolge "b". Die * Zeichen wird nicht als Metazeichen in einem Ersetzungsmuster erkannt.  
  
> [!NOTE]
>  Ersetzungen sind die nur für reguläre Ausdrücke Sprachelemente, die in einem Ersetzungsmuster erkannt werden. Alle anderen Sprachelemente für reguläre Ausdrücke, einschließlich [Zeichen Escapezeichen](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sind in Mustern von regulären Ausdrücken nur zulässig und werden nicht in Ersetzungsmustern erkannt.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit der Ersetzung des Timeoutintervalls gemäß überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie ein anderes Timeoutintervall nicht festlegen, wenn Sie den Konstruktor aufrufen, wird die Ausnahme ausgelöst, wenn der Vorgang alle für die Anwendungsdomäne eingerichtet, in dem Timeoutwert überschreitet die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst  
  
 Da der Methodenrückgabe `input` unverändert, wenn keine Übereinstimmung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methode, um zu bestimmen, ob die Methode auf die Eingabezeichenfolge von Ersetzungen durchgeführt wurden.  
  
   
  
## Examples  
 Im folgende Beispiel ersetzt die ersten fünf Vorkommen eines duplizierten Zeichen durch ein einzelnes Zeichen. Muster für reguläre Ausdrücke `(\w)\1` aufeinander folgenden Vorkommen eines einzelnen Zeichens und weist das erste Vorkommen der ersten Erfassungsgruppe. Das Ersetzungsmuster `$1` ersetzt die gesamte Übereinstimmung mit der ersten erfassten Gruppe.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample8.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="replacement" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="replacement">Die Ersatzzeichenfolge.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge alle mit einem angegebenen regulären Ausdruck übereinstimmenden Zeichenfolgen durch eine angegebene Ersetzungszeichenfolge.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Die Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn für <paramref name="pattern" /> keine Übereinstimmung in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die statische `Replace` Methoden sind gleichwertig, für das Erstellen einer <xref:System.Text.RegularExpressions.Regex> -Objekt mit dem angegebenen regulären Ausdrucksmuster und Aufrufen der Instanzmethode `Replace`.  
  
 Die `pattern` Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Die Suche nach Übereinstimmungen beginnt, am Anfang der `input` Zeichenfolge.  
  
 Die `replacement` Parameter gibt die Zeichenfolge, die jede Übereinstimmung in ersetzt `input`. `replacement` kann eine beliebige Kombination von literalen Text bestehen und [substitutionen](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Z. B. das Ersetzungsmuster `a*${test}b` fügt die Zeichenfolge "eine *" gefolgt von der Teilzeichenfolge, die durch die Übereinstimmung wird die `test` Erfassungsgruppe, ggf. gefolgt von der Zeichenfolge "b". Die * Zeichen wird nicht als Metazeichen in einem Ersetzungsmuster erkannt.  
  
> [!NOTE]
>  Ersetzungen sind die nur für reguläre Ausdrücke Sprachelemente, die in einem Ersetzungsmuster erkannt werden. Alle anderen Sprachelemente für reguläre Ausdrücke, einschließlich [Zeichen Escapezeichen](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sind in Mustern von regulären Ausdrücken nur zulässig und werden nicht in Ersetzungsmustern erkannt.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit der Ersetzung überschreitet das Timeoutintervall angegeben, für die Anwendungsdomäne, in dem die Methode aufgerufen wird. Wenn kein Timeout erfolgt in der Anwendungsdomäne Eigenschaften definiert ist, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
 Da der Methodenrückgabe `input` unverändert, wenn keine Übereinstimmung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methode, um zu bestimmen, ob die Methode auf die Eingabezeichenfolge von Ersetzungen durchgeführt wurden.  
  
   
  
## Examples  
 Das folgende Beispiel definiert einen regulären Ausdruck `\s+`, eine oder mehrere Leerzeichen entspricht. Die Ersatzzeichenfolge "", durch ein einzelnes Leerzeichen ersetzt.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample6.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample6.vb#6)]  
  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> Methode, um die lokalen Computer und Laufwerk Namen in einem UNC-Pfad durch einen lokalen Pfad ersetzen. Der reguläre Ausdruck verwendet die <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> Eigenschaft, um den Namen des lokalen Computers einzuschließen und die <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> Methode, um den Namen der logischen Laufwerke enthalten. Um das Beispiel erfolgreich ausgeführt wird, sollten Sie die Literalzeichenfolge "MeinComputer" durch den Namen des lokalen Computers ersetzen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace3.vb#3)]  
  
 Das Muster eines regulären Ausdrucks wird durch den folgenden Ausdruck definiert:  
  
 `"\\\\(?i:" + Environment.MachineName + ")(?:\.\w+)*\\((?i:[" + driveNames + "]))\$"`  
  
 Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\\\\`|Entspricht zwei aufeinander folgende umgekehrte Schrägstrich (`\`) Zeichen. Da der umgekehrte Schrägstrich als Escapezeichen interpretiert wird, muss jeder umgekehrte Schrägstrich mit einem weiteren umgekehrten Schrägstrich mit Escapezeichen versehen werden.|  
|`(?i:" + Environment.MachineName + ")`|Führen Sie eine Groß-/Kleinschreibung Übereinstimmung der Zeichenfolge, die von zurückgegeben wird die <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> Eigenschaft.|  
|`(?:\.\w+)*`|Übereinstimmung mit den Punkt (`.`) Zeichen, gefolgt von mindestens einem Wortzeichen. Dieser Vergleich kann keine oder mehrmalige erfolgen. Der übereinstimmende Teilausdruck nicht erfasst.|  
|`\\`|Entsprechen einen umgekehrten Schrägstrich (`\`) Zeichen.|  
|`((?i:[" + driveNames + "]))`|Führen Sie eine Groß-/Kleinschreibung Übereinstimmung mit der die Zeichenklasse, aus die die einzelnen Laufwerken beachtende besteht. Dieser entspricht der ersten erfassten Teilausdrucks.|  
|`\$`|Entspricht das Dollarzeichen (`$`) Zeichen.|  
  
 Das Ersetzungsmuster `$1` ersetzt die gesamte Übereinstimmung mit der ersten erfassten Teilausdrucks. D. h., wird der UNC-Computer und Laufwerk Name mit dem Laufwerkbuchstaben ersetzt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> oder <paramref name="replacement" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage">
          <para>Diese Methode ein Timeout eintritt, nach einem bestimmten Zeitintervall, das den Standardtimeoutwert der Anwendungsdomäne gleich in welcher er aufgerufen wird. Wenn Sie ein Timeoutwert für die Anwendungsdomäne, die den Wert nicht definiert wurde <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, die die Methode ein Timeout eintritt, verhindert wird verwendet. Ist die empfohlene statische Methode zum Ersetzen einer Musterübereinstimmung <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, und Sie können Sie das Timeoutintervall festgelegt.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="evaluator">Eine benutzerdefinierte Methode, die jede Übereinstimmung überprüft und entweder die ursprüngliche entsprechende Zeichenfolge oder eine Ersatzzeichenfolge zurückgibt.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge alle mit einem angegebenen regulären Ausdruck übereinstimmenden Zeichenfolgen durch eine von einem <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />-Delegaten zurückgegebene Zeichenfolge.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Eine Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn für <paramref name="pattern" /> keine Übereinstimmung in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> Methode eignet sich für die Übereinstimmung mit einem regulären Ausdruck ersetzt, wenn eine der folgenden Bedingungen zutrifft:  
  
-   Die Ersatzzeichenfolge kann nicht ohne weiteres von Ersatz-Muster eines regulären Ausdrucks angegeben werden.  
  
-   Die Ersetzungszeichenfolge ergibt sich aus der Verarbeitung auf die übereinstimmende Zeichenfolge.  
  
-   Die Ersetzungszeichenfolge ergibt sich aus bedingte Verarbeitung.  
  
 Die Methode entspricht dem Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> -Methode und übergeben jede <xref:System.Text.RegularExpressions.Match> Objekt im zurückgegebenen <xref:System.Text.RegularExpressions.MatchCollection> -Auflistung, um die `evaluator` delegieren.  
  
 Die `pattern` Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die `evaluator` Parameter wird der Delegat für eine benutzerdefinierte Methode, die Sie definieren und, die jede Übereinstimmung überprüft. Die benutzerdefinierte-Methode benötigen die folgende Signatur entsprechend der <xref:System.Text.RegularExpressions.MatchEvaluator> delegieren.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Die benutzerdefinierte Methode gibt eine Zeichenfolge, die die übereinstimmende Eingabe ersetzt.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit der Ersetzung überschreitet das Timeoutintervall angegeben, für die Anwendungsdomäne, in dem die Methode aufgerufen wird. Wenn kein Timeout erfolgt in der Anwendungsdomäne Eigenschaften definiert ist, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
 Da der Methodenrückgabe `input` unverändert, wenn keine Übereinstimmung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methode, um zu bestimmen, ob die Methode auf die Eingabezeichenfolge von Ersetzungen durchgeführt wurden.  
  
   
  
## Examples  
 Im folgende Beispiel wird einen regulären Ausdruck verwendet wird, um einzelne Wörter aus einer Zeichenfolge zu extrahieren und verwendet dann eine <xref:System.Text.RegularExpressions.MatchEvaluator> Delegaten aufrufen eine Methode mit dem Namen `WordScramble` , die die einzelnen Buchstaben im Wort verschlüsselt. Hierzu die `WordScramble` Methode erstellt ein Array mit den Zeichen in der Übereinstimmung zurück. Außerdem wird ein paralleles Array, das es füllt mit zufällige Gleitkommazahlen erstellt. Die Arrays werden sortiert, durch Aufrufen der <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> -Methode und das sortierte Array wird bereitgestellt, als Argument an einen <xref:System.String> Klassenkonstruktor. Diese neu erstellte Zeichenfolge wird zurückgegeben, durch die `WordScramble` Methode. Muster für reguläre Ausdrücke `\w+` entspricht mindestens einem Wortzeichen; das Modul für reguläre Ausdrücke wird weiterhin der Übereinstimmung Zeichen hinzugefügt, bis er erkennt, dass ein Nichtwortzeichen, z. B. ein Leerzeichen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace5.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace5.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> oder <paramref name="evaluator" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage">
          <para>Diese Methode ein Timeout eintritt, nach einem bestimmten Zeitintervall, das den Standardtimeoutwert der Anwendungsdomäne gleich in welcher er aufgerufen wird. Wenn Sie ein Timeoutwert für die Anwendungsdomäne, die den Wert nicht definiert wurde <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, die die Methode ein Timeout eintritt, verhindert wird verwendet. Die empfohlene statische Methode zum Auswerten und Ersetzen einen Mustervergleich ist <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, und Sie können Sie das Timeoutintervall festgelegt.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="evaluator">Eine benutzerdefinierte Methode, die jede Übereinstimmung überprüft und entweder die ursprüngliche entsprechende Zeichenfolge oder eine Ersatzzeichenfolge zurückgibt.</param>
        <param name="count">Die maximale Anzahl der Ersetzungen.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge eine angegebene Höchstanzahl von Zeichenfolgen, die mit dem Muster eines regulären Ausdrucks übereinstimmen, durch eine von einem <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />-Delegaten zurückgegebene Zeichenfolge.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Eine Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn keine Entsprechung für das reguläre Ausdrucksmuster in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType> Methode eignet sich für die Übereinstimmung mit einem regulären Ausdruck ersetzt, wenn eine der folgenden Bedingungen zutrifft:  
  
-   Die Ersatzzeichenfolge kann nicht ohne weiteres von Ersatz-Muster eines regulären Ausdrucks angegeben werden.  
  
-   Die Ersetzungszeichenfolge ergibt sich aus der Verarbeitung auf die übereinstimmende Zeichenfolge.  
  
-   Die Ersetzungszeichenfolge ergibt sich aus bedingte Verarbeitung.  
  
 Die Methode entspricht dem Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> -Methode und übergeben die erste `count` <xref:System.Text.RegularExpressions.Match> Objekte in der zurückgegebenen <xref:System.Text.RegularExpressions.MatchCollection> -Auflistung, um die `evaluator` delegieren.  
  
 Der reguläre Ausdruck wird vom Konstruktor für den aktuellen definierten Muster <xref:System.Text.RegularExpressions.Regex> Objekt.  
  
 Die `evaluator` Parameter wird der Delegat für eine benutzerdefinierte Methode, die Sie definieren und, die jede Übereinstimmung überprüft. Die benutzerdefinierte-Methode benötigen die folgende Signatur entsprechend der <xref:System.Text.RegularExpressions.MatchEvaluator> delegieren.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Die benutzerdefinierte Methode gibt eine Zeichenfolge, die die übereinstimmende Eingabe ersetzt.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit der Ersetzung des Timeoutintervalls gemäß überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie ein anderes Timeoutintervall nicht festlegen, wenn Sie den Konstruktor aufrufen, wird die Ausnahme ausgelöst, wenn der Vorgang alle für die Anwendungsdomäne eingerichtet, in dem Timeoutwert überschreitet die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst  
  
 Da der Methodenrückgabe `input` unverändert, wenn keine Übereinstimmung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methode, um zu bestimmen, ob die Methode auf die Eingabezeichenfolge von Ersetzungen durchgeführt wurden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird einen regulären Ausdruck, auf die Hälfte der Wörter in einer Liste absichtlich richtig geschrieben. Er verwendet den regulären Ausdruck `\w*(ie|ei)\w*` nach Wörtern, die die Zeichen "ie" oder "Ei" enthalten. Übergibt der erste Hälfte der Wörter die `ReverseLetter` -Methode, die wiederum die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Methode "i" und "e" in die entsprechende Zeichenfolge Reihenfolge umgekehrt werden soll. Die verbleibenden Wörter bleiben unverändert.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace7.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace7.vb#11)]  
  
 Der reguläre Ausdruck `\w*(ie|ei)\w*` wird entsprechend der Darstellung in der folgenden Tabelle definiert:  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\w*`|Übereinstimmung mit keinem oder mehreren Wortzeichen.|  
|`(ie&#124;ei)`|Übereinstimmung mit entweder "ie" oder "Ei".|  
|`\w*`|Übereinstimmung mit keinem oder mehreren Wortzeichen.|  
  
 Muster für reguläre Ausdrücke `([ie])([ie])` in die `ReverseLetter` Methode entspricht der ersten "i" oder "e" im Diphthong "ie" oder "Ei" und weist Sie den Buchstaben, um die erste Erfassungsgruppe. Sie entspricht dem zweiten "i" oder "e" und weist den Buchstaben, die zweite Erfassungsgruppe. Die zwei Zeichen werden dann umgekehrt, durch Aufrufen der <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> Methode mit dem Ersetzungsmuster `$2$1`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="evaluator" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="replacement">Die Ersatzzeichenfolge.</param>
        <param name="count">Die maximale Anzahl der Ersetzungen.</param>
        <param name="startat">Die Zeichenposition in der Eingabezeichenfolge, an der mit der Suche begonnen wird.</param>
        <summary>Ersetzt in einer angegebenen Eingabeteilzeichenfolge eine angegebene Höchstanzahl von Zeichenfolgen, die mit dem Muster eines regulären Ausdrucks übereinstimmen, durch eine angegebene Ersetzungszeichenfolge.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Die Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn keine Entsprechung für das reguläre Ausdrucksmuster in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche nach Übereinstimmungen beginnt, der `input` Zeichenfolge an der Position, die gemäß der `startat` Parameter. Der reguläre Ausdruck wird vom Konstruktor für den aktuellen definierten Muster <xref:System.Text.RegularExpressions.Regex> Objekt. Wenn `count` negativ ist, Ersetzungen bis zum Ende der Zeichenfolge fortgesetzt. Wenn `count` überschreitet die Anzahl der Übereinstimmungen, die alle Übereinstimmungen werden ersetzt.  
  
 Die `replacement` Parameter gibt die Zeichenfolge, die jede Übereinstimmung in ersetzt `input`. `replacement` kann eine beliebige Kombination von literalen Text bestehen und [substitutionen](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Z. B. das Ersetzungsmuster `a*${test}b` fügt die Zeichenfolge "eine *" gefolgt von der Teilzeichenfolge, die durch die Übereinstimmung wird die `test` Erfassungsgruppe, ggf. gefolgt von der Zeichenfolge "b". Die * Zeichen wird nicht als Metazeichen in einem Ersetzungsmuster erkannt.  
  
> [!NOTE]
>  Ersetzungen sind die nur für reguläre Ausdrücke Sprachelemente, die in einem Ersetzungsmuster erkannt werden. Alle anderen Sprachelemente für reguläre Ausdrücke, einschließlich [Zeichen Escapezeichen](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sind in Mustern von regulären Ausdrücken nur zulässig und werden nicht in Ersetzungsmustern erkannt.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit der Ersetzung des Timeoutintervalls gemäß überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie ein anderes Timeoutintervall nicht festlegen, wenn Sie den Konstruktor aufrufen, wird die Ausnahme ausgelöst, wenn der Vorgang alle für die Anwendungsdomäne eingerichtet, in dem Timeoutwert überschreitet die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst  
  
 Da der Methodenrückgabe `input` unverändert, wenn keine Übereinstimmung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methode, um zu bestimmen, ob die Methode auf die Eingabezeichenfolge von Ersetzungen durchgeführt wurden.  
  
   
  
## Examples  
 Im folgende Beispiel werden doppeltem Zeilenabstand formatiert alle außer der ersten Zeile einer Zeichenfolge. Definiert ein Muster für reguläre Ausdrücke `^.*$`, entspricht eine Zeile des Texts, ruft der <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> Methode entsprechend die erste Zeile der Zeichenfolge ein, und verwendet die `Match.Index` und `Match.Count` Eigenschaften, um zu bestimmen, die Anfangsposition des zweiten Zeile.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample9.vb#9)]  
  
 Das Muster für reguläre Ausdrücke `^.*$` wird entsprechend der folgenden Tabelle definiert:  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`^`|Übereinstimmung mit dem Anfang einer Zeile. (Beachten Sie, dass die <xref:System.Text.RegularExpressions.Regex> Objekt instanziiert wurde, mithilfe der <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option; andernfalls würde diese Zeichenklasse nur Anfang der Eingabezeichenfolge abgeglichen.)|  
|`.*`|Übereinstimmung mit beliebigem Zeichen 0 oder mehr Vorkommen.|  
|`$`|Übereinstimmung mit dem Ende einer Zeile aus. (Beachten Sie, dass die <xref:System.Text.RegularExpressions.Regex> Objekt instanziiert wurde, mithilfe der <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option; andernfalls würde diese Zeichenklasse nur Anfang der Eingabezeichenfolge abgeglichen.)|  
  
 Die Ersatzzeichenfolge (`vbCrLf + "$&"` in Visual Basic `"\n$&"` in c#) Fügt eine neue Zeile vor der übereinstimmenden Zeichenfolge. Beachten Sie, dass `\n` C#-Beispiel als neue Zeilenumbruchzeichen vom C#-Compiler interpretiert wird; es ist eine reguläre-Escape-Zeichen dar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="replacement" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> ist kleiner als 0 (null) oder größer als die Länge von <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="replacement">Die Ersatzzeichenfolge.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge alle mit einem angegebenen regulären Ausdruck übereinstimmenden Zeichenfolgen durch eine angegebene Ersetzungszeichenfolge. Durch angegebene Optionen wird die Suche nach Übereinstimmungen geändert.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Die Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn für <paramref name="pattern" /> keine Übereinstimmung in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die statische `Replace` Methoden sind gleichwertig, für das Erstellen einer <xref:System.Text.RegularExpressions.Regex> -Objekt mit dem angegebenen regulären Ausdrucksmuster und Aufrufen der Instanzmethode `Replace`.  
  
 Die `pattern` Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Bei Angabe von <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> für die `options` Parameter, die Suche nach Übereinstimmungen am Ende der Eingabezeichenfolge beginnt und bewegt sich nach links; andernfalls, die Suche beginnt am Anfang der Eingabezeichenfolge und wird nach rechts verschoben.  
  
 Die `replacement` Parameter gibt die Zeichenfolge, die jede Übereinstimmung in ersetzt `input`. `replacement` kann eine beliebige Kombination von literalen Text bestehen und [substitutionen](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Z. B. das Ersetzungsmuster `a*${test}b` fügt die Zeichenfolge "eine *" gefolgt von der Teilzeichenfolge, die durch die Übereinstimmung wird die `test` Erfassungsgruppe, ggf. gefolgt von der Zeichenfolge "b". Die * Zeichen wird nicht als Metazeichen in einem Ersetzungsmuster erkannt.  
  
> [!NOTE]
>  Ersetzungen sind die nur für reguläre Ausdrücke Sprachelemente, die in einem Ersetzungsmuster erkannt werden. Alle anderen Sprachelemente für reguläre Ausdrücke, einschließlich [Zeichen Escapezeichen](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sind in Mustern von regulären Ausdrücken nur zulässig und werden nicht in Ersetzungsmustern erkannt.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit der Ersetzung überschreitet das Timeoutintervall angegeben, für die Anwendungsdomäne, in dem die Methode aufgerufen wird. Wenn kein Timeout erfolgt in der Anwendungsdomäne Eigenschaften definiert ist, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
 Da der Methodenrückgabe `input` unverändert, wenn keine Übereinstimmung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methode, um zu bestimmen, ob die Methode auf die Eingabezeichenfolge von Ersetzungen durchgeführt wurden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Methode, um die lokalen Computer und Laufwerk Namen in einem UNC-Pfad durch einen lokalen Pfad ersetzen. Der reguläre Ausdruck verwendet die <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> Eigenschaft, um den Namen des lokalen Computers einzuschließen und die <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> Methode, um den Namen der logischen Laufwerke enthalten. Alle regulären Ausdruck Zeichenfolgenvergleiche Groß-/Kleinschreibung unterschieden. Um das Beispiel erfolgreich ausgeführt wird, sollten Sie die Literalzeichenfolge "MeinComputer" durch den Namen des lokalen Computers ersetzen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace4.vb#4)]  
  
 Das Muster eines regulären Ausdrucks wird durch den folgenden Ausdruck definiert:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\\\\`|Entspricht zwei aufeinander folgende umgekehrte Schrägstrich (`\`) Zeichen. Da der umgekehrte Schrägstrich als Escapezeichen interpretiert wird, muss jeder umgekehrte Schrägstrich mit einem weiteren umgekehrten Schrägstrich mit Escapezeichen versehen werden.|  
|`+ Environment.MachineName +`|Übereinstimmung mit der Zeichenfolge, die von zurückgegeben wird die <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> Eigenschaft.|  
|`(?:\.\w+)*`|Übereinstimmung mit den Punkt (`.`) Zeichen, gefolgt von mindestens einem Wortzeichen. Dieser Vergleich kann keine oder mehrmalige erfolgen. Der übereinstimmende Teilausdruck nicht erfasst.|  
|`\\`|Entsprechen einen umgekehrten Schrägstrich (`\`) Zeichen.|  
|`([" + driveNames + "])`|Übereinstimmung mit die Zeichenklasse, aus die die einzelnen Laufwerkbuchstaben besteht. Dieser entspricht der ersten erfassten Teilausdrucks.|  
|`\$`|Entspricht das Dollarzeichen (`$`) Zeichen.|  
  
 Das Ersetzungsmuster `$1` ersetzt die gesamte Übereinstimmung mit der ersten erfassten Teilausdrucks. D. h., wird der UNC-Computer und Laufwerk Name mit dem Laufwerkbuchstaben ersetzt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> oder <paramref name="replacement" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage">
          <para>Diese Methode ein Timeout eintritt, nach einem bestimmten Zeitintervall, das den Standardtimeoutwert der Anwendungsdomäne gleich in welcher er aufgerufen wird. Wenn Sie ein Timeoutwert für die Anwendungsdomäne, die den Wert nicht definiert wurde <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, die die Methode ein Timeout eintritt, verhindert wird verwendet. Ist die empfohlene statische Methode zum Ersetzen einer Musterübereinstimmung <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, und Sie können Sie das Timeoutintervall festgelegt.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="evaluator">Eine benutzerdefinierte Methode, die jede Übereinstimmung überprüft und entweder die ursprüngliche entsprechende Zeichenfolge oder eine Ersatzzeichenfolge zurückgibt.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge alle mit einem angegebenen regulären Ausdruck übereinstimmenden Zeichenfolgen durch eine von einem <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />-Delegaten zurückgegebene Zeichenfolge. Durch angegebene Optionen wird die Suche nach Übereinstimmungen geändert.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Eine Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn für <paramref name="pattern" /> keine Übereinstimmung in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> Methode eignet sich für die Übereinstimmung eines regulären Ausdrucks in ersetzen, wenn eine der folgenden Bedingungen zutrifft:  
  
-   Die Ersatzzeichenfolge kann nicht ohne weiteres von Ersatz-Muster eines regulären Ausdrucks angegeben werden.  
  
-   Die Ersetzungszeichenfolge ergibt sich aus der Verarbeitung auf die übereinstimmende Zeichenfolge.  
  
-   Die Ersetzungszeichenfolge ergibt sich aus bedingte Verarbeitung.  
  
 Die Methode entspricht dem Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> -Methode und übergeben jede <xref:System.Text.RegularExpressions.Match> Objekt im zurückgegebenen <xref:System.Text.RegularExpressions.MatchCollection> -Auflistung, um die `evaluator` delegieren.  
  
 Die `pattern` Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die `evaluator` Parameter wird der Delegat für eine benutzerdefinierte Methode, die Sie definieren und, die jede Übereinstimmung überprüft. Die benutzerdefinierte-Methode benötigen die folgende Signatur entsprechend der <xref:System.Text.RegularExpressions.MatchEvaluator> delegieren.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Die benutzerdefinierte Methode gibt eine Zeichenfolge, die die übereinstimmende Eingabe ersetzt.  
  
 Bei Angabe von <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> für die `options` Parameter, die Suche nach Übereinstimmungen am Ende der Eingabezeichenfolge beginnt und bewegt sich nach links; andernfalls, die Suche beginnt am Anfang der Eingabezeichenfolge und wird nach rechts verschoben.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit der Ersetzung überschreitet das Timeoutintervall angegeben, für die Anwendungsdomäne, in dem die Methode aufgerufen wird. Wenn kein Timeout erfolgt in der Anwendungsdomäne Eigenschaften definiert ist, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
 Da der Methodenrückgabe `input` unverändert, wenn keine Übereinstimmung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methode, um zu bestimmen, ob die Methode auf die Eingabezeichenfolge von Ersetzungen durchgeführt wurden.  
  
   
  
## Examples  
 Im folgende Beispiel wird einen regulären Ausdruck verwendet wird, um einzelne Wörter aus einer Zeichenfolge zu extrahieren und verwendet dann eine <xref:System.Text.RegularExpressions.MatchEvaluator> Delegaten aufrufen eine Methode mit dem Namen `WordScramble` , die die einzelnen Buchstaben im Wort verschlüsselt. Hierzu die `WordScramble` Methode erstellt ein Array mit den Zeichen in der Übereinstimmung zurück. Außerdem wird ein paralleles Array, das es füllt mit zufällige Gleitkommazahlen erstellt. Die Arrays werden sortiert, durch Aufrufen der <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> -Methode und das sortierte Array wird bereitgestellt, als Argument an einen <xref:System.String> Klassenkonstruktor. Diese neu erstellte Zeichenfolge wird zurückgegeben, durch die `WordScramble` Methode. Muster für reguläre Ausdrücke `\w+` entspricht mindestens einem Wortzeichen; das Modul für reguläre Ausdrücke wird weiterhin der Übereinstimmung Zeichen hinzugefügt, bis er erkennt, dass ein Nichtwortzeichen, z. B. ein Leerzeichen. Der Aufruf von der <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> Methode enthält die <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> Option, damit der Kommentar im Muster regulären Ausdrucks `\w+  # Matches all the characters in a word.` wird vom Modul für reguläre Ausdrücke ignoriert.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace6.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace6.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> oder <paramref name="evaluator" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="evaluator">Eine benutzerdefinierte Methode, die jede Übereinstimmung überprüft und entweder die ursprüngliche entsprechende Zeichenfolge oder eine Ersatzzeichenfolge zurückgibt.</param>
        <param name="count">Die maximale Anzahl der Ersetzungen.</param>
        <param name="startat">Die Zeichenposition in der Eingabezeichenfolge, an der mit der Suche begonnen wird.</param>
        <summary>Ersetzt in einer angegebenen Eingabeteilzeichenfolge eine angegebene Höchstanzahl von Zeichenfolgen, die mit dem Muster eines regulären Ausdrucks übereinstimmen, durch eine von einem <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />-Delegaten zurückgegebene Zeichenfolge.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Eine Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn keine Entsprechung für das reguläre Ausdrucksmuster in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Methode eignet sich für die Übereinstimmung mit einem regulären Ausdruck ersetzt, wenn eine der folgenden Bedingungen zutrifft:  
  
-   Die Ersatzzeichenfolge kann nicht ohne weiteres von Ersatz-Muster eines regulären Ausdrucks angegeben werden.  
  
-   Die Ersetzungszeichenfolge ergibt sich aus der Verarbeitung auf die übereinstimmende Zeichenfolge.  
  
-   Die Ersetzungszeichenfolge ergibt sich aus bedingte Verarbeitung.  
  
 Die Methode entspricht dem Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> -Methode und übergeben die erste `count` <xref:System.Text.RegularExpressions.Match> Objekte in der zurückgegebenen <xref:System.Text.RegularExpressions.MatchCollection> -Auflistung, um die `evaluator` delegieren.  
  
 Der reguläre Ausdruck wird vom Konstruktor für den aktuellen definierten Muster <xref:System.Text.RegularExpressions.Regex> Objekt.  
  
 Die `evaluator` Parameter wird der Delegat für eine benutzerdefinierte Methode, die Sie definieren und, die jede Übereinstimmung überprüft. Die benutzerdefinierte-Methode benötigen die folgende Signatur entsprechend der <xref:System.Text.RegularExpressions.MatchEvaluator> delegieren.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Die benutzerdefinierte Methode gibt eine Zeichenfolge, die die übereinstimmende Eingabe ersetzt.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit der Ersetzung des Timeoutintervalls gemäß überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie ein anderes Timeoutintervall nicht festlegen, wenn Sie den Konstruktor aufrufen, wird die Ausnahme ausgelöst, wenn der Vorgang alle für die Anwendungsdomäne eingerichtet, in dem Timeoutwert überschreitet die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst  
  
 Da der Methodenrückgabe `input` unverändert, wenn keine Übereinstimmung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methode, um zu bestimmen, ob die Methode auf die Eingabezeichenfolge von Ersetzungen durchgeführt wurden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="evaluator" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> ist kleiner als 0 (null) oder größer als die Länge von <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="replacement">Die Ersatzzeichenfolge.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <param name="matchTimeout">Ein Timeoutintervall oder <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das angibt, dass die Methode kein Timeout haben sollte.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge alle mit einem angegebenen regulären Ausdruck übereinstimmenden Zeichenfolgen durch eine angegebene Ersetzungszeichenfolge. Zusätzliche Parameter geben die Optionen an, die den entsprechenden Vorgang und ein Timeoutintervall ändern, wenn keine Übereinstimmung gefunden wird.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Die Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn für <paramref name="pattern" /> keine Übereinstimmung in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die statische `Replace` Methoden sind gleichwertig, für das Erstellen einer <xref:System.Text.RegularExpressions.Regex> -Objekt mit dem angegebenen regulären Ausdrucksmuster und Aufrufen der Instanzmethode `Replace`.  
  
 Die `pattern` Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Bei Angabe von <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> für die `options` Parameter, die Suche nach Übereinstimmungen am Ende der Eingabezeichenfolge beginnt und bewegt sich nach links; andernfalls, die Suche beginnt am Anfang der Eingabezeichenfolge und wird nach rechts verschoben.  
  
 Die `replacement` Parameter gibt die Zeichenfolge, die jede Übereinstimmung in ersetzt `input`. `replacement` kann eine beliebige Kombination von literalen Text bestehen und [substitutionen](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Z. B. das Ersetzungsmuster `a*${test}b` fügt die Zeichenfolge "eine *" gefolgt von der Teilzeichenfolge, die durch die Übereinstimmung wird die `test` Erfassungsgruppe, ggf. gefolgt von der Zeichenfolge "b". Die * Zeichen wird nicht als Metazeichen in einem Ersetzungsmuster erkannt.  
  
> [!NOTE]
>  Ersetzungen sind die nur für reguläre Ausdrücke Sprachelemente, die in einem Ersetzungsmuster erkannt werden. Alle anderen Sprachelemente für reguläre Ausdrücke, einschließlich [Zeichen Escapezeichen](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sind in Mustern von regulären Ausdrücken nur zulässig und werden nicht in Ersetzungsmustern erkannt.  
  
 Die `matchTimeout` Parameter gibt an, wie lange eine Mustervergleich Methode sollten versuchen, eine Übereinstimmung zu finden, bevor ein Timeout eintritt. Ein Timeoutintervall Einstellung wird verhindert, dass reguläre Ausdrücken, die übermäßige rückverfolgung nicht angezeigt wird, nicht mehr reagiert, wenn diese Eingaben verarbeiten, die in der Nähe von Übereinstimmungen enthält. Weitere Informationen finden Sie unter [bewährte Methoden für reguläre Ausdrücke](~/docs/standard/base-types/best-practices.md) und [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Wenn in diesem Zeitraum keine Übereinstimmung gefunden wird, löst die Methode eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme. `matchTimeout` überschreibt alle Standard-Timeoutwert definiert, die für die Anwendungsdomäne, in der die Methode ausgeführt wird.  
  
 Da der Methodenrückgabe `input` unverändert, wenn keine Übereinstimmung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methode, um zu bestimmen, ob die Methode auf die Eingabezeichenfolge von Ersetzungen durchgeführt wurden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Methode, um die lokalen Computer und Laufwerk Namen in einem UNC-Pfad durch einen lokalen Pfad ersetzen. Der reguläre Ausdruck verwendet die <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> Eigenschaft, um den Namen des lokalen Computers einzuschließen und die <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> Methode, um den Namen der logischen Laufwerke enthalten. Alle regulären Ausdruck Zeichenfolgenvergleiche Groß-/Kleinschreibung unterschieden, und jeder einzelnen Ersetzungsvorgang ein Timeout auftritt, wenn eine Übereinstimmung in 0,5 Sekunden gefunden werden kann. Um das Beispiel erfolgreich ausgeführt wird, sollten Sie die Literalzeichenfolge "MeinComputer" durch den Namen des lokalen Computers ersetzen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace12.cs#12)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace12.vb#12)]  
  
 Das Muster eines regulären Ausdrucks wird durch den folgenden Ausdruck definiert:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\\\\`|Entspricht zwei aufeinander folgende umgekehrte Schrägstrich (`\`) Zeichen. Da der umgekehrte Schrägstrich als Escapezeichen interpretiert wird, muss jeder umgekehrte Schrägstrich mit einem weiteren umgekehrten Schrägstrich mit Escapezeichen versehen werden.|  
|`+ Environment.MachineName +`|Übereinstimmung mit der Zeichenfolge, die von zurückgegeben wird die <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> Eigenschaft.|  
|`(?:\.\w+)*`|Übereinstimmung mit den Punkt (`.`) Zeichen, gefolgt von mindestens einem Wortzeichen. Dieser Vergleich kann keine oder mehrmalige erfolgen. Der übereinstimmende Teilausdruck nicht erfasst.|  
|`\\`|Entsprechen einen umgekehrten Schrägstrich (`\`) Zeichen.|  
|`([" + driveNames + "])`|Übereinstimmung mit die Zeichenklasse, aus die die einzelnen Laufwerkbuchstaben besteht. Dieser entspricht der ersten erfassten Teilausdrucks.|  
|`\$`|Entspricht das Dollarzeichen (`$`) Zeichen.|  
  
 Das Ersetzungsmuster `$1` ersetzt die gesamte Übereinstimmung mit der ersten erfassten Teilausdrucks. D. h., wird der UNC-Computer und Laufwerk Name mit dem Laufwerkbuchstaben ersetzt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> oder <paramref name="replacement" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.  Oder:  <paramref name="matchTimeout" /> ist negativ, null oder größer als ca. 24 Tage.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage">
          <para>Es wird empfohlen, Sie legen die <paramref name="matchTimeout" /> Parameter auf einen geeigneten Wert, z. B. zwei Sekunden. Wenn Sie Timeouts durch Angabe deaktivieren <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das Modul für reguläre Ausdrücke bietet eine etwas bessere Leistung. Sie sollten jedoch deaktivieren, Timeouts nur unter folgenden Bedingungen:: Wenn die Eingabe verarbeitet, die von einem regulären Ausdruck aus einer bekannten und vertrauenswürdigen Quelle stammt oder statischer Text besteht. Dies schließt Text, der Eingaben von Benutzern dynamisch wurde.  – Wenn Sie Muster des regulären Ausdrucks gründlich getestet wurden, um sicherzustellen, dass er effizient verarbeitet übereinstimmt, nicht-Übereinstimmungen und Naher übereinstimmt.  – Wenn Muster für reguläre Ausdrücke keine Language-Elemente enthält, die bekanntermaßen dazu führen, dass eine übermäßige rückverfolgung, bei der Verarbeitung einer Nahen Übereinstimmung.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="evaluator">Eine benutzerdefinierte Methode, die jede Übereinstimmung überprüft und entweder die ursprüngliche entsprechende Zeichenfolge oder eine Ersatzzeichenfolge zurückgibt.</param>
        <param name="options">Eine bitweise Kombination von Enumerationswerten, die Optionen für Vergleiche angeben.</param>
        <param name="matchTimeout">Ein Timeoutintervall oder <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das angibt, dass die Methode kein Timeout haben sollte.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge alle mit einem angegebenen regulären Ausdruck übereinstimmenden Teilzeichenfolgen durch eine von einem <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />-Delegaten zurückgegebene Zeichenfolge. Zusätzliche Parameter geben die Optionen an, die den entsprechenden Vorgang und ein Timeoutintervall ändern, wenn keine Übereinstimmung gefunden wird.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Die Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn für <paramref name="pattern" /> keine Übereinstimmung in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> Methode eignet sich für die Übereinstimmung mit einem regulären Ausdruck ersetzt, wenn eine der folgenden Bedingungen zutrifft:  
  
-   Wenn die Ersatzzeichenfolge leicht durch ein reguläres Ausdrucksmuster Ersetzung angegeben werden kann.  
  
-   Wenn die Ersatzzeichenfolge aus ergibt einige Verarbeitungsschritte an die übereinstimmende Zeichenfolge ausgeführt hat.  
  
-   Wenn die Ersatzzeichenfolge aus bedingte Verarbeitung ergibt.  
  
 Die Methode entspricht dem Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> -Methode und übergeben jede <xref:System.Text.RegularExpressions.Match> Objekt im zurückgegebenen <xref:System.Text.RegularExpressions.MatchCollection> -Auflistung, um die `evaluator` delegieren.  
  
 Die `pattern` Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die `evaluator` Parameter wird der Delegat für eine benutzerdefinierte Methode, die Sie definieren und, die jede Übereinstimmung überprüft. Die benutzerdefinierte-Methode benötigen die folgende Signatur entsprechend der <xref:System.Text.RegularExpressions.MatchEvaluator> delegieren.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Die benutzerdefinierte Methode gibt eine Zeichenfolge, die die übereinstimmende Eingabe ersetzt.  
  
 Bei Angabe von <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> für die `options` Parameter, die Suche nach Übereinstimmungen am Ende der Eingabezeichenfolge beginnt und bewegt sich nach links; andernfalls, die Suche beginnt am Anfang der Eingabezeichenfolge und wird nach rechts verschoben.  
  
 Die `matchTimeout` Parameter gibt an, wie lange eine Mustervergleich Methode sollten versuchen, eine Übereinstimmung zu finden, bevor ein Timeout eintritt. Ein Timeoutintervall Einstellung wird verhindert, dass reguläre Ausdrücken, die übermäßige rückverfolgung nicht angezeigt wird, um "nicht mehr reagiert, wenn diese Eingaben verarbeiten, die in der Nähe von Übereinstimmungen enthält. Weitere Informationen finden Sie unter [bewährte Methoden für reguläre Ausdrücke](~/docs/standard/base-types/best-practices.md) und [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Wenn in diesem Zeitraum keine Übereinstimmung gefunden wird, löst die Methode eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme. `matchTimeout` überschreibt alle Standard-Timeoutwert definiert, die für die Anwendungsdomäne, in der die Methode ausgeführt wird.  
  
 Da der Methodenrückgabe `input` unverändert, wenn keine Übereinstimmung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methode, um zu bestimmen, ob die Methode auf die Eingabezeichenfolge von Ersetzungen durchgeführt wurden.  
  
   
  
## Examples  
 Im folgende Beispiel wird einen regulären Ausdruck verwendet wird, um einzelne Wörter aus einer Zeichenfolge zu extrahieren und verwendet dann eine <xref:System.Text.RegularExpressions.MatchEvaluator> Delegaten aufrufen eine Methode mit dem Namen `WordScramble` , die die einzelnen Buchstaben im Wort verschlüsselt. Hierzu die `WordScramble` Methode erstellt ein Array mit den Zeichen in der Übereinstimmung zurück. Außerdem wird ein paralleles Array, das es füllt mit zufällige Gleitkommazahlen erstellt. Die Arrays werden sortiert, durch Aufrufen der <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> -Methode und das sortierte Array wird bereitgestellt, als Argument an einen <xref:System.String> Klassenkonstruktor. Diese neu erstellte Zeichenfolge wird zurückgegeben, durch die `WordScramble` Methode. Muster für reguläre Ausdrücke `\w+` entspricht mindestens einem Wortzeichen; das Modul für reguläre Ausdrücke wird weiterhin der Übereinstimmung Zeichen hinzugefügt, bis er erkennt, dass ein Nichtwortzeichen, z. B. ein Leerzeichen. Der Aufruf von der <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> Methode enthält die <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> Option, damit der Kommentar im Muster regulären Ausdrucks `\w+  # Matches all the characters in a word.` wird vom Modul für reguläre Ausdrücke ignoriert.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace13.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> oder <paramref name="evaluator" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.  Oder:  <paramref name="matchTimeout" /> ist negativ, null oder größer als ca. 24 Tage.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage">
          <para>Es wird empfohlen, Sie legen die <paramref name="matchTimeout" /> Parameter auf einen geeigneten Wert, z. B. zwei Sekunden. Wenn Sie Timeouts durch Angabe deaktivieren <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das Modul für reguläre Ausdrücke bietet eine etwas bessere Leistung. Sie sollten jedoch deaktivieren, Timeouts nur unter folgenden Bedingungen:: Wenn die Eingabe verarbeitet, die von einem regulären Ausdruck aus einer bekannten und vertrauenswürdigen Quelle stammt oder statischer Text besteht. Dies schließt Text, der Eingaben von Benutzern dynamisch wurde.  – Wenn Sie Muster des regulären Ausdrucks gründlich getestet wurden, um sicherzustellen, dass er effizient verarbeitet übereinstimmt, nicht-Übereinstimmungen und Naher übereinstimmt.  – Wenn Muster für reguläre Ausdrücke keine Language-Elemente enthält, die bekanntermaßen dazu führen, dass eine übermäßige rückverfolgung, bei der Verarbeitung einer Nahen Übereinstimmung.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der reguläre Ausdruck von rechts nach links sucht.</summary>
        <value>
          <see langword="true" />, wenn der reguläre Ausdruck von rechts nach links sucht, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.RightToLeft%2A> ist `true` Wenn die <xref:System.Text.RegularExpressions.Regex> Instanz erstellt wurde, mit der <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> Option.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="roptions">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexOptions roptions;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.Text.RegularExpressions.RegexOptions roptions" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.roptions" />
      <MemberSignature Language="VB.NET" Value="Protected Friend roptions As RegexOptions " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexOptions roptions;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Teilt eine Eingabezeichenfolge an den Positionen in ein Array von Teilzeichenfolgen auf, die durch eine Übereinstimmung mit einem regulären Ausdruck definiert werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die aufzuteilende Zeichenfolge.</param>
        <summary>Teilt die angegebene Eingabezeichenfolge an den Positionen in ein Array von Teilzeichenfolgen auf, die durch ein im <see cref="T:System.Text.RegularExpressions.Regex" />-Konstruktor angegebenes Muster für einen regulären Ausdruck definiert werden.</summary>
        <returns>Ein Array von Zeichenfolgen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Methoden ähneln den <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> -Methode, außer dass <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> teilt die Zeichenfolge an einem Trennzeichen, die bestimmt, indem ein regulärer Ausdruck anstatt einen Satz von Zeichen. Die Zeichenfolge wird so oft wie möglich zu teilen. Wenn kein Trennzeichen gefunden wird, enthält der Rückgabewert ein Element, dessen Wert der ursprünglichen Eingabezeichenfolge entspricht.  
  
 Wenn mehrere Übereinstimmungen zueinander nebeneinander angeordnet sind, wird eine leere Zeichenfolge in das Array eingefügt. Aufteilen einer Zeichenfolge in einen einzelnen Bindestrich verursacht beispielsweise das zurückgegebene Array an Position eine leere Zeichenfolge enthalten, in denen zwei aufeinander folgenden Bindestriche, wie im folgenden Code gezeigt gefunden werden.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split1.vb#1)]  
  
 Wenn eine Übereinstimmung am Anfang oder Ende der Eingabezeichenfolge gefunden wird, ist eine leere Zeichenfolge am Anfang oder Ende das zurückgegebene Array eingeschlossen werden. Im folgenden Beispiel wird das Muster eines regulären Ausdrucks `\d+` eine Eingabezeichenfolge hinsichtlich numerischen Zeichen geteilt. Da die Zeichenfolge beginnt und endet mit entsprechenden numerische Zeichen, ist der Wert des ersten und letzten Elements im zurückgegebenen Array <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split21.cs#21)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split21.vb#21)]  
  
 Wenn erfassen Klammern, in verwendet werden einem <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Ausdruck alle erfassten Text ist im resultierenden Zeichenfolgenarray enthalten. Wenn Sie die Zeichenfolge "Plum-Birne" auf einem Bindestrich schließenden Klammern Hauptvideos aufgeteilt wird, enthält das zurückgegebene Array z. B. eine String-Element, das den Bindestrich enthält.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split2.vb#2)]  
  
 Wenn das Muster des regulären Ausdrucks mehrere Sätze von schließenden Klammern enthält, hängt das Verhalten dieser Methode jedoch auf die Version von .NET Framework. Wenn innerhalb der ersten schließenden Klammern, keine Übereinstimmung gefunden wird, ist in .NET Framework 1.0 und 1.1 nicht erfassten Texts weiterer erfassen Klammern im zurückgegebenen Array enthalten. Beginnend mit .NET Framework 2.0, wird alle erfassten Texts auch in das zurückgegebene Array hinzugefügt. Der folgende Code verwendet beispielsweise zwei Sätze von schließenden Klammern, um die Elemente eines Datums, einschließlich der Datumstrennzeichen eine Datumszeichenfolge zu extrahieren. Der erste Satz von schließenden Klammern erfasst den Bindestrich, und der zweite Satz erfasst einen Schrägstrich. Wenn der Beispielcode wird kompiliert und unter .NET Framework 1.0 oder 1.1 ausgeführt werden, die Schrägstriche ausgeschlossen. Wenn die Kompilierung und bei Verwendung des .NET Framework 2.0 oder höher ausführen, nimmt diese.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split3.vb#3)]  
  
 Wenn der reguläre Ausdruck ist die leere Zeichenfolge Entsprechung möglich <xref:System.Text.RegularExpressions.Regex.Split%28System.String%29> teilen die Zeichenfolge in ein Array von Zeichenfolgen mit einem Zeichen, da die Trennzeichen für leere Zeichenfolgen an jeder Position gefunden werden kann. Zum Beispiel:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split11.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split11.vb#11)]  
  
 Beachten Sie, dass das zurückgegebene Array auch eine leere Zeichenfolge am Anfang und Ende des Arrays enthält.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit des Split-Vorgangs das Timeoutintervall gemäß überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie ein anderes Timeoutintervall nicht festlegen, wenn Sie den Konstruktor aufrufen, wird die Ausnahme ausgelöst, wenn der Vorgang alle für die Anwendungsdomäne eingerichtet, in dem Timeoutwert überschreitet die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die aufzuteilende Zeichenfolge.</param>
        <param name="count">Die maximale Anzahl der Teilungen.</param>
        <summary>Teilt die angegebene Eingabezeichenfolge höchstens die angegebene Anzahl von Malen an den Positionen in ein Array von Teilzeichenfolgenketten auf, die durch einen im <see cref="T:System.Text.RegularExpressions.Regex" />-Konstruktor angegebenen regulären Ausdruck definiert werden.</summary>
        <returns>Ein Array von Zeichenfolgen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Methoden ähneln den <xref:System.String.Split%2A?displayProperty=nameWithType> -Methode, außer dass <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> teilt die Zeichenfolge an einem Trennzeichen, die bestimmt, indem ein regulärer Ausdruck anstatt einen Satz von Zeichen. Die `count` Parameter gibt die maximale Anzahl von Teilzeichenfolgen auf, in dem die `input` Zeichenfolge aufgeteilt werden kann; die letzte Zeichenfolge enthält den nicht aufgeteilten Rest der Zeichenfolge. Ein `count` Wert von 0 (null) stellt das Standardverhalten des Teilens so oft wie möglich.  
  
 Wenn mehrere Übereinstimmungen aneinander angrenzenden sind oder wenn eine Übereinstimmung, am Anfang oder Ende des gefunden wird `input`, und die Anzahl der Übereinstimmungen gefunden wird, mindestens zwei kleiner als `count`, eine leere Zeichenfolge in das Array eingefügt wird. Das leere Zeichenfolgen, die von benachbarten Übereinstimmungen oder am Anfang oder Ende der Eingabezeichenfolge Übereinstimmungen ergeben gezählt werden, bei der Bestimmung, ob die Anzahl von Teilzeichenfolgen Equals abgeglichen `count`. Im folgenden Beispiel wird der reguläre Ausdruck `/d+` wird verwendet, um eine Eingabezeichenfolge aufgeteilt, die einem oder mehreren Dezimalstellen in maximal drei Teilzeichenfolgen enthält. Da der Anfang der Eingabezeichenfolge Muster des regulären Ausdrucks übereinstimmt, enthält das erste Arrayelement <xref:System.String.Empty?displayProperty=nameWithType>, das zweite enthält die erste Gruppe von alphabetischen Zeichen in der Eingabezeichenfolge und die dritte Spalte enthält den Rest der Zeichenfolge die die dritte Übereinstimmung folgt.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split25.cs#25)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split25.vb#25)]  
  
 Wenn umschließenden Klammern in einem regulären Ausdruck verwendet werden, ist die erfasster Text in das Array von Split Zeichenfolgen enthalten. Allerdings alle Arrayelemente, die erfassten Text enthalten, werden nicht gezählt bestimmen, ob die Anzahl der Übereinstimmungen erreicht hat `count`. Zeigt z. B. das Aufteilen der Zeichenfolge "Apple-Apricot-Plum-Birne-Banane" in maximal vier Teilzeichenfolgen Ergebnisse in ein Array mit sieben Elementen, wie im folgenden Code.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split4.vb#4)]  
  
 Wenn das Muster des regulären Ausdrucks mehrere Sätze von schließenden Klammern enthält, hängt das Verhalten dieser Methode jedoch auf die Version von .NET Framework. In .NET Framework 1.0 und 1.1 ist nur erfasster Text aus dem ersten Satz von schließenden Klammern in das zurückgegebene Array enthalten. Beginnend mit .NET Framework 2.0, ist das zurückgegebene Array alle erfasster Text hinzugefügt. Allerdings Elemente im zurückgegebenen Array, die erfassten Text enthalten, werden nicht gezählt bestimmen, ob die Anzahl von Teilzeichenfolgen Equals abgeglichen `count`. In den folgenden Code verwendet ein regulärer Ausdruck beispielsweise zwei Sätze von schließenden Klammern um die Elemente eines Datums eine Datumszeichenfolge zu extrahieren. Der erste Satz von schließenden Klammern erfasst den Bindestrich, und der zweite Satz erfasst einen Schrägstrich. Der Aufruf der <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> Methode gibt ein Maximum von zwei Elementen klicken Sie dann im zurückgegebenen Array. Wenn im Beispielcode wird kompiliert und unter .NET Framework 1.0 oder 1.1 ausgeführt werden, gibt die Methode ein Zeichenfolgenarray mit zwei Elementen zurück. Wenn kompilieren und bei Verwendung des .NET Framework 2.0 oder höher ausgeführt wird, gibt die Methode ein Zeichenfolgenarray mit drei Elementen zurück.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split5.vb#5)]  
  
 Wenn der reguläre Ausdruck ist die leere Zeichenfolge Entsprechung möglich <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> teilen die Zeichenfolge in ein Array von Zeichenfolgen mit einem Zeichen, da die Trennzeichen für leere Zeichenfolgen an jeder Position gefunden werden kann. Im folgenden Beispiel wird die Zeichenfolge "Zeichen" in so viele Elemente wie in der Eingabezeichenfolge enthält. Da die null-Zeichenfolge am Anfang der Eingabezeichenfolge entspricht, wird eine null-Zeichenfolge am Anfang des zurückgegebenen Array eingefügt. Dies bewirkt, dass der zehnte Element besteht aus den beiden Zeichen am Ende der Eingabezeichenfolge.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split12.vb#12)]  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit des Split-Vorgangs das Timeoutintervall gemäß überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie ein anderes Timeoutintervall nicht festlegen, wenn Sie den Konstruktor aufrufen, wird die Ausnahme ausgelöst, wenn der Vorgang alle für die Anwendungsdomäne eingerichtet, in dem Timeoutwert überschreitet die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die aufzuteilende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <summary>Teilt eine Eingabezeichenfolge an den durch ein reguläres Ausdrucksmuster definierten Positionen in ein Array von Teilzeichenfolgen auf.</summary>
        <returns>Ein Array von Zeichenfolgen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Methoden ähneln den <xref:System.String.Split%2A?displayProperty=nameWithType> -Methode, außer dass <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> teilt die Zeichenfolge an einem Trennzeichen, die bestimmt, indem ein regulärer Ausdruck anstatt einen Satz von Zeichen. Die `input` Zeichenfolge so oft wie möglich geteilt wird. Wenn `pattern` befindet sich nicht der `input` Zeichenfolge, enthält der Rückgabewert ein Element, dessen Wert die ursprünglichen `input` Zeichenfolge.  
  
 Die `pattern` Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Kompilierte reguläre Ausdrücke in Aufrufen statischer verwendet <xref:System.Text.RegularExpressions.Regex.Split%2A> Methoden werden automatisch zwischengespeichert. Um die Lebensdauer des kompilierten regulären Ausdrücken selbst zu verwalten, verwenden Sie die Instanz <xref:System.Text.RegularExpressions.Regex.Split%2A> Methoden.  
  
 Wenn mehrere Übereinstimmungen zueinander nebeneinander angeordnet sind, wird eine leere Zeichenfolge in das Array eingefügt. Aufteilen einer Zeichenfolge in einen einzelnen Bindestrich verursacht beispielsweise das zurückgegebene Array an Position eine leere Zeichenfolge enthalten, in denen zwei aufeinander folgenden Bindestriche, wie im folgenden Code gezeigt gefunden werden.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split8.vb#8)]  
  
 Wenn eine Übereinstimmung am Anfang oder Ende der Eingabezeichenfolge gefunden wird, ist eine leere Zeichenfolge am Anfang oder Ende das zurückgegebene Array eingeschlossen werden. Im folgenden Beispiel wird das Muster eines regulären Ausdrucks `\d+` eine Eingabezeichenfolge hinsichtlich numerischen Zeichen geteilt. Da die Zeichenfolge beginnt und endet mit entsprechenden numerische Zeichen, ist der Wert des ersten und letzten Elements im zurückgegebenen Array <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split22.cs#22)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split22.vb#22)]  
  
 Wenn erfassen Klammern, in verwendet werden einem <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Ausdruck alle erfassten Text ist im resultierenden Zeichenfolgenarray enthalten. Wenn Sie die Zeichenfolge "Plum-Birne" auf einem Bindestrich schließenden Klammern Hauptvideos aufgeteilt wird, enthält das zurückgegebene Array z. B. eine String-Element, das den Bindestrich enthält.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Wenn das Muster des regulären Ausdrucks mehrere Sätze von schließenden Klammern enthält, hängt das Verhalten dieser Methode jedoch auf die Version von .NET Framework. Wenn innerhalb der ersten schließenden Klammern, keine Übereinstimmung gefunden wird, ist in .NET Framework 1.0 und 1.1 nicht erfassten Texts weiterer erfassen Klammern im zurückgegebenen Array enthalten. Beginnend mit .NET Framework 2.0, wird alle erfassten Texts auch in das zurückgegebene Array hinzugefügt. Der folgende Code verwendet beispielsweise zwei Sätze von schließenden Klammern, um die Elemente eines Datums, einschließlich der Datumstrennzeichen eine Datumszeichenfolge zu extrahieren. Der erste Satz von schließenden Klammern erfasst den Bindestrich, und der zweite Satz erfasst einen Schrägstrich. Wenn der Beispielcode wird kompiliert und unter .NET Framework 1.0 oder 1.1 ausgeführt werden, die Schrägstriche ausgeschlossen. Wenn die Kompilierung und bei Verwendung des .NET Framework 2.0 oder höher ausführen, nimmt diese.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Wenn der reguläre Ausdruck ist die leere Zeichenfolge Entsprechung möglich <xref:System.Text.RegularExpressions.Regex.Split%2A> teilen die Zeichenfolge in ein Array von Zeichenfolgen mit einem Zeichen, da die Trennzeichen für leere Zeichenfolgen an jeder Position gefunden werden kann. Zum Beispiel:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split13.vb#13)]  
  
 Beachten Sie, dass das zurückgegebene Array auch eine leere Zeichenfolge am Anfang und Ende des Arrays enthält.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit des Split-Vorgangs überschreitet das Timeoutintervall angegeben, für die Anwendungsdomäne, in dem die Methode aufgerufen wird. Wenn kein Timeout erfolgt in der Anwendungsdomäne Eigenschaften definiert ist, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage">
          <para>Diese Methode ein Timeout eintritt, nach einem bestimmten Zeitintervall, die den Standardtimeoutwert der Anwendungsdomäne gleich ist, in dem die Methode aufgerufen wird. Wenn Sie ein Timeoutwert für die Anwendungsdomäne, die den Wert nicht definiert wurde <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, die die Methode ein Timeout eintritt, verhindert wird verwendet. Ist die empfohlene statische Methode zum Aufteilen von Text auf einer Musterübereinstimmung <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, und Sie können Sie das Timeoutintervall festgelegt.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer, startat As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count, int startat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die aufzuteilende Zeichenfolge.</param>
        <param name="count">Die maximale Anzahl der Teilungen.</param>
        <param name="startat">Die Zeichenposition in der Eingabezeichenfolge, an der mit der Suche begonnen wird.</param>
        <summary>Teilt die angegebene Eingabezeichenfolge höchstens die angegebene Anzahl von Malen an den Positionen in ein Array von Teilzeichenfolgenketten auf, die durch einen im <see cref="T:System.Text.RegularExpressions.Regex" />-Konstruktor angegebenen regulären Ausdruck definiert werden. Die Suche nach dem Muster des regulären Ausdrucks beginnt bei einer angegebenen Zeichenposition in der Eingabezeichenfolge.</summary>
        <returns>Ein Array von Zeichenfolgen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Methoden ähneln den <xref:System.String.Split%2A?displayProperty=nameWithType> -Methode, außer dass <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> teilt die Zeichenfolge an einem Trennzeichen, die bestimmt, indem ein regulärer Ausdruck anstatt einen Satz von Zeichen. Die `count` Parameter gibt die maximale Anzahl von Teilzeichenfolgen auf, in dem die `input` Zeichenfolge geteilt wird; die letzte Zeichenfolge enthält den nicht aufgeteilten Rest der Zeichenfolge. Ein `count` Wert von 0 (null) stellt das Standardverhalten des Teilens so oft wie möglich. Die `startat` Parameter definiert den Punkt, an dem die Suche nach dem ersten Trennzeichen beginnt (Dies kann verwendet werden für das Auslassen von führenden Leerzeichen).  
  
 Wenn keine Übereinstimmungen gefunden werden, aus der `count`+ 1 zu positionieren, in der Zeichenfolge, die Methode gibt ein Array von einem Element, enthält die `input` Zeichenfolge. Wenn eine oder mehrere Übereinstimmungen gefunden werden, enthält das erste Element im zurückgegebenen Array den erste Teil der Zeichenfolge vom ersten Zeichen bis zu einem Zeichen vor der Übereinstimmung.  
  
 Wenn mehrere Übereinstimmungen aneinander angrenzenden und die Anzahl der Übereinstimmungen gefunden, mindestens zwei wird kleiner als `count`, eine leere Zeichenfolge in das Array eingefügt wird. Auf ähnliche Weise, wenn eine Übereinstimmung, am gefunden wird `startat`, Hierbei handelt es sich um das erste Zeichen in der Zeichenfolge, das erste Element des zurückgegebenen Arrays ist eine leere Zeichenfolge. Das leere Zeichenfolgen, die angrenzende Übereinstimmungen ergeben gezählt werden, bei der Bestimmung, ob die Anzahl von Teilzeichenfolgen Equals abgeglichen `count`. Im folgenden Beispiel wird der reguläre Ausdruck `\d+` wird verwendet, um die Anfangsposition des ersten Teilzeichenfolge aus numerischen Zeichen in eine Zeichenfolge zu suchen und dann der Zeichenfolge mit maximal geteilt dreimal beginnend an dieser Position. Da Muster für reguläre Ausdrücke den Anfang der Eingabezeichenfolge entspricht, besteht die zurückgegebene Zeichenfolgenarray eine leere Zeichenfolge, eine Zeichenfolge mit fünf Zeichen alphabetisch und den Rest der Zeichenfolge,  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split26.cs#26)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split26.vb#26)]  
  
 Wenn umschließenden Klammern in einem regulären Ausdruck verwendet werden, ist die erfasster Text in das Array von Split Zeichenfolgen enthalten. Allerdings alle Arrayelemente, die erfassten Text enthalten, werden nicht gezählt bestimmen, ob die Anzahl der Übereinstimmungen erreicht hat `count`. Teilen Sie z. B. die Zeichenfolge ""Peach"in maximal vier Teilzeichenfolgen beginnend mit Zeichen 15 in den Ergebnissen der Zeichenfolge in ein Array mit sieben Elementen, wie im folgenden Code gezeigt.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split6.vb#6)]  
  
 Wenn das Muster des regulären Ausdrucks mehrere Sätze von schließenden Klammern enthält, hängt das Verhalten dieser Methode jedoch auf die Version von .NET Framework. Wenn innerhalb der ersten schließenden Klammern, keine Übereinstimmung gefunden wird, ist in .NET Framework 1.0 und 1.1 nicht erfassten Texts weiterer erfassen Klammern im zurückgegebenen Array enthalten. Beginnend mit .NET Framework 2.0, wird alle erfassten Texts auch in das zurückgegebene Array hinzugefügt. Der folgende Code verwendet z. B. zwei Sätze von schließenden Klammern, um die einzelnen Wörter in einer Zeichenfolge zu extrahieren. Der erste Satz von schließenden Klammern erfasst den Bindestrich, und der zweite Satz erfasst den senkrechte Strich. Wenn der Beispielcode wird kompiliert und unter .NET Framework 1.0 oder 1.1 ausgeführt, schließt Sie die vertikale Balken Zeichen; Wenn die Kompilierung und bei Verwendung des .NET Framework 2.0 oder höher ausführen, nimmt diese.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split7.vb#7)]  
  
 Wenn der reguläre Ausdruck ist die leere Zeichenfolge Entsprechung möglich <xref:System.Text.RegularExpressions.Regex.Split%2A> teilen die Zeichenfolge in ein Array von Zeichenfolgen mit einem Zeichen, da die Trennzeichen für leere Zeichenfolgen an jeder Position gefunden werden kann. Im folgenden Beispiel wird die Zeichenfolge "Zeichen" in beliebig viele Elemente, wie die Eingabezeichenfolge enthält, beginnend mit dem Zeichen, "a". Da die null-Zeichenfolge auf das Ende der Eingabezeichenfolge entspricht, wird eine Nullzeichenfolge am Ende das zurückgegebene Array eingefügt.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split14.cs#14)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split14.vb#14)]  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit des Split-Vorgangs das Timeoutintervall gemäß überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie ein anderes Timeoutintervall nicht festlegen, wenn Sie den Konstruktor aufrufen, wird die Ausnahme ausgelöst, wenn der Vorgang alle für die Anwendungsdomäne eingerichtet, in dem Timeoutwert überschreitet die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> ist kleiner als 0 (null) oder größer als die Länge von <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Die aufzuteilende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <summary>Teilt eine Eingabezeichenfolge an den durch ein angegebenes reguläres Ausdrucksmuster definierten Positionen in ein Array von Teilzeichenfolgen auf. Durch angegebene Optionen wird die Suche nach Übereinstimmungen geändert.</summary>
        <returns>Ein Array von Zeichenfolgen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Methoden ähneln den <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> -Methode, außer dass <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> teilt die Zeichenfolge an einem Trennzeichen, die bestimmt, indem ein regulärer Ausdruck anstatt einen Satz von Zeichen. Die Zeichenfolge wird so oft wie möglich zu teilen. Wenn kein Trennzeichen gefunden wird, enthält der Rückgabewert ein Element, dessen Wert die ursprünglichen `input` Zeichenfolge.  
  
 Die `pattern` Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Kompilierte reguläre Ausdrücke in Aufrufen statischer verwendet <xref:System.Text.RegularExpressions.Regex.Split%2A> Methoden werden automatisch zwischengespeichert. Um die Lebensdauer des kompilierten regulären Ausdrücken selbst zu verwalten, verwenden Sie die Instanz <xref:System.Text.RegularExpressions.Regex.Split%2A> Methoden.  
  
 Wenn mehrere Übereinstimmungen zueinander nebeneinander angeordnet sind, wird eine leere Zeichenfolge in das Array eingefügt. Aufteilen einer Zeichenfolge in einen einzelnen Bindestrich verursacht beispielsweise das zurückgegebene Array an Position eine leere Zeichenfolge enthalten, in denen zwei aufeinander folgenden Bindestriche gefunden werden.  
  
 Wenn eine Übereinstimmung am Anfang oder Ende der Eingabezeichenfolge gefunden wird, ist eine leere Zeichenfolge am Anfang oder Ende das zurückgegebene Array eingeschlossen werden. Im folgenden Beispiel wird das Muster eines regulären Ausdrucks `[a-z]+` zum Aufteilen einer Eingabezeichenfolge auf jedes beliebige alphabetische Zeichen in Groß- oder Kleinbuchstaben. Da die Zeichenfolge beginnt und endet mit übereinstimmenden alphabetische Zeichen, ist der Wert des ersten und letzten Elements im zurückgegebenen Array <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split24.cs#24)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split24.vb#24)]  
  
 Wenn erfassen Klammern, in verwendet werden einem <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Ausdruck alle erfassten Text ist im resultierenden Zeichenfolgenarray enthalten. Wenn Sie die Zeichenfolge "Plum-Birne" auf einem Bindestrich schließenden Klammern Hauptvideos aufgeteilt wird, enthält das zurückgegebene Array z. B. eine String-Element, das den Bindestrich enthält.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Wenn das Muster des regulären Ausdrucks mehrere Sätze von schließenden Klammern enthält, hängt das Verhalten dieser Methode jedoch auf die Version von .NET Framework. Wenn innerhalb der ersten schließenden Klammern, keine Übereinstimmung gefunden wird, ist in .NET Framework 1.0 und 1.1 nicht erfassten Texts weiterer erfassen Klammern im zurückgegebenen Array enthalten. Beginnend mit .NET Framework 2.0, wird alle erfassten Texts auch in das zurückgegebene Array hinzugefügt. Der folgende Code verwendet beispielsweise zwei Sätze von schließenden Klammern, um die Elemente eines Datums, einschließlich der Datumstrennzeichen eine Datumszeichenfolge zu extrahieren. Der erste Satz von schließenden Klammern erfasst den Bindestrich, und der zweite Satz erfasst einen Schrägstrich. Wenn der Beispielcode wird kompiliert und unter .NET Framework 1.0 oder 1.1 ausgeführt werden, die Schrägstriche ausgeschlossen. Wenn die Kompilierung und bei Verwendung des .NET Framework 2.0 oder höher ausführen, nimmt diese.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Wenn der reguläre Ausdruck ist die leere Zeichenfolge Entsprechung möglich <xref:System.Text.RegularExpressions.Regex.Split%2A> teilen die Zeichenfolge in ein Array von Zeichenfolgen mit einem Zeichen, da die Trennzeichen für leere Zeichenfolgen an jeder Position gefunden werden kann.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme wird ausgelöst, wenn die Ausführungszeit des Split-Vorgangs überschreitet das Timeoutintervall angegeben, für die Anwendungsdomäne, in dem die Methode aufgerufen wird. Wenn kein Timeout erfolgt in der Anwendungsdomäne Eigenschaften definiert ist, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage">
          <para>Diese Methode ein Timeout eintritt, nach einem bestimmten Zeitintervall, die den Standardtimeoutwert der Anwendungsdomäne gleich ist, in dem die Methode aufgerufen wird. Wenn Sie ein Timeoutwert für die Anwendungsdomäne, die den Wert nicht definiert wurde <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, die die Methode ein Timeout eintritt, verhindert wird verwendet. Ist die empfohlene statische Methode zum Aufteilen von Text auf einer Musterübereinstimmung <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, und Sie können Sie das Timeoutintervall festgelegt.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Die aufzuteilende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <param name="matchTimeout">Ein Timeoutintervall oder <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das angibt, dass die Methode kein Timeout haben sollte.</param>
        <summary>Teilt eine Eingabezeichenfolge an den durch ein angegebenes reguläres Ausdrucksmuster definierten Positionen in ein Array von Teilzeichenfolgen auf. Zusätzliche Parameter geben die Optionen an, die den entsprechenden Vorgang und ein Timeoutintervall ändern, wenn keine Übereinstimmung gefunden wird.</summary>
        <returns>Ein Zeichenfolgenarray.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Methoden ähneln den <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> -Methode, außer dass <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> teilt die Zeichenfolge an einem Trennzeichen, die bestimmt, indem ein regulärer Ausdruck anstatt einen Satz von Zeichen. Die Zeichenfolge wird so oft wie möglich zu teilen. Wenn kein Trennzeichen gefunden wird, enthält der Rückgabewert ein Element, dessen Wert die ursprünglichen `input` Zeichenfolge.  
  
 Die `pattern` Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Kompilierte reguläre Ausdrücke in Aufrufen statischer verwendet <xref:System.Text.RegularExpressions.Regex.Split%2A> Methoden werden automatisch zwischengespeichert. Um die Lebensdauer des kompilierten regulären Ausdrücken selbst zu verwalten, verwenden Sie die Instanz <xref:System.Text.RegularExpressions.Regex.Split%2A> Methoden.  
  
 Wenn mehrere Übereinstimmungen zueinander nebeneinander angeordnet sind, wird eine leere Zeichenfolge in das Array eingefügt. Aufteilen einer Zeichenfolge in einen einzelnen Bindestrich verursacht beispielsweise das zurückgegebene Array an Position eine leere Zeichenfolge enthalten, in denen zwei aufeinander folgenden Bindestriche gefunden werden.  
  
 Wenn eine Übereinstimmung am Anfang oder Ende der Eingabezeichenfolge gefunden wird, ist eine leere Zeichenfolge am Anfang oder Ende das zurückgegebene Array eingeschlossen werden. Im folgenden Beispiel wird das Muster eines regulären Ausdrucks `[a-z]+` zum Aufteilen einer Eingabezeichenfolge auf jedes beliebige alphabetische Zeichen in Groß- oder Kleinbuchstaben. Da die Zeichenfolge beginnt und endet mit übereinstimmenden alphabetische Zeichen, ist der Wert des ersten und letzten Elements im zurückgegebenen Array <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split23.cs#23)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split23.vb#23)]  
  
 Wenn erfassen Klammern, in verwendet werden einem <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Ausdruck alle erfassten Text ist im resultierenden Zeichenfolgenarray enthalten. Wenn Sie die Zeichenfolge "Plum-Birne" auf einem Bindestrich schließenden Klammern Hauptvideos aufgeteilt wird, enthält das zurückgegebene Array z. B. eine String-Element, das den Bindestrich enthält.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Wenn das Muster des regulären Ausdrucks mehrere Sätze von schließenden Klammern enthält, hängt das Verhalten dieser Methode jedoch auf die Version von .NET Framework. Wenn innerhalb der ersten schließenden Klammern, keine Übereinstimmung gefunden wird, ist in .NET Framework 1.0 und 1.1 nicht erfassten Texts weiterer erfassen Klammern im zurückgegebenen Array enthalten. Beginnend mit .NET Framework 2.0, wird alle erfassten Texts auch in das zurückgegebene Array hinzugefügt. Der folgende Code verwendet beispielsweise zwei Sätze von schließenden Klammern, um die Elemente eines Datums, einschließlich der Datumstrennzeichen eine Datumszeichenfolge zu extrahieren. Der erste Satz von schließenden Klammern erfasst den Bindestrich, und der zweite Satz erfasst einen Schrägstrich. Wenn der Beispielcode wird kompiliert und unter .NET Framework 1.0 oder 1.1 ausgeführt werden, die Schrägstriche ausgeschlossen. Wenn die Kompilierung und bei Verwendung des .NET Framework 2.0 oder höher ausführen, nimmt diese.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Wenn der reguläre Ausdruck ist die leere Zeichenfolge Entsprechung möglich <xref:System.Text.RegularExpressions.Regex.Split%2A> teilen die Zeichenfolge in ein Array von Zeichenfolgen mit einem Zeichen, da die Trennzeichen für leere Zeichenfolgen an jeder Position gefunden werden kann.  
  
 Die `matchTimeout` Parameter gibt an, wie lange eine Mustervergleich Methode sollten versuchen, eine Übereinstimmung zu finden, bevor ein Timeout eintritt. Ein Timeoutintervall Einstellung wird verhindert, dass reguläre Ausdrücken, die übermäßige rückverfolgung nicht angezeigt wird, nicht mehr reagiert, wenn diese Eingaben verarbeiten, die in der Nähe von Übereinstimmungen enthält. Weitere Informationen finden Sie unter [bewährte Methoden für reguläre Ausdrücke](~/docs/standard/base-types/best-practices.md) und [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Wenn in diesem Zeitraum keine Übereinstimmung gefunden wird, löst die Methode eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme. `matchTimeout` überschreibt alle Standard-Timeoutwert definiert, die für die Anwendungsdomäne, in der die Methode ausgeführt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.  Oder:  <paramref name="matchTimeout" /> ist negativ, null oder größer als ca. 24 Tage.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage">
          <para>Es wird empfohlen, Sie legen die <paramref name="matchTimeout" /> Parameter auf einen geeigneten Wert, z. B. zwei Sekunden. Wenn Sie Timeouts durch Angabe deaktivieren <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das Modul für reguläre Ausdrücke bietet eine etwas bessere Leistung. Sie sollten jedoch deaktivieren, Timeouts nur unter folgenden Bedingungen:: Wenn die Eingabe verarbeitet, die von einem regulären Ausdruck aus einer bekannten und vertrauenswürdigen Quelle stammt oder statischer Text besteht. Dies schließt Text, der Eingaben von Benutzern dynamisch wurde.  – Wenn Sie Muster des regulären Ausdrucks gründlich getestet wurden, um sicherzustellen, dass er effizient verarbeitet übereinstimmt, nicht-Übereinstimmungen und Naher übereinstimmt.  – Wenn Muster für reguläre Ausdrücke keine Language-Elemente enthält, die bekanntermaßen dazu führen, dass eine übermäßige rückverfolgung, bei der Verarbeitung einer Nahen Übereinstimmung.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="si">Das Objekt, das mit Serialisierungsinformationen aufgefüllt werden soll.</param>
        <param name="context">Der Ort zum Speichern und Abrufen von serialisierten Daten. Dieser Parameter ist für die zukünftige Verwendung reserviert.</param>
        <summary>Füllt ein <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt mit den Daten, die erforderlich sind, um das aktuelle <see cref="T:System.Text.RegularExpressions.Regex" />-Objekt zu deserialisieren.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt das Muster eines regulären Ausdrucks zurück, das an den <see langword="Regex" />-Konstruktor übergeben wurde.</summary>
        <returns>Der an den <paramref name="pattern" />-Konstruktor übergebene <see langword="Regex" />-Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `pattern` Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> ist die Basisklasse von regulären Ausdrücken, die erstellt, indem die <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> Methode. Diese kompilierten regulären Ausdrücke verwenden die <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> Implementierung der Basisklasse. Bei einem Aufruf in einer abgeleiteten Klasse die <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> Methode gibt die Zeichenfolge, die übergeben wurde, die <paramref name="pattern" /> Parameter von der <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> Klassenkonstruktor, die mit den regulären Ausdruck definiert wurde.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="public static string Unescape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Unescape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unescape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Unescape(System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Die Eingabezeichenfolge mit dem zu konvertierenden Text.</param>
        <summary>Konvertiert alle Escapezeichen in der Eingabezeichenfolge.</summary>
        <returns>Eine Zeichenfolge, in der alle Escapezeichen in die entsprechende Form ohne Escapezeichen konvertiert wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Unescape%2A> Methode führt eine der folgenden beiden Transformationen:  
  
-   Kehrt die Transformation ausgeführt wird, indem Sie die <xref:System.Text.RegularExpressions.Regex.Escape%2A> Methode durch das Entfernen der Escape-Zeichen ("\\") von jedem Zeichen mit Escapezeichen versehen, indem Sie die Methode. Dazu gehören die \\, *, +,?, &#124;, {, [, (,), ^, $,., # und Leerzeichen. Darüber hinaus die <xref:System.Text.RegularExpressions.Regex.Unescape%2A> Methode entfernt die schließende Klammer (]) und die schließende geschweifte Klammer (}) Zeichen.  
  
> [!NOTE]
>  <xref:System.Text.RegularExpressions.Regex.Unescape%2A> kann keine Zeichenfolge mit Escapezeichen umkehren, da es nicht ableiten kann genau die Zeichen mit Escapezeichen versehen wurden,  
  
-   Er ersetzt die Darstellung der nicht druckbare Zeichen durch die Zeichen selbst. Beispielsweise wird durch \x07 \a ersetzt. Die Darstellung von Zeichen, die es ersetzt werden \a "," \b "," \e "," \n "," \r "," \f "," \t, und "\v.  
  
 Wenn die <xref:System.Text.RegularExpressions.Regex.Unescape%2A> Methode trifft, andere Escapesequenzen, die nicht konvertiert werden können, z. B. \w oder \s, löst es eine <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="str" /> schließt eine nicht erkannte Escapesequenz ein.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="UseOptionC">
      <MemberSignature Language="C#" Value="protected bool UseOptionC ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionC() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionC" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionC () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionC();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <returns>
          <see langword="true" />, wenn die <see cref="P:System.Text.RegularExpressions.Regex.Options" />-Eigenschaft die <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />-Option enthält, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseOptionR">
      <MemberSignature Language="C#" Value="protected bool UseOptionR ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionR() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionR" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionR () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionR();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <returns>
          <see langword="true" />, wenn die <see cref="P:System.Text.RegularExpressions.Regex.Options" />-Eigenschaft die <see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" />-Option enthält, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal static void ValidateMatchTimeout (TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig void ValidateMatchTimeout(valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Sub ValidateMatchTimeout (matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static void ValidateMatchTimeout(TimeSpan matchTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="matchTimeout">Das zu überprüfende Timeoutintervall.</param>
        <summary>Überprüft, ob ein Timeoutintervall innerhalb eines akzeptablen Bereichs liegt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>