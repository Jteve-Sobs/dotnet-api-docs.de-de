<Type Name="Regex" FullName="System.Text.RegularExpressions.Regex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3100634e6ea4e3b3ecaf5ee2d872b8095fe44517" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48775806" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Regex : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Regex extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.Regex" />
  <TypeSignature Language="VB.NET" Value="Public Class Regex&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Regex : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Regex = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen unveränderlichen regulären Ausdruck dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex> Klasse stellt die .NET Framework Engine für reguläre Ausdrücke dar. Es kann verwendet werden, um schnell große Textmengen zur Suche nach bestimmten Zeichenmustern analysieren. zum Extrahieren, bearbeiten, ersetzen oder Löschen von Textzeichenfolgen; und zum Hinzufügen der extrahierten Zeichenfolgen zu einer Auflistung, die einen Bericht zu generieren.  
  
> [!NOTE]
>  Wenn Ihr Hauptinteresse ist, überprüfen eine Zeichenfolge, indem Sie bestimmen, ob sie einem bestimmten Muster entspricht, können Sie die <xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType> Klasse.  
  
 Um reguläre Ausdrücke verwenden, definieren Sie das Muster, die in einen Textstream zu identifizieren, mit der Syntax, dokumentiert werden sollen [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Als Nächstes können Sie optional Instanziieren einer <xref:System.Text.RegularExpressions.Regex> Objekt. Schließlich rufen Sie eine Methode, die einige Vorgänge, z. B. Ersetzen von Text, der das Muster für reguläre Ausdrücke entspricht, oder eine Musterübereinstimmung identifizieren ausführt.  
  
> [!NOTE]
>  Einige allgemeine Muster für reguläre Ausdrücke finden Sie unter [Beispiele für reguläre Ausdrücke](~/docs/standard/base-types/regular-expression-examples.md). Es gibt auch eine Reihe von online-Bibliotheken der Muster für reguläre Ausdrücke, wie z. B. unter [regulären-Expressions.info](https://www.regular-expressions.info/examples.html).  
  
<a name="remarks"></a> Weitere Informationen zur Verwendung der <xref:System.Text.RegularExpressions.Regex> Klasse, finden Sie unter den folgenden Abschnitten in diesem Thema:  
  
-   [Im Vergleich mit Regex String-Methoden](#regex_vs_string)  
  
-   [Statische und Instanzmethoden](#static_vs_instance)  
  
-   [Ausführen von Vorgängen für reguläre Ausdrücke](#regex_ops)  
  
-   [Definieren einen Timeoutwert](#define_timeout)  
  
 Weitere Informationen über die Sprache für reguläre Ausdrücke finden Sie unter [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Sie können auch eine der folgenden Broschüren herunterladen und ausdrucken:  
  
 [Kurzübersicht im Word-Format (.docx)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)  
 [Kurzübersicht im PDF-Format (.pdf)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)  
  
<a name="regex_vs_string"></a>   
## <a name="regex-vs-string-methods"></a>Im Vergleich mit Regex String-Methoden  
 Die <xref:System.String?displayProperty=nameWithType> Klasse enthält mehrere Methoden für den Vergleich und die Suche, die Sie verwenden können, zum Ausführen von Musterabgleich mit Text. Z. B. die <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.EndsWith%2A?displayProperty=nameWithType>, und <xref:System.String.StartsWith%2A?displayProperty=nameWithType> Methoden zu ermitteln, ob eine Zeichenfolgeninstanz eine angegebene Teilzeichenfolge enthält und die <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, <xref:System.String.IndexOfAny%2A?displayProperty=nameWithType>, <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>, und <xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType> Methoden zurück, das Starten die Position einer angegebenen Teilzeichenfolge in einer Zeichenfolge. Verwenden Sie die Methoden von der <xref:System.String?displayProperty=nameWithType> Klasse, wenn Sie nach einer bestimmten Zeichenfolge suchen. Verwenden der <xref:System.Text.RegularExpressions.Regex> Klasse, wenn Sie nach einem bestimmten Muster in einer Zeichenfolge suchen. Weitere Informationen und Beispiele finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md).  
  
 [Zurück zu "Hinweise"](#remarks)  
  
<a name="static_vs_instance"></a>   
## <a name="static-vs-instance-methods"></a>Statische und Instanzmethoden  
 Nach dem Muster eines regulären Ausdrucks definieren, können Sie es für die Engine für reguläre Ausdrücke in eine von zwei Arten bereitstellen:  
  
-   Durch die Instanziierung einer <xref:System.Text.RegularExpressions.Regex> -Objekt, das den regulären Ausdruck darstellt. Dazu übergeben Sie das Muster des regulären Ausdrucks zu einer <xref:System.Text.RegularExpressions.Regex.%23ctor%2A> Konstruktor. Ein <xref:System.Text.RegularExpressions.Regex> -Objekt unveränderlich ist; beim Instanziieren einer <xref:System.Text.RegularExpressions.Regex> Objekt mit einem regulären Ausdruck, dass reguläre Ausdrücke des Objekts nicht geändert werden kann.  
  
-   Durch das Angeben der reguläre Ausdruck und der Text, der zum Suchen einer `static` (`Shared` in Visual Basic) <xref:System.Text.RegularExpressions.Regex> Methode. Dadurch können Sie einen regulären Ausdruck verwenden, ohne explizite Erstellung einer <xref:System.Text.RegularExpressions.Regex> Objekt.  
  
 Alle <xref:System.Text.RegularExpressions.Regex> Identifikation Mustermethoden umfassen sowohl statische und der Instanz von Überladungen.  
  
 Ein bestimmtes Muster kann von der Engine für reguläre Ausdrücke muss kompiliert werden, bevor das Muster verwendet werden kann. Da <xref:System.Text.RegularExpressions.Regex> Objekte sind unveränderlich, dies ist eine einmalige Prozedur, die auftritt, wenn eine <xref:System.Text.RegularExpressions.Regex> Klassenkonstruktor oder eine statische Methode aufgerufen wird. Um einen einzelnen regulären Ausdruck wiederholt kompiliert werden muss, zu beseitigen, speichert die Engine für reguläre Ausdrücke die kompilierte reguläre Ausdrücke, die in statischen Methodenaufrufen verwendet. Daher bieten reguläre Ausdrucksmuster-Vergleichsmethoden an vergleichbare Leistung für statische und Instanzmethoden.  
  
> [!IMPORTANT]
>  In .NET Framework-Versionen 1.0 und 1.1, alle kompilierten regulären Ausdrücken klicken Sie, ob sie in der Instanz oder eine statische Methode verwendet wurden aufruft, zwischengespeichert wurden. Ab .NET Framework 2.0, werden nur in statischen Methodenaufrufen verwendete reguläre Ausdrücke zwischengespeichert werden.  
  
 Allerdings kann das Zwischenspeichern Leistung in den folgenden zwei Fällen beeinträchtigen:  
  
-   Wenn Sie statische Methodenaufrufe mit einer großen Anzahl von regulären Ausdrücken verwenden. In der Standardeinstellung speichert die Engine für reguläre Ausdrücke die 15 zuletzt verwendeten statischen regulären Ausdrücken. Wenn Ihre Anwendung mehr als 15 statische reguläre Ausdrücken verwendet, müssen einige reguläre Ausdrücke neu kompiliert werden. Um diese Neukompilierung zu verhindern, können Sie erhöhen die <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> Eigenschaft.  
  
-   Bei der Instanziierung neue <xref:System.Text.RegularExpressions.Regex> Objekte mit regulären Ausdrücken, die zuvor kompiliert wurden. Der folgende Code definiert z. B. einen regulären Ausdruck zum doppelte Wörter in einen Textstream gesucht werden soll. Obwohl das Beispiel einen einzelnen regulären Ausdruck verwendet wird, instanziiert ein neues <xref:System.Text.RegularExpressions.Regex> zu jeder Zeile des Texts zu verarbeitende Objekt. Dadurch wird die Neukompilierung des regulären Ausdrucks mit jeder Iteration der Schleife.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#1)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#1)]  
  
     Um zu verhindern, dass eine Neukompilierung, instanziieren Sie ein einzelnes <xref:System.Text.RegularExpressions.Regex> -Objekt, das kann zugegriffen werden, für den gesamten Code, der notwendig ist, wie die folgende umgeschriebene Beispiel gezeigt.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#2)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#2)]  
  
 [Zurück zu "Hinweise"](#remarks)  
  
<a name="regex_ops"></a>   
## <a name="performing-regular-expression-operations"></a>Ausführen von Vorgängen für reguläre Ausdrücke  
 Gibt an, ob Sie instanziieren möchten eine <xref:System.Text.RegularExpressions.Regex> Objekt und seine Methoden aufrufen oder statische Methoden, die <xref:System.Text.RegularExpressions.Regex> -Klasse bietet die folgende Mustervergleichs-Funktionen:  
  
-   Die Überprüfung einer Übereinstimmung. Rufen Sie die <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Methode, um zu bestimmen, ob eine Übereinstimmung vorhanden ist.  
  
-   Abrufen von einer einzelnen Übereinstimmung sucht. Rufen Sie die <xref:System.Text.RegularExpressions.Regex.Match%2A> Methode zum Abrufen einer <xref:System.Text.RegularExpressions.Match> Objekt, das die erste Übereinstimmung in einer Zeichenfolge oder Teil einer Zeichenfolge darstellt. Nachfolgende Übereinstimmungen abgerufen werden können, durch den Aufruf der <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> Methode.  
  
-   Abrufen von alle Übereinstimmungen. Rufen Sie die <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode zum Abrufen einer <xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType> Objekt, das alle Übereinstimmungen gefunden werden, in einer Zeichenfolge oder Teil einer Zeichenfolge darstellt.  
  
-   Ersetzt übereinstimmenden Text. Rufen Sie die <xref:System.Text.RegularExpressions.Regex.Replace%2A> Methode, um übereinstimmende Text ersetzt werden soll. Der Ersatztext kann auch von einem regulären Ausdruck definiert werden. Darüber hinaus einige der <xref:System.Text.RegularExpressions.Regex.Replace%2A> Methoden umfassen eine <xref:System.Text.RegularExpressions.MatchEvaluator> Parameter, der Ihnen ermöglicht, den Ersetzungstext programmgesteuert definieren.  
  
-   Die Erstellung eines Zeichenfolgenarrays, die aus Teilen einer Eingabezeichenfolge gebildet wird. Rufen Sie die <xref:System.Text.RegularExpressions.Regex.Split%2A> Methode, um eine Eingabezeichenfolge an den Positionen zu teilen, die mit dem regulären Ausdruck definiert sind.  
  
 Zusätzlich zu seiner Mustervergleichsmethoden die <xref:System.Text.RegularExpressions.Regex> Klasse enthält mehrere spezielle Methoden:  
  
-   Die <xref:System.Text.RegularExpressions.Regex.Escape%2A> Methode schützt alle Zeichen, die als Operatoren für reguläre Ausdrücke in einem regulären Ausdruck oder die Eingabezeichenfolge interpretiert werden können.  
  
-   Die <xref:System.Text.RegularExpressions.Regex.Unescape%2A> Methode entfernt diese Escape-Zeichen.  
  
-   Die <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> Methode erstellt eine Assembly, die vordefinierte reguläre Ausdrücke enthält. .NET Framework enthält Beispiele für diese spezielle Assemblys in der <xref:System.Web.RegularExpressions?displayProperty=nameWithType> Namespace.  
  
 [Zurück zu "Hinweise"](#remarks)  
  
<a name="define_timeout"></a>   
## <a name="defining-a-time-out-value"></a>Definieren einen Timeoutwert  
 .NET Framework unterstützt eine voll funktionsfähige reguläre-Sprache, die erhebliche Leistungsstärke und Flexibilität Musterabgleich enthält. Aber die Leistungsfähigkeit und Flexibilität mit Nachteilen verbunden: das Risiko einer schlechten Leistung. Reguläre Ausdrücke, die Verschlechterung der Leistung sind erstaunlich leicht zu erstellen. In einigen Fällen können reguläre Vorgänge, bei denen übermäßige rückverfolgung angezeigt werden, nicht mehr reagiert beim Verarbeiten von Text, der fast Muster des regulären Ausdrucks übereinstimmt. Weitere Informationen zu den .NET Framework-Engine für reguläre Ausdrücke, finden Sie unter [Details Verhalten regulärer Ausdrücke](~/docs/standard/base-types/details-of-regular-expression-behavior.md). Weitere Informationen über eine übermäßige rückverfolgung finden Sie unter [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], Sie können ein anderes Timeoutintervall für Übereinstimmungen mit regulären Ausdrücken definieren. Wenn die Engine für reguläre Ausdrücke eine Übereinstimmung innerhalb dieses Intervalls nicht identifizieren kann, löst der entsprechende Vorgang aus einem <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme. In den meisten Fällen verhindert, dass dies die Engine für reguläre Ausdrücke verarbeitungsleistung verschwendet, indem Sie versuchen, die Text übereinstimmen, der fast Muster des regulären Ausdrucks übereinstimmt. Es kann auch, allerdings hinweisen, dass das Timeoutintervall zu niedrig festgelegt wurde oder die aktuelle computerauslastung eine allgemeine Beeinträchtigung der Leistung verursacht hat.  
  
 Wie Sie die Ausnahme behandeln, hängt von der Ursache der Ausnahme ab. Wenn die Ausnahme tritt auf, weil das Timeoutintervall zu niedrig festgelegt ist oder aufgrund übermäßiger computerauslastung vorhanden ist, können Sie das Timeoutintervall erhöhen und den Vergleichsvorgang erneut ausführen. Wenn die Ausnahme tritt auf, da der reguläre Ausdruck auf eine übermäßige rückverfolgung angewiesen ist, können Sie davon ausgehen, dass eine Übereinstimmung ist nicht vorhanden, und, optional, Sie können Protokollinformationen, mit denen Sie das Muster des regulären Ausdrucks zu ändern.  
  
 Sie können ein Timeoutintervall festlegen, durch den Aufruf der <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Konstruktor beim Instanziieren Objekt eines regulären Ausdrucks. Für statische Methoden, können Sie ein Timeoutintervall festlegen, durch den Aufruf einer Überladung einer übereinstimmenden Methode, die eine `matchTimeout` Parameter. Wenn Sie nicht explizit einen Timeoutwert festlegen, wird die Timeoutwert wie folgt bestimmt:  
  
-   Ist Sie mithilfe des gesamten Anwendung Timeouts-Wert, wenn eine vorhanden. Dies kann jeder Timeoutwert, der für die Anwendungsdomäne, in dem gilt sein der <xref:System.Text.RegularExpressions.Regex> -Objekt instanziiert oder statische Methode aufgerufen wird. Sie können den Timeoutwert der gesamten Anwendung festlegen, durch den Aufruf der <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> Methode zum Zuweisen der angegebene Zeichenfolgendarstellung einer <xref:System.TimeSpan> Wert für die Eigenschaft "REGEX_DEFAULT_MATCH_TIMEOUT".  
  
-   Mit dem Wert <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>, wenn kein anwendungsweite Timeoutwert festgelegt wurde.  
  
> [!IMPORTANT]
>  Es wird empfohlen, dass Sie einen Timeoutwert in allen reguläre Mustervergleichs-Operationen festlegen. Weitere Informationen finden Sie unter [bewährte Methoden für reguläre Ausdrücke](~/docs/standard/base-types/best-practices.md).  
  
 [Zurück zu "Hinweise"](#remarks)  
  
   
  
## Examples  
 Im folgenden Beispiel wird einen regulären Ausdruck für wiederholte Vorkommen von Wörtern in einer Zeichenfolge zu überprüfen. Der reguläre Ausdruck `\b(?<word>\w+)\s+(\k<word>)\b` wie in der folgenden Tabelle dargestellt interpretiert werden kann.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\b`|Beginnt den Abgleich an einer Wortgrenze.|  
|`(?<word>\w+)`|Übereinstimmung mit mindestens einem Wortzeichen bis zu einer Wortgrenze. Nennen Sie diese erfasste Gruppe `word`.|  
|`\s+`|Übereinstimmung mit ein oder mehrere Leerzeichen Zeichen.|  
|`(\k<word>)`|Die erfasste Gruppe mit dem Namen übereinstimmen `word`.|  
|`\b`|Übereinstimmung mit einer Wortgrenze.|  
  
 [!code-cpp[Regex_Words#0](~/samples/snippets/cpp/VS_Snippets_CLR/Regex_Words/CPP/words.cpp#0)]
 [!code-csharp[Regex_Words#0](~/samples/snippets/csharp/VS_Snippets_CLR/Regex_Words/CS/words.cs#0)]
 [!code-vb[Regex_Words#0](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex_Words/VB/words.vb#0)]  
  
 Das folgende Beispiel veranschaulicht die Verwendung eines regulären Ausdrucks zu überprüfen, ob eine Zeichenfolge eine Währung darstellt, oder es verfügt über das richtige Format zum Darstellen einer Währung. In diesem Fall der reguläre Ausdruck wird dynamisch erstellt, aus der <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, und <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> Eigenschaften für die aktuelle Kultur des Benutzers. Wenn das System den aktuellen ist Kultur "En-US" ist, ist der resultierende reguläre `^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`. Wie in der folgenden Tabelle gezeigt, kann dieser reguläre Ausdruck interpretiert werden.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`^`|Beginnen Sie am Anfang der Zeichenfolge.|  
|`\s*`|Sucht nach 0 (null) oder mehr Leerzeichen.|  
|`[\+-]?`|Übereinstimmung mit keinem oder einem Vorkommen entweder das positiven Vorzeichen oder das negativen Vorzeichen.|  
|`\s?`|Übereinstimmung mit keinem oder einem Leerzeichen.|  
|`\$?`|Übereinstimmung mit keinem oder einem Vorkommen das Dollarzeichen.|  
|`\s?`|Übereinstimmung mit keinem oder einem Leerzeichen.|  
|`\d*`|0 (null) oder mehr Dezimalstellen sollen übereinstimmen.|  
|`\.?`|Übereinstimmung mit keinem oder einem Dezimaltrennzeichen.|  
|`\d{2}?`|Übereinstimmung mit zwei Dezimalzahlen 0 (null) oder einem Vorkommen.|  
|`(\d*\.?\d{2}?){1}`|Übereinstimmung mit dem Muster der vor- und Nachkommastellen Ziffern getrennt durch ein Dezimaltrennzeichen mindestens einmal aus.|  
|`$`|Übereinstimmung mit dem Ende der Zeichenfolge.|  
  
 Der reguläre Ausdruck in diesem Fall wird jedoch vorausgesetzt, dass eine gültige Währungszeichenfolge keine Gruppe für Trennzeichensymbole und hat entweder keine Dezimalstellen oder die Anzahl der Dezimalstellen, die von der aktuellen Kultur definiert <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A> Eigenschaft.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/cs/regex_example1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/vb/regex_example1.vb#1)]  
  
 Da die reguläre Ausdrücke in diesem Beispiel wird dynamisch erstellt wurde, wissen nicht zur Entwurfszeit wir, ob das Währungssymbol der aktuellen Kultur, Dezimaltrennzeichen oder positiven und negativen Vorzeichen durch die Engine für reguläre Ausdrücke als reguläre fehlinterpretiert werden können Language-Operatoren für Ausdrücke. Im Beispiel wird jede dynamisch generierte Zeichenfolge, die um alle Fehlinterpretationen zu vermeiden, übergeben die <xref:System.Text.RegularExpressions.Regex.Escape%2A> Methode.  
  
 ]]></format>
    </remarks>
    <threadsafe>Die <see cref="T:System.Text.RegularExpressions.Regex" /> Klasse ist unveränderlich (schreibgeschützt) und Thread-sicher. <see cref="T:System.Text.RegularExpressions.Regex" /> Objekte können in jedem Thread erzeugt und mehreren Threads gemeinsam genutzt werden. Weitere Informationen finden Sie unter [Threadsicherheit](~/docs/standard/base-types/thread-safety-in-regular-expressions.md).</threadsafe>
    <altmember cref="T:System.Configuration.RegexStringValidator" />
    <related type="Article" href="~/docs/standard/base-types/regular-expressions.md">Reguläre Ausdrücke von .NET Framework</related>
    <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
    <related type="ExternalDocumentation" href="http://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular expressions quick reference.docx">Reguläre Ausdrücke – Kurzübersicht (Download im Word-Format)</related>
    <related type="ExternalDocumentation" href="http://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular expressions quick reference.pdf">Reguläre Ausdrücke – Kurzübersicht (Download im PDF-Format)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.RegularExpressions.Regex" />-Klasse.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.RegularExpressions.Regex" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass dieser Konstruktor ist geschützt. Es kann nur von abgeleiteten Klassen aufgerufen werden die <xref:System.Text.RegularExpressions.Regex> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex pattern" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.RegularExpressions.Regex" />-Klasse für den angegebenen regulären Ausdruck.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `pattern` -Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter den [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md) Themen.  
  
 Aufrufen der <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29> Konstruktor entspricht dem Aufrufen der <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Konstruktor mit einem Wert von <xref:System.Text.RegularExpressions.RegexOptions.None> für die `options` Argument.  
  
 Ein <xref:System.Text.RegularExpressions.Regex> -Objekt unveränderlich ist, was bedeutet, dass es nur für Muster von Match können Sie definieren verwendet werden, wenn Sie ihn erstellen. Es kann jedoch oft ohne erneute Kompilierung verwendet.  
  
 Dieser Konstruktor instanziiert das Objekt eines regulären Ausdrucks, der versucht, Groß-/ Kleinschreibung von alphabetischen Zeichen in definierten `pattern`. Verwenden Sie für eine Übereinstimmung Groß-/Kleinschreibung der <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> Konstruktor.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie dieser Konstruktor verwendet einen regulären Ausdruck instanziiert werden, die mit einem beliebigen Wort übereinstimmt, die mit den Buchstaben beginnt "a" oder "t".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/constructors1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/constructors1.vb#1)]  
  
 Beachten Sie, dass das Muster des regulären Ausdrucks das Wort entsprechen, darf nicht "The" am Anfang des Texts, da es sich bei Vergleichen wird die Groß-/Kleinschreibung standardmäßig. Ein Beispiel für die Groß-/Kleinschreibung Vergleich, finden Sie unter den <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Konstruktor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Dieser Konstruktor erstellt ein <see cref="T:System.Text.RegularExpressions.Regex" /> Objekt, das den Standardtimeoutwert der Anwendungsdomäne verwendet, in dem es erstellt wird. Wenn Sie ein Timeoutwert für die Anwendungsdomäne, nicht definiert wurde die <see cref="T:System.Text.RegularExpressions.Regex" /> Objekt verwendet den Wert <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, die verhindert, dass bei der ein Timeout erfolgt. Die empfohlene Konstruktor zum Erstellen einer <see cref="T:System.Text.RegularExpressions.Regex" /> Objekt ist <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, mit dem Sie das Timeoutintervall festlegen.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Das Objekt, das ein serialisiertes Muster und <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Informationen enthält.</param>
        <param name="context">Das Ziel dieser Serialisierung. (Dieser Parameter wird nicht verwendet, geben Sie <see langword="null" /> an.)</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.RegularExpressions.Regex" />-Klasse mithilfe von serialisierten Daten.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">Das Muster, das diese <paramref name="info" /> enthält, ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="info" /> enthält ein ungültiges <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Flag.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die den regulären Ausdruck ändern.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.RegularExpressions.Regex" />-Klasse für den angegebenen regulären Ausdruck mit Optionen zum Verändern des Musters.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `pattern` -Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter den [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md) Themen.  
  
 Ein <xref:System.Text.RegularExpressions.Regex> -Objekt unveränderlich ist, was bedeutet, dass es nur für die Parameter für aktivitätsübereinstimmung können Sie definieren verwendet werden, bei der Erstellung. Es kann jedoch oft ohne erneute Kompilierung verwendet.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie dieser Konstruktor verwendet einen regulären Ausdruck instanziiert werden, die mit einem beliebigen Wort übereinstimmt, die mit den Buchstaben beginnt "a" oder "t".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/Constructors2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/Constructors2.vb#2)]  
  
 Beachten Sie, dass die Match-Sammlung das Wort "The", die der Text beginnt enthält, da die `options` Parameter wurde die Groß-/Kleinschreibung Vergleiche definiert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> enthält ein ungültiges Flag.</exception>
        <block subset="none" type="usage">
          <para>Dieser Konstruktor erstellt ein <see cref="T:System.Text.RegularExpressions.Regex" /> Objekt, das den Standardtimeoutwert der Anwendungsdomäne verwendet, in dem es erstellt wird. Wenn Sie ein Timeoutwert für die Anwendungsdomäne, nicht definiert wurde die <see cref="T:System.Text.RegularExpressions.Regex" /> Objekt verwendet den Wert <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, die verhindert, dass bei der ein Timeout erfolgt. Die empfohlene Konstruktor zum Erstellen einer <see cref="T:System.Text.RegularExpressions.Regex" /> Objekt ist <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, mit dem Sie das Timeoutintervall festlegen.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions, matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options, matchTimeout)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die den regulären Ausdruck ändern.</param>
        <param name="matchTimeout">Ein Timeoutintervall oder <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das angibt, dass die Methode kein Timeout haben sollte.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Text.RegularExpressions.Regex" />-Klasse für den angegebenen regulären Ausdruck mit Optionen, die das Muster und einen Wert ändern, der angibt, wie lange eine Mustervergleichsmethode versuchen sollte, eine Übereinstimmung zu finden, bevor ein Timeout eintritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `pattern` -Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter den [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md) Themen.  
  
 Ein <xref:System.Text.RegularExpressions.Regex> -Objekt unveränderlich ist, was bedeutet, dass es, die Sie definieren, bei der Erstellung nur für Muster von Match verwendet werden kann. Es kann jedoch oft ohne erneute Kompilierung verwendet.  
  
 Die `matchTimeout` Parameter gibt an, wie lange eine Mustervergleichs-Methode sollten versuchen, eine Übereinstimmung gefunden wird, bevor ein Timeout eintritt. Wenn in diesem Zeitintervall keine Übereinstimmung gefunden wird, löst die musterübereinstimmungen-Methode eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme. `matchTimeout` überschreibt alle Standard-Timeoutwert für die Anwendungsdomäne, in dem definiert die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Die Instanz Mustervergleichs-Methoden, die beobachten der `matchTimeout` Timeoutintervall umfassen Folgendes:  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%2A>  
  
-   <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>  
  
 Ein Timeoutintervall festlegen wird verhindert, dass reguläre Ausdrücke, die übermäßige rückverfolgung angezeigt werden, nicht mehr reagiert, wenn diese Eingaben verarbeiten, die in der Nähe von Übereinstimmungen enthält. Weitere Informationen finden Sie unter [bewährte Methoden für reguläre Ausdrücke](~/docs/standard/base-types/best-practices.md) und [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Um eine angemessene Timeoutintervall festzulegen, Faktoren Sie die folgenden:  
  
-   Die Länge und Komplexität der Muster des regulären Ausdrucks. Längere und komplexere reguläre Ausdrücken benötigen mehr Zeit als kürzer und einfacher.  
  
-   Der erwartete computerauslastung. Die Verarbeitung dauert länger auf Systemen mit hoher CPU- und speicherauslastung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Konstruktor zum Instanziieren einer <xref:System.Text.RegularExpressions.Regex> Objekt mit einem Timeoutwert von einer Sekunde. Das Muster des regulären Ausdrucks `(a+)+$`, das mit mindestens einer Sequenz von einem oder mehreren "a"-Zeichen am Ende einer Zeile übereinstimmt, unterliegt übermäßiger Rückverfolgung. Wenn eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> wird ausgelöst, im Beispiel wird der Timeoutwert bis zum Höchstwert von drei Sekunden erhöht. Andernfalls abgebrochen beim Versuch, die dem Muster entsprechen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> ist kein gültiger <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Wert.  
  
- oder -  
 <paramref name="matchTimeout" /> ist negativ, 0 oder größer als ca. 24 Tage.</exception>
        <block subset="none" type="usage">
          <para>Es wird empfohlen, Sie legen die <paramref name="matchTimeout" /> Parameter auf einen geeigneten Wert, z. B. zwei Sekunden. Wenn Sie Timeouts werden, indem deaktiviert <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, die Engine für reguläre Ausdrücke bietet eine etwas bessere Leistung. Allerdings sollten Sie Timeouts nur unter folgenden Bedingungen deaktivieren: 
– Wenn die Eingabe verarbeitet, die von einem regulären Ausdruck aus einer bekannten und vertrauenswürdigen Quelle stammt oder besteht aus statischen Text. Dies schließt Text, der vom Benutzer eingegebene dynamisch wurde.  
  
– Wenn Sie Muster für reguläre Ausdrücke gründlich getestet wurde, um sicherzustellen, dass er effizient verarbeitet übereinstimmt, nicht-Übereinstimmungen und Naher entspricht.  
  
– Wenn Muster für reguläre Ausdrücke keine Language-Elemente enthält, die bekannt sind, um eine übermäßige rückverfolgung bei der Verarbeitung einer Nahen Übereinstimmung zu verursachen.</para>
        </block>
        <related type="Article" href="http://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">Backtracking</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="CacheSize">
      <MemberSignature Language="C#" Value="public static int CacheSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CacheSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CacheSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CacheSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CacheSize : int with get, set" Usage="System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Anzahl von Einträgen im aktuellen statischen Cache für die kompilierten regulären Ausdrücke ab oder legt diese fest.</summary>
        <value>Die maximale Anzahl von Einträgen im statischen Cache.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex> Klasse verwaltet einen internen Cache kompilierter regulärer Ausdrücke, die in statischen Methodenaufrufen verwendet. Wenn in einem Set-Vorgang angegebene Wert kleiner als die aktuelle Cachegröße ist, werden Einträge im Cache verworfen, bis die Cachegröße auf den angegebenen Wert entspricht.  
  
 Standardmäßig enthält der Cache, 15 statische reguläre Ausdrücke kompiliert. Ihre Anwendung wird in der Regel nicht berechtigt, die Größe des Caches ändern. Verwenden der <xref:System.Text.RegularExpressions.Regex.CacheSize%2A> Eigenschaft nur, wenn Sie caching oder wenn Sie einen ungewöhnlich großen Cache deaktivieren möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert in einem Set-Vorgang ist kleiner als 0 (null).</exception>
        <block subset="none" type="usage">
          <para>In .NET Framework vor der [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)], reguläre Ausdrücke verwendet werden, in dem sowohl statische und Instanzmethoden aufgerufenen zwischengespeichert wurden. Beginnend mit der [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)], nur reguläre in statischen Methodenaufrufen verwendete Ausdrücke werden zwischengespeichert.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="capnames">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable capnames;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable capnames" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capnames" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capnames As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ capnames;" />
      <MemberSignature Language="F#" Value="val mutable capnames : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.capnames" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CapNames">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary CapNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary CapNames" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CapNames" />
      <MemberSignature Language="VB.NET" Value="Protected Property CapNames As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ CapNames { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CapNames : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.CapNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Wörterbuch ab, das Erfassungsgruppen ihren Indexwerten zuordnet, oder legt es fest.</summary>
        <value>Ein Wörterbuch, das Erfassungsgruppen ihren Indexwerten zuordnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass diese Eigenschaft geschützt ist. Es kann nur von einer Klasse abgeleitet zugegriffen werden die <xref:System.Text.RegularExpressions.Regex> Klasse.  
  
 Ein Set-Vorgang versucht, den Wert der Eigenschaft zugewiesen, um konvertieren eine <xref:System.Collections.Hashtable> Objekt; Wenn es sich bei dieser Konvertierung ein Fehler auftritt, ruft es die <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> Konstruktor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der einer <see cref="P:System.Text.RegularExpressions.Regex.CapNames" />-Eigenschaft zugeordnete Wert in einer festgelegten Operation ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="caps">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable caps;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable caps" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.caps" />
      <MemberSignature Language="VB.NET" Value="Protected Friend caps As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ caps;" />
      <MemberSignature Language="F#" Value="val mutable caps : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.caps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Caps">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary Caps { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Caps" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Caps" />
      <MemberSignature Language="VB.NET" Value="Protected Property Caps As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ Caps { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Caps : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.Caps" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Wörterbuch ab oder legt es fest, das nummerierte Erfassungsgruppen ihren Indexwerten zuordnet.</summary>
        <value>Ein Wörterbuch, das nummerierte Erfassungsgruppen ihren Indexwerten zuordnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass diese Eigenschaft geschützt ist. Es kann nur von einer Klasse abgeleitet zugegriffen werden die <xref:System.Text.RegularExpressions.Regex> Klasse.  
  
 Ein Set-Vorgang versucht, den Wert der Eigenschaft zugewiesen, um konvertieren eine <xref:System.Collections.Hashtable> Objekt; Wenn es sich bei dieser Konvertierung ein Fehler auftritt, ruft es die <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> Konstruktor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der einer <see cref="P:System.Text.RegularExpressions.Regex.Caps" />-Eigenschaft zugeordnete Wert in einer festgelegten Operation ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="capsize">
      <MemberSignature Language="C#" Value="protected internal int capsize;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly int32 capsize" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capsize" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capsize As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected public: int capsize;" />
      <MemberSignature Language="F#" Value="val mutable capsize : int" Usage="System.Text.RegularExpressions.Regex.capsize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="capslist">
      <MemberSignature Language="C#" Value="protected internal string[] capslist;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string[] capslist" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capslist" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capslist As String() " />
      <MemberSignature Language="C++ CLI" Value="protected public: cli::array &lt;System::String ^&gt; ^ capslist;" />
      <MemberSignature Language="F#" Value="val mutable capslist : string[]" Usage="System.Text.RegularExpressions.Regex.capslist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompileToAssembly">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kompiliert reguläre Ausdrücke und speichert diese in einer einzelnen Assembly auf der Festplatte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Auf .NET Core, Aufrufe von der `Regex.CompileToAssembly` Methode Auslösen einer <xref:System.PlatformNotSupportedException>; Ausgeben einer Assemblys wird nicht unterstützt.
  
       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Ein Array, das die zu kompilierenden regulären Ausdrücke beschreibt.</param>
        <param name="assemblyname">Der Dateiname der Assembly.</param>
        <summary>Kompiliert ein oder mehrere angegebene <see cref="T:System.Text.RegularExpressions.Regex" />-Objekte in eine benannte Assembly.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> Methode generiert eine .NET Framework-Assembly in der jeder reguläre Ausdruck definiert, der `regexinfos` Array wird durch eine Klasse dargestellt. In der Regel die <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> Methode wird aufgerufen, in einer separaten Anwendung, die eine Assembly aus kompilierten regulären Ausdrücken generiert. Jeder reguläre Ausdruck, der in der Assembly enthalten weist folgende Merkmale auf:  
  
-   Es ergibt sich aus der <xref:System.Text.RegularExpressions.Regex> Klasse.  
  
-   Es erhält den vollqualifizierten Namen, die von definiert ist die `fullnamespace` und `name` Parameter des entsprechenden <xref:System.Text.RegularExpressions.RegexCompilationInfo> Objekt.  
  
-   Es verfügt über einen Standardwert (oder parameterlosen) Konstruktor.  
  
 Normalerweise wird der Code, der instanziiert und verwendet den kompilierten regulären Ausdruck gefunden, in eine Assembly oder Anwendung, die aus dem Code getrennt ist, die die Assembly erstellt.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Assembly namens RegexLib.dll erstellt. Die Assembly enthält zwei kompilierte reguläre Ausdrücke. Die erste `Utilities.RegularExpressions.DuplicatedString`, entspricht zwei identische aufeinander folgende Wörter. Der zweite `Utilities.RegularExpressions.EmailAddress`, überprüft, ob eine Zeichenfolge, die eine e-Mail-Adresse das richtige Format hat.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile1.vb#1)]  
  
 Der reguläre Ausdruck, der eine Zeichenfolge für doppelte Wörter überprüft wird dann instanziiert und vom im folgenden Beispiel.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Erfolgreicher Kompilierung dieses zweite Beispiel erfordert einen Verweis auf RegexLib.dll erstellt (die Assembly, die von der im ersten Beispiel erstellt wird), um dem Projekt hinzugefügt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Wert der <see cref="P:System.Reflection.AssemblyName.Name" />-Eigenschaft des <paramref name="assemblyname" />-Parameters ist eine leere oder eine NULL-Zeichenfolge.  
  
- oder -  
Das Muster des regulären Ausdrucks eines oder mehrerer Objekte in <paramref name="regexinfos" /> enthält eine ungültige Syntax.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyname" /> oder <paramref name="regexinfos" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Das Erstellen einer Assembly aus kompilierten regulären Ausdrücken wird nicht unterstützt.</exception>
        <block subset="none" type="usage">
          <para>Wenn Sie auf einem System entwickeln, die [!INCLUDE[net_v45](~/includes/net-v45-md.md)] oder dessen punktreleases installiert, Sie als Ziel [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], und Sie verwenden die <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> Methode, um eine Assembly erstellen, enthält kompilierte reguläre Ausdrücke. Versuch, die regulären Ausdrücke zu verwenden, in dieser Assembly auf einem System, das verfügt über [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] löst eine Ausnahme aus. Um dieses Problem zu umgehen, haben Sie die folgenden Möglichkeiten: 
– Erstellen Sie die Assembly, die die kompilierte reguläre Ausdrücke auf einem System enthält, die [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] anstelle von neueren Versionen.  
  
-Anstelle eines Aufrufs <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> und Abrufen des kompilierten regulären Ausdrucks aus einer Assembly an, entweder statisch oder-Instanz <see cref="T:System.Text.RegularExpressions.Regex" /> Methoden mit der <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> option beim Instanziieren einer <see cref="T:System.Text.RegularExpressions.Regex" /> Objekt oder einen regulären Ausdruck aufrufen musterabgleichsmethode.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Kompilierung und Wiederverwendung</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Ein Array, das die zu kompilierenden regulären Ausdrücke beschreibt.</param>
        <param name="assemblyname">Der Dateiname der Assembly.</param>
        <param name="attributes">Ein Array, das die auf die Assembly anzuwendenden Attribute definiert.</param>
        <summary>Kompiliert ein oder mehrere angegebene <see cref="T:System.Text.RegularExpressions.Regex" />-Objekte in eine benannte Assembly mit den angegebenen Attributen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> Methode generiert eine .NET Framework-Assembly in der jeder reguläre Ausdruck definiert, der `regexinfos` Array wird durch eine Klasse dargestellt. In der Regel die <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> Methode wird aufgerufen, in einer separaten Anwendung, die eine Assembly aus kompilierten regulären Ausdrücken generiert. Jeder reguläre Ausdruck, der in der Assembly enthalten weist folgende Merkmale auf:  
  
-   Es ergibt sich aus der <xref:System.Text.RegularExpressions.Regex> Klasse.  
  
-   Es erhält den vollqualifizierten Namen, die von definiert ist die `fullnamespace` und `name` Parameter des entsprechenden <xref:System.Text.RegularExpressions.RegexCompilationInfo> Objekt.  
  
-   Es verfügt über einen Standardwert (oder parameterlosen) Konstruktor.  
  
 Normalerweise wird der Code, der instanziiert und verwendet den kompilierten regulären Ausdruck gefunden, in eine Assembly oder Anwendung, die aus dem Code getrennt ist, die die Assembly erstellt.  
  
 Da die <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> Methode generiert eine .NET Framework-Assembly aus einem Methodenaufruf anstelle einer bestimmten Sprache Class Definition-Schlüsselwort (z. B. `class` in c# oder `Class`...`End Class` in Visual Basic) lässt es nicht .NET Framework-Attribute, die auf die Assembly mit der Entwicklungssprache Standardattributsyntax zugewiesen werden. Die `attributes` Parameter stellt eine alternative Methode für die, die auf die Assembly anzuwendenden Attribute definiert. Führen Sie für jedes Attribut, das Sie auf die Assembly anwenden möchten folgende Schritte aus:  
  
1.  Erstellt ein Array von <xref:System.Type> Objekte, die die Parametertypen des Attributkonstruktors, die Sie aufrufen möchten darstellen.  
  
2.  Abrufen einer <xref:System.Type> Objekt, das die Attributklasse, die Sie zur neuen Assembly anwenden möchten darstellt.  
  
3.  Rufen Sie die <xref:System.Type.GetConstructor%2A> Methode des Attributs <xref:System.Type> abzurufenden Objekts eine <xref:System.Reflection.ConstructorInfo> Objekt, das den Konstruktor des Attributs, die Sie aufrufen möchten darstellt. Übergeben Sie die <xref:System.Type.GetConstructor%2A> Methode das Array von <xref:System.Type> Objekte, die Parametertypen des Konstruktors darstellt.  
  
4.  Erstellen Sie eine <xref:System.Object> Array, das die Parameter zur Übergabe an den Konstruktor des Attributs definiert.  
  
5.  Instanziieren einer <xref:System.Reflection.Emit.CustomAttributeBuilder> Objekt durch Übergeben des Konstruktors der <xref:System.Reflection.ConstructorInfo> Objekt abgerufen in Schritt 3 und die <xref:System.Object> in Schritt 4 erstellte Array.  
  
 Anschließend können Sie ein Array dieser übergeben <xref:System.Reflection.Emit.CustomAttributeBuilder> anstelle von Objekten der `attributes` Parameter, um die <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Assembly mit dem Namen RegexLib.dll erstellt, und wendet die <xref:System.Reflection.AssemblyTitleAttribute> -Attribut an. Die Assembly enthält zwei kompilierte reguläre Ausdrücke. Die erste `Utilities.RegularExpressions.DuplicatedString`, entspricht zwei identische aufeinander folgende Wörter. Der zweite `Utilities.RegularExpressions.EmailAddress`, überprüft, ob eine Zeichenfolge, die eine e-Mail-Adresse das richtige Format hat.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile3.vb#3)]  
  
 Sie können überprüfen, ob die <xref:System.Reflection.AssemblyTitleAttribute> -Attribut auf die Assembly durch das Manifest mit einem Reflektionshilfsprogramm wie ILDasm untersuchen angewendet wurde.  
  
 Der reguläre Ausdruck, der eine Zeichenfolge für doppelte Wörter überprüft wird dann instanziiert und vom im folgenden Beispiel.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Erfolgreicher Kompilierung dieses zweite Beispiel erfordert einen Verweis auf RegexLib.dll erstellt (die Assembly, die von der im ersten Beispiel erstellt wird), um dem Projekt hinzugefügt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Wert der <see cref="P:System.Reflection.AssemblyName.Name" />-Eigenschaft des <paramref name="assemblyname" />-Parameters ist eine leere oder eine NULL-Zeichenfolge.  
  
- oder -  
Das Muster des regulären Ausdrucks eines oder mehrerer Objekte in <paramref name="regexinfos" /> enthält eine ungültige Syntax.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyname" /> oder <paramref name="regexinfos" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Das Erstellen einer Assembly aus kompilierten regulären Ausdrücken wird nicht unterstützt.</exception>
        <block subset="none" type="usage">
          <para>Wenn Sie auf einem System entwickeln, die [!INCLUDE[net_v45](~/includes/net-v45-md.md)] oder dessen punktreleases installiert, Sie als Ziel [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], und Sie verwenden die <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> Methode, um eine Assembly erstellen, enthält kompilierte reguläre Ausdrücke. Versuch, die regulären Ausdrücke zu verwenden, in dieser Assembly auf einem System, das verfügt über [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] löst eine Ausnahme aus. Um dieses Problem zu umgehen, haben Sie die folgenden Möglichkeiten: 
– Erstellen Sie die Assembly, die die kompilierte reguläre Ausdrücke auf einem System enthält, die [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] anstelle von neueren Versionen.  
  
-Anstelle eines Aufrufs <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> und Abrufen des kompilierten regulären Ausdrucks aus einer Assembly an, entweder statisch oder-Instanz <see cref="T:System.Text.RegularExpressions.Regex" /> Methoden mit der <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> option beim Instanziieren einer <see cref="T:System.Text.RegularExpressions.Regex" /> Objekt oder einen regulären Ausdruck aufrufen musterabgleichsmethode.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Kompilierung und Wiederverwendung</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes, System::String ^ resourceFile);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] * string -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes, resourceFile)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
        <Parameter Name="resourceFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Ein Array, das die zu kompilierenden regulären Ausdrücke beschreibt.</param>
        <param name="assemblyname">Der Dateiname der Assembly.</param>
        <param name="attributes">Ein Array, das die auf die Assembly anzuwendenden Attribute definiert.</param>
        <param name="resourceFile">Der Name der in die Assembly einzufügenden Win32-Ressourcendatei.</param>
        <summary>Kompiliert ein oder mehrere angegebene <see cref="T:System.Text.RegularExpressions.Regex" />-Objekte und eine angegebene Ressourcendatei in eine benannte Assembly mit den angegebenen Attributen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName% 2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 >-Methode generiert eine .NET Framework-Assembly in der jeder reguläre Ausdruck definiert, der `regexinfos` Array wird durch eine Klasse dargestellt. In der Regel die [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D% 2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 >-Methode wird aufgerufen, in einer separaten Anwendung, die eine Assembly aus kompilierten regulären Ausdrücken generiert. Jeder reguläre Ausdruck, der in der Assembly enthalten weist folgende Merkmale auf:  
  
-   Es ergibt sich aus der <xref:System.Text.RegularExpressions.Regex> Klasse.  
  
-   Es erhält den vollqualifizierten Namen, die von definiert ist die `fullnamespace` und `name` Parameter des entsprechenden <xref:System.Text.RegularExpressions.RegexCompilationInfo> Objekt.  
  
-   Es verfügt über einen Standardwert (oder parameterlosen) Konstruktor.  
  
 Normalerweise wird der Code, der instanziiert und verwendet den kompilierten regulären Ausdruck gefunden, in eine Assembly oder Anwendung, die aus dem Code getrennt ist, die die Assembly erstellt.  
  
 Da die <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> Methode generiert eine .NET Framework-Assembly aus einem Methodenaufruf anstelle einer bestimmten Sprache Class Definition-Schlüsselwort (z. B. `class` in c# oder `Class`...`End Class` in Visual Basic) lässt es nicht .NET Framework-Attribute, die auf die Assembly mit der Entwicklungssprache Standardattributsyntax zugewiesen werden. Die `attributes` Parameter stellt eine alternative Methode für die, die auf die Assembly anzuwendenden Attribute definiert. Führen Sie für jedes Attribut, das Sie auf die Assembly anwenden möchten folgende Schritte aus:  
  
1.  Erstellt ein Array von <xref:System.Type> Objekte, die die Parametertypen des Attributkonstruktors, die Sie aufrufen möchten darstellen.  
  
2.  Abrufen einer <xref:System.Type> Objekt, das die Attributklasse, die Sie zur neuen Assembly anwenden möchten darstellt.  
  
3.  Rufen Sie die <xref:System.Type.GetConstructor%2A> Methode des Attributs <xref:System.Type> abzurufenden Objekts eine <xref:System.Reflection.ConstructorInfo> Objekt, das den Konstruktor des Attributs, die Sie aufrufen möchten darstellt. Übergeben Sie die <xref:System.Type.GetConstructor%2A> Methode das Array von <xref:System.Type> Objekte, die Parametertypen des Konstruktors darstellt.  
  
4.  Erstellen Sie eine <xref:System.Object> Array, das die Parameter zur Übergabe an den Konstruktor des Attributs definiert.  
  
5.  Instanziieren einer <xref:System.Reflection.Emit.CustomAttributeBuilder> Objekt durch Übergeben des Konstruktors der <xref:System.Reflection.ConstructorInfo> Objekt abgerufen in Schritt 3 und die <xref:System.Object> in Schritt 4 erstellte Array.  
  
 Anschließend können Sie ein Array dieser übergeben <xref:System.Reflection.Emit.CustomAttributeBuilder> anstelle von Objekten der `attributes` Parameter, um das [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly% 28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 >-Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Wert der <see cref="P:System.Reflection.AssemblyName.Name" />-Eigenschaft des <paramref name="assemblyname" />-Parameters ist eine leere oder eine NULL-Zeichenfolge.  
  
- oder -  
Das Muster des regulären Ausdrucks eines oder mehrerer Objekte in <paramref name="regexinfos" /> enthält eine ungültige Syntax.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyname" /> oder <paramref name="regexinfos" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Der <paramref name="resourceFile" />-Parameter legt eine ungültige Win32-Ressourcendatei fest.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die vom <paramref name="resourceFile" />-Parameter angegebene Datei kann nicht gefunden werden.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Das Erstellen einer Assembly aus kompilierten regulären Ausdrücken wird nicht unterstützt.</exception>
        <block subset="none" type="usage">
          <para>Wenn Sie auf einem System entwickeln, die [!INCLUDE[net_v45](~/includes/net-v45-md.md)] oder dessen punktreleases installiert, Sie als Ziel [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], und Sie verwenden die <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> Methode, um eine Assembly erstellen, enthält kompilierte reguläre Ausdrücke. Versuch, die regulären Ausdrücke zu verwenden, in dieser Assembly auf einem System, das verfügt über [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] löst eine Ausnahme aus. Um dieses Problem zu umgehen, haben Sie die folgenden Möglichkeiten: 
– Erstellen Sie die Assembly, die die kompilierte reguläre Ausdrücke auf einem System enthält, die [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] anstelle von neueren Versionen.  
  
-Anstelle eines Aufrufs <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> und Abrufen des kompilierten regulären Ausdrucks aus einer Assembly an, entweder statisch oder-Instanz <see cref="T:System.Text.RegularExpressions.Regex" /> Methoden mit der <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> option beim Instanziieren einer <see cref="T:System.Text.RegularExpressions.Regex" /> Objekt oder einen regulären Ausdruck aufrufen musterabgleichsmethode.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Kompilierung und Wiederverwendung</related>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="public static string Escape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Escape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Escape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Escape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Escape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Escape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Die Eingabezeichenfolge mit dem zu konvertierenden Text.</param>
        <summary>Versieht einen minimalen Satz an Zeichen (\\, *, +, ?, |, {, [, (,), ^, $,., # und Leerzeichen) mit Escapezeichen, indem diese durch die jeweils entsprechende Escapesequenz ersetzt werden. Damit wird die Engine für reguläre Ausdrücke angewiesen, diese Zeichen als Literale statt als Metazeichen zu interpretieren.</summary>
        <returns>Eine Zeichenfolge, in der Metazeichen in die entsprechenden Escapecodes konvertiert wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Escape%2A> Konvertiert eine Zeichenfolge an, damit, dass die Engine für reguläre Ausdrücke Metazeichen interpretiert, die es als Zeichenliterale enthalten kann. Betrachten Sie beispielsweise einen regulären Ausdruck an, der entwickelt wurde, um Kommentare zu extrahieren, die vom gerade öffnende bzw. schließende Klammern ([und]) aus Text getrennt sind. Im folgenden Beispiel ist der reguläre Ausdruck "[(.*?)]" wird als eine Zeichenklasse interpretiert. Übereinstimmende Kommentare, die in den eingegebenen Text eingebettet, entspricht dem regulären Ausdruck an jede öffnende oder schließende Klammer ein, Punkte, Sternchen oder Fragezeichen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#1)]  
  
 Jedoch, wenn die öffnenden geschweiften Klammer mit Escapezeichen versehen werden, durch die Übergabe an die <xref:System.Text.RegularExpressions.Regex.Escape%2A> -Methode der reguläre Ausdruck ist erfolgreich, bei der Zuordnung von Kommentaren, die in der Eingabezeichenfolge eingebettet sind. Dies wird anhand des folgenden Beispiels veranschaulicht.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#2)]  
  
 In einem regulären Ausdruck, der mithilfe von statischen Text definiert ist, interpretiert werden soll, statt als Metazeichen Zeichen können mit Escapezeichen versehen werden abgrenzen, indem Sie mit einem umgekehrten Schrägstrich (\\) sowie als auch durch Aufrufen der <xref:System.Text.RegularExpressions.Regex.Escape%2A> Methode. In einem regulären Ausdruck, der definiert ist, dynamisch mit Zeichen, die nicht zur Entwurfszeit bekanntermaßen Aufrufen der <xref:System.Text.RegularExpressions.Regex.Escape%2A> Methode ist besonders wichtig, um sicherzustellen, dass die Engine für reguläre Ausdrücke einzelne Zeichen als Literale stattdessen interpretiert als Metazeichen.  
  
> [!NOTE]
>  Wenn ein Muster für reguläre Ausdrücke entweder das Nummernzeichen (#) oder die literalen Leerzeichen enthält, sie müssen mit Escapezeichen versehen werden, wenn der eingegebene Text analysiert wird, mit der <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> Option aktiviert ist.  
  
 Während der <xref:System.Text.RegularExpressions.Regex.Escape%2A> -Methode versieht gerade Klammer ([) öffnen und geschweifte Klammer ({)-Zeichen, es ist nicht mit Escapezeichen versehen die entsprechenden Zeichen schließen (] und}). In den meisten Fällen ist das Escapezeichen nicht erforderlich. Wenn eine schließende Klammer oder geschweiften Klammern nicht das entsprechende öffnende Zeichen vorangestellt ist, interpretiert die Engine für reguläre Ausdrücke wörtlich. Wenn eine öffnende Braket oder eine geschweifte Klammer als bei einem Metazeichen interpretiert wird, interpretiert die Engine für reguläre Ausdrücke die erste entsprechendes schließendes Zeichen als ein Metazeichen. Ist dies nicht das gewünschte Verhalten, die schließende Klammer oder geschweiften Klammer sollten das Escapezeichen vorangestellt Sie explizit den umgekehrten Schrägstrich (\\) Zeichen. Eine Veranschaulichung finden Sie im Beispielabschnitt.  
  
   
  
## Examples  
 Im folgende Beispiel werden Kommentare aus dem Text extrahiert. Es wird davon ausgegangen, dass die Kommentare begrenzt werden, indem Sie ein Kommentarsymbol Begin und eine End-Kommentarsymbol, das vom Benutzer ausgewählt ist. Da die Kommentarzeichen sind, wörtlich interpretiert werden sollen, werden sie zum Übergeben der <xref:System.Text.RegularExpressions.Regex.Escape%2A> Methode, um sicherzustellen, dass sie nicht als Metazeichen fehlinterpretiert werden können. Darüber hinaus überprüft das Beispiel explizit, ob das Ende Kommentarsymbol, die vom Benutzer eingegebene eine schließende Klammer (]) oder eine geschweifte Klammer (}). Wenn es sich handelt, einen umgekehrten Schrägstrich (\\) der Klammer oder geschweiften Klammern vorangestellt wird, so dass es buchstäblich interpretiert wird. Beachten Sie, die im Beispiel auch verwendet die <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> -Auflistung, um den Kommentar, anstatt den Kommentar zusammen mit der öffnenden und schließenden Kommentarsymbole anzuzeigen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
        <related type="Article" href="http://msdn.microsoft.com/library/f49cc9cc-db7d-4058-8b8a-422bc08b29b0">Escapezeichen in regulären Ausdrücken</related>
      </Docs>
    </Member>
    <Member MemberName="factory">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexRunnerFactory factory;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Text.RegularExpressions.RegexRunnerFactory factory" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.factory" />
      <MemberSignature Language="VB.NET" Value="Protected Friend factory As RegexRunnerFactory " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexRunnerFactory ^ factory;" />
      <MemberSignature Language="F#" Value="val mutable factory : System.Text.RegularExpressions.RegexRunnerFactory" Usage="System.Text.RegularExpressions.Regex.factory" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexRunnerFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Regex ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="regex.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNames">
      <MemberSignature Language="C#" Value="public string[] GetGroupNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetGroupNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetGroupNames();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNames : unit -&gt; string[]" Usage="regex.GetGroupNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Array der Namen von Erfassungsgruppen für den regulären Ausdruck zurück.</summary>
        <returns>Ein Zeichenfolgenarray von Gruppennamen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Auflistung von Gruppennamen enthält den Satz von Zeichenfolgen verwendet, um die Benennung von Erfassungsgruppen im Ausdruck. Erfassungsgruppen nicht explizit benannt werden, sie werden automatisch zugewiesen, selbst wenn numerische Namen ("0", "1", "2", "3" usw.). "0" benannte Gruppe stellt alle Text mit dem Muster des regulären Ausdrucks übereinstimmt. Nummerierte Gruppen explizit benannten Gruppen voraus, in der Auflistung und benannte Gruppen angezeigt, in der Reihenfolge, in der sie im Muster eines regulären Ausdrucks definiert sind.  
  
 Sie können die <xref:System.Array.Length%2A> Eigenschaft für das Array, das von dieser Methode, um zu bestimmen, die Anzahl der Gruppen in einem regulären Ausdruck zurückgegeben.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine allgemeine `ShowMatches` Methode, die die Namen von Gruppen für reguläre Ausdrücke und dem übereinstimmenden Text anzeigt.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/cs/getgroupnames1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/vb/getgroupnames1.vb#1)]  
  
 In diesem Fall ist das Muster des regulären Ausdrucks `\b(?<FirstWord>\w+)\s?((\w+)\s)*(?<LastWord>\w+)?(?<Punctuation>\p{Po})` richtet sich an einen einfachen Satz zu analysieren und die erste Wort, das letzte Wort und schließende Satzzeichen zu identifizieren. Die folgende Tabelle zeigt, wie das Muster des regulären Ausdrucks interpretiert werden:  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\b`|Der Vergleich beginnt an einer Wortgrenze.|  
|`(?<FirstWord>\w+)`|Übereinstimmung mit mindestens einem Wortzeichen. Dies ist die `FirstWord` benannte Gruppe.|  
|\s?|Sucht nach einer Übereinstimmung mit keinem oder einem Leerzeichen.|  
|(\w+)|Übereinstimmung mit mindestens einem Wortzeichen. Dies ist die zweite Erfassungsgruppe.|  
|\s|Entsprechung für ein Leerraumzeichen finden.|  
|((\w+)\s)*|Übereinstimmung mit NULL oder mehr Vorkommen einer oder mehreren Wortzeichen gefolgt von einem Leerzeichen. Dies ist die erste Erfassungsgruppe.|  
|(? \<LastWord > \w+)?|Übereinstimmung mit keinem oder einem Vorkommen von einem oder mehreren Wortzeichen. Dies ist die `LastWord` benannte Gruppe.|  
|(? \<Satzzeichen > \p{Po})|Übereinstimmung mit einem Zeichen, dessen Unicode-Kategorie, Interpunktionszeichen und ist, andere. Dies ist die `Punctuation` benannte Gruppe.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="http://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Gruppierungskonstrukte in regulären Ausdrücken</related>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNumbers">
      <MemberSignature Language="C#" Value="public int[] GetGroupNumbers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] GetGroupNumbers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNumbers () As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ GetGroupNumbers();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNumbers : unit -&gt; int[]" Usage="regex.GetGroupNumbers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Array der Nummern von Erfassungsgruppen zurück, die den Gruppennamen in einem Array entsprechen.</summary>
        <returns>Ein Ganzzahlarray der Gruppennummern.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unbenannte und benannte Erfassungsgruppen können durch Anzahl zugegriffen werden. Unbenannte Gruppen werden von links nach rechts beginnend mit 1 nummeriert. (Die Erfassungsgruppe an Index 0 (null) gibt die Übereinstimmung als Ganzes.)  Benannte Gruppen sind dann nummeriert von links nach rechts beginnend mit einer Zahl, der eins größer ist als die Anzahl unbenannter Erfassungsgruppen.  
  
 Verweisen auf eine Gruppe von der Anzahl anstelle der Zeichenfolgennamen bieten schnelleren Zugriff.  
  
   
  
## Examples  
 Das folgende Beispiel definiert einen regulären Ausdruck `\b((?<word>\w+)\s*)+(?<end>[.?!])`, entspricht einen Satz. Der reguläre Ausdruck umfasst drei Erfassungsgruppen: eine unbenannte Gruppe, die ein einzelnes Wort zusammen mit einem Leerzeichen erfasst, die dies durchführen können eine Gruppe namens `word` , die die einzelnen Wörter des Satzes; erfasst und eine Gruppe mit dem Namen `end` , die die Satzzeichen, die den Satz endet aufzeichnet. Im Beispiel wird die <xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A> -Methode zum Abrufen der Anzahl von allen erfassen gruppiert, und zeigt dann die erfasste Zeichenfolge. Darüber hinaus die <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> Methode wird verwendet, um anzugeben, ob eine bestimmte nummerierte Gruppe zu einer benannten Gruppe entspricht.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/cs/getgroupnumbers1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/vb/getgroupnumbers1.vb#1)]  
  
 Das Muster für reguläre Ausdrücke wird entsprechend der folgenden Tabelle interpretiert.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\b`|Der Vergleich beginnt an einer Wortgrenze.|  
|`(?<word>\w+)`|Übereinstimmung mit mindestens einem Wortzeichen, und weisen Sie die entsprechenden Zeichenfolgen zu einer Gruppe mit dem Namen `word`.|  
|`\s*`|Sucht nach 0 (null) oder mehr Leerzeichen.|  
|`((?<word>\w+)\s*)`|Weisen Sie die `word` gefolgt von einer Erfassungsgruppe erfasst Leerzeichen auf ersten erfassten Gruppe.|  
|`((?<word>\w+)\s*)+`|Übereinstimmung mit dem Muster einer oder mehrerer Wortzeichen gesucht, die Leerraumzeichen einmal oder mehrmals gefolgt werden soll.|  
|`(?<end>[.?!])`|Übereinstimmung mit einem Punkt, Fragezeichen oder Ausrufezeichen. Weisen Sie die übereinstimmenden Zeichen der `end` Erfassungsgruppe.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="http://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Gruppierungskonstrukte in regulären Ausdrücken</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNameFromNumber">
      <MemberSignature Language="C#" Value="public string GroupNameFromNumber (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GroupNameFromNumber(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNameFromNumber (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GroupNameFromNumber(int i);" />
      <MemberSignature Language="F#" Value="member this.GroupNameFromNumber : int -&gt; string" Usage="regex.GroupNameFromNumber i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Die Gruppennummer, die in den entsprechenden Gruppennamen konvertiert werden soll.</param>
        <summary>Ruft den Gruppennamen ab, der der angegebenen Gruppennummer entspricht.</summary>
        <returns>Eine Zeichenfolge, die den Gruppennamen enthält, der der angegebenen Gruppennummer zugeordnet ist. Wenn kein Gruppenname vorhanden ist, der <paramref name="i" /> entspricht, gibt die Methode <see cref="F:System.String.Empty" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Muster eines regulären Ausdrucks kann entweder benannte oder nummerierte Erfassungsgruppen enthalten, die Grenzen Teilausdrücke in eine Musterübereinstimmung. Nummerierte Gruppen sind von der Syntax begrenzt (*Teilausdruck*) und Zahlen, die basierend auf ihrer Reihenfolge im regulären Ausdruck zugewiesen. Benannte Gruppen werden durch die Syntax begrenzt (?`<` *Namen*`>`*Teilausdruck*) oder (? " *Namen*"*Teilausdruck*), wobei *Namen* ist der Name, anhand dessen der Teilausdruck identifiziert wird. (Weitere Informationen finden Sie unter [Gruppierungskonstrukte](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md).) Die <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> Methode identifiziert, sowohl für benannte Gruppen als auch für nummerierte Gruppen nach ihrer Ordinalposition im regulären Ausdruck. Die Ordnungsposition 0 (null) stellt immer den gesamten regulären Ausdruck dar. Alle nummerierten Gruppen werden dann gezählt, bevor Sie benannte Gruppen, unabhängig von ihrer tatsächlichen Position im Muster eines regulären Ausdrucks.  
  
 Wenn `i` ist die Anzahl einer benannten Gruppe, die Methode gibt den Namen der Gruppe zurück. Wenn `i` ist die Anzahl von einer unbenannten Gruppe wird die-Methode gibt eine Zeichenfolgendarstellung der Zahl zurück. Z. B. wenn `i` 1 ist, gibt die Methode "1" zurück. Wenn `i` ist nicht die Anzahl von einer Erfassungsgruppe ist, gibt die Methode zurück <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Wenn eine Musterübereinstimmung gefunden wird, der von dieser Methode zurückgegebene Wert kann dann verwendet werden zum Abrufen der <xref:System.Text.RegularExpressions.Group> -Objekt, aus die erfasste Gruppe darstellt. die <xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType> Eigenschaft. Die <xref:System.Text.RegularExpressions.GroupCollection> -Objekt zurück, die <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel definiert ein Muster für reguläre Ausdrücke, die eine Adresszeile, die mit einer US-Ortsnamen, zustandsname und Postleitzahl entspricht. Im Beispiel wird die <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> Methode zum Abrufen der Namen von Erfassungsgruppen. Dann wird diese Namen verwendet, um die entsprechenden erfassten Gruppen nach Übereinstimmungen abzurufen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/cs/groupnamefromnumberex.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/vb/groupnamefromnumberex.vb#1)]  
  
 Muster für reguläre Ausdrücke wird durch den folgenden Ausdruck definiert:  
  
 `(?<city>[A-Za-z\s]+), (?<state>[A-Za-z]{2}) (?<zip>\d{5}(-\d{4})?)`  
  
 Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`(?<city>[A-Za-z\s]+)`|Übereinstimmung mit mindestens Buchstaben oder Leerzeichen Zeichen. Weisen Sie diese erfasste Gruppe den Namen `city`.|  
|`,`|Übereinstimmung mit einem Komma (,), gefolgt von einem Leerzeichen.|  
|`(?<state>[A-Za-z]{2})`|Übereinstimmung mit zwei alphabetisches Zeichen. Weisen Sie diese erfasste Gruppe den Namen `state`. Diese Gruppe sollte ein Leerzeichen folgen.|  
|`(?<zip>\d{5}(-\d{4})?)`|Entsprechen Sie fünf Ziffern, gefolgt von entweder keinem oder einem Vorkommen von einem Bindestrich gefolgt von vier Ziffern an. Weisen Sie diese erfasste Gruppe den Namen `zip`.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
        <related type="Article" href="http://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Gruppierungskonstrukte</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNumberFromName">
      <MemberSignature Language="C#" Value="public int GroupNumberFromName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GroupNumberFromName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNumberFromName (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GroupNumberFromName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GroupNumberFromName : string -&gt; int" Usage="regex.GroupNumberFromName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Gruppenname, der in die entsprechende Gruppennummer konvertiert werden soll.</param>
        <summary>Gibt die Gruppennummer zurück, die dem angegebenen Gruppennamen entspricht.</summary>
        <returns>Die Gruppennummer, die dem angegebenen Gruppennamen entspricht, oder -1, wenn <paramref name="name" /> kein gültiger Gruppenname ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Muster eines regulären Ausdrucks kann entweder benannte oder nummerierte Erfassungsgruppen enthalten, die Grenzen Teilausdrücke in eine Musterübereinstimmung. Nummerierte Gruppen sind von der Syntax begrenzt (*Teilausdruck*) und Zahlen, die basierend auf ihrer Reihenfolge im regulären Ausdruck zugewiesen. Benannte Gruppen werden durch die Syntax begrenzt (?`<` *Namen*`>`*Teilausdruck*) oder (? " *Namen*"*Teilausdruck*), wobei *Namen* ist der Name, anhand dessen der Teilausdruck identifiziert wird. (Weitere Informationen finden Sie unter [Gruppierungskonstrukte](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md).) Die <xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A> Methode identifiziert, sowohl für benannte Gruppen als auch für nummerierte Gruppen nach ihrer Ordinalposition im regulären Ausdruck. Die Ordnungsposition 0 (null) stellt immer den gesamten regulären Ausdruck dar. Alle nummerierten Gruppen werden dann gezählt, bevor Sie benannte Gruppen, unabhängig von ihrer tatsächlichen Position im Muster eines regulären Ausdrucks.  
  
 Wenn `name` die angegebene Zeichenfolgendarstellung einer Gruppennummer, die im Muster eines regulären Ausdrucks, der Rückgabe der Methode vorhanden ist, die Zahl ist. Wenn `name` entspricht einer benannten Erfassungsgruppe, die im Muster für reguläre Ausdrücke vorhanden ist, gibt die Methode die entsprechende Anzahl. Der Vergleich `name` Name für die Gruppe ist Groß-/Kleinschreibung beachtet. Wenn `name` entspricht nicht der Name einer Erfassungsgruppe oder die Zeichenfolgendarstellung für die Nummer einer Erfassungsgruppe, die Methode gibt-1 zurück.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
        <related type="Article" href="http://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Gruppierungskonstrukte</related>
      </Docs>
    </Member>
    <Member MemberName="InfiniteMatchTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass bei einem Mustervergleichsvorgang kein Timeout angewendet werden sollte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Klasse, Konstruktor und eine Reihe von statischen übereinstimmende Methoden verwenden die <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> -Konstante, um anzugeben, dass der Versuch, eine Musterübereinstimmung finden kein Timeout haben sollte.  
  
> [!WARNING]
>  Festlegen der Timeoutwert für die Engine für reguläre Ausdrücke auf <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> kann dazu führen, dass reguläre Ausdrücke, die übermäßige rückverfolgung angezeigt werden, nicht mehr reagiert, bei der Verarbeitung von Text, der fast Muster des regulären Ausdrucks übereinstimmt. Wenn Sie Timeouts deaktivieren, sollten Sie sicherstellen, dass der reguläre Ausdruck nicht auf eine übermäßige rückverfolgung angewiesen ist und es Text verarbeitet, der fast mit das Muster eines regulären Ausdrucks übereinstimmt.  
>   
>  Weitere Informationen zur Behandlung der rückverfolgung finden Sie unter [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 Die <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> Konstante kann angegeben werden, als Wert für die `matchTimeout` Argument der folgenden Elemente:  
  
-   <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.RegexCompilationInfo.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.String%2CSystem.String%2CSystem.Boolean%2CSystem.TimeSpan%29?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      </Docs>
    </Member>
    <Member MemberName="InitializeReferences">
      <MemberSignature Language="C#" Value="protected void InitializeReferences ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeReferences() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.InitializeReferences" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeReferences ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeReferences();" />
      <MemberSignature Language="F#" Value="member this.InitializeReferences : unit -&gt; unit" Usage="regex.InitializeReferences " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Verweise wurden bereits initialisiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="internalMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.TimeSpan internalMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend internalMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="protected public: TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="F#" Value="val mutable internalMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.OptionalField(VersionAdded=2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Die maximale Zeit, die ein Mustervergleichsvorgang ausgeführt werden kann, bevor des Timeout eintritt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsMatch">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, ob der reguläre Ausdruck eine Übereinstimmung in der Eingabezeichenfolge findet.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string -&gt; bool" Usage="regex.IsMatch input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <summary>Gibt an, ob der im <see cref="T:System.Text.RegularExpressions.Regex" />-Konstruktor angegebene reguläre Ausdruck eine Übereinstimmung in einer angegebenen Eingabezeichenfolge findet.</summary>
        <returns>
          <see langword="true" />, wenn der reguläre Ausdruck eine Übereinstimmung findet, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Methode wird normalerweise verwendet, um eine Zeichenfolge zu überprüfen, oder stellen Sie sicher, dass eine Zeichenfolge zu einem bestimmten Muster entsprechen, ohne die Zeichenfolge für eine nachfolgende Änderung abzurufen. Wenn Sie bestimmen, ob eine oder mehrere Zeichenfolgen Muster eines regulären Ausdrucks übereinstimmen, und klicken Sie dann für die Bearbeitung von nachfolgenden Aufruf abrufen möchten die <xref:System.Text.RegularExpressions.Regex.Match%2A> oder <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme ausgelöst, wenn die Ausführungszeit von den entsprechenden Vorgang das Timeoutintervall gemäß überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie ein Timeoutintervall nicht festlegen, wenn Sie den Konstruktor aufrufen, wird die Ausnahme ausgelöst, wenn der Vorgang alle für die Anwendungsdomäne festgelegt wird, in dem Timeoutwert überschreitet die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> Methode, um zu bestimmen, ob eine Zeichenfolge eine gültige Teilenummer. Der reguläre Ausdruck wird davon ausgegangen, dass die Teilenummer ein bestimmtes Format hat, das besteht aus drei Gruppen von Zeichen, die durch Bindestriche getrennt sind. Die erste Gruppe, die vier Zeichen enthält, muss aus einem alphanumerischen Zeichen gefolgt von zwei numerischen Zeichen gefolgt von einem alphanumerischen Zeichen bestehen. Die zweite Gruppe, die aus drei Zeichen besteht, muss numerisch sein. Die dritte Gruppe, die aus vier Zeichen besteht, müssen drei numerische Zeichen gefolgt von einem alphanumerischen Zeichen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch2.vb#2)]  
  
 Das Muster des regulären Ausdrucks lautet:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`^`|Beginnt den Vergleich am Anfang der Zeile.|  
|`[a-zA-Z0-9]`|Ein einzelnes alphabetisches Zeichen übereinstimmen (`a` über `z` oder `A` über `Z`) oder ein numerisches Zeichen.|  
|`\d{2}`|Übereinstimmung mit zwei numerischen Zeichen.|  
|`[a-zA-Z0-9]`|Ein einzelnes alphabetisches Zeichen übereinstimmen (`a` über `z` oder `A` über `Z`) oder ein numerisches Zeichen.|  
|`-`|Entsprechung für einen Bindestrich finden.|  
|`\d{3}`|Übereinstimmung mit genau drei numerischen Zeichen.|  
|`(-\d{3}){2}`|Suchen von einem Bindestrich gefolgt von drei numerische Zeichen und Übereinstimmung mit zwei Vorkommen dieses Musters.|  
|`[a-zA-Z0-9]`|Ein einzelnes alphabetisches Zeichen übereinstimmen (`a` über `z` oder `A` über `Z`) oder ein numerisches Zeichen.|  
|`$`|Ende des Abgleichs am Ende der Zeile.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String, startat As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string * int -&gt; bool" Usage="regex.IsMatch (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="startat">Die Zeichenposition, an der mit der Suche begonnen werden soll.</param>
        <summary>Gibt an, ob der im <see cref="T:System.Text.RegularExpressions.Regex" />-Konstruktor angegebene reguläre Ausdruck ab der angegebenen Anfangsposition eine Übereinstimmung in der angegebenen Eingabezeichenfolge findet.</summary>
        <returns>
          <see langword="true" />, wenn der reguläre Ausdruck eine Übereinstimmung findet, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Methode wird normalerweise verwendet, um eine Zeichenfolge zu überprüfen, oder stellen Sie sicher, dass eine Zeichenfolge zu einem bestimmten Muster entsprechen, ohne die Zeichenfolge für eine nachfolgende Änderung abzurufen. Wenn Sie bestimmen, ob eine oder mehrere Zeichenfolgen Muster eines regulären Ausdrucks übereinstimmen, und klicken Sie dann für die Bearbeitung von nachfolgenden Aufruf abrufen möchten die <xref:System.Text.RegularExpressions.Regex.Match%2A> oder <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme ausgelöst, wenn die Ausführungszeit von den entsprechenden Vorgang das Timeoutintervall gemäß überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie ein Timeoutintervall nicht festlegen, wenn Sie den Konstruktor aufrufen, wird die Ausnahme ausgelöst, wenn der Vorgang alle für die Anwendungsdomäne festgelegt wird, in dem Timeoutwert überschreitet die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> Methode, um zu bestimmen, ob eine Zeichenfolge eine gültige Teilenummer. Es sucht nach einer Teilenummer, die einen Doppelpunkt (:) in einer Zeichenfolge folgt. Die <xref:System.String.IndexOf%28System.Char%29> Methode wird verwendet, um die Position des den Doppelpunkt, zu bestimmen, die dann an die <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> Methode. Der reguläre Ausdruck wird davon ausgegangen, dass die Teilenummer ein bestimmtes Format hat, das besteht aus drei Gruppen von Zeichen, die durch Bindestriche getrennt sind. Die erste Gruppe, die vier Zeichen enthält, muss aus einem alphanumerischen Zeichen gefolgt von zwei numerischen Zeichen gefolgt von einem alphanumerischen Zeichen bestehen. Die zweite Gruppe, die aus drei Zeichen besteht, muss numerisch sein. Die dritte Gruppe, die aus vier Zeichen besteht, müssen drei numerische Zeichen gefolgt von einem alphanumerischen Zeichen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch3.vb#3)]  
  
 Das Muster des regulären Ausdrucks lautet:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`[a-zA-Z0-9]`|Ein einzelnes alphabetisches Zeichen übereinstimmen (`a` über `z` oder `A` über `Z`) oder ein numerisches Zeichen.|  
|`\d{2}`|Übereinstimmung mit zwei numerischen Zeichen.|  
|`[a-zA-Z0-9]`|Ein einzelnes alphabetisches Zeichen übereinstimmen (`a` über `z` oder `A` über `Z`) oder ein numerisches Zeichen.|  
|`-`|Entsprechung für einen Bindestrich finden.|  
|`\d{3}`|Übereinstimmung mit genau drei numerischen Zeichen.|  
|`(-\d{3}){2}`|Suchen von einem Bindestrich gefolgt von drei numerische Zeichen und Übereinstimmung mit zwei Vorkommen dieses Musters.|  
|`[a-zA-Z0-9]`|Ein einzelnes alphabetisches Zeichen übereinstimmen (`a` über `z` oder `A` über `Z`) oder ein numerisches Zeichen.|  
|`$`|Ende des Abgleichs am Ende der Zeile.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> ist kleiner als 0 (null) oder größer als die Länge von <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <summary>Gibt an, ob der reguläre Ausdruck eine Übereinstimmung in der angegebenen Eingabezeichenfolge findet.</summary>
        <returns>
          <see langword="true" />, wenn der reguläre Ausdruck eine Übereinstimmung findet, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Methode wird normalerweise verwendet, um eine Zeichenfolge zu überprüfen, oder stellen Sie sicher, dass eine Zeichenfolge zu einem bestimmten Muster entsprechen, ohne die Zeichenfolge für eine nachfolgende Änderung abzurufen. Wenn Sie bestimmen, ob eine oder mehrere Zeichenfolgen Muster eines regulären Ausdrucks übereinstimmen, und klicken Sie dann für die Bearbeitung von nachfolgenden Aufruf abrufen möchten die <xref:System.Text.RegularExpressions.Regex.Match%2A> oder <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode.  
  
 Die statische <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> Methode entspricht dem Erstellen einer <xref:System.Text.RegularExpressions.Regex> Objekt mit dem Muster eines regulären Ausdrucks gemäß `pattern` und das Aufrufen der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> Instanzmethode. Dieses Muster für reguläre Ausdrücke wird durch die Engine für reguläre Ausdrücke für einen schnellen Abruf zwischengespeichert.  
  
 Die `pattern` -Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme ausgelöst, wenn die Ausführungszeit von den entsprechenden Vorgang überschreitet das Timeoutintervall angegeben, für die Anwendungsdomäne, in dem die Methode aufgerufen wird. Wenn kein Timeout in der Anwendungsdomäne definiert ist, oder der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> Methode, um zu bestimmen, ob eine Zeichenfolge eine gültige Teilenummer. Der reguläre Ausdruck wird davon ausgegangen, dass die Teilenummer ein bestimmtes Format hat, das besteht aus drei Gruppen von Zeichen, die durch Bindestriche getrennt sind. Die erste Gruppe, die vier Zeichen enthält, muss aus einem alphanumerischen Zeichen gefolgt von zwei numerischen Zeichen gefolgt von einem alphanumerischen Zeichen bestehen. Die zweite Gruppe, die aus drei Zeichen besteht, muss numerisch sein. Die dritte Gruppe, die aus vier Zeichen besteht, müssen drei numerische Zeichen gefolgt von einem alphanumerischen Zeichen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch1.vb#1)]  
  
 Das Muster des regulären Ausdrucks lautet:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`^`|Beginnt den Vergleich am Anfang der Zeile.|  
|`[a-zA-Z0-9]`|Ein einzelnes alphabetisches Zeichen übereinstimmen (`a` über `z` oder `A` über `Z`) oder ein numerisches Zeichen.|  
|`\d{2}`|Übereinstimmung mit zwei numerischen Zeichen.|  
|`[a-zA-Z0-9]`|Ein einzelnes alphabetisches Zeichen übereinstimmen (`a` über `z` oder `A` über `Z`) oder ein numerisches Zeichen.|  
|`-`|Entsprechung für einen Bindestrich finden.|  
|`\d{3}`|Übereinstimmung mit genau drei numerischen Zeichen.|  
|`(-\d{3}){2}`|Suchen von einem Bindestrich gefolgt von drei numerische Zeichen und Übereinstimmung mit zwei Vorkommen dieses Musters.|  
|`[a-zA-Z0-9]`|Ein einzelnes alphabetisches Zeichen übereinstimmen (`a` über `z` oder `A` über `Z`) oder ein numerisches Zeichen.|  
|`$`|Ende des Abgleichs am Ende der Zeile.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage">
          <para>Diese-Methode ein Timeout, nach einem bestimmten Zeitintervall, das gleich der Standardwert für das Timeout der Anwendungsdomäne, in dem die Methode aufgerufen wird. Wenn Sie ein Timeoutwert für die Anwendungsdomäne, der Wert nicht definiert wurde <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das Timeout, die Methode verhindert werden. Ist die empfohlene statische Methode für die Überprüfung einer Musterübereinstimmung <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, mit dem Sie das Timeoutintervall festlegen.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <summary>Gibt an, ob der angegebene reguläre Ausdruck unter Verwendung der angegebenen Übereinstimmungsoptionen eine Übereinstimmung in der angegebenen Eingabezeichenfolge findet.</summary>
        <returns>
          <see langword="true" />, wenn der reguläre Ausdruck eine Übereinstimmung findet, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Methode wird normalerweise verwendet, um eine Zeichenfolge zu überprüfen, oder stellen Sie sicher, dass eine Zeichenfolge zu einem bestimmten Muster entsprechen, ohne die Zeichenfolge für eine nachfolgende Änderung abzurufen. Wenn Sie bestimmen, ob eine oder mehrere Zeichenfolgen Muster eines regulären Ausdrucks übereinstimmen, und klicken Sie dann für die Bearbeitung von nachfolgenden Aufruf abrufen möchten die <xref:System.Text.RegularExpressions.Regex.Match%2A> oder <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode.  
  
 Die statische <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Methode entspricht dem Erstellen einer <xref:System.Text.RegularExpressions.Regex> Objekt mit dem Muster eines regulären Ausdrucks gemäß `pattern` und den angegebenen Optionen für reguläre Ausdrücke `options` und das Aufrufen der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> Instanz -Methode. Dieses Muster für reguläre Ausdrücke wird durch die Engine für reguläre Ausdrücke für einen schnellen Abruf zwischengespeichert.  
  
 Die `pattern` -Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme ausgelöst, wenn die Ausführungszeit von den entsprechenden Vorgang überschreitet das Timeoutintervall angegeben, für die Anwendungsdomäne, in dem die Methode aufgerufen wird. Wenn kein Timeout in der Anwendungsdomäne definiert ist, oder der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> Methode, um zu bestimmen, ob eine Zeichenfolge eine gültige Teilenummer. Der reguläre Ausdruck wird davon ausgegangen, dass die Teilenummer ein bestimmtes Format hat, das besteht aus drei Gruppen von Zeichen, die durch Bindestriche getrennt sind. Die erste Gruppe, die vier Zeichen enthält, muss aus einem alphanumerischen Zeichen gefolgt von zwei numerischen Zeichen gefolgt von einem alphanumerischen Zeichen bestehen. Die zweite Gruppe, die aus drei Zeichen besteht, muss numerisch sein. Die dritte Gruppe, die aus vier Zeichen besteht, müssen drei numerische Zeichen gefolgt von einem alphanumerischen Zeichen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch4.vb#4)]  
  
 Das Muster des regulären Ausdrucks lautet:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`^`|Beginnt die Suche am Anfang der Zeichenfolge.|  
|`[A-Z0-9]`|Übereinstimmung mit beliebigem einzelne alphabetische Zeichen aus `A` über `Z`, oder einem beliebigen numerischen Zeichen.|  
|`\d{2}`|Übereinstimmung mit zwei numerischen Zeichen.|  
|`[A-Z0-9]`|Übereinstimmung mit beliebigem einzelne alphabetische Zeichen aus `A` über `Z`, oder einem beliebigen numerischen Zeichen.|  
|`-`|Entsprechung für einen Bindestrich finden.|  
|`\d{3}`|Übereinstimmung mit genau drei numerischen Zeichen.|  
|`(-\d{3}){2}`|Suchen von einem Bindestrich gefolgt von drei Ziffern, und zwei Vorkommen dieses Muster übereinstimmen..|  
|`[A-Z0-9]`|Übereinstimmung mit beliebigem einzelne alphabetische Zeichen aus `A` über `Z`, oder einem beliebigen numerischen Zeichen.|  
|`$`|Beendet die Suche am Ende der Zeichenfolge.|  
  
 Aufrufen der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> -Methode mit dem `options` Parametersatz zu <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> ist gleichbedeutend mit den folgenden regulären Ausdruck definieren:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Vergleich finden Sie im Beispiel für die <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> ist kein gültiger <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Wert.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage">
          <para>Diese-Methode ein Timeout, nach einem bestimmten Zeitintervall, das gleich der Standardwert für das Timeout der Anwendungsdomäne, in dem sie aufgerufen wird. Wenn Sie ein Timeoutwert für die Anwendungsdomäne, der Wert nicht definiert wurde <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das Timeout, die Methode verhindert werden. Ist die empfohlene statische Methode für die Überprüfung einer Musterübereinstimmung <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, mit dem Sie das Timeoutintervall festlegen.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <param name="matchTimeout">Ein Timeoutintervall oder <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das angibt, dass die Methode kein Timeout haben sollte.</param>
        <summary>Gibt an, ob der angegebene reguläre Ausdruck unter Verwendung der angegebenen Übereinstimmungsoptionen und des angegebenen Timeoutintervalls eine Übereinstimmung in der angegebenen Eingabezeichenfolge findet.</summary>
        <returns>
          <see langword="true" />, wenn der reguläre Ausdruck eine Übereinstimmung findet, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> Methode wird normalerweise verwendet, um eine Zeichenfolge zu überprüfen, oder stellen Sie sicher, dass eine Zeichenfolge zu einem bestimmten Muster entsprechen, ohne die Zeichenfolge für eine nachfolgende Änderung abzurufen. Wenn Sie bestimmen, ob eine oder mehrere Zeichenfolgen Muster eines regulären Ausdrucks übereinstimmen, und klicken Sie dann für die Bearbeitung von nachfolgenden Aufruf abrufen möchten die <xref:System.Text.RegularExpressions.Regex.Match%2A> oder <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode.  
  
 Die statische <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Methode entspricht dem Erstellen einer <xref:System.Text.RegularExpressions.Regex> Objekt mit dem Muster eines regulären Ausdrucks gemäß `pattern` und den angegebenen Optionen für reguläre Ausdrücke `options` und das Aufrufen der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> Instanz -Methode. Dieses Muster für reguläre Ausdrücke wird durch die Engine für reguläre Ausdrücke für einen schnellen Abruf zwischengespeichert.  
  
 Die `pattern` -Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die `matchTimeout` Parameter gibt an, wie lange ein Musterabgleich Methode sollten versuchen, eine Übereinstimmung gefunden wird, bevor ein Timeout eintritt. Ein Timeoutintervall festlegen wird verhindert, dass reguläre Ausdrücke, die übermäßige rückverfolgung angezeigt werden, nicht mehr reagiert, wenn diese Eingaben verarbeiten, die in der Nähe von Übereinstimmungen enthält. Weitere Informationen finden Sie unter [bewährte Methoden für reguläre Ausdrücke](~/docs/standard/base-types/best-practices.md) und [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Wenn Sie in dieses Zeitintervalls keine Übereinstimmung gefunden wird, löst die Methode eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme. `matchTimeout` überschreibt alle Standard-Timeoutwert, der definiert, die für die Anwendungsdomäne, in der die Methode ausgeführt wird.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Methode, um zu bestimmen, ob eine Zeichenfolge eine gültige Teilenummer. Der reguläre Ausdruck wird davon ausgegangen, dass die Teilenummer ein bestimmtes Format hat, das besteht aus drei Gruppen von Zeichen, die durch Bindestriche getrennt sind. Die erste Gruppe, die vier Zeichen enthält, muss aus einem alphanumerischen Zeichen gefolgt von zwei numerischen Zeichen gefolgt von einem alphanumerischen Zeichen bestehen. Die zweite Gruppe, die aus drei Zeichen besteht, muss numerisch sein. Die dritte Gruppe, die aus vier Zeichen besteht, müssen drei numerische Zeichen gefolgt von einem alphanumerischen Zeichen. Übereinstimmende Muster für reguläre Ausdrücke sollten die Anpassungen minimale durchsucht die Eingabezeichenfolge, damit die Methode mit einem Timeoutintervall von 500 Millisekunden festlegt.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch5.vb#5)]  
  
 Das Muster des regulären Ausdrucks lautet:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`^`|Beginnt die Suche am Anfang der Zeichenfolge.|  
|`[A-Z0-9]`|Übereinstimmung mit beliebigem einzelne alphabetische Zeichen aus `A` über `Z`, oder einem beliebigen numerischen Zeichen.|  
|`\d{2}`|Übereinstimmung mit zwei numerischen Zeichen.|  
|`[A-Z0-9]`|Übereinstimmung mit beliebigem einzelne alphabetische Zeichen aus `A` über `Z`, oder einem beliebigen numerischen Zeichen.|  
|`-`|Entsprechung für einen Bindestrich finden.|  
|`\d{3}`|Übereinstimmung mit genau drei numerischen Zeichen.|  
|`(-\d{3}){2}`|Suchen von einem Bindestrich gefolgt von drei numerische Zeichen und Übereinstimmung mit zwei Vorkommen dieses Musters.|  
|`[A-Z0-9]`|Übereinstimmung mit beliebigem einzelne alphabetische Zeichen aus `A` über `Z`, oder einem beliebigen numerischen Zeichen.|  
|`$`|Beendet die Suche am Ende der Zeichenfolge.|  
  
 Aufrufen der <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> -Methode mit dem `options` Parametersatz zu <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> ist gleichbedeutend mit den folgenden regulären Ausdruck definieren:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Vergleich finden Sie im Beispiel für die <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> ist kein gültiger <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Wert.  
  
- oder -  
 <paramref name="matchTimeout" /> ist negativ, 0 oder größer als ca. 24 Tage.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten.</exception>
        <block subset="none" type="usage">
          <para>Es wird empfohlen, Sie legen die <paramref name="matchTimeout" /> Parameter auf einen geeigneten Wert, z. B. zwei Sekunden. Wenn Sie Timeouts werden, indem deaktiviert <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, die Engine für reguläre Ausdrücke bietet eine etwas bessere Leistung. Allerdings sollten Sie Timeouts nur unter folgenden Bedingungen deaktivieren: 
– Wenn die Eingabe verarbeitet, die von einem regulären Ausdruck aus einer bekannten und vertrauenswürdigen Quelle stammt oder besteht aus statischen Text. Dies schließt Text, der vom Benutzer eingegebene dynamisch wurde.  
  
– Wenn Sie Muster für reguläre Ausdrücke gründlich getestet wurde, um sicherzustellen, dass er effizient verarbeitet übereinstimmt, nicht-Übereinstimmungen und Naher entspricht.  
  
– Wenn Muster für reguläre Ausdrücke keine Language-Elemente enthält, die bekannt sind, um eine übermäßige rückverfolgung bei der Verarbeitung einer Nahen Übereinstimmung zu verursachen.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Match">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Durchsucht eine Eingabezeichenfolge nach einer Teilzeichenfolge, die mit einem Muster eines regulären Ausdrucks übereinstimmt, und gibt das erste Vorkommen als einzelnes <see cref="T:System.Text.RegularExpressions.Match" />-Objekt zurück.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Match : string -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <summary>Durchsucht die angegebene Eingabezeichenfolge nach dem ersten Vorkommen des im <see cref="T:System.Text.RegularExpressions.Regex" />-Konstruktor angegebenen regulären Ausdrucks.</summary>
        <returns>Ein Objekt, das Informationen zur Übereinstimmung enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> Methode gibt die erste Teilzeichenfolge zurück, die Muster eines regulären Ausdrucks in einer Eingabezeichenfolge entspricht. Informationen, die Sprachelemente, die zum Erstellen des Muster eines regulären Ausdrucks verwendet wird, finden Sie unter [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Sie können bestimmen, ob das Muster für reguläre Ausdrücke in der Eingabezeichenfolge gefunden wurde, indem der Wert des zurückgegebenen überprüft <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Group.Success%2A> Eigenschaft. Wenn eine Übereinstimmung gefunden wird, die zurückgegebene <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Capture.Value%2A> Eigenschaft enthält die Teilzeichenfolge aus `input` , die Muster des regulären Ausdrucks übereinstimmt. Wenn keine Übereinstimmung gefunden wird, wird der Wert ist <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Diese Methode gibt die erste Teilzeichenfolge in `input` , die Muster des regulären Ausdrucks übereinstimmt. Sie können die nachfolgende Übereinstimmungen abrufen, indem Sie durch wiederholtes Aufrufen das zurückgegebene <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> Methode. Sie können auch alle Übereinstimmungen in einem einzelnen Methodenaufruf abrufen, durch den Aufruf der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> Methode.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme ausgelöst, wenn die Ausführungszeit von den entsprechenden Vorgang das Timeoutintervall gemäß überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie ein Timeoutintervall nicht festlegen, wenn Sie den Konstruktor aufrufen, wird die Ausnahme ausgelöst, wenn der Vorgang alle für die Anwendungsdomäne festgelegt wird, in dem Timeoutwert überschreitet die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Das folgende Beispiel findet Muster für reguläre Ausdrücke in einer Zeichenfolge entspricht und anschließend eine Liste der übereinstimmenden Gruppen, erfasst und Capture-Positionen.  
  
 [!code-cpp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp#8)]
 [!code-csharp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs#8)]
 [!code-vb[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb#8)]  
  
 Muster für reguläre Ausdrücke `(\w+)\s+(car)` Vorkommen des Worts "Car" mit dem Wort, das ihm vorausgeht. Es wird entsprechend in der folgenden Tabelle interpretiert.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`(\w+)`|Übereinstimmung mit mindestens einem Wortzeichen. Dies ist die erste Erfassungsgruppe.|  
|`\s+`|Übereinstimmung mit ein oder mehrere Leerzeichen Zeichen.|  
|(PKW)|Mit die literale Zeichenfolge "Car" übereinstimmen. Dies ist die zweite Erfassungsgruppe.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, startat As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="startat">Die nullbasierte Zeichenposition, an der mit der Suche begonnen werden soll.</param>
        <summary>Durchsucht die Eingabezeichenfolge nach dem ersten Vorkommen eines regulären Ausdrucks ab der angegebenen Anfangsposition in der Zeichenfolge.</summary>
        <returns>Ein Objekt, das Informationen zur Übereinstimmung enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> Methode gibt die erste Teilzeichenfolge, die ein Muster für reguläre Ausdrücke ab, um oder nach entspricht der `startat` Position in einer Eingabezeichenfolge Zeichen. Informationen, die Sprachelemente, die zum Erstellen des Muster eines regulären Ausdrucks verwendet wird, finden Sie unter [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Muster für reguläre Ausdrücke für die die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> Methode durchsucht wird durch den Aufruf eines definiert die <xref:System.Text.RegularExpressions.Regex> Klassenkonstruktoren. Weitere Informationen zu den Elementen, die ein Muster für reguläre Ausdrücke bilden können, finden Sie unter [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Sie können optional die Position des ersten in der Zeichenfolge angeben, mit der `startat` Parameter. Wenn die Engine für reguläre Ausdrücke von links nach rechts (Standard) analysiert wird, die übereinstimmen und die Überprüfung verschieben rightward, beginnend ab der Zeichen im angegebenen `startat`. Wenn analysiert die Engine für reguläre Ausdrücke von rechts nach links (wenn Muster für reguläre Ausdrücke erstellt wird, mit der <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> Option), der Übereinstimmung und die Überprüfung in die entgegengesetzte Richtung zu verschieben, und beginnen mit dem Zeichen am `startat` -1. Wenn Sie keine Position des ersten angeben, wird die Suche beginnt, den Standardwert `startat` Position. Wenn der reguläre Ausdruck von links nach rechts und von der Standardeinstellung sucht `startat` Position befindet sich am linken Ende `input`; wenn er sucht, von rechts nach links ist, wird der Standardwert `startat` Position befindet sich am rechten Ende `input`.  
  
 Wenn eine Übereinstimmung zu beschränken, damit sie an einer bestimmten Zeichenposition in der Zeichenfolge beginnt und die Engine für reguläre Ausdrücke der Rest der Zeichenfolge nach einer Übereinstimmung nicht überprüft werden sollen, Verankern des regulären Ausdrucks mit einem `\G` (auf einem von links nach rechts nach links Muster oder rechts für rechts-nach-links-Muster). Dadurch wird die Übereinstimmung, sodass sie genau bei beginnen muss `startat`.  
  
 Sie können bestimmen, ob das Muster für reguläre Ausdrücke in der Eingabezeichenfolge gefunden wurde, indem der Wert des zurückgegebenen überprüft <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Group.Success%2A> Eigenschaft. Wenn eine Übereinstimmung gefunden wird, die zurückgegebene <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Capture.Value%2A> Eigenschaft enthält die Teilzeichenfolge aus `input` , die Muster des regulären Ausdrucks übereinstimmt. Wenn keine Übereinstimmung gefunden wird, wird der Wert ist <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Diese Methode gibt die erste Teilzeichenfolge gefunden wird, um oder nach der `startat` Zeichenposition in `input` , die Muster des regulären Ausdrucks übereinstimmt. Sie können die nachfolgende Übereinstimmungen abrufen, indem Sie durch wiederholtes Aufrufen das zurückgegebene <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> Methode. Sie können auch alle Übereinstimmungen in einem einzelnen Methodenaufruf abrufen, durch den Aufruf der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> Methode.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme ausgelöst, wenn die Ausführungszeit von den entsprechenden Vorgang das Timeoutintervall gemäß überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie ein Timeoutintervall nicht festlegen, wenn Sie den Konstruktor aufrufen, wird die Ausnahme ausgelöst, wenn der Vorgang überschreitet die maximal alle Timeoutwert für die Anwendungsdomäne, in dem hergestellt. die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> ist kleiner als 0 (null) oder größer als die Länge von <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Match : string * string -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <summary>Durchsucht die angegebene Eingabezeichenfolge nach dem ersten Vorkommen des angegebenen regulären Ausdrucks.</summary>
        <returns>Ein Objekt, das Informationen zur Übereinstimmung enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> Methode gibt die erste Teilzeichenfolge zurück, die Muster eines regulären Ausdrucks in einer Eingabezeichenfolge entspricht. Informationen, die Sprachelemente, die zum Erstellen des Muster eines regulären Ausdrucks verwendet wird, finden Sie unter [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die statische <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> Methode entspricht dem Erstellen einer <xref:System.Text.RegularExpressions.Regex> Objekt mit dem angegebenen regulären Ausdrucksmuster und dem Aufrufen der <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> Methode. In diesem Fall wird die Engine für reguläre Ausdrücke das Muster für reguläre Ausdrücke zwischengespeichert.  
  
 Die `pattern` -Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Sie können bestimmen, ob das Muster für reguläre Ausdrücke in der Eingabezeichenfolge gefunden wurde, indem der Wert des zurückgegebenen überprüft <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Group.Success%2A> Eigenschaft. Wenn eine Übereinstimmung gefunden wird, die zurückgegebene <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Capture.Value%2A> Eigenschaft enthält die Teilzeichenfolge aus `input` , die Muster des regulären Ausdrucks übereinstimmt. Wenn keine Übereinstimmung gefunden wird, wird der Wert ist <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Diese Methode gibt die erste Teilzeichenfolge in `input` , die Muster des regulären Ausdrucks übereinstimmt. Sie können die nachfolgende Übereinstimmungen abrufen, indem Sie durch wiederholtes Aufrufen das zurückgegebene <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> Methode. Sie können auch alle Übereinstimmungen in einem einzelnen Methodenaufruf abrufen, durch den Aufruf der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> Methode.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme ausgelöst, wenn die Ausführungszeit von den entsprechenden Vorgang überschreitet das Timeoutintervall angegeben, für die Anwendungsdomäne, in dem die Methode aufgerufen wird. Wenn kein Timeout in der Anwendungsdomäne definiert ist, oder der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> Methode, um das erste Wort zu suchen, die mindestens eins enthält `z` Zeichen, und ruft dann die <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> Methode, um zusätzlichen Übereinstimmungen gefunden.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match1.vb#1)]  
  
 Das Muster für reguläre Ausdrücke `\b\w*z+\w*\b` wird entsprechend der folgenden Tabelle interpretiert:  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\b`|Der Vergleich beginnt an einer Wortgrenze.|  
|`\w*`|Entspricht 0 (null), 1 oder mehr Wortzeichen.|  
|`z+`|Übereinstimmung mit mindestens der `z` Zeichen.|  
|`\w*`|Entspricht 0 (null), 1 oder mehr Wortzeichen.|  
|`\b`|Der Vergleich endet an einer Wortgrenze.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage">
          <para>Diese-Methode ein Timeout, nach einem bestimmten Zeitintervall, das gleich der Standardwert für das Timeout der Anwendungsdomäne, in dem sie aufgerufen wird. Wenn Sie ein Timeoutwert für die Anwendungsdomäne, der Wert nicht definiert wurde <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das Timeout, die Methode verhindert werden. Ist die empfohlene statische Methode zum Abrufen von eine Musterübereinstimmung <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, mit dem Sie das Timeoutintervall festlegen.</para>
        </block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int beginning, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 beginning, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, beginning As Integer, length As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int beginning, int length);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, beginning, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="beginning" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="beginning">Die nullbasierte Zeichenposition in der Eingabezeichenfolge, die die am weitesten links stehende Position definiert, die gesucht werden soll.</param>
        <param name="length">Die Anzahl der Zeichen der Teilzeichenfolge, die in die Suche einbezogen werden soll.</param>
        <summary>Sucht beginnend an der angegebenen Anfangsposition in der Eingabezeichenfolge nach dem ersten Vorkommen eines regulären Ausdrucks und sucht nur nach der angegebenen Anzahl von Zeichen.</summary>
        <returns>Ein Objekt, das Informationen zur Übereinstimmung enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> Methode gibt die erste Teilzeichenfolge, die Muster eines regulären Ausdrucks in einem Teil einer Eingabezeichenfolge entspricht. Informationen, die Sprachelemente, die zum Erstellen des Muster eines regulären Ausdrucks verwendet wird, finden Sie unter [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Muster für reguläre Ausdrücke für die die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> Methode durchsucht wird durch den Aufruf eines definiert die <xref:System.Text.RegularExpressions.Regex> Klassenkonstruktoren. Weitere Informationen zu den Elementen, die ein Muster für reguläre Ausdrücke bilden können, finden Sie unter [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> Methode durchsucht, die Teil des `input` von definiert die `beginning` und `length` Parameter für das Muster für reguläre Ausdrücke. `beginning` immer definiert den Index des ersten Zeichens in die Suche eingeschlossen und `length` definiert die maximale Anzahl der zu suchenden Zeichen. Zusammen definieren sie den Bereich der Suche. Wenn die Suche von links nach rechts (Standard) fortgesetzt wird, sucht die Engine für reguläre Ausdrücke aus dem Zeichen am Index `beginning` auf das Zeichen am Index `beginning`  +  `length` – 1. Wenn die Engine für reguläre Ausdrücke, mithilfe instanziiert wurde der <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> auswählen, sodass die Suche von rechts nach wird fortgesetzt, links, die reguläre Ausdrücke-Engine sucht mit dem Zeichen am Index `beginning`  +  `length` – 1, die Zeichen am Index `beginning`. Diese Methode gibt die erste Übereinstimmung, die in diesen Bereich gefunden. Sie können die nachfolgende Übereinstimmungen abrufen, indem Sie durch wiederholtes Aufrufen das zurückgegebene <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> Methode.  
  
 Sie können bestimmen, ob das Muster für reguläre Ausdrücke in der Eingabezeichenfolge gefunden wurde, indem der Wert des zurückgegebenen überprüft <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Group.Success%2A> Eigenschaft. Wenn eine Übereinstimmung gefunden wird, die zurückgegebene <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Capture.Value%2A> Eigenschaft enthält die Teilzeichenfolge aus `input` , die Muster des regulären Ausdrucks übereinstimmt. Wenn keine Übereinstimmung gefunden wird, wird der Wert ist <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme ausgelöst, wenn die Ausführungszeit von den entsprechenden Vorgang das Timeoutintervall gemäß überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie einen Timeoutwert nicht festlegen, wenn Sie den Konstruktor aufrufen, wird die Ausnahme ausgelöst, wenn der Vorgang alle für die Anwendungsdomäne festgelegt wird, in dem Timeoutwert überschreitet die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="beginning" /> ist kleiner als 0 (null) oder größer als die Länge von <paramref name="input" />.  
  
- oder -  
 <paramref name="length" /> ist kleiner als 0 (null) oder größer als die Länge von <paramref name="input" />.  
  
- oder -  
 <paramref name="beginning" /><see langword="+" /><paramref name="length" /><see langword="–1" /> gibt eine Position außerhalb des Bereichs von <paramref name="input" /> an.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <summary>Durchsucht die angegebene Eingabezeichenfolge unter Verwendung der angegebenen Übereinstimmungsoptionen nach dem ersten Vorkommen des angegebenen regulären Ausdrucks.</summary>
        <returns>Ein Objekt, das Informationen zur Übereinstimmung enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Methode gibt die erste Teilzeichenfolge zurück, die Muster eines regulären Ausdrucks in einer Eingabezeichenfolge entspricht. Informationen, die Sprachelemente, die zum Erstellen des Muster eines regulären Ausdrucks verwendet wird, finden Sie unter [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die statische <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Methode entspricht dem Erstellen einer <xref:System.Text.RegularExpressions.Regex> Objekt mit der <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Konstruktor und dem Aufrufen der <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> Methode.  
  
 Die `pattern` -Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Sie können bestimmen, ob das Muster für reguläre Ausdrücke in der Eingabezeichenfolge gefunden wurde, indem der Wert des zurückgegebenen überprüft <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Group.Success%2A> Eigenschaft. Wenn eine Übereinstimmung gefunden wird, die zurückgegebene <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Capture.Value%2A> Eigenschaft enthält die Teilzeichenfolge aus `input` , die Muster des regulären Ausdrucks übereinstimmt. Wenn keine Übereinstimmung gefunden wird, wird der Wert ist <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Diese Methode gibt die erste Teilzeichenfolge in gefunden `input` , die Muster des regulären Ausdrucks übereinstimmt. Sie können die nachfolgende Übereinstimmungen abrufen, indem Sie durch wiederholtes Aufrufen das zurückgegebene <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Match.NextMatch%2A> Methode. Sie können auch alle Übereinstimmungen in einem einzelnen Methodenaufruf abrufen, durch den Aufruf der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> Methode.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme ausgelöst, wenn die Ausführungszeit von den entsprechenden Vorgang überschreitet das Timeoutintervall angegeben, für die Anwendungsdomäne, in dem die Methode aufgerufen wird. Wenn kein Timeout in der Anwendungsdomäne definiert ist, oder der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Das folgende Beispiel definiert einen regulären Ausdruck, der entspricht Wörtern beginnend mit dem Buchstaben "a". Er verwendet den <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> Option aus, um sicherzustellen, dass der reguläre Ausdruck Wörter mit einem Großbuchstaben "a" und ein kleines sucht "a".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match2.vb#2)]  
  
 Das Muster für reguläre Ausdrücke `\ba\w*\b` wird entsprechend der folgenden Tabelle interpretiert:  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\b`|Der Vergleich beginnt an einer Wortgrenze.|  
|`a`|Übereinstimmung mit dem Zeichen "a".|  
|`\w*`|Entspricht 0 (null), 1 oder mehr Wortzeichen.|  
|`\b`|Der Vergleich endet an einer Wortgrenze.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage">
          <para>Diese-Methode ein Timeout, nach einem bestimmten Zeitintervall, das gleich der Standardwert für das Timeout der Anwendungsdomäne, in dem sie aufgerufen wird. Wenn Sie ein Timeoutwert für die Anwendungsdomäne, der Wert nicht definiert wurde <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das Timeout, die Methode verhindert werden. Ist die empfohlene statische Methode zum Abrufen von eine Musterübereinstimmung <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, mit dem Sie das Timeoutintervall festlegen.</para>
        </block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <param name="matchTimeout">Ein Timeoutintervall oder <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das angibt, dass die Methode kein Timeout haben sollte.</param>
        <summary>Durchsucht die Eingabezeichenfolge unter Verwendung der angegebenen Übereinstimmungsoptionen und des angegebenen Timeoutintervalls nach dem ersten Vorkommen des angegebenen regulären Ausdrucks.</summary>
        <returns>Ein Objekt, das Informationen zur Übereinstimmung enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Methode gibt die erste Teilzeichenfolge zurück, die Muster eines regulären Ausdrucks in einer Eingabezeichenfolge entspricht. Informationen, die Sprachelemente, die zum Erstellen des Muster eines regulären Ausdrucks verwendet wird, finden Sie unter [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die statische <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Methode entspricht dem Erstellen einer <xref:System.Text.RegularExpressions.Regex> Objekt mit der <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Konstruktor und dem Aufrufen der <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> Methode.  
  
 Die `pattern` -Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Sie können bestimmen, ob das Muster für reguläre Ausdrücke in der Eingabezeichenfolge gefunden wurde, indem der Wert des zurückgegebenen überprüft <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Group.Success%2A> Eigenschaft. Wenn eine Übereinstimmung gefunden wird, die zurückgegebene <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Capture.Value%2A> Eigenschaft enthält die Teilzeichenfolge aus `input` , die Muster des regulären Ausdrucks übereinstimmt. Wenn keine Übereinstimmung gefunden wird, wird der Wert ist <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Diese Methode gibt die erste Teilzeichenfolge in gefunden `input` , die Muster des regulären Ausdrucks übereinstimmt. Sie können die nachfolgende Übereinstimmungen abrufen, indem Sie durch wiederholtes Aufrufen das zurückgegebene <xref:System.Text.RegularExpressions.Match> des Objekts <xref:System.Text.RegularExpressions.Match.NextMatch%2A> Methode. Sie können auch alle Übereinstimmungen in einem einzelnen Methodenaufruf abrufen, durch den Aufruf der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> Methode.  
  
 Die `matchTimeout` Parameter gibt an, wie lange ein Musterabgleich Methode sollten versuchen, eine Übereinstimmung gefunden wird, bevor ein Timeout eintritt. Ein Timeoutintervall festlegen wird verhindert, dass reguläre Ausdrücke, die übermäßige rückverfolgung angezeigt werden, nicht mehr reagiert, wenn diese Eingaben verarbeiten, die in der Nähe von Übereinstimmungen enthält. Weitere Informationen finden Sie unter [bewährte Methoden für reguläre Ausdrücke](~/docs/standard/base-types/best-practices.md) und [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Wenn Sie in dieses Zeitintervalls keine Übereinstimmung gefunden wird, löst die Methode eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme. `matchTimeout` überschreibt alle Standard-Timeoutwert, der definiert, die für die Anwendungsdomäne, in der die Methode ausgeführt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.  
  
- oder -  
 <paramref name="matchTimeout" /> ist negativ, 0 oder größer als ca. 24 Tage.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage">
          <para>Es wird empfohlen, Sie legen die <paramref name="matchTimeout" /> Parameter auf einen geeigneten Wert, z. B. zwei Sekunden. Wenn Sie Timeouts werden, indem deaktiviert <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, die Engine für reguläre Ausdrücke bietet eine etwas bessere Leistung. Allerdings sollten Sie Timeouts nur unter folgenden Bedingungen deaktivieren: 
– Wenn die Eingabe verarbeitet, die von einem regulären Ausdruck aus einer bekannten und vertrauenswürdigen Quelle stammt oder besteht aus statischen Text. Dies schließt Text, der vom Benutzer eingegebene dynamisch wurde.  
  
– Wenn Sie Muster für reguläre Ausdrücke gründlich getestet wurde, um sicherzustellen, dass er effizient verarbeitet übereinstimmt, nicht-Übereinstimmungen und Naher entspricht.  
  
– Wenn Muster für reguläre Ausdrücke keine Language-Elemente enthält, die bekannt sind, um eine übermäßige rückverfolgung bei der Verarbeitung einer Nahen Übereinstimmung zu verursachen.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Matches">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Durchsucht eine Eingabezeichenfolge nach allen Vorkommen eines regulären Ausdrucks und gibt alle Übereinstimmungen zurück.</summary>
        <block subset="none" type="usage">
          <para>Wenn ein Versuch wird wiederholt durch Aufrufen der <see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /> Methode, die Engine für reguläre Ausdrücke gibt leere Übereinstimmungen besondere Behandlung. Die Engine für reguläre Ausdrücke beginnt in der Regel die Suche für die nächste Übereinstimmung genau, wo die vorherige Übereinstimmung unterbrochen. Allerdings setzt die Engine für reguläre Ausdrücke in der nach einer leeren Übereinstimmung, um ein Zeichen bevor Sie versuchen, die nächste Übereinstimmung wird. Dieses Verhalten wird sichergestellt, dass die Engine für reguläre Ausdrücke durch die Zeichenfolge fortgesetzt wird. Da es sich bei eine leere Übereinstimmung keine vorwärtsbewegung ergibt, andernfalls startet die nächste Übereinstimmung in genau dieselbe Stelle ein wie die vorherige Übereinstimmung, und es würde die gleiche leere Zeichenfolge wiederholt übereinstimmen.  
  
Im folgenden Beispiel, das reguläre Ausdrucksmuster <c>eine *</c> Suchvorgänge für NULL oder mehr Vorkommen des Buchstabens "a" in der Zeichenfolge "Abaabb". Wie die Ausgabe des Beispiels zeigt, die die resultierende <see cref="T:System.Text.RegularExpressions.MatchCollection" /> Objekt enthält sechs <see cref="T:System.Text.RegularExpressions.Match" /> Objekte. Der erste Versuch sucht das erste "a". Die zweite Match-beginnt, in dem die erste exakt endet, vor dem ersten b. Es findet keine Vorkommen von "a" und eine leere Zeichenfolge zurückgegeben. Die dritte Übereinstimmung beginnt nun nicht genau, in dem zweiten beendet wurde, da die zweite Übereinstimmung eine leere Zeichenfolge zurückgegeben wurde. Stattdessen wird ein Zeichen später, nach der ersten "b". Die dritte Übereinstimmung sucht nach zwei Vorkommen von "a" und "aa" zurückgegeben. Der vierte Versuch beginnt, in denen die dritte Vergleich beendet wurde, bevor Sie die zweite "b", und eine leere Zeichenfolge zurückgegeben. Der fünfte Versuch setzt erneut ein Zeichen, damit sie vor der dritten "b" beginnt und eine leere Zeichenfolge zurückgegeben. Die sechste Übereinstimmung nach der letzten "b" beginnt und erneut eine leere Zeichenfolge zurückgegeben.  
  
[! Code-Csharp[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/emptymatches1.cs#9)] [! Code – Vb[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/emptymatches1.vb#9)]</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Matches : string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <summary>Durchsucht die angegebene Eingabezeichenfolge nach allen Vorkommen eines regulären Ausdrucks.</summary>
        <returns>Eine Auflistung der im Suchvorgang gefundenen <see cref="T:System.Text.RegularExpressions.Match" />-Objekte. Wenn keine Übereinstimmungen gefunden werden, gibt die Methode ein leeres Auflistungsobjekt zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> Methode ähnelt der <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> -Methode, mit dem Unterschied, dass die It Informationen über alle Übereinstimmungen zurückgibt, finden Sie in der Eingabezeichenfolge, anstelle einer einzelnen Übereinstimmung sucht. Dies entspricht dem folgenden Code:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#5)]  
  
 Die Auflistung enthält nur Übereinstimmungen und endet bei der ersten nicht-Übereinstimmung.  
  
 Muster für reguläre Ausdrücke für die die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> Methode durchsucht wird durch den Aufruf eines definiert die <xref:System.Text.RegularExpressions.Regex> Klassenkonstruktoren. Weitere Informationen zu den Elementen, die ein Muster für reguläre Ausdrücke bilden können, finden Sie unter [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode mithilfe der verzögerten Auswertung, füllen Sie das zurückgegebene <xref:System.Text.RegularExpressions.MatchCollection> Objekt. Zugriff auf Mitglieder dieser Sammlung wie z. B. <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> und <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> bewirkt, dass die Auflistung sofort aufgefüllt werden. Um verzögerte Auswertung nutzen zu können, sollten Sie die Auflistung durchlaufen, mit einem Konstrukt wie `foreach` in C# geschrieben und `For Each`...`Next` in Visual Basic.  
  
 Aufgrund der verzögerten Auswertung Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> Methode löst keine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme. Jedoch die Ausnahme wird ausgelöst, wenn ein Vorgang ausgeführt wird, auf die <xref:System.Text.RegularExpressions.MatchCollection> Objekt, das von dieser Methode zurückgegeben wird, wenn die <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> Eigenschaft ist nicht <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> und ein Abgleichsvorgang überschreitet das Timeoutintervall.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> Methode, um alle Wörter in einem Satz zu identifizieren, die auf "es" enden.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches1.vb#1)]  
  
 Das Muster für reguläre Ausdrücke `\b\w+es\b` wird entsprechend der folgenden Tabelle definiert:  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\b`|Der Vergleich beginnt an einer Wortgrenze.|  
|`\w+`|Übereinstimmung mit mindestens einem Wortzeichen.|  
|`es`|Entspricht der literalen Zeichenfolge "es".|  
|`\b`|Der Vergleich endet an einer Wortgrenze.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String, startat As Integer) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Matches : string * int -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="startat">Die Zeichenposition in der Eingabezeichenfolge, an der mit der Suche begonnen werden soll.</param>
        <summary>Durchsucht die angegebene Eingabezeichenfolge nach allen Vorkommen eines regulären Ausdrucks ab der angegebenen Anfangsposition in der Zeichenfolge.</summary>
        <returns>Eine Auflistung der im Suchvorgang gefundenen <see cref="T:System.Text.RegularExpressions.Match" />-Objekte. Wenn keine Übereinstimmungen gefunden werden, gibt die Methode ein leeres Auflistungsobjekt zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> Methode ähnelt der <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> -Methode, mit dem Unterschied, dass die It Informationen über alle Übereinstimmungen zurückgibt, finden Sie in der Eingabezeichenfolge, anstelle einer einzelnen Übereinstimmung sucht. Dies entspricht dem folgenden Code:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#6)]  
  
 Muster für reguläre Ausdrücke für die die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> Methode durchsucht wird durch den Aufruf eines definiert die <xref:System.Text.RegularExpressions.Regex> Klassenkonstruktoren. Weitere Informationen zu den Elementen, die ein Muster für reguläre Ausdrücke bilden können, finden Sie unter [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode mithilfe der verzögerten Auswertung, füllen Sie das zurückgegebene <xref:System.Text.RegularExpressions.MatchCollection> Objekt. Zugriff auf Mitglieder dieser Sammlung wie z. B. <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> und <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> bewirkt, dass die Auflistung sofort aufgefüllt werden. Um verzögerte Auswertung nutzen zu können, sollten Sie die Auflistung durchlaufen, mit einem Konstrukt wie `foreach` in C# geschrieben und `For Each`...`Next` in Visual Basic.  
  
 Aufgrund der verzögerten Auswertung Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> Methode löst keine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme. Allerdings wird die Ausnahme ausgelöst, wenn ein Vorgang ausgeführt wird, auf die <xref:System.Text.RegularExpressions.MatchCollection> Objekt, das von dieser Methode zurückgegeben wird, wenn die <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> Eigenschaft ist nicht <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> und ein Abgleichsvorgang überschreitet das Timeoutintervall..  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> Methode, um das erste Wort im Satz zu ermitteln, die in "es" endet, und ruft dann die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> Methode, um alle weiteren Wörter zu identifizieren, die auf "es" enden.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches3.vb#3)]  
  
 Das Muster für reguläre Ausdrücke `\b\w+es\b` wird entsprechend der folgenden Tabelle definiert:  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\b`|Der Vergleich beginnt an einer Wortgrenze.|  
|`\w+`|Übereinstimmung mit mindestens einem Wortzeichen.|  
|`es`|Entspricht der literalen Zeichenfolge "es".|  
|`\b`|Der Vergleich endet an einer Wortgrenze.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> ist kleiner als 0 (null) oder größer als die Länge von <paramref name="input" />.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <summary>Durchsucht die angegebene Eingabezeichenfolge nach allen Vorkommen eines angegebenen regulären Ausdrucks.</summary>
        <returns>Eine Auflistung der im Suchvorgang gefundenen <see cref="T:System.Text.RegularExpressions.Match" />-Objekte. Wenn keine Übereinstimmungen gefunden werden, gibt die Methode ein leeres Auflistungsobjekt zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> Methode ähnelt der <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> -Methode, mit dem Unterschied, dass die It Informationen über alle Übereinstimmungen zurückgibt, finden Sie in der Eingabezeichenfolge, anstelle einer einzelnen Übereinstimmung sucht. Dies entspricht dem folgenden Code:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#7)]  
  
 Die statische `Matches` Methoden sind gleichwertig mit der Erstellung einer <xref:System.Text.RegularExpressions.Regex> Objekt mit dem angegebenen regulären Ausdrucksmuster und Aufrufen der Instanzmethode `Matches`.  
  
 Die `pattern` -Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode mithilfe der verzögerten Auswertung, füllen Sie das zurückgegebene <xref:System.Text.RegularExpressions.MatchCollection> Objekt. Zugriff auf Mitglieder dieser Sammlung wie z. B. <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> und <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> bewirkt, dass die Auflistung sofort aufgefüllt werden. Um verzögerte Auswertung nutzen zu können, sollten Sie die Auflistung durchlaufen, mit einem Konstrukt wie `foreach` in C# geschrieben und `For Each`...`Next` in Visual Basic.  
  
 Aufgrund der verzögerten Auswertung Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> Methode löst keine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme. Allerdings wird die Ausnahme ausgelöst, wenn ein Vorgang ausgeführt wird, auf die <xref:System.Text.RegularExpressions.MatchCollection> Objekt, das von dieser Methode zurückgegeben wird, wenn ein Timeoutintervall, durch die Eigenschaft "REGEX_DEFAULT_MATCH_TIMEOUT" von der aktuellen Anwendungsdomäne und einen Abgleichsvorgang definiert ist überschreitet das Timeoutintervall an.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> Methode, um alle Wörter in einem Satz zu identifizieren, die mit "es" endet.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches2.vb#2)]  
  
 Das Muster für reguläre Ausdrücke `\b\w+es\b` wird entsprechend der folgenden Tabelle definiert:  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\b`|Der Vergleich beginnt an einer Wortgrenze.|  
|`\w+`|Übereinstimmung mit mindestens einem Wortzeichen.|  
|`es`|Entspricht der literalen Zeichenfolge "es".|  
|`\b`|Der Vergleich endet an einer Wortgrenze.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Diese-Methode ein Timeout, nach einem bestimmten Zeitintervall, das gleich der Standardwert für das Timeout der Anwendungsdomäne, in dem sie aufgerufen wird. Wenn Sie ein Timeoutwert für die Anwendungsdomäne, der Wert nicht definiert wurde <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das Timeout, die Methode verhindert werden. Statische Methode wird nicht für mehrere Muster abrufen entspricht <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, sodass Sie das Timeoutintervall angeben.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <summary>Durchsucht die angegebene Eingabezeichenfolge unter Verwendung der angegebenen Übereinstimmungsoptionen nach allen Vorkommen des angegebenen regulären Ausdrucks.</summary>
        <returns>Eine Auflistung der im Suchvorgang gefundenen <see cref="T:System.Text.RegularExpressions.Match" />-Objekte. Wenn keine Übereinstimmungen gefunden werden, gibt die Methode ein leeres Auflistungsobjekt zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Methode ähnelt der <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> -Methode, mit dem Unterschied, dass die It Informationen über alle Übereinstimmungen zurückgibt, finden Sie in der Eingabezeichenfolge, anstelle einer einzelnen Übereinstimmung sucht. Dies entspricht dem folgenden Code:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#8)]  
  
 Die statische `Matches` Methoden sind gleichwertig mit der Erstellung einer <xref:System.Text.RegularExpressions.Regex> Objekt mit dem angegebenen regulären Ausdrucksmuster und Aufrufen der Instanzmethode `Matches`.  
  
 Die `pattern` -Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode mithilfe der verzögerten Auswertung, füllen Sie das zurückgegebene <xref:System.Text.RegularExpressions.MatchCollection> Objekt. Zugriff auf Mitglieder dieser Sammlung wie z. B. <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> und <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> bewirkt, dass die Auflistung sofort aufgefüllt werden. Um verzögerte Auswertung nutzen zu können, sollten Sie die Auflistung durchlaufen, mit einem Konstrukt wie `foreach` in C# geschrieben und `For Each`...`Next` in Visual Basic.  
  
 Aufgrund der verzögerten Auswertung Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> Methode löst keine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme. Allerdings wird die Ausnahme ausgelöst, wenn ein Vorgang ausgeführt wird, auf die <xref:System.Text.RegularExpressions.MatchCollection> Objekt, das von dieser Methode zurückgegeben wird, wenn ein Timeoutintervall, durch die Eigenschaft "REGEX_DEFAULT_MATCH_TIMEOUT" von der aktuellen Anwendungsdomäne und einen Abgleichsvorgang definiert ist überschreitet das Timeoutintervall an.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> Methode, um alle Wörter im Satz zu identifizieren, die auf "es" endet, und ruft dann die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Methode zum Ausführen eines Vergleichs Groß-/Kleinschreibung des Musters mit der Eingabezeichenfolge. Die Ausgabe zeigt, werden die beiden Methoden unterschiedliche Ergebnisse zurück.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches4.vb#4)]  
  
 Das Muster für reguläre Ausdrücke `\b\w+es\b` wird entsprechend der folgenden Tabelle definiert:  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\b`|Der Vergleich beginnt an einer Wortgrenze.|  
|`\w+`|Übereinstimmung mit mindestens einem Wortzeichen.|  
|`es`|Entspricht der literalen Zeichenfolge "es".|  
|`\b`|Der Vergleich endet an einer Wortgrenze.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.</exception>
        <block subset="none" type="usage">
          <para>Diese-Methode ein Timeout, nach einem bestimmten Zeitintervall, das gleich der Standardwert für das Timeout der Anwendungsdomäne, in dem sie aufgerufen wird. Wenn Sie ein Timeoutwert für die Anwendungsdomäne, der Wert nicht definiert wurde <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das Timeout, die Methode verhindert werden. Statische Methode wird nicht für mehrere Muster abrufen entspricht <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, mit dem Sie das Timeoutintervall festlegen.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <param name="matchTimeout">Ein Timeoutintervall oder <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das angibt, dass die Methode kein Timeout haben sollte.</param>
        <summary>Durchsucht die angegebene Eingabezeichenfolge unter Verwendung der angegebenen Übereinstimmungsoptionen und des angegebenen Timeoutintervalls nach allen Vorkommen des angegebenen regulären Ausdrucks.</summary>
        <returns>Eine Auflistung der im Suchvorgang gefundenen <see cref="T:System.Text.RegularExpressions.Match" />-Objekte. Wenn keine Übereinstimmungen gefunden werden, gibt die Methode ein leeres Auflistungsobjekt zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Methode ähnelt der <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> -Methode, mit dem Unterschied, dass die It Informationen über alle Übereinstimmungen zurückgibt, finden Sie in der Eingabezeichenfolge, anstelle einer einzelnen Übereinstimmung sucht. Dies entspricht dem folgenden Code:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#10)]  
  
 Die statische `Matches` Methoden sind gleichwertig mit der Erstellung einer <xref:System.Text.RegularExpressions.Regex> Objekt mit dem angegebenen regulären Ausdrucksmuster und Aufrufen der Instanzmethode `Matches`.  
  
 Die `pattern` -Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode mithilfe der verzögerten Auswertung, füllen Sie das zurückgegebene <xref:System.Text.RegularExpressions.MatchCollection> Objekt. Zugriff auf Mitglieder dieser Sammlung wie z. B. <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> und <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> bewirkt, dass die Auflistung sofort aufgefüllt werden. Um verzögerte Auswertung nutzen zu können, sollten Sie die Auflistung durchlaufen, mit einem Konstrukt wie `foreach` in C# geschrieben und `For Each`...`Next` in Visual Basic.  
  
 Aufgrund der verzögerten Auswertung Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%2A> Methode löst keine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme. Allerdings wird eine Ausnahme ausgelöst, wenn ein Vorgang ausgeführt wird, auf die <xref:System.Text.RegularExpressions.MatchCollection> Objekt, das von dieser Methode zurückgegeben wird, übersteigt ein Abgleichsvorgang mit diesem Timeoutintervall, die gemäß der`matchTimeout` Parameter.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Methode, um einen Vergleich Groß-/Kleinschreibung auszuführen, die alle Wörter in einem Satz entspricht, die mit "es" endet. Es ruft dann die <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Methode zum Ausführen eines Vergleichs Groß-/Kleinschreibung des Musters mit der Eingabezeichenfolge. In beiden Fällen wird das Timeoutintervall auf eine Sekunde festgelegt. Die Ausgabe zeigt, werden die beiden Methoden unterschiedliche Ergebnisse zurück.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches5.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches5.vb#11)]  
  
 Das Muster für reguläre Ausdrücke `\b\w+es\b` wird entsprechend der folgenden Tabelle definiert:  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\b`|Der Vergleich beginnt an einer Wortgrenze.|  
|`\w+`|Übereinstimmung mit mindestens einem Wortzeichen.|  
|`es`|Entspricht der literalen Zeichenfolge "es".|  
|`\b`|Der Vergleich endet an einer Wortgrenze.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.  
  
- oder -  
 <paramref name="matchTimeout" /> ist negativ, 0 oder größer als ca. 24 Tage.</exception>
        <block subset="none" type="usage">
          <para>Es wird empfohlen, Sie legen die <paramref name="matchTimeout" /> Parameter auf einen geeigneten Wert, z. B. zwei Sekunden. Wenn Sie Timeouts werden, indem deaktiviert <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, die Engine für reguläre Ausdrücke bietet eine etwas bessere Leistung. Allerdings sollten Sie Timeouts nur unter folgenden Bedingungen deaktivieren: 
– Wenn die Eingabe verarbeitet, die von einem regulären Ausdruck aus einer bekannten und vertrauenswürdigen Quelle stammt oder besteht aus statischen Text. Dies schließt Text, der vom Benutzer eingegebene dynamisch wurde.  
  
– Wenn Sie Muster für reguläre Ausdrücke gründlich getestet wurde, um sicherzustellen, dass er effizient verarbeitet übereinstimmt, nicht-Übereinstimmungen und Naher entspricht.  
  
– Wenn Muster für reguläre Ausdrücke keine Language-Elemente enthält, die bekannt sind, um eine übermäßige rückverfolgung bei der Verarbeitung einer Nahen Übereinstimmung zu verursachen.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="MatchTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan MatchTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MatchTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MatchTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MatchTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Laufzeitintervall der aktuellen Instanz ab.</summary>
        <value>Das maximale Zeitintervall, das in einem Mustervergleichsvorgang verstreichen kann, bevor eine <see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" />-Ausnahme ausgelöst wird, oder <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, wenn Timeouts deaktiviert sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> Eigenschaft definiert die ungefähre maximale Zeitintervall für einen <xref:System.Text.RegularExpressions.Regex> Instanz zum Ausführen eines einzelnen übereinstimmenden Vorgangs, bevor der Vorgang ein eintritt Timeout. Die Engine für reguläre Ausdrücke löst eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme während der nächsten Überprüfung der zeitlichen Steuerung nach der das Timeoutintervall abgelaufen ist. Dadurch wird verhindert, dass die Engine für reguläre Ausdrücke verarbeiten von Zeichenfolgen, die eine übermäßige rückverfolgung zu erfordern. Weitere Informationen finden Sie unter [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md) und [bewährte Methoden für reguläre Ausdrücke](~/docs/standard/base-types/best-practices.md).  
  
 Diese Eigenschaft ist schreibgeschützt. Legen Sie dessen Wert explizit für ein einzelnes <xref:System.Text.RegularExpressions.Regex> -Objekt durch Aufrufen der <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor, und Sie können den Wert festlegen, für alle <xref:System.Text.RegularExpressions.Regex> Abgleichen von Vorgängen in einer Anwendungsdomäne durch Aufrufen der <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> Methode und eine <xref:System.TimeSpan> für die Eigenschaft "REGEX_DEFAULT_MATCH_TIMEOUT"-Wert, wie das folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/cs/regexmatchtimeout1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/vb/regexmatchtimeout1.vb#1)]  
  
 Wenn Sie nicht explizit ein Timeoutintervall, die den Standardwert festlegen <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> wird verwendet, und die entsprechenden Vorgänge werden nicht automatisch gelöscht.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.RegexOptions Options { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.RegularExpressions.RegexOptions Options" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Options" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Options As RegexOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::RegularExpressions::RegexOptions Options { System::Text::RegularExpressions::RegexOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.Options : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.Options" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Optionen ab, die an den <see cref="T:System.Text.RegularExpressions.Regex" />-Konstruktor übergeben wurden.</summary>
        <value>Mindestens ein Member der <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Enumeration, der Optionen darstellt, die dem <see cref="T:System.Text.RegularExpressions.Regex" />-Konstruktor übergeben wurden</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert des der <xref:System.Text.RegularExpressions.Regex.Options%2A> Eigenschaft besteht aus mindestens Mitglied der <xref:System.Text.RegularExpressions.RegexOptions> Enumeration. Wenn keine Optionen, in festgelegt wurden der <xref:System.Text.RegularExpressions.Regex> Klassenkonstruktor, sein Wert ist <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>. Die verfügbaren Optionen werden ausführlich in die [Optionen für reguläre Ausdrücke](~/docs/standard/base-types/regular-expression-options.md) Thema.  
  
 Beachten Sie, dass die <xref:System.Text.RegularExpressions.Regex.Options%2A> Eigenschaft spiegelt nicht die Inlineoptionen, die im regulären Ausdruck definierten Muster selbst.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> ist die Basisklasse von regulären Ausdrücken, die erstellt werden, indem die <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> Methode. Diese kompilierte reguläre Ausdrücke verwenden Sie die basisklassenimplementierung von der <see cref="P:System.Text.RegularExpressions.Regex.Options" /> Eigenschaft. Wenn von einer abgeleiteten Klasse aufgerufen der <see cref="P:System.Text.RegularExpressions.Regex.Options" /> Eigenschaft gibt die Optionen, die übergeben wurden, die <paramref name="options" /> Parameter, der die <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> Konstruktor der Klasse, die zum Definieren des regulären Ausdrucks verwendet wurde.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="http://msdn.microsoft.com/library/c82dc689-7e82-4767-a18d-cd24ce5f05e9">Optionen für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="pattern">
      <MemberSignature Language="C#" Value="protected internal string pattern;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string pattern" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.pattern" />
      <MemberSignature Language="VB.NET" Value="Protected Friend pattern As String " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::String ^ pattern;" />
      <MemberSignature Language="F#" Value="val mutable pattern : string" Usage="System.Text.RegularExpressions.Regex.pattern" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge die mit dem Muster für den regulären Ausdruck übereinstimmenden Zeichenfolgen durch eine angegebene Ersetzungszeichenfolge.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
        <related type="Article" href="http://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Ersetzungen</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="regex.Replace (input, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="replacement">Die Ersatzzeichenfolge.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge alle mit dem Muster für den regulären Ausdruck übereinstimmenden Zeichenfolgen durch eine angegebene Ersetzungszeichenfolge.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Die Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn keine Entsprechung für das reguläre Ausdrucksmuster in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche nach Übereinstimmungen beginnt am Anfang der `input` Zeichenfolge. Der reguläre Ausdruck ist, durch den Konstruktor für den aktuellen definierten Muster <xref:System.Text.RegularExpressions.Regex> Objekt.  
  
 Die `replacement` Parameter gibt die Zeichenfolge, die jede Übereinstimmung in ersetzt `input`. `replacement` kann einer beliebigen Kombination von literalen Text bestehen und [Ersetzungen](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Z. B. das Ersetzungsmuster `a*${test}b` fügt die Zeichenfolge "eine *" gefolgt von der Teilzeichenfolge, die mit der `test` Erfassungsgruppe, ggf. gefolgt von der Zeichenfolge "b". Die * Zeichen nicht als bei einem Metazeichen in einem Ersetzungsmuster erkannt wird.  
  
> [!NOTE]
>  Ersetzungen sind, die nur für reguläre Ausdrücke Sprachelemente, die in einem Ersetzungsmuster erkannt werden. Alle anderen Sprachelemente für reguläre Ausdrücke, einschließlich [Zeichen Escapezeichen](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sind im Muster für reguläre Ausdrücke nur zulässig und werden nicht in Ersetzungsmustern erkannt.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme ausgelöst, wenn die Ausführungszeit der Ersetzung des Timeoutintervalls, der anhand des überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie ein Timeoutintervall nicht festlegen, wenn Sie den Konstruktor aufrufen, wird die Ausnahme ausgelöst, wenn der Vorgang alle für die Anwendungsdomäne festgelegt wird, in dem Timeoutwert überschreitet die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst  
  
 Da die Methode gibt `input` unverändert, wenn keine Übereinstimmung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methode, um zu bestimmen, ob die Methode auf die Eingabezeichenfolge Ersetzungen vorgenommen hat.  
  
   
  
## Examples  
 Das folgende Beispiel definiert einen regulären Ausdruck `\s+`, mit der eine oder mehrere Leerzeichen übereinstimmt. Die Ersetzungszeichenfolge "", durch ein einzelnes Leerzeichen ersetzt.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample5.vb#5)]  
  
 Das folgende Beispiel definiert einen regulären Ausdruck `(\p{Sc}\s?)?(\d+\.?((?<=\.)\d+)?)(?(1)|\s?\p{Sc})?`, auch ein Ersetzungsmuster `$2`, die entweder einen führenden oder nachgestellten Währungssymbol aus einem numerischen Wert entfernt.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample7.vb#7)]  
  
 Der reguläre Ausdruck wird entsprechend der Darstellung in der folgenden Tabelle interpretiert.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\p{Sc}`|Übereinstimmung mit einem Währungssymbol. `{Sc}` Gibt alle Zeichen, die ein Mitglied der Unicode-Kategorie Symbol, Währung an.|  
|`\s?`|Übereinstimmung mit keinem oder einem Leerzeichen.|  
|`(\p{Sc}\s?)?`|Übereinstimmung mit keinem oder einem Vorkommen der Kombination aus ein Währungssymbol gefolgt von keinem oder einem Leerzeichen. Dies ist die erste Erfassungsgruppe.|  
|`\d+`|Entsprechung für mindestens eine Dezimalstelle finden.|  
|`\.?`|Übereinstimmung mit 0 (null) oder 1 Vorkommen eines Punkts, der (als ein Dezimaltrennzeichen verwendet).|  
|`((?<=\.)\d+)?`|Wenn ein bestimmten Zeitraum das vorherige Zeichen ist, entsprechen Sie eine oder mehrere Dezimalstellen sind. Dieses Muster kann entweder NULL oder einem Vorkommen abgeglichen werden.|  
|`(\d+\.?((?<=\.)\d+)?)`|Übereinstimmung mit dem Muster eine oder mehrere Dezimalstellen gefolgt von einem optionalen Zeitraum und nachfolgende Dezimalziffern. Dies ist die zweite Erfassungsgruppe. Der Aufruf der <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29> Methode ersetzt die gesamte Übereinstimmung mit dem Wert, der diese erfasste Gruppe.|  
|`(?(1)&#124;\s?\p{Sc})?`|Wenn die erste Erfassungsgruppe vorhanden ist, entsprechen Sie eine leere Zeichenfolge. Übereinstimmen Sie, andernfalls 0 (null) oder ein Leerzeichen ein Währungssymbol gefolgt ein.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="replacement" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
        <related type="Article" href="http://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Ersetzungen</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="regex.Replace (input, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="evaluator">Eine benutzerdefinierte Methode, die jede Übereinstimmung überprüft und entweder die ursprüngliche entsprechende Zeichenfolge oder eine Ersatzzeichenfolge zurückgibt.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge alle mit einem angegebenen regulären Ausdruck übereinstimmenden Zeichenfolgen durch eine von einem <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />-Delegaten zurückgegebene Zeichenfolge.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Eine Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn keine Entsprechung für das reguläre Ausdrucksmuster in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> Methode eignet sich für die Übereinstimmung eines regulären Ausdrucks ersetzen, wenn eine der folgenden Bedingungen zutrifft:  
  
-   Die Ersetzungszeichenfolge kann nicht ohne weiteres von Ersatz-Muster eines regulären Ausdrucks angegeben werden.  
  
-   Die Ersetzungszeichenfolge ergibt sich aus der Verarbeitung in der entsprechenden Zeichenfolge.  
  
-   Die Ersetzungszeichenfolge ergibt sich aus bedingte Verarbeitung.  
  
 Die Methode entspricht dem Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> -Methode und übergeben jede <xref:System.Text.RegularExpressions.Match> Objekt in der zurückgegebenen <xref:System.Text.RegularExpressions.MatchCollection> -Auflistung, um die `evaluator` delegieren.  
  
 Der reguläre Ausdruck ist, durch den Konstruktor für den aktuellen definierten Muster <xref:System.Text.RegularExpressions.Regex> Objekt.  
  
 Die `evaluator` Parameter ist der Delegat für eine benutzerdefinierte Methode, die Sie definieren und, die jede Übereinstimmung überprüft. Die benutzerdefinierte Methode benötigen die folgende Signatur entsprechend der <xref:System.Text.RegularExpressions.MatchEvaluator> delegieren.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Die benutzerdefinierte Methode gibt eine Zeichenfolge, die ersetzt die übereinstimmende Eingabe zurück.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme ausgelöst, wenn die Ausführungszeit der Ersetzung des Timeoutintervalls, der anhand des überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie ein Timeoutintervall nicht festlegen, wenn Sie den Konstruktor aufrufen, wird die Ausnahme ausgelöst, wenn der Vorgang alle für die Anwendungsdomäne festgelegt wird, in dem Timeoutwert überschreitet die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst  
  
 Da die Methode gibt `input` unverändert, wenn keine Übereinstimmung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methode, um zu bestimmen, ob die Methode auf die Eingabezeichenfolge Ersetzungen vorgenommen hat.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt von einer ursprünglichen Zeichenfolge, vergleicht jedes Wort in der ursprünglichen Zeichenfolge, konvertiert dem ersten Zeichen der jede Übereinstimmung in Großbuchstaben, zeigt die konvertierte Zeichenfolge.  
  
 [!code-csharp[Regex.Replace-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Regex.Replace-Instance/cs/sample.cs#1)]
 [!code-vb[Regex.Replace-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex.Replace-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="evaluator" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="http://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Ersetzungen</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int -&gt; string" Usage="regex.Replace (input, replacement, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="replacement">Die Ersatzzeichenfolge.</param>
        <param name="count">Die maximale Anzahl der Ersetzungen.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge eine angegebene Höchstanzahl von Zeichenfolgen, die mit dem Muster eines regulären Ausdrucks übereinstimmen, durch eine angegebene Ersetzungszeichenfolge.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Die Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn keine Entsprechung für das reguläre Ausdrucksmuster in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche nach Übereinstimmungen beginnt am Anfang der `input` Zeichenfolge. Der reguläre Ausdruck ist das Muster, das durch den Konstruktor für die aktuelle definiert ist <xref:System.Text.RegularExpressions.Regex> Objekt. Wenn `count` ist negativ, Ersetzungen weiterhin bis zum Ende der Zeichenfolge. Wenn `count` überschreitet die Anzahl der Übereinstimmungen, die alle Übereinstimmungen werden ersetzt.  
  
 Die `replacement` Parameter gibt die Zeichenfolge, die die erste ersetzen `count` findet in `input`. `replacement` kann einer beliebigen Kombination von literalen Text bestehen und [Ersetzungen](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Z. B. das Ersetzungsmuster `a*${test}b` fügt die Zeichenfolge "eine *" gefolgt von der Teilzeichenfolge, die mit der `test` Erfassungsgruppe, ggf. gefolgt von der Zeichenfolge "b". Die * Zeichen nicht als bei einem Metazeichen in einem Ersetzungsmuster erkannt wird.  
  
> [!NOTE]
>  Ersetzungen sind, die nur für reguläre Ausdrücke Sprachelemente, die in einem Ersetzungsmuster erkannt werden. Alle anderen Sprachelemente für reguläre Ausdrücke, einschließlich [Zeichen Escapezeichen](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sind im Muster für reguläre Ausdrücke nur zulässig und werden nicht in Ersetzungsmustern erkannt.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme ausgelöst, wenn die Ausführungszeit der Ersetzung des Timeoutintervalls, der anhand des überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie ein Timeoutintervall nicht festlegen, wenn Sie den Konstruktor aufrufen, wird die Ausnahme ausgelöst, wenn der Vorgang alle für die Anwendungsdomäne festgelegt wird, in dem Timeoutwert überschreitet die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst  
  
 Da die Methode gibt `input` unverändert, wenn keine Übereinstimmung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methode, um zu bestimmen, ob die Methode auf die Eingabezeichenfolge Ersetzungen vorgenommen hat.  
  
   
  
## Examples  
 Im folgende Beispiel ersetzt die ersten fünf Vorkommen von doppelten Zeichen durch ein einzelnes Zeichen an. Muster für reguläre Ausdrücke `(\w)\1` aufeinander folgenden Vorkommen eines einzelnen Zeichens entspricht, und weist das erste Vorkommen der ersten Erfassungsgruppe. Das Ersetzungsmuster `$1` ersetzt die gesamte Übereinstimmung mit der ersten erfassten Gruppe.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample8.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="replacement" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
        <related type="Article" href="http://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Ersetzungen</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="replacement">Die Ersatzzeichenfolge.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge alle mit einem angegebenen regulären Ausdruck übereinstimmenden Zeichenfolgen durch eine angegebene Ersetzungszeichenfolge.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Die Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn für <paramref name="pattern" /> keine Übereinstimmung in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die statische `Replace` Methoden sind gleichwertig mit der Erstellung einer <xref:System.Text.RegularExpressions.Regex> Objekt mit dem angegebenen regulären Ausdrucksmuster und Aufrufen der Instanzmethode `Replace`.  
  
 Die `pattern` -Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Die Suche nach Übereinstimmungen beginnt am Anfang der `input` Zeichenfolge.  
  
 Die `replacement` Parameter gibt die Zeichenfolge, die jede Übereinstimmung in ersetzt `input`. `replacement` kann einer beliebigen Kombination von literalen Text bestehen und [Ersetzungen](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Z. B. das Ersetzungsmuster `a*${test}b` fügt die Zeichenfolge "eine *" gefolgt von der Teilzeichenfolge, die mit der `test` Erfassungsgruppe, ggf. gefolgt von der Zeichenfolge "b". Die * Zeichen nicht als bei einem Metazeichen in einem Ersetzungsmuster erkannt wird.  
  
> [!NOTE]
>  Ersetzungen sind, die nur für reguläre Ausdrücke Sprachelemente, die in einem Ersetzungsmuster erkannt werden. Alle anderen Sprachelemente für reguläre Ausdrücke, einschließlich [Zeichen Escapezeichen](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sind im Muster für reguläre Ausdrücke nur zulässig und werden nicht in Ersetzungsmustern erkannt.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme ausgelöst, wenn die Ausführungszeit der Ersetzung überschreitet das Timeoutintervall angegeben, für die Anwendungsdomäne, in dem die Methode aufgerufen wird. Wenn kein Timeout in der Anwendungsdomäne definiert ist, oder der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
 Da die Methode gibt `input` unverändert, wenn keine Übereinstimmung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methode, um zu bestimmen, ob die Methode auf die Eingabezeichenfolge Ersetzungen vorgenommen hat.  
  
   
  
## Examples  
 Das folgende Beispiel definiert einen regulären Ausdruck `\s+`, mit der eine oder mehrere Leerzeichen übereinstimmt. Die Ersetzungszeichenfolge "", durch ein einzelnes Leerzeichen ersetzt.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample6.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample6.vb#6)]  
  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> Methode, um die lokalen Computer und Laufwerk Namen in einem UNC-Pfad mit einem lokalen Dateipfad zu ersetzen. Der reguläre Ausdruck verwendet die <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> Eigenschaft, um den Namen des lokalen Computers enthalten und die <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> Methode, um den Namen der logischen Laufwerke enthalten. Um das Beispiel erfolgreich ausgeführt wird, sollten Sie das Zeichenfolgenliteral "MeinComputer" durch den Namen Ihres lokalen Computers ersetzen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace3.vb#3)]  
  
 Muster für reguläre Ausdrücke wird durch den folgenden Ausdruck definiert:  
  
 `"\\\\(?i:" + Environment.MachineName + ")(?:\.\w+)*\\((?i:[" + driveNames + "]))\$"`  
  
 Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\\\\`|Entspricht zwei aufeinander folgende umgekehrte Schrägstrich (`\`) Zeichen. Da der umgekehrte Schrägstrich als Escapezeichen interpretiert wird, muss jeder umgekehrte Schrägstrich mit einem weiteren umgekehrten Schrägstrich mit Escapezeichen versehen werden.|  
|`(?i:" + Environment.MachineName + ")`|Führen Sie eine Suche die Zeichenfolge, die von zurückgegeben wird Groß-/Kleinschreibung der <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> Eigenschaft.|  
|`(?:\.\w+)*`|Entsprechung für den Punkt (`.`) Zeichens, gefolgt von einem oder mehreren Wortzeichen. Diese Übereinstimmung kann 0 (null) oder mehrmals vorkommen. Der übereinstimmende Teilausdruck jedoch nicht erfasst.|  
|`\\`|Entsprechen einen umgekehrten Schrägstrich (`\`) Zeichen.|  
|`((?i:[" + driveNames + "]))`|Führen Sie eine Übereinstimmung Groß-/Kleinschreibung der Zeichenklasse, die aus den einzelnen Laufwerks beachtende besteht. Dies ist der ersten erfassten Teilausdruck.|  
|`\$`|Entspricht das Dollarzeichen (`$`) Zeichen.|  
  
 Das Ersetzungsmuster `$1` ersetzt die gesamte Übereinstimmung mit der ersten erfassten Teilausdruck. D. h. ersetzt er den UNC-Namen für Computer und Laufwerk mit dem Laufwerkbuchstaben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> oder <paramref name="replacement" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage">
          <para>Diese-Methode ein Timeout, nach einem bestimmten Zeitintervall, das gleich der Standardwert für das Timeout der Anwendungsdomäne, in dem sie aufgerufen wird. Wenn Sie ein Timeoutwert für die Anwendungsdomäne, der Wert nicht definiert wurde <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das Timeout, die Methode verhindert werden. Ist die empfohlene statische Methode für das Ersetzen einer Musterübereinstimmung <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, mit dem Sie das Timeoutintervall festlegen.</para>
        </block>
        <related type="Article" href="http://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Ersetzungen</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="evaluator">Eine benutzerdefinierte Methode, die jede Übereinstimmung überprüft und entweder die ursprüngliche entsprechende Zeichenfolge oder eine Ersatzzeichenfolge zurückgibt.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge alle mit einem angegebenen regulären Ausdruck übereinstimmenden Zeichenfolgen durch eine von einem <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />-Delegaten zurückgegebene Zeichenfolge.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Eine Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn für <paramref name="pattern" /> keine Übereinstimmung in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> Methode eignet sich für die Übereinstimmung eines regulären Ausdrucks ersetzen, wenn eine der folgenden Bedingungen zutrifft:  
  
-   Die Ersetzungszeichenfolge kann nicht ohne weiteres von Ersatz-Muster eines regulären Ausdrucks angegeben werden.  
  
-   Die Ersetzungszeichenfolge ergibt sich aus der Verarbeitung in der entsprechenden Zeichenfolge.  
  
-   Die Ersetzungszeichenfolge ergibt sich aus bedingte Verarbeitung.  
  
 Die Methode entspricht dem Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> -Methode und übergeben jede <xref:System.Text.RegularExpressions.Match> Objekt in der zurückgegebenen <xref:System.Text.RegularExpressions.MatchCollection> -Auflistung, um die `evaluator` delegieren.  
  
 Die `pattern` -Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die `evaluator` Parameter ist der Delegat für eine benutzerdefinierte Methode, die Sie definieren und, die jede Übereinstimmung überprüft. Die benutzerdefinierte Methode benötigen die folgende Signatur entsprechend der <xref:System.Text.RegularExpressions.MatchEvaluator> delegieren.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Die benutzerdefinierte Methode gibt eine Zeichenfolge, die ersetzt die übereinstimmende Eingabe zurück.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme ausgelöst, wenn die Ausführungszeit der Ersetzung überschreitet das Timeoutintervall angegeben, für die Anwendungsdomäne, in dem die Methode aufgerufen wird. Wenn kein Timeout in der Anwendungsdomäne definiert ist, oder der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
 Da die Methode gibt `input` unverändert, wenn keine Übereinstimmung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methode, um zu bestimmen, ob die Methode auf die Eingabezeichenfolge Ersetzungen vorgenommen hat.  
  
   
  
## Examples  
 Im folgenden Beispiel wird einen regulären Ausdruck verwendet, um die einzelnen Wörter aus einer Zeichenfolge zu extrahieren und verwendet dann ein <xref:System.Text.RegularExpressions.MatchEvaluator> Delegat zum Aufrufen einer Methode, die mit dem Namen `WordScramble` , die die einzelnen Buchstaben im Wort durcheinanderbringt. Zu diesem Zweck die `WordScramble` Methode erstellt ein Array, das die Zeichen in der Übereinstimmung enthält. Außerdem erstellt es ein paralleles Array, das mit Daten gefüllt mit zufällige Gleitkommazahlen. Die Arrays sind sortiert, durch den Aufruf der <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> -Methode, und das sortierte Array dient als Argument an eine <xref:System.String> Klassenkonstruktor. Diese neu erstellte Zeichenfolge wird dann zurückgegeben, durch die `WordScramble` Methode. Muster für reguläre Ausdrücke `\w+` entspricht einem oder mehreren Wortzeichen, weiterhin die Engine für reguläre Ausdrücke zur Übereinstimmung Zeichen hinzufügen, bis ein nicht-Wortzeichen, z. B. ein Leerzeichen auftritt.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace5.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace5.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> oder <paramref name="evaluator" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage">
          <para>Diese-Methode ein Timeout, nach einem bestimmten Zeitintervall, das gleich der Standardwert für das Timeout der Anwendungsdomäne, in dem sie aufgerufen wird. Wenn Sie ein Timeoutwert für die Anwendungsdomäne, der Wert nicht definiert wurde <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das Timeout, die Methode verhindert werden. Die empfohlene statische Methode für das Auswerten und eine Musterübereinstimmung zu ersetzen ist <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, mit dem Sie das Timeoutintervall festlegen.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="http://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Ersetzungen</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int -&gt; string" Usage="regex.Replace (input, evaluator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="evaluator">Eine benutzerdefinierte Methode, die jede Übereinstimmung überprüft und entweder die ursprüngliche entsprechende Zeichenfolge oder eine Ersatzzeichenfolge zurückgibt.</param>
        <param name="count">Die maximale Anzahl der Ersetzungen.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge eine angegebene Höchstanzahl von Zeichenfolgen, die mit dem Muster eines regulären Ausdrucks übereinstimmen, durch eine von einem <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />-Delegaten zurückgegebene Zeichenfolge.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Eine Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn keine Entsprechung für das reguläre Ausdrucksmuster in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType> Methode eignet sich für die Übereinstimmung eines regulären Ausdrucks ersetzen, wenn eine der folgenden Bedingungen zutrifft:  
  
-   Die Ersetzungszeichenfolge kann nicht ohne weiteres von Ersatz-Muster eines regulären Ausdrucks angegeben werden.  
  
-   Die Ersetzungszeichenfolge ergibt sich aus der Verarbeitung in der entsprechenden Zeichenfolge.  
  
-   Die Ersetzungszeichenfolge ergibt sich aus bedingte Verarbeitung.  
  
 Die Methode entspricht dem Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> -Methode und übergeben die erste `count` <xref:System.Text.RegularExpressions.Match> Objekte in der zurückgegebenen <xref:System.Text.RegularExpressions.MatchCollection> -Auflistung, um die `evaluator` delegieren.  
  
 Der reguläre Ausdruck ist, durch den Konstruktor für den aktuellen definierten Muster <xref:System.Text.RegularExpressions.Regex> Objekt.  
  
 Die `evaluator` Parameter ist der Delegat für eine benutzerdefinierte Methode, die Sie definieren und, die jede Übereinstimmung überprüft. Die benutzerdefinierte Methode benötigen die folgende Signatur entsprechend der <xref:System.Text.RegularExpressions.MatchEvaluator> delegieren.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Die benutzerdefinierte Methode gibt eine Zeichenfolge, die ersetzt die übereinstimmende Eingabe zurück.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme ausgelöst, wenn die Ausführungszeit der Ersetzung des Timeoutintervalls, der anhand des überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie ein Timeoutintervall nicht festlegen, wenn Sie den Konstruktor aufrufen, wird die Ausnahme ausgelöst, wenn der Vorgang alle für die Anwendungsdomäne festgelegt wird, in dem Timeoutwert überschreitet die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst  
  
 Da die Methode gibt `input` unverändert, wenn keine Übereinstimmung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methode, um zu bestimmen, ob die Methode auf die Eingabezeichenfolge Ersetzungen vorgenommen hat.  
  
   
  
## Examples  
 Im folgenden Beispiel wird einen regulären Ausdruck, um die Hälfte der Wörter in einer Liste absichtlich falsch geschrieben. Er verwendet den regulären Ausdruck `\w*(ie|ei)\w*` für Wörter zu finden, die die Zeichen "ie" oder "Ei" enthalten. Übergibt der erste Hälfte der übereinstimmenden Wörter, die `ReverseLetter` -Methode, die wiederum verwendet die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Methode, um das "i" und "e" in die entsprechende Zeichenfolge umgekehrt. Die verbleibenden Wörter bleiben unverändert.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace7.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace7.vb#11)]  
  
 Der reguläre Ausdruck `\w*(ie|ei)\w*` wird entsprechend der Darstellung in der folgenden Tabelle definiert:  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\w*`|Übereinstimmung mit keinem oder mehreren Wortzeichen.|  
|`(ie&#124;ei)`|Übereinstimmung mit "ie" oder "Ei".|  
|`\w*`|Übereinstimmung mit keinem oder mehreren Wortzeichen.|  
  
 Muster für reguläre Ausdrücke `([ie])([ie])` in die `ReverseLetter` Methode entspricht dem ersten "i" oder "e" im Diphthong "ie" oder "Ei" und weist Sie den Buchstaben der ersten Erfassungsgruppe. Sie entspricht dem zweiten "i" oder "e" und weist den Buchstaben für die zweite Erfassungsgruppe. Die zwei Zeichen werden dann durch Aufrufen von umgekehrt die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> -Methode durch das Ersatzmuster `$2$1`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="evaluator" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="http://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Ersetzungen</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; string" Usage="regex.Replace (input, replacement, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="replacement">Die Ersatzzeichenfolge.</param>
        <param name="count">Die maximale Anzahl der Ersetzungen.</param>
        <param name="startat">Die Zeichenposition in der Eingabezeichenfolge, an der mit der Suche begonnen wird.</param>
        <summary>Ersetzt in einer angegebenen Eingabeteilzeichenfolge eine angegebene Höchstanzahl von Zeichenfolgen, die mit dem Muster eines regulären Ausdrucks übereinstimmen, durch eine angegebene Ersetzungszeichenfolge.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Die Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn keine Entsprechung für das reguläre Ausdrucksmuster in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche nach Übereinstimmungen startet in der `input` Zeichenfolge an der Position, die gemäß der `startat` Parameter. Der reguläre Ausdruck ist, durch den Konstruktor für den aktuellen definierten Muster <xref:System.Text.RegularExpressions.Regex> Objekt. Wenn `count` ist negativ, Ersetzungen weiterhin bis zum Ende der Zeichenfolge. Wenn `count` überschreitet die Anzahl der Übereinstimmungen, die alle Übereinstimmungen werden ersetzt.  
  
 Die `replacement` Parameter gibt die Zeichenfolge, die jede Übereinstimmung in ersetzt `input`. `replacement` kann einer beliebigen Kombination von literalen Text bestehen und [Ersetzungen](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Z. B. das Ersetzungsmuster `a*${test}b` fügt die Zeichenfolge "eine *" gefolgt von der Teilzeichenfolge, die mit der `test` Erfassungsgruppe, ggf. gefolgt von der Zeichenfolge "b". Die * Zeichen nicht als bei einem Metazeichen in einem Ersetzungsmuster erkannt wird.  
  
> [!NOTE]
>  Ersetzungen sind, die nur für reguläre Ausdrücke Sprachelemente, die in einem Ersetzungsmuster erkannt werden. Alle anderen Sprachelemente für reguläre Ausdrücke, einschließlich [Zeichen Escapezeichen](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sind im Muster für reguläre Ausdrücke nur zulässig und werden nicht in Ersetzungsmustern erkannt.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme ausgelöst, wenn die Ausführungszeit der Ersetzung des Timeoutintervalls, der anhand des überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie ein Timeoutintervall nicht festlegen, wenn Sie den Konstruktor aufrufen, wird die Ausnahme ausgelöst, wenn der Vorgang alle für die Anwendungsdomäne festgelegt wird, in dem Timeoutwert überschreitet die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst  
  
 Da die Methode gibt `input` unverändert, wenn keine Übereinstimmung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methode, um zu bestimmen, ob die Methode auf die Eingabezeichenfolge Ersetzungen vorgenommen hat.  
  
   
  
## Examples  
 Im folgende Beispiel werden doppeltem Zeilenabstand formatiert alle bis auf die erste Zeile einer Zeichenfolge. Definiert ein Muster für reguläre Ausdrücke `^.*$`, entspricht eine Zeile des Texts, Aufrufe der <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> Methode entsprechend die erste Zeile der Zeichenfolge ein, und verwendet die `Match.Index` und `Match.Count` Eigenschaften, um zu bestimmen, die Anfangsposition des zweiten Zeile.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample9.vb#9)]  
  
 Das Muster für reguläre Ausdrücke `^.*$` wird entsprechend der folgenden Tabelle definiert:  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`^`|Übereinstimmung mit dem Anfang einer Zeile. (Beachten Sie, dass die <xref:System.Text.RegularExpressions.Regex> Objekt instanziiert wurde, mithilfe der <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option; diese Zeichenklasse entsprechen, andernfalls nur der Anfang der Eingabezeichenfolge steht.)|  
|`.*`|Übereinstimmung mit beliebigem Zeichen NULL oder mehr Vorkommen.|  
|`$`|Übereinstimmung mit dem Ende einer Zeile. (Beachten Sie, dass die <xref:System.Text.RegularExpressions.Regex> Objekt instanziiert wurde, mithilfe der <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option; diese Zeichenklasse entsprechen, andernfalls nur der Anfang der Eingabezeichenfolge steht.)|  
  
 Die Ersetzungszeichenfolge (`vbCrLf + "$&"` in Visual Basic `"\n$&"` in c#) Fügt eine neue Zeile vor der übereinstimmenden Zeichenfolge. Beachten Sie, dass `\n` in die C#-Beispiel als das Zeilenumbruchzeichen vom C#-Compiler interpretiert wird; es stellt einen regulären Ausdruck-Escape-Zeichen dar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="replacement" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> ist kleiner als 0 (null) oder größer als die Länge von <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Ersetzungen</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="replacement">Die Ersatzzeichenfolge.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge alle mit einem angegebenen regulären Ausdruck übereinstimmenden Zeichenfolgen durch eine angegebene Ersetzungszeichenfolge. Durch angegebene Optionen wird die Suche nach Übereinstimmungen geändert.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Die Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn für <paramref name="pattern" /> keine Übereinstimmung in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die statische `Replace` Methoden sind gleichwertig mit der Erstellung einer <xref:System.Text.RegularExpressions.Regex> Objekt mit dem angegebenen regulären Ausdrucksmuster und Aufrufen der Instanzmethode `Replace`.  
  
 Die `pattern` -Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Bei Angabe von <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> für die `options` Parameter, die Suche nach Übereinstimmungen am Ende der Eingabezeichenfolge beginnt und bewegt sich nach links; andernfalls die Suche beginnt am Anfang der Eingabezeichenfolge und wird nach rechts verschoben.  
  
 Die `replacement` Parameter gibt die Zeichenfolge, die jede Übereinstimmung in ersetzt `input`. `replacement` kann einer beliebigen Kombination von literalen Text bestehen und [Ersetzungen](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Z. B. das Ersetzungsmuster `a*${test}b` fügt die Zeichenfolge "eine *" gefolgt von der Teilzeichenfolge, die mit der `test` Erfassungsgruppe, ggf. gefolgt von der Zeichenfolge "b". Die * Zeichen nicht als bei einem Metazeichen in einem Ersetzungsmuster erkannt wird.  
  
> [!NOTE]
>  Ersetzungen sind, die nur für reguläre Ausdrücke Sprachelemente, die in einem Ersetzungsmuster erkannt werden. Alle anderen Sprachelemente für reguläre Ausdrücke, einschließlich [Zeichen Escapezeichen](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sind im Muster für reguläre Ausdrücke nur zulässig und werden nicht in Ersetzungsmustern erkannt.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme ausgelöst, wenn die Ausführungszeit der Ersetzung überschreitet das Timeoutintervall angegeben, für die Anwendungsdomäne, in dem die Methode aufgerufen wird. Wenn kein Timeout in der Anwendungsdomäne definiert ist, oder der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
 Da die Methode gibt `input` unverändert, wenn keine Übereinstimmung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methode, um zu bestimmen, ob die Methode auf die Eingabezeichenfolge Ersetzungen vorgenommen hat.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> Methode, um die lokalen Computer und Laufwerk Namen in einem UNC-Pfad mit einem lokalen Dateipfad zu ersetzen. Der reguläre Ausdruck verwendet die <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> Eigenschaft, um den Namen des lokalen Computers enthalten und die <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> Methode, um den Namen der logischen Laufwerke enthalten. Alle Groß-regulären Ausdruck Zeichenfolge und Kleinschreibung beachtet. Um das Beispiel erfolgreich ausgeführt wird, sollten Sie das Zeichenfolgenliteral "MeinComputer" durch den Namen Ihres lokalen Computers ersetzen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace4.vb#4)]  
  
 Muster für reguläre Ausdrücke wird durch den folgenden Ausdruck definiert:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\\\\`|Entspricht zwei aufeinander folgende umgekehrte Schrägstrich (`\`) Zeichen. Da der umgekehrte Schrägstrich als Escapezeichen interpretiert wird, muss jeder umgekehrte Schrägstrich mit einem weiteren umgekehrten Schrägstrich mit Escapezeichen versehen werden.|  
|`+ Environment.MachineName +`|Übereinstimmung mit der Zeichenfolge, die von zurückgegeben wird das <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> Eigenschaft.|  
|`(?:\.\w+)*`|Entsprechung für den Punkt (`.`) Zeichens, gefolgt von einem oder mehreren Wortzeichen. Diese Übereinstimmung kann 0 (null) oder mehrmals vorkommen. Der übereinstimmende Teilausdruck jedoch nicht erfasst.|  
|`\\`|Entsprechen einen umgekehrten Schrägstrich (`\`) Zeichen.|  
|`([" + driveNames + "])`|Ordnen Sie die Zeichenklasse, die aus den einzelnen Laufwerkbuchstaben besteht. Dies ist der ersten erfassten Teilausdruck.|  
|`\$`|Entspricht das Dollarzeichen (`$`) Zeichen.|  
  
 Das Ersetzungsmuster `$1` ersetzt die gesamte Übereinstimmung mit der ersten erfassten Teilausdruck. D. h. ersetzt er den UNC-Namen für Computer und Laufwerk mit dem Laufwerkbuchstaben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> oder <paramref name="replacement" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage">
          <para>Diese-Methode ein Timeout, nach einem bestimmten Zeitintervall, das gleich der Standardwert für das Timeout der Anwendungsdomäne, in dem sie aufgerufen wird. Wenn Sie ein Timeoutwert für die Anwendungsdomäne, der Wert nicht definiert wurde <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das Timeout, die Methode verhindert werden. Ist die empfohlene statische Methode für das Ersetzen einer Musterübereinstimmung <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, mit dem Sie das Timeoutintervall festlegen.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="http://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Ersetzungen</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="evaluator">Eine benutzerdefinierte Methode, die jede Übereinstimmung überprüft und entweder die ursprüngliche entsprechende Zeichenfolge oder eine Ersatzzeichenfolge zurückgibt.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge alle mit einem angegebenen regulären Ausdruck übereinstimmenden Zeichenfolgen durch eine von einem <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />-Delegaten zurückgegebene Zeichenfolge. Durch angegebene Optionen wird die Suche nach Übereinstimmungen geändert.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Eine Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn für <paramref name="pattern" /> keine Übereinstimmung in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> Methode eignet sich für die Übereinstimmung eines regulären Ausdrucks in ersetzen, wenn eine der folgenden Bedingungen zutrifft:  
  
-   Die Ersetzungszeichenfolge kann nicht ohne weiteres von Ersatz-Muster eines regulären Ausdrucks angegeben werden.  
  
-   Die Ersetzungszeichenfolge ergibt sich aus der Verarbeitung in der entsprechenden Zeichenfolge.  
  
-   Die Ersetzungszeichenfolge ergibt sich aus bedingte Verarbeitung.  
  
 Die Methode entspricht dem Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> -Methode und übergeben jede <xref:System.Text.RegularExpressions.Match> Objekt in der zurückgegebenen <xref:System.Text.RegularExpressions.MatchCollection> -Auflistung, um die `evaluator` delegieren.  
  
 Die `pattern` -Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die `evaluator` Parameter ist der Delegat für eine benutzerdefinierte Methode, die Sie definieren und, die jede Übereinstimmung überprüft. Die benutzerdefinierte Methode benötigen die folgende Signatur entsprechend der <xref:System.Text.RegularExpressions.MatchEvaluator> delegieren.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Die benutzerdefinierte Methode gibt eine Zeichenfolge, die ersetzt die übereinstimmende Eingabe zurück.  
  
 Bei Angabe von <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> für die `options` Parameter, die Suche nach Übereinstimmungen am Ende der Eingabezeichenfolge beginnt und bewegt sich nach links; andernfalls die Suche beginnt am Anfang der Eingabezeichenfolge und wird nach rechts verschoben.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme ausgelöst, wenn die Ausführungszeit der Ersetzung überschreitet das Timeoutintervall angegeben, für die Anwendungsdomäne, in dem die Methode aufgerufen wird. Wenn kein Timeout in der Anwendungsdomäne definiert ist, oder der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
 Da die Methode gibt `input` unverändert, wenn keine Übereinstimmung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methode, um zu bestimmen, ob die Methode auf die Eingabezeichenfolge Ersetzungen vorgenommen hat.  
  
   
  
## Examples  
 Im folgenden Beispiel wird einen regulären Ausdruck verwendet, um die einzelnen Wörter aus einer Zeichenfolge zu extrahieren und verwendet dann ein <xref:System.Text.RegularExpressions.MatchEvaluator> Delegat zum Aufrufen einer Methode, die mit dem Namen `WordScramble` , die die einzelnen Buchstaben im Wort durcheinanderbringt. Zu diesem Zweck die `WordScramble` Methode erstellt ein Array, das die Zeichen in der Übereinstimmung enthält. Außerdem erstellt es ein paralleles Array, das mit Daten gefüllt mit zufällige Gleitkommazahlen. Die Arrays sind sortiert, durch den Aufruf der <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> -Methode, und das sortierte Array dient als Argument an eine <xref:System.String> Klassenkonstruktor. Diese neu erstellte Zeichenfolge wird dann zurückgegeben, durch die `WordScramble` Methode. Muster für reguläre Ausdrücke `\w+` entspricht einem oder mehreren Wortzeichen, weiterhin die Engine für reguläre Ausdrücke zur Übereinstimmung Zeichen hinzufügen, bis ein nicht-Wortzeichen, z. B. ein Leerzeichen auftritt. Der Aufruf der <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> Methode enthält die <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> Option, damit den Kommentar im Muster eines regulären Ausdrucks `\w+  # Matches all the characters in a word.` wird von der Engine für reguläre Ausdrücke ignoriert.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace6.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace6.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> oder <paramref name="evaluator" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="http://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Ersetzungen</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int * int -&gt; string" Usage="regex.Replace (input, evaluator, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="evaluator">Eine benutzerdefinierte Methode, die jede Übereinstimmung überprüft und entweder die ursprüngliche entsprechende Zeichenfolge oder eine Ersatzzeichenfolge zurückgibt.</param>
        <param name="count">Die maximale Anzahl der Ersetzungen.</param>
        <param name="startat">Die Zeichenposition in der Eingabezeichenfolge, an der mit der Suche begonnen wird.</param>
        <summary>Ersetzt in einer angegebenen Eingabeteilzeichenfolge eine angegebene Höchstanzahl von Zeichenfolgen, die mit dem Muster eines regulären Ausdrucks übereinstimmen, durch eine von einem <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />-Delegaten zurückgegebene Zeichenfolge.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Eine Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn keine Entsprechung für das reguläre Ausdrucksmuster in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Methode eignet sich für die Übereinstimmung eines regulären Ausdrucks ersetzen, wenn eine der folgenden Bedingungen zutrifft:  
  
-   Die Ersetzungszeichenfolge kann nicht ohne weiteres von Ersatz-Muster eines regulären Ausdrucks angegeben werden.  
  
-   Die Ersetzungszeichenfolge ergibt sich aus der Verarbeitung in der entsprechenden Zeichenfolge.  
  
-   Die Ersetzungszeichenfolge ergibt sich aus bedingte Verarbeitung.  
  
 Die Methode entspricht dem Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> -Methode und übergeben die erste `count` <xref:System.Text.RegularExpressions.Match> Objekte in der zurückgegebenen <xref:System.Text.RegularExpressions.MatchCollection> -Auflistung, um die `evaluator` delegieren.  
  
 Der reguläre Ausdruck ist, durch den Konstruktor für den aktuellen definierten Muster <xref:System.Text.RegularExpressions.Regex> Objekt.  
  
 Die `evaluator` Parameter ist der Delegat für eine benutzerdefinierte Methode, die Sie definieren und, die jede Übereinstimmung überprüft. Die benutzerdefinierte Methode benötigen die folgende Signatur entsprechend der <xref:System.Text.RegularExpressions.MatchEvaluator> delegieren.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Die benutzerdefinierte Methode gibt eine Zeichenfolge, die ersetzt die übereinstimmende Eingabe zurück.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme ausgelöst, wenn die Ausführungszeit der Ersetzung des Timeoutintervalls, der anhand des überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie ein Timeoutintervall nicht festlegen, wenn Sie den Konstruktor aufrufen, wird die Ausnahme ausgelöst, wenn der Vorgang alle für die Anwendungsdomäne festgelegt wird, in dem Timeoutwert überschreitet die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst  
  
 Da die Methode gibt `input` unverändert, wenn keine Übereinstimmung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methode, um zu bestimmen, ob die Methode auf die Eingabezeichenfolge Ersetzungen vorgenommen hat.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="evaluator" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> ist kleiner als 0 (null) oder größer als die Länge von <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="http://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Ersetzungen</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="replacement">Die Ersatzzeichenfolge.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <param name="matchTimeout">Ein Timeoutintervall oder <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das angibt, dass die Methode kein Timeout haben sollte.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge alle mit einem angegebenen regulären Ausdruck übereinstimmenden Zeichenfolgen durch eine angegebene Ersetzungszeichenfolge. Zusätzliche Parameter geben die Optionen an, die den entsprechenden Vorgang und ein Timeoutintervall ändern, wenn keine Übereinstimmung gefunden wird.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Die Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn für <paramref name="pattern" /> keine Übereinstimmung in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die statische `Replace` Methoden sind gleichwertig mit der Erstellung einer <xref:System.Text.RegularExpressions.Regex> Objekt mit dem angegebenen regulären Ausdrucksmuster und Aufrufen der Instanzmethode `Replace`.  
  
 Die `pattern` -Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Bei Angabe von <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> für die `options` Parameter, die Suche nach Übereinstimmungen am Ende der Eingabezeichenfolge beginnt und bewegt sich nach links; andernfalls die Suche beginnt am Anfang der Eingabezeichenfolge und wird nach rechts verschoben.  
  
 Die `replacement` Parameter gibt die Zeichenfolge, die jede Übereinstimmung in ersetzt `input`. `replacement` kann einer beliebigen Kombination von literalen Text bestehen und [Ersetzungen](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Z. B. das Ersetzungsmuster `a*${test}b` fügt die Zeichenfolge "eine *" gefolgt von der Teilzeichenfolge, die mit der `test` Erfassungsgruppe, ggf. gefolgt von der Zeichenfolge "b". Die * Zeichen nicht als bei einem Metazeichen in einem Ersetzungsmuster erkannt wird.  
  
> [!NOTE]
>  Ersetzungen sind, die nur für reguläre Ausdrücke Sprachelemente, die in einem Ersetzungsmuster erkannt werden. Alle anderen Sprachelemente für reguläre Ausdrücke, einschließlich [Zeichen Escapezeichen](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sind im Muster für reguläre Ausdrücke nur zulässig und werden nicht in Ersetzungsmustern erkannt.  
  
 Die `matchTimeout` Parameter gibt an, wie lange ein Musterabgleich Methode sollten versuchen, eine Übereinstimmung gefunden wird, bevor ein Timeout eintritt. Ein Timeoutintervall festlegen wird verhindert, dass reguläre Ausdrücke, die übermäßige rückverfolgung angezeigt werden, nicht mehr reagiert, wenn diese Eingaben verarbeiten, die in der Nähe von Übereinstimmungen enthält. Weitere Informationen finden Sie unter [bewährte Methoden für reguläre Ausdrücke](~/docs/standard/base-types/best-practices.md) und [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Wenn Sie in dieses Zeitintervalls keine Übereinstimmung gefunden wird, löst die Methode eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme. `matchTimeout` überschreibt alle Standard-Timeoutwert, der definiert, die für die Anwendungsdomäne, in der die Methode ausgeführt wird.  
  
 Da die Methode gibt `input` unverändert, wenn keine Übereinstimmung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methode, um zu bestimmen, ob die Methode auf die Eingabezeichenfolge Ersetzungen vorgenommen hat.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> Methode, um die lokalen Computer und Laufwerk Namen in einem UNC-Pfad mit einem lokalen Dateipfad zu ersetzen. Der reguläre Ausdruck verwendet die <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> Eigenschaft, um den Namen des lokalen Computers enthalten und die <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> Methode, um den Namen der logischen Laufwerke enthalten. Alle regulären Ausdruck Zeichenfolge Groß-und Kleinschreibung beachtet, und jeder einzelne Ersetzung-Vorgang ein Timeout in 0,5-Sekunden keine Übereinstimmung gefunden werden kann. Um das Beispiel erfolgreich ausgeführt wird, sollten Sie das Zeichenfolgenliteral "MeinComputer" durch den Namen Ihres lokalen Computers ersetzen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace12.cs#12)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace12.vb#12)]  
  
 Muster für reguläre Ausdrücke wird durch den folgenden Ausdruck definiert:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 Die folgende Tabelle zeigt, wie das Muster eines regulären Ausdrucks interpretiert wird.  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\\\\`|Entspricht zwei aufeinander folgende umgekehrte Schrägstrich (`\`) Zeichen. Da der umgekehrte Schrägstrich als Escapezeichen interpretiert wird, muss jeder umgekehrte Schrägstrich mit einem weiteren umgekehrten Schrägstrich mit Escapezeichen versehen werden.|  
|`+ Environment.MachineName +`|Übereinstimmung mit der Zeichenfolge, die von zurückgegeben wird das <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> Eigenschaft.|  
|`(?:\.\w+)*`|Entsprechung für den Punkt (`.`) Zeichens, gefolgt von einem oder mehreren Wortzeichen. Diese Übereinstimmung kann 0 (null) oder mehrmals vorkommen. Der übereinstimmende Teilausdruck jedoch nicht erfasst.|  
|`\\`|Entsprechen einen umgekehrten Schrägstrich (`\`) Zeichen.|  
|`([" + driveNames + "])`|Ordnen Sie die Zeichenklasse, die aus den einzelnen Laufwerkbuchstaben besteht. Dies ist der ersten erfassten Teilausdruck.|  
|`\$`|Entspricht das Dollarzeichen (`$`) Zeichen.|  
  
 Das Ersetzungsmuster `$1` ersetzt die gesamte Übereinstimmung mit der ersten erfassten Teilausdruck. D. h. ersetzt er den UNC-Namen für Computer und Laufwerk mit dem Laufwerkbuchstaben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> oder <paramref name="replacement" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.  
  
- oder -  
 <paramref name="matchTimeout" /> ist negativ, 0 oder größer als ca. 24 Tage.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage">
          <para>Es wird empfohlen, Sie legen die <paramref name="matchTimeout" /> Parameter auf einen geeigneten Wert, z. B. zwei Sekunden. Wenn Sie Timeouts werden, indem deaktiviert <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, die Engine für reguläre Ausdrücke bietet eine etwas bessere Leistung. Allerdings sollten Sie Timeouts nur unter folgenden Bedingungen deaktivieren: 
– Wenn die Eingabe verarbeitet, die von einem regulären Ausdruck aus einer bekannten und vertrauenswürdigen Quelle stammt oder besteht aus statischen Text. Dies schließt Text, der vom Benutzer eingegebene dynamisch wurde.  
  
– Wenn Sie Muster für reguläre Ausdrücke gründlich getestet wurde, um sicherzustellen, dass er effizient verarbeitet übereinstimmt, nicht-Übereinstimmungen und Naher entspricht.  
  
– Wenn Muster für reguläre Ausdrücke keine Language-Elemente enthält, die bekannt sind, um eine übermäßige rückverfolgung bei der Verarbeitung einer Nahen Übereinstimmung zu verursachen.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="http://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Ersetzungen</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
        <related type="Article" href="http://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">Backtracking</related>
        <related type="Article" href="http://msdn.microsoft.com/library/618e5afb-3a97-440d-831a-70e4c526a51c">Empfohlene Vorgehensweisen für die Verwendung von regulären Ausdrücken in .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Die nach einer Übereinstimmung zu durchsuchende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="evaluator">Eine benutzerdefinierte Methode, die jede Übereinstimmung überprüft und entweder die ursprüngliche entsprechende Zeichenfolge oder eine Ersatzzeichenfolge zurückgibt.</param>
        <param name="options">Eine bitweise Kombination von Enumerationswerten, die Optionen für Vergleiche angeben.</param>
        <param name="matchTimeout">Ein Timeoutintervall oder <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das angibt, dass die Methode kein Timeout haben sollte.</param>
        <summary>Ersetzt in einer angegebenen Eingabezeichenfolge alle mit einem angegebenen regulären Ausdruck übereinstimmenden Teilzeichenfolgen durch eine von einem <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />-Delegaten zurückgegebene Zeichenfolge. Zusätzliche Parameter geben die Optionen an, die den entsprechenden Vorgang und ein Timeoutintervall ändern, wenn keine Übereinstimmung gefunden wird.</summary>
        <returns>Eine neue, mit der Eingabezeichenfolge identische Zeichenfolge. Die Ersetzungszeichenfolge ersetzt jedoch alle übereinstimmenden Zeichenfolgen. Wenn für <paramref name="pattern" /> keine Übereinstimmung in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> Methode eignet sich für die Übereinstimmung eines regulären Ausdrucks ersetzen, wenn eine der folgenden Bedingungen zutrifft:  
  
-   Wenn die Ersatzzeichenfolge leicht von Ersatz-Muster eines regulären Ausdrucks angegeben werden kann.  
  
-   Wenn die Ersatzzeichenfolge aus führt einige Verarbeitungsschritte, die für die übereinstimmende Zeichenfolge ausgeführt werden.  
  
-   Wenn die Ersatzzeichenfolge aus bedingte Verarbeitung ergibt.  
  
 Die Methode entspricht dem Aufrufen der <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> -Methode und übergeben jede <xref:System.Text.RegularExpressions.Match> Objekt in der zurückgegebenen <xref:System.Text.RegularExpressions.MatchCollection> -Auflistung, um die `evaluator` delegieren.  
  
 Die `pattern` -Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Die `evaluator` Parameter ist der Delegat für eine benutzerdefinierte Methode, die Sie definieren und, die jede Übereinstimmung überprüft. Die benutzerdefinierte Methode benötigen die folgende Signatur entsprechend der <xref:System.Text.RegularExpressions.MatchEvaluator> delegieren.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Die benutzerdefinierte Methode gibt eine Zeichenfolge, die ersetzt die übereinstimmende Eingabe zurück.  
  
 Bei Angabe von <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> für die `options` Parameter, die Suche nach Übereinstimmungen am Ende der Eingabezeichenfolge beginnt und bewegt sich nach links; andernfalls die Suche beginnt am Anfang der Eingabezeichenfolge und wird nach rechts verschoben.  
  
 Die `matchTimeout` Parameter gibt an, wie lange ein Musterabgleich Methode sollten versuchen, eine Übereinstimmung gefunden wird, bevor ein Timeout eintritt. Ein Timeoutintervall festlegen wird verhindert, dass reguläre Ausdrücke, die übermäßige rückverfolgung angezeigt werden, um "nicht mehr reagiert, wenn diese Eingaben verarbeiten, die in der Nähe von Übereinstimmungen enthält. Weitere Informationen finden Sie unter [bewährte Methoden für reguläre Ausdrücke](~/docs/standard/base-types/best-practices.md) und [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Wenn Sie in dieses Zeitintervalls keine Übereinstimmung gefunden wird, löst die Methode eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme. `matchTimeout` überschreibt alle Standard-Timeoutwert, der definiert, die für die Anwendungsdomäne, in der die Methode ausgeführt wird.  
  
 Da die Methode gibt `input` unverändert, wenn keine Übereinstimmung vorhanden ist, können Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methode, um zu bestimmen, ob die Methode auf die Eingabezeichenfolge Ersetzungen vorgenommen hat.  
  
   
  
## Examples  
 Im folgenden Beispiel wird einen regulären Ausdruck verwendet, um die einzelnen Wörter aus einer Zeichenfolge zu extrahieren und verwendet dann ein <xref:System.Text.RegularExpressions.MatchEvaluator> Delegat zum Aufrufen einer Methode, die mit dem Namen `WordScramble` , die die einzelnen Buchstaben im Wort durcheinanderbringt. Zu diesem Zweck die `WordScramble` Methode erstellt ein Array, das die Zeichen in der Übereinstimmung enthält. Außerdem erstellt es ein paralleles Array, das mit Daten gefüllt mit zufällige Gleitkommazahlen. Die Arrays sind sortiert, durch den Aufruf der <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> -Methode, und das sortierte Array dient als Argument an eine <xref:System.String> Klassenkonstruktor. Diese neu erstellte Zeichenfolge wird dann zurückgegeben, durch die `WordScramble` Methode. Muster für reguläre Ausdrücke `\w+` entspricht einem oder mehreren Wortzeichen, weiterhin die Engine für reguläre Ausdrücke zur Übereinstimmung Zeichen hinzufügen, bis ein nicht-Wortzeichen, z. B. ein Leerzeichen auftritt. Der Aufruf der <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> Methode enthält die <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> Option, damit den Kommentar im Muster eines regulären Ausdrucks `\w+  # Matches all the characters in a word.` wird von der Engine für reguläre Ausdrücke ignoriert.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace13.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> oder <paramref name="evaluator" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.  
  
- oder -  
 <paramref name="matchTimeout" /> ist negativ, 0 oder größer als ca. 24 Tage.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage">
          <para>Es wird empfohlen, Sie legen die <paramref name="matchTimeout" /> Parameter auf einen geeigneten Wert, z. B. zwei Sekunden. Wenn Sie Timeouts werden, indem deaktiviert <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, die Engine für reguläre Ausdrücke bietet eine etwas bessere Leistung. Allerdings sollten Sie Timeouts nur unter folgenden Bedingungen deaktivieren: 
– Wenn die Eingabe verarbeitet, die von einem regulären Ausdruck aus einer bekannten und vertrauenswürdigen Quelle stammt oder besteht aus statischen Text. Dies schließt Text, der vom Benutzer eingegebene dynamisch wurde.  
  
– Wenn Sie Muster für reguläre Ausdrücke gründlich getestet wurde, um sicherzustellen, dass er effizient verarbeitet übereinstimmt, nicht-Übereinstimmungen und Naher entspricht.  
  
– Wenn Muster für reguläre Ausdrücke keine Language-Elemente enthält, die bekannt sind, um eine übermäßige rückverfolgung bei der Verarbeitung einer Nahen Übereinstimmung zu verursachen.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="http://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Ersetzungen</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
        <related type="Article" href="http://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">Backtracking</related>
        <related type="Article" href="http://msdn.microsoft.com/library/618e5afb-3a97-440d-831a-70e4c526a51c">Empfohlene Vorgehensweisen für die Verwendung von regulären Ausdrücken in .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : bool" Usage="System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der reguläre Ausdruck von rechts nach links sucht.</summary>
        <value>
          <see langword="true" />, wenn der reguläre Ausdruck von rechts nach links sucht, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.RightToLeft%2A> ist `true` Wenn die <xref:System.Text.RegularExpressions.Regex> Instanz erstellt wurde, mit der <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> Option.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="roptions">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexOptions roptions;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.Text.RegularExpressions.RegexOptions roptions" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.roptions" />
      <MemberSignature Language="VB.NET" Value="Protected Friend roptions As RegexOptions " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexOptions roptions;" />
      <MemberSignature Language="F#" Value="val mutable roptions : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.roptions" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Teilt eine Eingabezeichenfolge an den Positionen in ein Array von Teilzeichenfolgen auf, die durch eine Übereinstimmung mit einem regulären Ausdruck definiert werden.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Split : string -&gt; string[]" Usage="regex.Split input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die aufzuteilende Zeichenfolge.</param>
        <summary>Teilt die angegebene Eingabezeichenfolge an den Positionen in ein Array von Teilzeichenfolgen auf, die durch ein im <see cref="T:System.Text.RegularExpressions.Regex" />-Konstruktor angegebenes Muster für einen regulären Ausdruck definiert werden.</summary>
        <returns>Ein Array von Zeichenfolgen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Methoden ähneln den <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> -Methode, außer dass <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> teilt die Zeichenfolge an einem Trennzeichen, die von einem regulären Ausdruck statt eines Satzes von Zeichen festgelegt. Die Zeichenfolge wird so oft wie möglich zu teilen. Wenn kein Trennzeichen gefunden wird, enthält der zurückgegebene Wert ein Element, dessen Wert der ursprünglichen Eingabezeichenfolge entspricht.  
  
 Wenn mehrere Übereinstimmungen neben anderen sind, wird eine leere Zeichenfolge in das Array eingefügt. Beispielsweise wird das Aufteilen einer Zeichenfolge in einen einzelnen Bindestrich das zurückgegebene Array an der Position eine leere Zeichenfolge eingeschlossen, in denen zwei aufeinanderfolgende Bindestriche, wie im folgenden Code gezeigt gefunden werden.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split1.vb#1)]  
  
 Wenn eine Übereinstimmung am Anfang oder Ende der Eingabezeichenfolge gefunden wird, ist eine leere Zeichenfolge am Anfang oder Ende des zurückgegebenen Arrays enthalten. Im folgenden Beispiel wird das Muster für reguläre Ausdrücke `\d+` eine Eingabezeichenfolge auf numerische Zeichen geteilt. Da die Zeichenfolge beginnt und endet mit entsprechenden numerische Zeichen, ist der Wert des ersten und letzten Elements von dem zurückgegebenen Array <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split21.cs#21)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split21.vb#21)]  
  
 Wenn in Klammern für die Erfassung verwendet werden eine <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Ausdruck, der alle aufgezeichneten Text ist in der sich ergebende Zeichenfolge enthalten. Wenn die Zeichenfolge "Plum-Pear" auf einen Bindestrich innerhalb von Klammern umschließenden aufgeteilt wird, enthält das zurückgegebene Array z. B. eine String-Element, das den Bindestrich enthält.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split2.vb#2)]  
  
 Wenn das Muster für reguläre Ausdrücke mehrere Sätze von schließenden Klammern enthält, hängt jedoch das Verhalten dieser Methode die Version von .NET Framework. Wenn eine Übereinstimmung in den ersten Satz von schließenden Klammern, nicht gefunden wird, ist in .NET Framework 1.0 und 1.1 nicht erfasster Text von zusätzlichen Klammern für die Erfassung im zurückgegebenen Array enthalten. Ab .NET Framework 2.0, wird allen erfasster Text auch das zurückgegebene Array hinzugefügt. Der folgende Code verwendet beispielsweise zwei Sätze von schließenden Klammern, um die Elemente eines Datums, einschließlich der Date-Trennzeichen, über eine Datumszeichenfolge zu extrahieren. Der erste Satz von schließenden Klammern erfasst den Bindestrich ein, und der zweite Satz erfasst einen Schrägstrich. Wenn Beispielcode kompiliert und unter .NET Framework 1.0 oder 1.1 ausgeführt werden, die Schrägstriche ausgeschlossen. Wenn sie der Kompilierung und Ausführung unter der .NET Framework 2.0 oder höher, werden diese eingeschlossen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split3.vb#3)]  
  
 Wenn der reguläre Ausdruck der leere Zeichenfolge ist, als Entsprechung möglich <xref:System.Text.RegularExpressions.Regex.Split%28System.String%29> die Zeichenfolge wird in ein Array von Einzelzeichen-Zeichenfolgen aufgeteilt werden, da die Trennzeichen für leere Zeichenfolgen an jedem Standort gefunden werden kann. Zum Beispiel:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split11.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split11.vb#11)]  
  
 Beachten Sie, dass das zurückgegebene Array auch eine leere Zeichenfolge am Anfang und Ende des Arrays enthält.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme ausgelöst, wenn die Ausführungszeit des Split-Vorgangs das Timeoutintervall gemäß überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie ein Timeoutintervall nicht festlegen, wenn Sie den Konstruktor aufrufen, wird die Ausnahme ausgelöst, wenn der Vorgang alle für die Anwendungsdomäne festgelegt wird, in dem Timeoutwert überschreitet die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int -&gt; string[]" Usage="regex.Split (input, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die aufzuteilende Zeichenfolge.</param>
        <param name="count">Die maximale Anzahl der Teilungen.</param>
        <summary>Teilt die angegebene Eingabezeichenfolge höchstens die angegebene Anzahl von Malen an den Positionen in ein Array von Teilzeichenfolgenketten auf, die durch einen im <see cref="T:System.Text.RegularExpressions.Regex" />-Konstruktor angegebenen regulären Ausdruck definiert werden.</summary>
        <returns>Ein Array von Zeichenfolgen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Methoden ähneln den <xref:System.String.Split%2A?displayProperty=nameWithType> -Methode, außer dass <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> teilt die Zeichenfolge an einem Trennzeichen, die von einem regulären Ausdruck statt eines Satzes von Zeichen festgelegt. Die `count` Parameter gibt die maximale Anzahl von Teilzeichenfolgen auf, in dem die `input` Zeichenfolge aufgeteilt werden kann; die letzte Zeichenfolge enthält, die nicht aufgeteilten Rest der Zeichenfolge. Ein `count` Wert 0 (null) ist das Standardverhalten so oft wie möglich geteilt.  
  
 Wenn mehrere Übereinstimmungen neben anderen sind oder wenn eine Übereinstimmung, am Anfang oder Ende des gefunden wird `input`, und die Anzahl der gefundenen Übereinstimmungen ist mindestens zwei kleiner als `count`, eine leere Zeichenfolge in das Array eingefügt wird. Also leere Zeichenfolgen, die aus den benachbarten Übereinstimmungen oder aus den Übereinstimmungen am Anfang oder Ende der Eingabezeichenfolge resultieren gezählt werden bei der Bestimmung, ob die Anzahl der Teilzeichenfolgen Equals abgeglichen `count`. Im folgenden Beispiel ist der reguläre Ausdruck `/d+` wird verwendet, um eine Eingabezeichenfolge zu teilen, die eine oder mehrere Dezimalstellen sind in maximal drei Teilzeichenfolgen enthält. Da es sich bei der Anfang der Eingabezeichenfolge Muster des regulären Ausdrucks übereinstimmt, enthält das erste Arrayelement <xref:System.String.Empty?displayProperty=nameWithType>, die zweite enthält die erste Gruppe von alphabetischen Zeichen in der Eingabezeichenfolge und die dritte Spalte enthält den Rest der Zeichenfolge der die dritte Übereinstimmung folgt.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split25.cs#25)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split25.vb#25)]  
  
 Wenn Klammern für die Erfassung in einem regulären Ausdruck verwendet werden, ist erfasster Text in das Split-Zeichenfolgenarray enthalten. Allerdings alle Elemente des Arrays, die aufgezeichneten Text enthalten, werden nicht gezählt bei der Bestimmung, ob die Anzahl der Übereinstimmungen erreicht hat `count`. Beispielsweise zeigt Teilen der Zeichenfolge "Apple-Apricot-Plum-Pear-Banane" in die maximale Anzahl von vier Teilzeichenfolgen-Ergebnissen in ein Array mit sieben Elementen, wie der folgende Code.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split4.vb#4)]  
  
 Wenn das Muster für reguläre Ausdrücke mehrere Sätze von schließenden Klammern enthält, hängt jedoch das Verhalten dieser Methode die Version von .NET Framework. In .NET Framework 1.0 und 1.1 ist nur erfasster Text aus den ersten Satz von schließenden Klammern im zurückgegebenen Array enthalten. Ab .NET Framework 2.0, wird das zurückgegebene Array alle erfasster Text hinzugefügt. Allerdings Elemente im zurückgegebenen Array erfassten Text enthalten werden nicht gezählt, bei der Bestimmung, ob die Anzahl der Teilzeichenfolgen Equals abgeglichen `count`. Im folgenden Code verwendet einen regulären Ausdruck beispielsweise zwei Sätze von schließenden Klammern um die Elemente eines Datums aus eine Datumszeichenfolge zu extrahieren. Der erste Satz von schließenden Klammern erfasst den Bindestrich ein, und der zweite Satz erfasst einen Schrägstrich. Der Aufruf der <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> Methode gibt dann ein Maximum von zwei Elementen im zurückgegebenen Array. Wenn Beispielcode kompiliert und unter .NET Framework 1.0 oder 1.1 ausgeführt werden, gibt die Methode ein Zeichenfolgenarray mit zwei Elementen zurück. Wenn sie der Kompilierung und Ausführung unter der .NET Framework 2.0 oder höher, gibt die Methode ein Array drei Elemente zurück.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split5.vb#5)]  
  
 Wenn der reguläre Ausdruck der leere Zeichenfolge ist, als Entsprechung möglich <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> die Zeichenfolge wird in ein Array von Einzelzeichen-Zeichenfolgen aufgeteilt werden, da die Trennzeichen für leere Zeichenfolgen an jedem Standort gefunden werden kann. Im folgende Beispiel teilt die Zeichenfolge "Zeichen" in, wie Anzahl der Elemente in der Eingabezeichenfolge steht. Da die null-Zeichenfolge auf den Anfang der Eingabezeichenfolge entspricht, wird eine null-Zeichenfolge am Anfang der zurückgegebenen Array eingefügt. Dies bewirkt, dass der zehnten Elements der beiden Zeichen am Ende der Eingabezeichenfolge bestehen.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split12.vb#12)]  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme ausgelöst, wenn die Ausführungszeit des Split-Vorgangs das Timeoutintervall gemäß überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie ein Timeoutintervall nicht festlegen, wenn Sie den Konstruktor aufrufen, wird die Ausnahme ausgelöst, wenn der Vorgang alle für die Anwendungsdomäne festgelegt wird, in dem Timeoutwert überschreitet die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Split : string * string -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die aufzuteilende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <summary>Teilt eine Eingabezeichenfolge an den durch ein reguläres Ausdrucksmuster definierten Positionen in ein Array von Teilzeichenfolgen auf.</summary>
        <returns>Ein Array von Zeichenfolgen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Methoden ähneln den <xref:System.String.Split%2A?displayProperty=nameWithType> -Methode, außer dass <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> teilt die Zeichenfolge an einem Trennzeichen, die von einem regulären Ausdruck statt eines Satzes von Zeichen festgelegt. Die `input` -Zeichenfolge wird geteilt, so oft wie möglich. Wenn `pattern` befindet sich nicht der `input` Zeichenfolge und der Rückgabewert enthält ein Element, dessen Wert die ursprünglichen `input` Zeichenfolge.  
  
 Die `pattern` -Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Kompilierte reguläre Ausdrücke, die in statischen Aufrufen verwendet <xref:System.Text.RegularExpressions.Regex.Split%2A> Methoden werden automatisch zwischengespeichert. Um die Lebensdauer der kompilierte reguläre Ausdrücke selbst zu verwalten, verwenden Sie die Instanz <xref:System.Text.RegularExpressions.Regex.Split%2A> Methoden.  
  
 Wenn mehrere Übereinstimmungen neben anderen sind, wird eine leere Zeichenfolge in das Array eingefügt. Beispielsweise wird das Aufteilen einer Zeichenfolge in einen einzelnen Bindestrich das zurückgegebene Array an der Position eine leere Zeichenfolge eingeschlossen, in denen zwei aufeinanderfolgende Bindestriche, wie im folgenden Code gezeigt gefunden werden.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split8.vb#8)]  
  
 Wenn eine Übereinstimmung am Anfang oder Ende der Eingabezeichenfolge gefunden wird, ist eine leere Zeichenfolge am Anfang oder Ende des zurückgegebenen Arrays enthalten. Im folgenden Beispiel wird das Muster für reguläre Ausdrücke `\d+` eine Eingabezeichenfolge auf numerische Zeichen geteilt. Da die Zeichenfolge beginnt und endet mit entsprechenden numerische Zeichen, ist der Wert des ersten und letzten Elements von dem zurückgegebenen Array <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split22.cs#22)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split22.vb#22)]  
  
 Wenn in Klammern für die Erfassung verwendet werden eine <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Ausdruck, der alle aufgezeichneten Text ist in der sich ergebende Zeichenfolge enthalten. Wenn die Zeichenfolge "Plum-Pear" auf einen Bindestrich innerhalb von Klammern umschließenden aufgeteilt wird, enthält das zurückgegebene Array z. B. eine String-Element, das den Bindestrich enthält.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Wenn das Muster für reguläre Ausdrücke mehrere Sätze von schließenden Klammern enthält, hängt jedoch das Verhalten dieser Methode die Version von .NET Framework. Wenn eine Übereinstimmung in den ersten Satz von schließenden Klammern, nicht gefunden wird, ist in .NET Framework 1.0 und 1.1 nicht erfasster Text von zusätzlichen Klammern für die Erfassung im zurückgegebenen Array enthalten. Ab .NET Framework 2.0, wird allen erfasster Text auch das zurückgegebene Array hinzugefügt. Der folgende Code verwendet beispielsweise zwei Sätze von schließenden Klammern, um die Elemente eines Datums, einschließlich der Date-Trennzeichen, über eine Datumszeichenfolge zu extrahieren. Der erste Satz von schließenden Klammern erfasst den Bindestrich ein, und der zweite Satz erfasst einen Schrägstrich. Wenn Beispielcode kompiliert und unter .NET Framework 1.0 oder 1.1 ausgeführt werden, die Schrägstriche ausgeschlossen. Wenn sie der Kompilierung und Ausführung unter der .NET Framework 2.0 oder höher, werden diese eingeschlossen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Wenn der reguläre Ausdruck der leere Zeichenfolge ist, als Entsprechung möglich <xref:System.Text.RegularExpressions.Regex.Split%2A> die Zeichenfolge wird in ein Array von Einzelzeichen-Zeichenfolgen aufgeteilt werden, da die Trennzeichen für leere Zeichenfolgen an jedem Standort gefunden werden kann. Zum Beispiel:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split13.vb#13)]  
  
 Beachten Sie, dass das zurückgegebene Array auch eine leere Zeichenfolge am Anfang und Ende des Arrays enthält.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme ausgelöst, wenn die Ausführungszeit des Split-Vorgangs überschreitet das Timeoutintervall angegeben, für die Anwendungsdomäne, in dem die Methode aufgerufen wird. Wenn kein Timeout in der Anwendungsdomäne definiert ist, oder der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage">
          <para>Diese-Methode ein Timeout, nach einem bestimmten Zeitintervall, das gleich der Standardwert für das Timeout der Anwendungsdomäne, in dem die Methode aufgerufen wird. Wenn Sie ein Timeoutwert für die Anwendungsdomäne, der Wert nicht definiert wurde <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das Timeout, die Methode verhindert werden. Ist die empfohlene statische Methode für das Aufteilen von Text auf einem mustertreffer <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, mit dem Sie das Timeoutintervall festlegen.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer, startat As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * int -&gt; string[]" Usage="regex.Split (input, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Die aufzuteilende Zeichenfolge.</param>
        <param name="count">Die maximale Anzahl der Teilungen.</param>
        <param name="startat">Die Zeichenposition in der Eingabezeichenfolge, an der mit der Suche begonnen wird.</param>
        <summary>Teilt die angegebene Eingabezeichenfolge höchstens die angegebene Anzahl von Malen an den Positionen in ein Array von Teilzeichenfolgenketten auf, die durch einen im <see cref="T:System.Text.RegularExpressions.Regex" />-Konstruktor angegebenen regulären Ausdruck definiert werden. Die Suche nach dem Muster des regulären Ausdrucks beginnt bei einer angegebenen Zeichenposition in der Eingabezeichenfolge.</summary>
        <returns>Ein Array von Zeichenfolgen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Methoden ähneln den <xref:System.String.Split%2A?displayProperty=nameWithType> -Methode, außer dass <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> teilt die Zeichenfolge an einem Trennzeichen, die von einem regulären Ausdruck statt eines Satzes von Zeichen festgelegt. Die `count` Parameter gibt die maximale Anzahl von Teilzeichenfolgen auf, in dem die `input` aufteilen Zeichenfolge, die letzte Zeichenfolge enthält den nicht aufgeteilten Rest der Zeichenfolge. Ein `count` Wert 0 (null) ist das Standardverhalten so oft wie möglich geteilt. Die `startat` Parameter definiert, den Punkt, an dem die Suche nach dem ersten Trennzeichen beginnt (Dies kann verwendet werden um führende Leerzeichen zu überspringen).  
  
 Wenn keine Übereinstimmungen gefunden werden, aus der `count`+ 1 zu positionieren, in der Zeichenfolge, die Methode gibt ein Array von einem Element, enthält die `input` Zeichenfolge. Wenn eine oder mehrere Übereinstimmungen gefunden werden, enthält das erste Element des zurückgegebenen Arrays den ersten Teil der Zeichenfolge vom ersten Zeichen bis zu einem Zeichen vor der Übereinstimmung.  
  
 Wenn mehrere Übereinstimmungen angrenzend an anderen werden, und die Anzahl der gefundenen Übereinstimmungen mindestens zwei ist kleiner als `count`, eine leere Zeichenfolge in das Array eingefügt wird. Auf ähnliche Weise, wenn eine Übereinstimmung, am gefunden wird `startat`, der das erste Zeichen in der Zeichenfolge, das erste Element des zurückgegebenen Arrays ist eine leere Zeichenfolge. D. h. leere Zeichenfolgen, die sich aus den benachbarten Übereinstimmungen ergeben erfasst bestimmen, ob die Anzahl der Teilzeichenfolgen Equals abgeglichen `count`. Im folgenden Beispiel ist der reguläre Ausdruck `\d+` verwendet, um die Position des ersten Teilzeichenfolge von numerischen Zeichen in einer Zeichenfolge zu suchen und klicken Sie dann zum Aufteilen der Zeichenfolge bis zu drei Mal ab an dieser Position. Da Muster für reguläre Ausdrücke den Anfang der Eingabezeichenfolge entspricht, besteht das zurückgegebene Zeichenfolgenarray aus eine leere Zeichenfolge, eine Zeichenfolge mit fünf Zeichen alphabetisch und den Rest der Zeichenfolge,  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split26.cs#26)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split26.vb#26)]  
  
 Wenn Klammern für die Erfassung in einem regulären Ausdruck verwendet werden, ist erfasster Text in das Split-Zeichenfolgenarray enthalten. Allerdings alle Elemente des Arrays, die aufgezeichneten Text enthalten, werden nicht gezählt bei der Bestimmung, ob die Anzahl der Übereinstimmungen erreicht hat `count`. Z. B. Teilen der Zeichenfolge ""Peach"in die maximale Anzahl von vier Teilzeichenfolgen ab 15 Zeichen, in den Ergebnissen der Zeichenfolge in ein Array mit sieben Elementen, wie im folgenden Code gezeigt.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split6.vb#6)]  
  
 Wenn das Muster für reguläre Ausdrücke mehrere Sätze von schließenden Klammern enthält, hängt jedoch das Verhalten dieser Methode die Version von .NET Framework. Wenn eine Übereinstimmung in den ersten Satz von schließenden Klammern, nicht gefunden wird, ist in .NET Framework 1.0 und 1.1 nicht erfasster Text von zusätzlichen Klammern für die Erfassung im zurückgegebenen Array enthalten. Ab .NET Framework 2.0, wird allen erfasster Text auch das zurückgegebene Array hinzugefügt. Der folgende Code verwendet beispielsweise zwei Sätze von schließenden Klammern, um die einzelnen Wörter in einer Zeichenfolge zu extrahieren. Der erste Satz von schließenden Klammern erfasst den Bindestrich ein, und der zweite Satz erfasst den senkrechte Strich. Wenn Beispielcode kompiliert und unter .NET Framework 1.0 oder 1.1 ausgeführt werden, schließt er die vertikale Leiste Zeichen. Wenn sie der Kompilierung und Ausführung unter der .NET Framework 2.0 oder höher, werden diese eingeschlossen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split7.vb#7)]  
  
 Wenn der reguläre Ausdruck der leere Zeichenfolge ist, als Entsprechung möglich <xref:System.Text.RegularExpressions.Regex.Split%2A> die Zeichenfolge wird in ein Array von Einzelzeichen-Zeichenfolgen aufgeteilt werden, da die Trennzeichen für leere Zeichenfolgen an jedem Standort gefunden werden kann. Im folgenden Beispiel wird die Zeichenfolge "Zeichen" in beliebig viele Elemente, wie die Eingabezeichenfolge enthält, beginnend mit dem Zeichen, "a". Da die null-Zeichenfolge auf das Ende der Eingabezeichenfolge entspricht, wird eine null-Zeichenfolge am Ende des zurückgegebenen Arrays eingefügt.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split14.cs#14)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split14.vb#14)]  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme ausgelöst, wenn die Ausführungszeit des Split-Vorgangs das Timeoutintervall gemäß überschreitet die <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> Konstruktor. Wenn Sie ein Timeoutintervall nicht festlegen, wenn Sie den Konstruktor aufrufen, wird die Ausnahme ausgelöst, wenn der Vorgang alle für die Anwendungsdomäne festgelegt wird, in dem Timeoutwert überschreitet die <xref:System.Text.RegularExpressions.Regex> Objekt erstellt wird. Wenn kein Timeout, in definiert ist der <xref:System.Text.RegularExpressions.Regex> Konstruktoraufruf oder in Eigenschaften der Anwendungsdomäne, oder wenn der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> ist kleiner als 0 (null) oder größer als die Länge von <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Die aufzuteilende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <summary>Teilt eine Eingabezeichenfolge an den durch ein angegebenes reguläres Ausdrucksmuster definierten Positionen in ein Array von Teilzeichenfolgen auf. Durch angegebene Optionen wird die Suche nach Übereinstimmungen geändert.</summary>
        <returns>Ein Array von Zeichenfolgen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Methoden ähneln den <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> -Methode, außer dass <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> teilt die Zeichenfolge an einem Trennzeichen, die von einem regulären Ausdruck statt eines Satzes von Zeichen festgelegt. Die Zeichenfolge wird so oft wie möglich zu teilen. Wenn kein Trennzeichen gefunden wird, wird der Rückgabewert enthält ein Element, dessen Wert die ursprünglichen `input` Zeichenfolge.  
  
 Die `pattern` -Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Kompilierte reguläre Ausdrücke, die in statischen Aufrufen verwendet <xref:System.Text.RegularExpressions.Regex.Split%2A> Methoden werden automatisch zwischengespeichert. Um die Lebensdauer der kompilierte reguläre Ausdrücke selbst zu verwalten, verwenden Sie die Instanz <xref:System.Text.RegularExpressions.Regex.Split%2A> Methoden.  
  
 Wenn mehrere Übereinstimmungen neben anderen sind, wird eine leere Zeichenfolge in das Array eingefügt. Beispielsweise wird das Aufteilen einer Zeichenfolge in einen einzelnen Bindestrich das zurückgegebene Array an der Position eine leere Zeichenfolge eingeschlossen, in denen zwei aufeinanderfolgende Bindestriche gefunden werden.  
  
 Wenn eine Übereinstimmung am Anfang oder Ende der Eingabezeichenfolge gefunden wird, ist eine leere Zeichenfolge am Anfang oder Ende des zurückgegebenen Arrays enthalten. Im folgenden Beispiel wird das Muster für reguläre Ausdrücke `[a-z]+` zum Aufteilen einer Eingabezeichenfolge auf jedes beliebige alphabetische Zeichen in Groß- oder Kleinbuchstaben. Da die Zeichenfolge beginnt und endet mit übereinstimmenden alphabetische Zeichen, ist der Wert des ersten und letzten Elements von dem zurückgegebenen Array <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split24.cs#24)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split24.vb#24)]  
  
 Wenn in Klammern für die Erfassung verwendet werden eine <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Ausdruck, der alle aufgezeichneten Text ist in der sich ergebende Zeichenfolge enthalten. Wenn die Zeichenfolge "Plum-Pear" auf einen Bindestrich innerhalb von Klammern umschließenden aufgeteilt wird, enthält das zurückgegebene Array z. B. eine String-Element, das den Bindestrich enthält.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Wenn das Muster für reguläre Ausdrücke mehrere Sätze von schließenden Klammern enthält, hängt jedoch das Verhalten dieser Methode die Version von .NET Framework. Wenn eine Übereinstimmung in den ersten Satz von schließenden Klammern, nicht gefunden wird, ist in .NET Framework 1.0 und 1.1 nicht erfasster Text von zusätzlichen Klammern für die Erfassung im zurückgegebenen Array enthalten. Ab .NET Framework 2.0, wird allen erfasster Text auch das zurückgegebene Array hinzugefügt. Der folgende Code verwendet beispielsweise zwei Sätze von schließenden Klammern, um die Elemente eines Datums, einschließlich der Date-Trennzeichen, über eine Datumszeichenfolge zu extrahieren. Der erste Satz von schließenden Klammern erfasst den Bindestrich ein, und der zweite Satz erfasst einen Schrägstrich. Wenn Beispielcode kompiliert und unter .NET Framework 1.0 oder 1.1 ausgeführt werden, die Schrägstriche ausgeschlossen. Wenn sie der Kompilierung und Ausführung unter der .NET Framework 2.0 oder höher, werden diese eingeschlossen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Wenn der reguläre Ausdruck der leere Zeichenfolge ist, als Entsprechung möglich <xref:System.Text.RegularExpressions.Regex.Split%2A> die Zeichenfolge wird in ein Array von Einzelzeichen-Zeichenfolgen aufgeteilt werden, da die Trennzeichen für leere Zeichenfolgen an jedem Standort gefunden werden kann.  
  
 Die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme ausgelöst, wenn die Ausführungszeit des Split-Vorgangs überschreitet das Timeoutintervall angegeben, für die Anwendungsdomäne, in dem die Methode aufgerufen wird. Wenn kein Timeout in der Anwendungsdomäne definiert ist, oder der Timeoutwert ist <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, wird keine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage">
          <para>Diese-Methode ein Timeout, nach einem bestimmten Zeitintervall, das gleich der Standardwert für das Timeout der Anwendungsdomäne, in dem die Methode aufgerufen wird. Wenn Sie ein Timeoutwert für die Anwendungsdomäne, der Wert nicht definiert wurde <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das Timeout, die Methode verhindert werden. Ist die empfohlene statische Methode für das Aufteilen von Text auf einem mustertreffer <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, mit dem Sie das Timeoutintervall festlegen.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Die aufzuteilende Zeichenfolge.</param>
        <param name="pattern">Das Muster eines regulären Ausdrucks, mit dem Übereinstimmungen gefunden werden sollen.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die Optionen für Vergleiche angeben.</param>
        <param name="matchTimeout">Ein Timeoutintervall oder <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, das angibt, dass die Methode kein Timeout haben sollte.</param>
        <summary>Teilt eine Eingabezeichenfolge an den durch ein angegebenes reguläres Ausdrucksmuster definierten Positionen in ein Array von Teilzeichenfolgen auf. Zusätzliche Parameter geben die Optionen an, die den entsprechenden Vorgang und ein Timeoutintervall ändern, wenn keine Übereinstimmung gefunden wird.</summary>
        <returns>Ein Zeichenfolgenarray.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Methoden ähneln den <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> -Methode, außer dass <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> teilt die Zeichenfolge an einem Trennzeichen, die von einem regulären Ausdruck statt eines Satzes von Zeichen festgelegt. Die Zeichenfolge wird so oft wie möglich zu teilen. Wenn kein Trennzeichen gefunden wird, wird der Rückgabewert enthält ein Element, dessen Wert die ursprünglichen `input` Zeichenfolge.  
  
 Die `pattern` -Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Kompilierte reguläre Ausdrücke, die in statischen Aufrufen verwendet <xref:System.Text.RegularExpressions.Regex.Split%2A> Methoden werden automatisch zwischengespeichert. Um die Lebensdauer der kompilierte reguläre Ausdrücke selbst zu verwalten, verwenden Sie die Instanz <xref:System.Text.RegularExpressions.Regex.Split%2A> Methoden.  
  
 Wenn mehrere Übereinstimmungen neben anderen sind, wird eine leere Zeichenfolge in das Array eingefügt. Beispielsweise wird das Aufteilen einer Zeichenfolge in einen einzelnen Bindestrich das zurückgegebene Array an der Position eine leere Zeichenfolge eingeschlossen, in denen zwei aufeinanderfolgende Bindestriche gefunden werden.  
  
 Wenn eine Übereinstimmung am Anfang oder Ende der Eingabezeichenfolge gefunden wird, ist eine leere Zeichenfolge am Anfang oder Ende des zurückgegebenen Arrays enthalten. Im folgenden Beispiel wird das Muster für reguläre Ausdrücke `[a-z]+` zum Aufteilen einer Eingabezeichenfolge auf jedes beliebige alphabetische Zeichen in Groß- oder Kleinbuchstaben. Da die Zeichenfolge beginnt und endet mit übereinstimmenden alphabetische Zeichen, ist der Wert des ersten und letzten Elements von dem zurückgegebenen Array <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split23.cs#23)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split23.vb#23)]  
  
 Wenn in Klammern für die Erfassung verwendet werden eine <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Ausdruck, der alle aufgezeichneten Text ist in der sich ergebende Zeichenfolge enthalten. Wenn die Zeichenfolge "Plum-Pear" auf einen Bindestrich innerhalb von Klammern umschließenden aufgeteilt wird, enthält das zurückgegebene Array z. B. eine String-Element, das den Bindestrich enthält.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Wenn das Muster für reguläre Ausdrücke mehrere Sätze von schließenden Klammern enthält, hängt jedoch das Verhalten dieser Methode die Version von .NET Framework. Wenn eine Übereinstimmung in den ersten Satz von schließenden Klammern, nicht gefunden wird, ist in .NET Framework 1.0 und 1.1 nicht erfasster Text von zusätzlichen Klammern für die Erfassung im zurückgegebenen Array enthalten. Ab .NET Framework 2.0, wird allen erfasster Text auch das zurückgegebene Array hinzugefügt. Der folgende Code verwendet beispielsweise zwei Sätze von schließenden Klammern, um die Elemente eines Datums, einschließlich der Date-Trennzeichen, über eine Datumszeichenfolge zu extrahieren. Der erste Satz von schließenden Klammern erfasst den Bindestrich ein, und der zweite Satz erfasst einen Schrägstrich. Wenn Beispielcode kompiliert und unter .NET Framework 1.0 oder 1.1 ausgeführt werden, die Schrägstriche ausgeschlossen. Wenn sie der Kompilierung und Ausführung unter der .NET Framework 2.0 oder höher, werden diese eingeschlossen.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Wenn der reguläre Ausdruck der leere Zeichenfolge ist, als Entsprechung möglich <xref:System.Text.RegularExpressions.Regex.Split%2A> die Zeichenfolge wird in ein Array von Einzelzeichen-Zeichenfolgen aufgeteilt werden, da die Trennzeichen für leere Zeichenfolgen an jedem Standort gefunden werden kann.  
  
 Die `matchTimeout` Parameter gibt an, wie lange ein Musterabgleich Methode sollten versuchen, eine Übereinstimmung gefunden wird, bevor ein Timeout eintritt. Ein Timeoutintervall festlegen wird verhindert, dass reguläre Ausdrücke, die übermäßige rückverfolgung angezeigt werden, nicht mehr reagiert, wenn diese Eingaben verarbeiten, die in der Nähe von Übereinstimmungen enthält. Weitere Informationen finden Sie unter [bewährte Methoden für reguläre Ausdrücke](~/docs/standard/base-types/best-practices.md) und [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Wenn Sie in dieses Zeitintervalls keine Übereinstimmung gefunden wird, löst die Methode eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Ausnahme. `matchTimeout` überschreibt alle Standard-Timeoutwert, der definiert, die für die Anwendungsdomäne, in der die Methode ausgeführt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Analysefehler für reguläre Ausdrücke ist aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="pattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> ist keine gültige bitweise Kombination von <see cref="T:System.Text.RegularExpressions.RegexOptions" />-Werten.  
  
- oder -  
 <paramref name="matchTimeout" /> ist negativ, 0 oder größer als ca. 24 Tage.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Es ist ein Timeout aufgetreten. Weitere Informationen zu Timeouts finden Sie im Abschnitt „Hinweise“.</exception>
        <block subset="none" type="usage">
          <para>Es wird empfohlen, Sie legen die <paramref name="matchTimeout" /> Parameter auf einen geeigneten Wert, z. B. zwei Sekunden. Wenn Sie Timeouts werden, indem deaktiviert <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, die Engine für reguläre Ausdrücke bietet eine etwas bessere Leistung. Allerdings sollten Sie Timeouts nur unter folgenden Bedingungen deaktivieren: 
– Wenn die Eingabe verarbeitet, die von einem regulären Ausdruck aus einer bekannten und vertrauenswürdigen Quelle stammt oder besteht aus statischen Text. Dies schließt Text, der vom Benutzer eingegebene dynamisch wurde.  
  
– Wenn Sie Muster für reguläre Ausdrücke gründlich getestet wurde, um sicherzustellen, dass er effizient verarbeitet übereinstimmt, nicht-Übereinstimmungen und Naher entspricht.  
  
– Wenn Muster für reguläre Ausdrücke keine Language-Elemente enthält, die bekannt sind, um eine übermäßige rückverfolgung bei der Verarbeitung einer Nahen Übereinstimmung zu verursachen.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke</related>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="si">Das Objekt, das mit Serialisierungsinformationen aufgefüllt werden soll.</param>
        <param name="context">Der Ort zum Speichern und Abrufen von serialisierten Daten. Dieser Parameter ist für die zukünftige Verwendung reserviert.</param>
        <summary>Füllt ein <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt mit den Daten, die erforderlich sind, um das aktuelle <see cref="T:System.Text.RegularExpressions.Regex" />-Objekt zu deserialisieren.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="regex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt das Muster eines regulären Ausdrucks zurück, das an den <see langword="Regex" />-Konstruktor übergeben wurde.</summary>
        <returns>Der an den <paramref name="pattern" />-Konstruktor übergebene <see langword="Regex" />-Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `pattern` -Parameter besteht aus Sprachelemente regulärer Ausdrücke, die zu vergleichende Zeichenfolge symbolisch beschreiben. Weitere Informationen zu regulären Ausdrücken finden Sie unter [reguläre Ausdrücke von .NET Framework](~/docs/standard/base-types/regular-expressions.md) und [Sprachelemente für reguläre Ausdrücke – Kurzübersicht](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> ist die Basisklasse von regulären Ausdrücken, die erstellt werden, indem die <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> Methode. Diese kompilierten regulären Ausdrücke verwenden die <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> Implementierung der Basisklasse. Wenn von einer abgeleiteten Klasse aufgerufen der <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> -Methode gibt die Zeichenfolge, die übergeben wurde, die <paramref name="pattern" /> Parameter, der die <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> Konstruktor der Klasse, die zum Definieren des regulären Ausdrucks verwendet wurde.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="public static string Unescape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Unescape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unescape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Unescape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Unescape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Unescape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Die Eingabezeichenfolge mit dem zu konvertierenden Text.</param>
        <summary>Konvertiert alle Escapezeichen in der Eingabezeichenfolge.</summary>
        <returns>Eine Zeichenfolge, in der alle Escapezeichen in die entsprechende Form ohne Escapezeichen konvertiert wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Text.RegularExpressions.Regex.Unescape%2A> -Methode führt eine der folgenden beiden Transformationen:  
  
-   Kehrt die Transformation ausgeführt wird, indem die <xref:System.Text.RegularExpressions.Regex.Escape%2A> Methode durch das Entfernen von Escapezeichen ("\\") aus den einzelnen Zeichen mit Escapezeichen versehen, von der Methode. Dazu gehören die \\, *, +,?, &#124;, {, [, (,), ^, $,., # und Leerzeichen. Darüber hinaus die <xref:System.Text.RegularExpressions.Regex.Unescape%2A> Methode entfernt die schließende Klammer (]) und die schließende Klammer (}) Zeichen.  
  
> [!NOTE]
>  <xref:System.Text.RegularExpressions.Regex.Unescape%2A> kann keine Zeichenfolge mit Escapezeichen umkehren, da es nicht ableiten kann genau die Zeichen mit Escapezeichen versehen wurden,  
  
-   Die Darstellung der nicht druckbare Zeichen ersetzt durch die Zeichen selbst. Beispielsweise wird durch \x07 \a ersetzt. Die Darstellung von Zeichen, die sie ersetzt werden \a "," \b "," \e "," \n "," \r "," \f "," \t, und "\v.  
  
 Wenn die <xref:System.Text.RegularExpressions.Regex.Unescape%2A> Methode trifft, andere Escapesequenzen, die nicht konvertiert werden können, z. B. \w "oder" \s ", löst er eine <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="str" /> schließt eine nicht erkannte Escapesequenz ein.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Sprachelemente für reguläre Ausdrücke – Kurzübersicht</related>
      </Docs>
    </Member>
    <Member MemberName="UseOptionC">
      <MemberSignature Language="C#" Value="protected bool UseOptionC ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionC() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionC" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionC () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionC();" />
      <MemberSignature Language="F#" Value="member this.UseOptionC : unit -&gt; bool" Usage="regex.UseOptionC " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <returns>
          <see langword="true" />, wenn die <see cref="P:System.Text.RegularExpressions.Regex.Options" />-Eigenschaft die <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />-Option enthält, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseOptionR">
      <MemberSignature Language="C#" Value="protected bool UseOptionR ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionR() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionR" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionR () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionR();" />
      <MemberSignature Language="F#" Value="member this.UseOptionR : unit -&gt; bool" Usage="regex.UseOptionR " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird von einem durch die <see cref="T:System.Text.RegularExpressions.Regex" />-Methode generierten <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />-Objekt verwendet.</summary>
        <returns>
          <see langword="true" />, wenn die <see cref="P:System.Text.RegularExpressions.Regex.Options" />-Eigenschaft die <see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" />-Option enthält, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal static void ValidateMatchTimeout (TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig void ValidateMatchTimeout(valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Sub ValidateMatchTimeout (matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static void ValidateMatchTimeout(TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member ValidateMatchTimeout : TimeSpan -&gt; unit" Usage="System.Text.RegularExpressions.Regex.ValidateMatchTimeout matchTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="matchTimeout">Das zu überprüfende Timeoutintervall.</param>
        <summary>Überprüft, ob ein Timeoutintervall innerhalb eines akzeptablen Bereichs liegt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>