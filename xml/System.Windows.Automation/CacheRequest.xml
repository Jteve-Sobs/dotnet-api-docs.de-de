<Type Name="CacheRequest" FullName="System.Windows.Automation.CacheRequest">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ba79b367856f83c772f8c7971dde04e0ee956e6d" />
    <Meta Name="ms.sourcegitcommit" Value="f9e3295b6cc303a611a73a84c4b27f9da792ad0d" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/26/2018" />
    <Meta Name="ms.locfileid" Value="31909945" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class CacheRequest" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit CacheRequest extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Automation.CacheRequest" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class CacheRequest" />
  <TypeSignature Language="C++ CLI" Value="public ref class CacheRequest sealed" />
  <AssemblyInfo>
    <AssemblyName>UIAutomationClient</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Gibt Eigenschaften und Muster an, die das „UI Automation“-Framework beim Abrufen eines <see cref="T:System.Windows.Automation.AutomationElement" /> zwischenspeichert.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abrufen von Eigenschaften und Muster über [!INCLUDE[TLA2#tla_uiautomation](~/includes/tla2sharptla-uiautomation-md.md)] erfordert prozessübergreifenden Aufrufen, die Leistung verlangsamen können. Durch Zwischenspeichern der Werte von Eigenschaften und Mustern in einem Batchvorgang, können Sie die Leistung der Anwendung erhöhen.  
  
 Erstellen Sie eine neue cacheanforderung durch Aufrufen des Klassenkonstruktors. Die Anforderung wird durch wiederholte Aufrufe von aufgefüllt die <xref:System.Windows.Automation.CacheRequest.Add%2A> Methode.  
  
 Nur ein einzelner <xref:System.Windows.Automation.CacheRequest> aktiv sein können. Es gibt zwei Möglichkeiten, eine Anforderung zu aktivieren:  
  
-   Rufen Sie <xref:System.Windows.Automation.CacheRequest.Activate%2A> in der Anforderung. Dies legt die Anforderung im Stapel, und die Anforderung wird per pop ausgelesen, wenn das Objekt verworfen wird. Verwenden Sie zum Sicherstellen der Freigabe, selbst wenn eine Ausnahme ausgelöst wird, den Rückgabewert <xref:System.Windows.Automation.CacheRequest.Activate%2A> innerhalb einer `using` Block (`Using` in Visual Basic).  
  
-   Setzen Sie die Anforderung im internen Stapel durch den Aufruf <xref:System.Windows.Automation.CacheRequest.Push%2A>. Nur die oberste Anforderung auf dem Stapel aktiv ist, muss er den nächsten Endpunkt aus dem Stapel entfernt <xref:System.Windows.Automation.CacheRequest.Pop%2A>. Das herunternehmen der Anforderungs wird sie deaktiviert.  
  
 [!INCLUDE[TLA2#tla_uiautomation](~/includes/tla2sharptla-uiautomation-md.md)] Elemente abgerufen werden, während die Anforderung aktiv ist, werden Werte für die Eigenschaften und Muster, die angegeben zwischengespeichert haben.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie <xref:System.Windows.Automation.CacheRequest.Activate%2A> zum Zwischenspeichern von Mustern und Eigenschaften.  
  
 [!code-csharp[UIAClient_snip#107](~/samples/snippets/csharp/VS_Snippets_Wpf/UIAClient_snip/CSharp/ClientForm.cs#107)]
 [!code-vb[UIAClient_snip#107](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIAClient_snip/VisualBasic/ClientForm.vb#107)]  
  
 Das folgende Beispiel zeigt, wie Sie <xref:System.Windows.Automation.CacheRequest.Push%2A> und <xref:System.Windows.Automation.CacheRequest.Pop%2A> zum Zwischenspeichern von Mustern und Eigenschaften.  
  
 [!code-csharp[UIAClient_snip#108](~/samples/snippets/csharp/VS_Snippets_Wpf/UIAClient_snip/CSharp/ClientForm.cs#108)]
 [!code-vb[UIAClient_snip#108](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIAClient_snip/VisualBasic/ClientForm.vb#108)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CacheRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.CacheRequest.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CacheRequest();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Automation.CacheRequest" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine <xref:System.Windows.Automation.CacheRequest> wird erstellt, die <xref:System.Windows.Automation.AutomationElement.RuntimeIdProperty> Bezeichner als Standardeigenschaft der Cache hinzugefügt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public IDisposable Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IDisposable Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.CacheRequest.Activate" />
      <MemberSignature Language="VB.NET" Value="Public Function Activate () As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IDisposable ^ Activate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legt diesen <see cref="T:System.Windows.Automation.CacheRequest" /> als aktive Spezifikation für die Elemente fest, die zurückgegeben werden, wenn ein <see cref="T:System.Windows.Automation.AutomationElement" /> im gleichen Thread angefordert wird.</summary>
        <returns>Das Objekt, mit dem der <see cref="T:System.Windows.Automation.CacheRequest" /> freigegeben werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode werden meist mit <xref:System.Windows.Automation.CacheRequest.Push%2A> und <xref:System.Windows.Automation.CacheRequest.Pop%2A> als Mittel zum Aktivieren der <xref:System.Windows.Automation.CacheRequest>. Das Objekt auf dem Stapel abgelegt wird beim <xref:System.Windows.Automation.CacheRequest.Activate%2A> wird aufgerufen, und geholt, wenn sie freigegeben ist. Zum Sicherstellen der Freigabe, platzieren Sie den Rückgabewert in einer `using` Block (`Using` in Visual Basic).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie <xref:System.Windows.Automation.CacheRequest.Activate%2A> zum Zwischenspeichern von Mustern und Eigenschaften.  
  
 [!code-csharp[UIAClient_snip#107](~/samples/snippets/csharp/VS_Snippets_Wpf/UIAClient_snip/CSharp/ClientForm.cs#107)]
 [!code-vb[UIAClient_snip#107](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIAClient_snip/VisualBasic/ClientForm.vb#107)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Automation.CacheRequest.Push" />
        <altmember cref="M:System.Windows.Automation.CacheRequest.Pop" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt einem <see cref="T:System.Windows.Automation.CacheRequest" /> einen Eigenschaften- oder Musterbezeichner hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine <xref:System.Windows.Automation.CacheRequest> -Objekt wird erstellt, die <xref:System.Windows.Automation.AutomationElement.RuntimeIdProperty> Bezeichner als Standardeigenschaft der Cache hinzugefügt wird.  
  
 Hinzufügen eines Objekts, das bereits in der cacheanforderung ist, hat keine Auswirkungen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (System.Windows.Automation.AutomationPattern pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(class System.Windows.Automation.AutomationPattern pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.CacheRequest.Add(System.Windows.Automation.AutomationPattern)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (pattern As AutomationPattern)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::Windows::Automation::AutomationPattern ^ pattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.Windows.Automation.AutomationPattern" />
      </Parameters>
      <Docs>
        <param name="pattern">Ein Bezeichner, der ein zwischenzuspeicherndes Muster angibt.</param>
        <summary>Fügt den angegebenen <see cref="T:System.Windows.Automation.AutomationPattern" />-Bezeichner diesem <see cref="T:System.Windows.Automation.CacheRequest" /> hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hinzufügen von einem Muster, das bereits in der cacheanforderung ist, hat keine Auswirkung.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie zum Erstellen einer <xref:System.Windows.Automation.CacheRequest> und fügen Sie ein Muster zwischengespeichert werden soll.  
  
 [!code-csharp[UIAClient_snip#202](~/samples/snippets/csharp/VS_Snippets_Wpf/UIAClient_snip/CSharp/ClientForm.cs#202)]
 [!code-vb[UIAClient_snip#202](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIAClient_snip/VisualBasic/ClientForm.vb#202)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Windows.Automation.CacheRequest" /> ist aktiv.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (System.Windows.Automation.AutomationProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(class System.Windows.Automation.AutomationProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.CacheRequest.Add(System.Windows.Automation.AutomationProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (property As AutomationProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::Windows::Automation::AutomationProperty ^ property);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.Windows.Automation.AutomationProperty" />
      </Parameters>
      <Docs>
        <param name="property">Ein Bezeichner, der einen zwischenzuspeichernden Eigenschaftswert angibt.</param>
        <summary>Fügt den angegebenen <see cref="T:System.Windows.Automation.AutomationProperty" />-Bezeichner diesem <see cref="T:System.Windows.Automation.CacheRequest" /> hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine <xref:System.Windows.Automation.CacheRequest> wird erstellt, die <xref:System.Windows.Automation.AutomationElement.RuntimeIdProperty> Bezeichner als Standardeigenschaft der Cache hinzugefügt wird.  
  
 Hinzufügen einer Eigenschaft, die bereits in der cacheanforderung hat keine Auswirkungen.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie zum Erstellen einer <xref:System.Windows.Automation.CacheRequest> und Hinzufügen einer Eigenschaft, die zwischengespeichert werden.  
  
 [!code-csharp[UIAClient_snip#202](~/samples/snippets/csharp/VS_Snippets_Wpf/UIAClient_snip/CSharp/ClientForm.cs#202)]
 [!code-vb[UIAClient_snip#202](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIAClient_snip/VisualBasic/ClientForm.vb#202)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Windows.Automation.CacheRequest" /> ist aktiv.</exception>
      </Docs>
    </Member>
    <Member MemberName="AutomationElementMode">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.AutomationElementMode AutomationElementMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Automation.AutomationElementMode AutomationElementMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Automation.CacheRequest.AutomationElementMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomationElementMode As AutomationElementMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Automation::AutomationElementMode AutomationElementMode { System::Windows::Automation::AutomationElementMode get(); void set(System::Windows::Automation::AutomationElementMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.AutomationElementMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob zurückgegebene Elemente vollständige Verweise auf die zugrunde liegende [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] oder nur zwischengespeicherte Informationen enthalten sollen, oder legt diesen fest.</summary>
        <value>
          <see cref="F:System.Windows.Automation.AutomationElementMode.Full" />, wenn die zurückgegebenen Elemente über einen vollständigen Verweis auf die zugrunde liegende [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] verfügen, andernfalls <see cref="F:System.Windows.Automation.AutomationElementMode.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Automation.AutomationElementMode.Full> Der Standardwert ist, und gibt an, dass die zurückgegebenen Elemente ein vollständigen Verweises auf die zugrunde liegende enthalten [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]. <xref:System.Windows.Automation.AutomationElementMode.None> Gibt an, dass die zurückgegebenen Elemente kein Verweis auf die zugrunde liegende [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)], und nur zwischengespeicherte Informationen enthalten.  
  
 Bestimmte Vorgänge auf Elemente, einschließlich <xref:System.Windows.Automation.AutomationElement.GetCurrentPropertyValue%2A>, <xref:System.Windows.Automation.AutomationElement.GetCurrentPattern%2A>, und <xref:System.Windows.Automation.AutomationElement.SetFocus%2A>, erfordern eine vollständige Referenz; es wird versucht, zum Ausführen dieser auf ein Element, das keine verfügt, führt zu einer <xref:System.InvalidOperationException>.  
  
 Mithilfe von <xref:System.Windows.Automation.AutomationElementMode.None> effizienter, wenn Sie nur Eigenschaften erforderlich sind, werden können, wie es der Mehraufwand vermieden wird zum Einrichten der vollständigen Verweise beteiligt.  
  
   
  
## Examples  
 Im folgenden Beispiel <xref:System.Windows.Automation.CacheRequest.AutomationElementMode%2A> festgelegt ist, um <xref:System.Windows.Automation.AutomationElementMode.None>, mit dem Ergebnis zwischengespeichert, die nur Eigenschaften und Muster für das abgerufene Objekt verfügbar sind.  
  
 [!code-csharp[UIAClient_snip#108](~/samples/snippets/csharp/VS_Snippets_Wpf/UIAClient_snip/CSharp/ClientForm.cs#108)]
 [!code-vb[UIAClient_snip#108](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIAClient_snip/VisualBasic/ClientForm.vb#108)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.CacheRequest Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.CacheRequest Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.CacheRequest.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As CacheRequest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::CacheRequest ^ Clone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.CacheRequest</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine Kopie dieser Instanz von <see cref="T:System.Windows.Automation.CacheRequest" />.</summary>
        <returns>Eine änderbare Kopie des aktuellen Objekts.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Windows.Automation.CacheRequest Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Automation.CacheRequest Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Automation.CacheRequest.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As CacheRequest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Automation::CacheRequest ^ Current { System::Windows::Automation::CacheRequest ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.CacheRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Windows.Automation.CacheRequest" /> ab, der im aktuellen Thread aktiv ist.</summary>
        <value>Das aktive <see cref="T:System.Windows.Automation.CacheRequest" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public void Pop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.CacheRequest.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt den aktiven <see cref="T:System.Windows.Automation.CacheRequest" /> aus dem internen Stapel für den aktuellen Thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur die derzeit aktive Anforderung kann entfernt werden, mithilfe der <xref:System.Windows.Automation.CacheRequest.Pop%2A> Methode. Es wird versucht, eine Anforderung zu entfernen, die nicht die aktuellen eine Ergebnisse eine Ausnahme ausgelöst wird.  
  
 Wenn Sie cacheanforderungen schachteln, ist es besser, verwenden Sie <xref:System.Windows.Automation.CacheRequest.Activate%2A> auf die Anforderung auf dem Stapel platzieren. Der Grund hierfür ist, dass Sie verwenden können <xref:System.Windows.Automation.CacheRequest.Activate%2A> innerhalb einer `using` Block (`Using` in Visual Basic), um sicherzustellen, dass die Anforderung vom Stapel geholt wird, auch wenn eine Ausnahme ausgelöst wird.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie zum Deaktivieren einer <xref:System.Windows.Automation.CacheRequest> mit <xref:System.Windows.Automation.CacheRequest.Pop%2A>.  
  
 [!code-csharp[UIAClient_snip#108](~/samples/snippets/csharp/VS_Snippets_Wpf/UIAClient_snip/CSharp/ClientForm.cs#108)]
 [!code-vb[UIAClient_snip#108](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIAClient_snip/VisualBasic/ClientForm.vb#108)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Cacheanforderung zu entfernen, bei der es sich nicht um die letzte auf dem Stapel abgelegte Anforderung handelt.</exception>
        <altmember cref="M:System.Windows.Automation.CacheRequest.Push" />
      </Docs>
    </Member>
    <Member MemberName="Push">
      <MemberSignature Language="C#" Value="public void Push ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Push() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.CacheRequest.Push" />
      <MemberSignature Language="VB.NET" Value="Public Sub Push ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Push();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Platziert den <see cref="T:System.Windows.Automation.CacheRequest" /> auf dem internen Zustandsstapel, sodass diese die aktuelle Anforderung im aktuellen Thread wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mehrere <xref:System.Windows.Automation.CacheRequest> Objekte im Stapel Zustand platziert werden können. Cacheanforderungen zu verarbeiten, müssen aus dem Stapel in der Reihenfolge entfernt werden, die sie vorgenommen wurden, auf; andernfalls ein <xref:System.InvalidOperationException> Ausnahme ausgelöst.  
  
 Wenn Sie cacheanforderungen schachteln, ist es besser, verwenden Sie <xref:System.Windows.Automation.CacheRequest.Activate%2A> auf die Anforderung auf dem Stapel platzieren. Der Grund hierfür ist, dass Sie verwenden können <xref:System.Windows.Automation.CacheRequest.Activate%2A> innerhalb einer `using` Block (`Using` in Visual Basic), um sicherzustellen, dass die Anforderung vom Stapel geholt wird, auch wenn eine Ausnahme ausgelöst wird.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie zum Aktivieren einer <xref:System.Windows.Automation.CacheRequest> mit <xref:System.Windows.Automation.CacheRequest.Push%2A>.  
  
 [!code-csharp[UIAClient_snip#108](~/samples/snippets/csharp/VS_Snippets_Wpf/UIAClient_snip/CSharp/ClientForm.cs#108)]
 [!code-vb[UIAClient_snip#108](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIAClient_snip/VisualBasic/ClientForm.vb#108)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Automation.CacheRequest.Pop" />
      </Docs>
    </Member>
    <Member MemberName="TreeFilter">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Condition TreeFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Automation.Condition TreeFilter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Automation.CacheRequest.TreeFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property TreeFilter As Condition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Automation::Condition ^ TreeFilter { System::Windows::Automation::Condition ^ get(); void set(System::Windows::Automation::Condition ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Condition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab einen Wert ab, der die beim Zwischenspeichern zu verwendende Ansicht der [!INCLUDE[TLA2#tla_uiautomation](~/includes/tla2sharptla-uiautomation-md.md)]-Elementstruktur angibt, oder legt diesen fest.</summary>
        <value>Die Ansicht der [!INCLUDE[TLA2#tla_uiautomation](~/includes/tla2sharptla-uiautomation-md.md)]-Elementstruktur. Die Standardansicht ist <see cref="F:System.Windows.Automation.Automation.ControlViewCondition" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu Ansichten der [!INCLUDE[TLA2#tla_uiautomation](~/includes/tla2sharptla-uiautomation-md.md)] Elementstruktur, finden Sie unter [Übersicht über die Benutzeroberflächenautomatisierungs-Struktur](~/docs/framework/ui-automation/ui-automation-tree-overview.md).  
  
   
  
## Examples  
 Im folgenden Beispiel <xref:System.Windows.Automation.CacheRequest.TreeFilter%2A> festgelegt ist, um <xref:System.Windows.Automation.Automation.RawViewCondition> so, dass Zwischenspeichern für alle Elemente, unabhängig davon, ob sie in der Inhaltsansicht oder der Steuerelementansicht ausgeführt wird.  
  
 [!code-csharp[UIAClient_snip#108](~/samples/snippets/csharp/VS_Snippets_Wpf/UIAClient_snip/CSharp/ClientForm.cs#108)]
 [!code-vb[UIAClient_snip#108](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIAClient_snip/VisualBasic/ClientForm.vb#108)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Automation.Automation.ContentViewCondition" />
      </Docs>
    </Member>
    <Member MemberName="TreeScope">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.TreeScope TreeScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Automation.TreeScope TreeScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Automation.CacheRequest.TreeScope" />
      <MemberSignature Language="VB.NET" Value="Public Property TreeScope As TreeScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Automation::TreeScope TreeScope { System::Windows::Automation::TreeScope get(); void set(System::Windows::Automation::TreeScope value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.TreeScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Zwischenspeichern nur für den Stamm der Teilstruktur oder auch für untergeordnete Elemente oder Nachfolgerelemente erfolgt, oder legt diesen fest.</summary>
        <value>Ein oder mehrere Elemente von <see cref="F:System.Windows.Automation.TreeScope.Element" />, <see cref="F:System.Windows.Automation.TreeScope.Children" />, <see cref="F:System.Windows.Automation.TreeScope.Descendants" /> oder <see cref="F:System.Windows.Automation.TreeScope.Subtree" />. Der Standardwert ist <see cref="F:System.Windows.Automation.TreeScope.Element" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Umfang des Zwischenspeicherns wird in Bezug auf Objekte, die abgerufen werden, nicht in Bezug auf das Objekt auf dem <xref:System.Windows.Automation.AutomationElement.FindFirst%2A> oder <xref:System.Windows.Automation.AutomationElement.FindAll%2A> aufgerufen wird. Siehe das Beispiel.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Listenfeldelement aus dem übergeordneten Fensterelement beim abgerufen eine <xref:System.Windows.Automation.CacheRequest> ist aktiv und <xref:System.Windows.Automation.CacheRequest.TreeScope%2A> ist <xref:System.Windows.Automation.TreeScope.Children>. Die angegebenen Eigenschaften der untergeordneten Elemente (d. h. die Listenelemente) werden im Cache gespeichert und abgerufen werden können, aus der <xref:System.Windows.Automation.AutomationElement.CachedChildren%2A> neben dem Listenfeld.  
  
 [!code-csharp[UIAClient_snip#119](~/samples/snippets/csharp/VS_Snippets_Wpf/UIAClient_snip/CSharp/ClientForm.cs#119)]
 [!code-vb[UIAClient_snip#119](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIAClient_snip/VisualBasic/ClientForm.vb#119)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Es wurde versucht, die Eigenschaft auf <see cref="F:System.Windows.Automation.TreeScope.Parent" /> oder <see cref="F:System.Windows.Automation.TreeScope.Ancestors" /> festzulegen.</exception>
      </Docs>
    </Member>
  </Members>
</Type>