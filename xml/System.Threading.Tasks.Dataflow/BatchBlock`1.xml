<Type Name="BatchBlock&lt;T&gt;" FullName="System.Threading.Tasks.Dataflow.BatchBlock&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="13e5608b75ee5947d0fa3d079d073bc32fbb4c25" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56374634" /></Metadata><TypeSignature Language="C#" Value="public sealed class BatchBlock&lt;T&gt; : System.Threading.Tasks.Dataflow.IPropagatorBlock&lt;T,T[]&gt;, System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;T[]&gt;, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;, System.Threading.Tasks.Dataflow.ITargetBlock&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit BatchBlock`1&lt;T&gt; extends System.Object implements class System.Threading.Tasks.Dataflow.IDataflowBlock, class System.Threading.Tasks.Dataflow.IPropagatorBlock`2&lt;!T, !T[]&gt;, class System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&lt;!T[]&gt;, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!T[]&gt;, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!T&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Dataflow.BatchBlock`1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class BatchBlock(Of T)&#xA;Implements IPropagatorBlock(Of T, T()), IReceivableSourceBlock(Of T()), ISourceBlock(Of T()), ITargetBlock(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class BatchBlock sealed : System::Threading::Tasks::Dataflow::IPropagatorBlock&lt;T, cli::array &lt;T&gt; ^&gt;, System::Threading::Tasks::Dataflow::IReceivableSourceBlock&lt;cli::array &lt;T&gt; ^&gt;, System::Threading::Tasks::Dataflow::ISourceBlock&lt;cli::array &lt;T&gt; ^&gt;, System::Threading::Tasks::Dataflow::ITargetBlock&lt;T&gt;" />
  <TypeSignature Language="F#" Value="type BatchBlock&lt;'T&gt; = class&#xA;    interface IDataflowBlock&#xA;    interface IPropagatorBlock&lt;'T, 'T[]&gt;&#xA;    interface ISourceBlock&lt;'T[]&gt;&#xA;    interface ITargetBlock&lt;'T&gt;&#xA;    interface IReceivableSourceBlock&lt;'T[]&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
    <AssemblyVersion>4.5.25.0</AssemblyVersion>
    <AssemblyVersion>4.6.0.0</AssemblyVersion>
    <AssemblyVersion>4.6.1.0</AssemblyVersion>
    <AssemblyVersion>4.6.2.0</AssemblyVersion>
    <AssemblyVersion>4.6.3.0</AssemblyVersion>
    <AssemblyVersion>4.6.4.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.IDataflowBlock</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.IPropagatorBlock&lt;T,T[]&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;T[]&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.ITargetBlock&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;dotnet-uwp-10.0">
      <AttributeName>System.Diagnostics.DebuggerDisplay("{DebuggerDisplayContent,nq}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;dotnet-uwp-10.0">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.Dataflow.BatchBlock`1/DebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Gibt den Typ der Daten an, die in Batches abgelegt werden.</typeparam>
    <summary>Stellt einen Datenflussblock bereit, der stapelweise Eingaben in Arrays verarbeitet.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [tpl-install-instructions](~/includes/tpl-install-instructions.md)]
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BatchBlock (int batchSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 batchSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (batchSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BatchBlock(int batchSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Dataflow.BatchBlock&lt;'T&gt; : int -&gt; System.Threading.Tasks.Dataflow.BatchBlock&lt;'T&gt;" Usage="new System.Threading.Tasks.Dataflow.BatchBlock&lt;'T&gt; batchSize" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="batchSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="batchSize">Die Anzahl der in einen Batch zu gruppierenden Elemente.</param>
        <summary>Initialisiert eine neue Instanz von <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" /> mit der angegebenen Batchgröße.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="batchSize" /> muss positiv sein.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BatchBlock (int batchSize, System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions dataflowBlockOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 batchSize, class System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions dataflowBlockOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.#ctor(System.Int32,System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (batchSize As Integer, dataflowBlockOptions As GroupingDataflowBlockOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BatchBlock(int batchSize, System::Threading::Tasks::Dataflow::GroupingDataflowBlockOptions ^ dataflowBlockOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Dataflow.BatchBlock&lt;'T&gt; : int * System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions -&gt; System.Threading.Tasks.Dataflow.BatchBlock&lt;'T&gt;" Usage="new System.Threading.Tasks.Dataflow.BatchBlock&lt;'T&gt; (batchSize, dataflowBlockOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="batchSize" Type="System.Int32" />
        <Parameter Name="dataflowBlockOptions" Type="System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions" />
      </Parameters>
      <Docs>
        <param name="batchSize">Die Anzahl der in einen Batch zu gruppierenden Elemente.</param>
        <param name="dataflowBlockOptions">Die Optionen, mit denen dieser <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" /> zu konfigurieren ist.</param>
        <summary>Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" /> mit der angegebenen Batchgröße, der degressiven Option und den Blockoptionen.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="batchSize" /> muss positiv sein.  
  
- oder - 
Der Wert <paramref name="batchSize" /> muss kleiner sein als der Wert der <see cref="P:System.Threading.Tasks.Dataflow.DataflowBlockOptions.BoundedCapacity" />-Option, wenn kein Standardwert festgelegt wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="dataflowBlockOptions" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BatchSize">
      <MemberSignature Language="C#" Value="public int BatchSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BatchSize" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.BatchBlock`1.BatchSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BatchSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BatchSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BatchSize : int" Usage="System.Threading.Tasks.Dataflow.BatchBlock&lt;'T&gt;.BatchSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe der Batches ab, die von diesem <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" /> generiert werden.</summary>
        <value>Die Batchgröße</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Anzahl der Elemente, die bereitgestellt, um den Block nicht durch die Batchgröße, die für den Block Konstruktor bereitgestellten teilbar ist, kann der Block der abschließenden Batch weniger als die angeforderte Anzahl von Elementen enthalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Complete">
      <MemberSignature Language="C#" Value="public void Complete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Complete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.Complete" />
      <MemberSignature Language="VB.NET" Value="Public Sub Complete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Complete();" />
      <MemberSignature Language="F#" Value="abstract member Complete : unit -&gt; unit&#xA;override this.Complete : unit -&gt; unit" Usage="batchBlock.Complete " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Signalisiert <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />, dass es keine Nachrichten mehr akzeptieren und keine produzieren und keine weiteren zurückgestellten Nachrichten verarbeiten soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach dem <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.Complete%2A> war aufgerufen wird, in einem Datenflussblock, der Block ausgeführt, und die zugehörige <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.Completion%2A> Aufgabe wird einen abschließenden Zustand versetzt, nachdem sie alle zuvor verfügbare Daten verarbeitet hat. <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.Complete%2A> wird nicht blockiert, die Abschluss vorgenommen wird, wartet aber stattdessen wird die Anforderung initiiert Warten, bis hin zu auftreten, die <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.Completion%2A> Aufgabe kann verwendet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Completion">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task Completion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.Task Completion" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.BatchBlock`1.Completion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Completion As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::Task ^ Completion { System::Threading::Tasks::Task ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Completion : System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Dataflow.BatchBlock&lt;'T&gt;.Completion" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Threading.Tasks.Task" /> ab, das den asynchronen Vorgang und die Beendigung des Datenflussblocks darstellt.</summary>
        <value>Die Aufgabe.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Datenflussblock gilt als abgeschlossen, wenn er nicht gerade verarbeitet, eine Nachricht, und wenn diese garantiert, dass es keine weiteren Nachrichten nicht verarbeitet werden. Das zurückgegebene <xref:System.Threading.Tasks.Task> Übergang in Status "abgeschlossen" wird, wenn der zugeordnete Block abgeschlossen ist. Es erfolgt ein Wechsel in den <xref:System.Threading.Tasks.TaskStatus> <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Status, wenn der Block die Verarbeitung gemäß des datenflussblocks erfolgreich abgeschlossen ist, definierte Semantik. Es erfolgt ein Wechsel in die <xref:System.Threading.Tasks.TaskStatus> <xref:System.Threading.Tasks.TaskStatus.Faulted> Status, wenn der Datenflussblock Verarbeitung vorzeitig aufgrund einer nicht behandelten Ausnahme abgeschlossen ist, und es ein in Wechsel erfolgt den <xref:System.Threading.Tasks.TaskStatus> <xref:System.Threading.Tasks.TaskStatus.Canceled> Zustand nach Abschluss der Datenflussblock die Verarbeitung aufgrund von vorzeitig eine abbruchanforderung empfangen. Wenn die Aufgabe abgeschlossen, in ist der <xref:System.Threading.Tasks.TaskStatus.Faulted> Status, seine `Exception` Eigenschaft zurückgegeben wird ein <xref:System.AggregateException> mit der eine oder mehrere Ausnahmen, die Fehlschlagen des Blockes verursacht hat.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LinkTo">
      <MemberSignature Language="C#" Value="public IDisposable LinkTo (System.Threading.Tasks.Dataflow.ITargetBlock&lt;T[]&gt; target, System.Threading.Tasks.Dataflow.DataflowLinkOptions linkOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IDisposable LinkTo(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!T[]&gt; target, class System.Threading.Tasks.Dataflow.DataflowLinkOptions linkOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{`0[]},System.Threading.Tasks.Dataflow.DataflowLinkOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function LinkTo (target As ITargetBlock(Of T()), linkOptions As DataflowLinkOptions) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IDisposable ^ LinkTo(System::Threading::Tasks::Dataflow::ITargetBlock&lt;cli::array &lt;T&gt; ^&gt; ^ target, System::Threading::Tasks::Dataflow::DataflowLinkOptions ^ linkOptions);" />
      <MemberSignature Language="F#" Value="abstract member LinkTo : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T[]&gt; * System.Threading.Tasks.Dataflow.DataflowLinkOptions -&gt; IDisposable&#xA;override this.LinkTo : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T[]&gt; * System.Threading.Tasks.Dataflow.DataflowLinkOptions -&gt; IDisposable" Usage="batchBlock.LinkTo (target, linkOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Threading.Tasks.Dataflow.DataflowLinkOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;T[]&gt;" />
        <Parameter Name="linkOptions" Type="System.Threading.Tasks.Dataflow.DataflowLinkOptions" />
      </Parameters>
      <Docs>
        <param name="target">Das <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />-Objekt, das mit dieser Quelle verbunden werden soll.</param>
        <param name="linkOptions">Eine <see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" />-Instanz, die den Link konfiguriert.</param>
        <summary>Verbindet <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> mit dem angegebenen <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />-Objekt.</summary>
        <returns>Ein IDisposable, der nach dem Aufrufen von Dispose, die Quelle vom Ziel trennt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> ist NULL (Nothing in Visual Basic), oder <paramref name="linkOptions" /> ist NULL (Nothing in Visual Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="OutputCount">
      <MemberSignature Language="C#" Value="public int OutputCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 OutputCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.BatchBlock`1.OutputCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutputCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int OutputCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.OutputCount : int" Usage="System.Threading.Tasks.Dataflow.BatchBlock&lt;'T&gt;.OutputCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Ausgabe-Elementen ab, die von diesem Block empfangen werden können.</summary>
        <value>Die Anzahl von Ausgabe-Elementen in.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.IDataflowBlock.Fault">
      <MemberSignature Language="C#" Value="void IDataflowBlock.Fault (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception ^ exception) = System::Threading::Tasks::Dataflow::IDataflowBlock::Fault;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(System.Exception)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="exception">Die <see cref="T:System.Exception" />, die den Fehler verursacht hat.</param>
        <summary>Hat zur Folge, dass <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> im Status <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> abgeschlossen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach dem <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Fault%2A> wurde für einen Datenflussblock aufgerufen wird, der Block ausgeführt, und die zugehörige <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.Completion%2A> Aufgabe wird einen abschließenden Zustand versetzt. Fehler von einem Block, wird als mit Abbrechen eines Blocks gepufferte Nachrichten (nicht verarbeitet eingehende Nachrichten sowie unoffered ausgabemeldungen) verloren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="exception" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ConsumeMessage">
      <MemberSignature Language="C#" Value="T[] ISourceBlock&lt;T[]&gt;.ConsumeMessage (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, System.Threading.Tasks.Dataflow.ITargetBlock&lt;T[]&gt; target, out bool messageConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance !T[] System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ConsumeMessage(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!T[]&gt; target, [out] bool&amp; messageConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock&lt;T[]&gt;#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0[]},System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Function ConsumeMessage (messageHeader As DataflowMessageHeader, target As ITargetBlock(Of T()), ByRef messageConsumed As Boolean) As T() Implements ISourceBlock(Of T()).ConsumeMessage" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;T&gt; ^ System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ConsumeMessage(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, System::Threading::Tasks::Dataflow::ITargetBlock&lt;cli::array &lt;T&gt; ^&gt; ^ target, [Runtime::InteropServices::Out] bool % messageConsumed) = System::Threading::Tasks::Dataflow::ISourceBlock&lt;cli::array &lt;T&gt; ^&gt;::ConsumeMessage;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;T[]&gt;" />
        <Parameter Name="messageConsumed" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="messageHeader"><see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> der Meldung, die verarbeitet wird.</param>
        <param name="target">Die <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, die die Nachricht verwendet.</param>
        <param name="messageConsumed"><see langword="true" />, wenn die Nachricht erfolgreich verarbeitet wurde, andernfalls <see langword="false" />.</param>
        <summary>Wird von einem verknüpften <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />-Objekt aufgerufen, um ein <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />-Objekt zu akzeptieren und zu verarbeiten, das zuvor durch dieses <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> angeboten wurde.</summary>
        <returns>Der Wert der verarbeiteten Meldung. Dies entspricht möglicherweise einer anderen <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />-Instanz als die zuvor reservierte und die als <paramref name="messageHeader" /> an <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" /> übergebene. Der <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> muss den zurückgegebenen Wert benutzen und nicht den Wert, der als messageValue von <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" /> übergeben wird.  
  
Wenn die Meldung, die angefordert wird, nicht verfügbar ist, ist der Rückgabewert <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur [ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601 >-Instanzen verknüpft wird, folgt [ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601 >-Instanz können Sie [ISourceBlock ( T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A >, und muss nur verwendet werden, um nutzen [ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.DataflowMessageHeader > Instanzen zuvor von dieser Quelle zum Ziel bereitgestellt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="messageHeader" /> ist ungültig.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ReleaseReservation">
      <MemberSignature Language="C#" Value="void ISourceBlock&lt;T[]&gt;.ReleaseReservation (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, System.Threading.Tasks.Dataflow.ITargetBlock&lt;T[]&gt; target);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ReleaseReservation(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!T[]&gt; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock&lt;T[]&gt;#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0[]})" />
      <MemberSignature Language="VB.NET" Value="Sub ReleaseReservation (messageHeader As DataflowMessageHeader, target As ITargetBlock(Of T())) Implements ISourceBlock(Of T()).ReleaseReservation" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ReleaseReservation(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, System::Threading::Tasks::Dataflow::ITargetBlock&lt;cli::array &lt;T&gt; ^&gt; ^ target) = System::Threading::Tasks::Dataflow::ISourceBlock&lt;cli::array &lt;T&gt; ^&gt;::ReleaseReservation;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;T[]&gt;" />
      </Parameters>
      <Docs>
        <param name="messageHeader"><see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> der reservierten Meldung, die freigegeben wird.</param>
        <param name="target"><see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, der die Nachricht freigibt, die er vorher reserviert hat.</param>
        <summary>Wird von einem verknüpften <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, um einen <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />, der von diesem <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> zuvor reserviert wurde, freizugeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur [ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601 >-Instanzen verknüpft wird, folgt [ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601 >-Instanz verwenden kann `ReleaseReservation` , und muss nur verwendet werden, um die Version [ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.DataflowMessageHeader > Instanzen, die zuvor und erfolgreich vom Ziel reserviert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="messageHeader" /> ist ungültig.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Das <paramref name="target" /> hatte die Meldung nicht reserviert.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ReserveMessage">
      <MemberSignature Language="C#" Value="bool ISourceBlock&lt;T[]&gt;.ReserveMessage (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, System.Threading.Tasks.Dataflow.ITargetBlock&lt;T[]&gt; target);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ReserveMessage(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!T[]&gt; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock&lt;T[]&gt;#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0[]})" />
      <MemberSignature Language="VB.NET" Value="Function ReserveMessage (messageHeader As DataflowMessageHeader, target As ITargetBlock(Of T())) As Boolean Implements ISourceBlock(Of T()).ReserveMessage" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ReserveMessage(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, System::Threading::Tasks::Dataflow::ITargetBlock&lt;cli::array &lt;T&gt; ^&gt; ^ target) = System::Threading::Tasks::Dataflow::ISourceBlock&lt;cli::array &lt;T&gt; ^&gt;::ReserveMessage;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;T[]&gt;" />
      </Parameters>
      <Docs>
        <param name="messageHeader"><see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> der Meldung, die reserviert wird.</param>
        <param name="target">Die <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> der Meldung empfängt.</param>
        <summary>Wird von einem verknüpften <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, um einen <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />, der von diesem <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> zuvor angeboten wurde, zu reservieren.</summary>
        <returns><see langword="true" />, wenn die Nachricht erfolgreich reserviert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur [ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601 >-Instanzen verknüpft wird, folgt [ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601 >-Instanz können Sie [ISourceBlock ( T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A >, und es darf nur verwendet, zu reservieren [ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.DataflowMessageHeader > Instanzen zuvor von dieser Quelle zum Ziel bereitgestellt werden.  
  
 Wenn `true` zurückgegeben wird, die [ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601 > muss anschließend rufen Sie entweder [ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601. ConsumeMessage % 2A > oder [ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A > für diese Nachricht. Bei unterlassen, möglicherweise in der Quelle nicht auf weiteren Nachrichten an diese oder andere Ziele weitergegeben werden.  
  
 [ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A > darf nicht aufgerufen werden, während das Ziel internen Sperren enthalten ist. Auf diese Weise wird der Sperrhierarchie erforderlich, um Deadlocks in einem Datenflussnetzwerk vermeiden verletzen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="messageHeader" /> ist ungültig.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ITargetBlock&lt;T&gt;.OfferMessage">
      <MemberSignature Language="C#" Value="System.Threading.Tasks.Dataflow.DataflowMessageStatus ITargetBlock&lt;T&gt;.OfferMessage (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, T messageValue, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T&gt; source, bool consumeToAccept);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Threading.Tasks.Dataflow.DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock&lt;T&gt;.OfferMessage(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, !T messageValue, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!T&gt; source, bool consumeToAccept) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.System#Threading#Tasks#Dataflow#ITargetBlock&lt;T&gt;#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function OfferMessage (messageHeader As DataflowMessageHeader, messageValue As T, source As ISourceBlock(Of T), consumeToAccept As Boolean) As DataflowMessageStatus Implements ITargetBlock(Of T).OfferMessage" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Threading::Tasks::Dataflow::DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock&lt;T&gt;.OfferMessage(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, T messageValue, System::Threading::Tasks::Dataflow::ISourceBlock&lt;T&gt; ^ source, bool consumeToAccept) = System::Threading::Tasks::Dataflow::ITargetBlock&lt;T&gt;::OfferMessage;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Dataflow.DataflowMessageStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="messageValue" Type="T" />
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T&gt;" />
        <Parameter Name="consumeToAccept" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="messageHeader">Eine <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />-Instanz, die die Header der Nachricht darstellt, die bereitgestellt wird.</param>
        <param name="messageValue">Der Wert der Nachricht, die bereitgestellt wird.</param>
        <param name="source">Die <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />, die die Nachricht anbietet. Dies kann NULL sein.</param>
        <param name="consumeToAccept">Auf <see langword="true" /> festlegen, um das Ziel anzuweisen, <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" /> während des Aufrufs von <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" /><see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" /> synchron aufzurufen, um die Meldung zu verarbeiten.</param>
        <summary>Bietet eine Meldung für <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> an und gibt dem Ziel die Möglichkeit, die Nachricht zu verarbeiten oder zurückzustellen.</summary>
        <returns>Der Status der angebotenen Meldung. Wenn die Meldung vom Ziel akzeptiert wurde, wird <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" /> zurückgegeben, und die Quelle sollte die angebotene Meldung nicht mehr verwenden, da sie jetzt dem Ziel gehört. Wenn die Nachricht vom Ziel zurückgestellt wurde, wird <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed" /> als Benachrichtigung zurückgegeben, dass das Ziel später möglicherweise versucht, die Nachricht zu verarbeiten oder zu reservieren. Zwischenzeitlich besitzt die Quelle die Nachricht weiterhin und bietet sie möglicherweise anderen Blöcke an.  
  
Wenn das Ziel andernfalls die Meldung zurückgestellt hätte, aber <paramref name="source" /> gleich <see langword="null" /> war, wird stattdessen <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" /> zurückgegeben.  
  
Wenn das Ziel versucht hat, die Nachricht zu akzeptieren, diese aber verpasst hat, weil die Quelle die die Meldung an ein anderes Ziel übermittelt oder einfach verworfen hat, wird <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable" /> zurückgegeben.  
  
Wenn das Ziel beschlossen hat, die Nachricht nicht zu akzeptieren, wird <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" /> zurückgegeben. Wenn das Ziel beschlossen hat, die Meldung nicht zu akzeptieren und niemals eine weitere Meldung von dieser Quelle akzeptieren wird, wird <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently" /> zurückgegeben.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="messageHeader" /> ist ungültig.  
  
oder <paramref name="consumeToAccept" /> kann nur TRUE sein, wenn eine <paramref name="source" /> bereitgestellt wird, die nicht NULL ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="batchBlock.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Zeichenfolge zurück, die den formatierten Namen dieser <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />-Instanz darstellt.</summary>
        <returns>Eine Zeichenfolge, die den formatierten Namen dieser <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />-Instanz darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird von <xref:System.Object> geerbt. Verwendet die <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.NameFormat%2A> Option.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TriggerBatch">
      <MemberSignature Language="C#" Value="public void TriggerBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TriggerBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.TriggerBatch" />
      <MemberSignature Language="VB.NET" Value="Public Sub TriggerBatch ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TriggerBatch();" />
      <MemberSignature Language="F#" Value="member this.TriggerBatch : unit -&gt; unit" Usage="batchBlock.TriggerBatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" />, um einen Batchvorgang zu initiieren, auch wenn die Anzahl der Elemente, die sich momentan in der Warteschlange befinden oder zurückgestellt wurden, kleiner ist als <see cref="P:System.Threading.Tasks.Dataflow.BatchBlock`1.BatchSize" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im gierigen Modus wird ein Batch von Elementen in der Warteschlange generiert werden, auch wenn weniger als die Batchgröße vorhanden.  
  
 Im nicht gierigen Modus wird ein Batch asynchron aus verschobene Elemente generiert werden, auch wenn weniger Elemente als durch die Batchgröße angegeben wird, genutzt werden können.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReceive">
      <MemberSignature Language="C#" Value="public bool TryReceive (Predicate&lt;T[]&gt; filter, out T[] item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryReceive(class System.Predicate`1&lt;!T[]&gt; filter, [out] !T[]&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.TryReceive(System.Predicate{`0[]},`0[]@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReceive (filter As Predicate(Of T()), ByRef item As T()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryReceive(Predicate&lt;cli::array &lt;T&gt; ^&gt; ^ filter, [Runtime::InteropServices::Out] cli::array &lt;T&gt; ^ % item);" />
      <MemberSignature Language="F#" Value="abstract member TryReceive : Predicate&lt;'T[]&gt; *  -&gt; bool&#xA;override this.TryReceive : Predicate&lt;'T[]&gt; *  -&gt; bool" Usage="batchBlock.TryReceive (filter, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Predicate&lt;T[]&gt;" />
        <Parameter Name="item" Type="T[]" RefType="out" />
      </Parameters>
      <Docs>
        <param name="filter">Das Prädikat, das ein Wert erfolgreich übergeben muss, damit es empfangen wird.  <paramref name="filter" /> ist möglicherweise <see langword="null" />, in diesem Fall werden alle Elemente übergeben.</param>
        <param name="item">Das von der Quelle empfangene Element.</param>
        <summary>Versucht, ein verfügbares Output-Element von<see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" /> synchron zu empfangen.</summary>
        <returns><see langword="true" />, wenn ein Element empfangen werden konnte; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird warten auf die Quelle, geben Sie ein Element nicht blockiert werden.  
  
 Es wird nach der Überprüfung für ein Element zurückgegeben, und zwar unabhängig davon, ob ein Element verfügbar war.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReceiveAll">
      <MemberSignature Language="C#" Value="public bool TryReceiveAll (out System.Collections.Generic.IList&lt;T[]&gt; items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryReceiveAll([out] class System.Collections.Generic.IList`1&lt;!T[]&gt;&amp; items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.TryReceiveAll(System.Collections.Generic.IList{`0[]}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReceiveAll (ByRef items As IList(Of T())) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryReceiveAll([Runtime::InteropServices::Out] System::Collections::Generic::IList&lt;cli::array &lt;T&gt; ^&gt; ^ % items);" />
      <MemberSignature Language="F#" Value="abstract member TryReceiveAll :  -&gt; bool&#xA;override this.TryReceiveAll :  -&gt; bool" Usage="batchBlock.TryReceiveAll items" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="System.Collections.Generic.IList&lt;T[]&gt;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="items">Die von der Quelle empfangenen Elemente.</param>
        <summary>Versucht, alle verfügbaren Elemente aus <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" /> synchron zu empfangen.</summary>
        <returns><see langword="true" />, wenn ein oder mehrere Elemente empfangen werden konnten; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird warten auf die Quelle, geben Sie ein Element nicht blockiert werden.  
  
 Es wird nach der Überprüfung für Elemente zurückgegeben, und zwar unabhängig davon, ob ein Element verfügbar war.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>