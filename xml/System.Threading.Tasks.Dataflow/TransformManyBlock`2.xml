<Type Name="TransformManyBlock&lt;TInput,TOutput&gt;" FullName="System.Threading.Tasks.Dataflow.TransformManyBlock&lt;TInput,TOutput&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f12d4b32bed0ce9dfcb8c2e784cc3fd17f6f1a63" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86620375" /></Metadata><TypeSignature Language="C#" Value="public sealed class TransformManyBlock&lt;TInput,TOutput&gt; : System.Threading.Tasks.Dataflow.IPropagatorBlock&lt;TInput,TOutput&gt;, System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;TOutput&gt;, System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;, System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit TransformManyBlock`2&lt;TInput, TOutput&gt; extends System.Object implements class System.Threading.Tasks.Dataflow.IDataflowBlock, class System.Threading.Tasks.Dataflow.IPropagatorBlock`2&lt;!TInput, !TOutput&gt;, class System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&lt;!TOutput&gt;, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!TOutput&gt;, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!TInput&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class TransformManyBlock(Of TInput, TOutput)&#xA;Implements IPropagatorBlock(Of TInput, TOutput), IReceivableSourceBlock(Of TOutput), ISourceBlock(Of TOutput), ITargetBlock(Of TInput)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TInput, typename TOutput&gt;&#xA;public ref class TransformManyBlock sealed : System::Threading::Tasks::Dataflow::IPropagatorBlock&lt;TInput, TOutput&gt;, System::Threading::Tasks::Dataflow::IReceivableSourceBlock&lt;TOutput&gt;, System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt;, System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt;" />
  <TypeSignature Language="F#" Value="type TransformManyBlock&lt;'Input, 'Output&gt; = class&#xA;    interface IPropagatorBlock&lt;'Input, 'Output&gt;&#xA;    interface ITargetBlock&lt;'Input&gt;&#xA;    interface IDataflowBlock&#xA;    interface ISourceBlock&lt;'Output&gt;&#xA;    interface IReceivableSourceBlock&lt;'Output&gt;" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1" />
  <TypeSignature Language="F#" Value="type TransformManyBlock&lt;'Input, 'Output&gt; = class&#xA;    interface IDataflowBlock&#xA;    interface IPropagatorBlock&lt;'Input, 'Output&gt;&#xA;    interface ISourceBlock&lt;'Output&gt;&#xA;    interface ITargetBlock&lt;'Input&gt;&#xA;    interface IReceivableSourceBlock&lt;'Output&gt;" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
    <AssemblyVersion>4.5.25.0</AssemblyVersion>
    <AssemblyVersion>4.6.0.0</AssemblyVersion>
    <AssemblyVersion>4.6.1.0</AssemblyVersion>
    <AssemblyVersion>4.6.2.0</AssemblyVersion>
    <AssemblyVersion>4.6.3.0</AssemblyVersion>
    <AssemblyVersion>4.6.4.0</AssemblyVersion>
    <AssemblyVersion>4.6.5.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TInput" />
    <TypeParameter Name="TOutput" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.IDataflowBlock</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.IPropagatorBlock&lt;TInput,TOutput&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;TOutput&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1">
      <AttributeName Language="C#">[System.Diagnostics.DebuggerDisplay("{DebuggerDisplayContent,nq}")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerDisplay("{DebuggerDisplayContent,nq}")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1">
      <AttributeName Language="C#">[System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.Dataflow.TransformManyBlock`2/DebugView))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.Dataflow.TransformManyBlock`2/DebugView))&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TInput">Gibt den Datentyp an, der durch dieses <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" /> empfangen und bearbeitet wird.</typeparam>
    <typeparam name="TOutput">Gibt den Datentyp an, der von dieser <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" /> ausgegeben wird.</typeparam>
    <summary>Stellt einen Datenflussblock bereit, der einen bereitgestellten <see cref="T:System.Func`2" />-Delegaten für jede empfangene Datenelement aufruft.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [tpl-install-instructions](~/includes/tpl-install-instructions.md)]
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TransformManyBlock (Func&lt;TInput,System.Collections.Generic.IEnumerable&lt;TOutput&gt;&gt; transform);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`2&lt;!TInput, class System.Collections.Generic.IEnumerable`1&lt;!TOutput&gt;&gt; transform) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.#ctor(System.Func{`0,System.Collections.Generic.IEnumerable{`1}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (transform As Func(Of TInput, IEnumerable(Of TOutput)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TransformManyBlock(Func&lt;TInput, System::Collections::Generic::IEnumerable&lt;TOutput&gt; ^&gt; ^ transform);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Dataflow.TransformManyBlock&lt;'Input, 'Output&gt; : Func&lt;'Input, seq&lt;'Output&gt;&gt; -&gt; System.Threading.Tasks.Dataflow.TransformManyBlock&lt;'Input, 'Output&gt;" Usage="new System.Threading.Tasks.Dataflow.TransformManyBlock&lt;'Input, 'Output&gt; transform" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="transform" Type="System.Func&lt;TInput,System.Collections.Generic.IEnumerable&lt;TOutput&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="transform">Die Funktion, die für jedes empfangene Datenelement aufzurufen ist. Alle Daten von dem zurückgegebenen <see cref="T:System.Collections.Generic.IEnumerable`1" /> werden als Ausgabe dieses <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" /> zur Verfügung gestellt.</param>
        <summary>Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" /> mit der angegebenen Funktion.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="transform" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TransformManyBlock (Func&lt;TInput,System.Threading.Tasks.Task&lt;System.Collections.Generic.IEnumerable&lt;TOutput&gt;&gt;&gt; transform);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`2&lt;!TInput, class System.Threading.Tasks.Task`1&lt;class System.Collections.Generic.IEnumerable`1&lt;!TOutput&gt;&gt;&gt; transform) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.#ctor(System.Func{`0,System.Threading.Tasks.Task{System.Collections.Generic.IEnumerable{`1}}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (transform As Func(Of TInput, Task(Of IEnumerable(Of TOutput))))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TransformManyBlock(Func&lt;TInput, System::Threading::Tasks::Task&lt;System::Collections::Generic::IEnumerable&lt;TOutput&gt; ^&gt; ^&gt; ^ transform);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Dataflow.TransformManyBlock&lt;'Input, 'Output&gt; : Func&lt;'Input, System.Threading.Tasks.Task&lt;seq&lt;'Output&gt;&gt;&gt; -&gt; System.Threading.Tasks.Dataflow.TransformManyBlock&lt;'Input, 'Output&gt;" Usage="new System.Threading.Tasks.Dataflow.TransformManyBlock&lt;'Input, 'Output&gt; transform" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="transform" Type="System.Func&lt;TInput,System.Threading.Tasks.Task&lt;System.Collections.Generic.IEnumerable&lt;TOutput&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="transform">Die Funktion, die für jedes empfangene Datenelement aufzurufen ist. Alle Daten, die asynchron in <see cref="T:System.Collections.Generic.IEnumerable`1" /> zurückgegeben werden, werden als Ausgabe aus diesem <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" />-Objekt zur Verfügung gestellt.</param>
        <summary>Initialisiert einen neuen <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" /> mit der angegebenen Funktion.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="transform" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TransformManyBlock (Func&lt;TInput,System.Collections.Generic.IEnumerable&lt;TOutput&gt;&gt; transform, System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions dataflowBlockOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`2&lt;!TInput, class System.Collections.Generic.IEnumerable`1&lt;!TOutput&gt;&gt; transform, class System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions dataflowBlockOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.#ctor(System.Func{`0,System.Collections.Generic.IEnumerable{`1}},System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (transform As Func(Of TInput, IEnumerable(Of TOutput)), dataflowBlockOptions As ExecutionDataflowBlockOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TransformManyBlock(Func&lt;TInput, System::Collections::Generic::IEnumerable&lt;TOutput&gt; ^&gt; ^ transform, System::Threading::Tasks::Dataflow::ExecutionDataflowBlockOptions ^ dataflowBlockOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Dataflow.TransformManyBlock&lt;'Input, 'Output&gt; : Func&lt;'Input, seq&lt;'Output&gt;&gt; * System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions -&gt; System.Threading.Tasks.Dataflow.TransformManyBlock&lt;'Input, 'Output&gt;" Usage="new System.Threading.Tasks.Dataflow.TransformManyBlock&lt;'Input, 'Output&gt; (transform, dataflowBlockOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="transform" Type="System.Func&lt;TInput,System.Collections.Generic.IEnumerable&lt;TOutput&gt;&gt;" />
        <Parameter Name="dataflowBlockOptions" Type="System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions" />
      </Parameters>
      <Docs>
        <param name="transform">Die Funktion, die für jedes empfangene Datenelement aufzurufen ist. Alle Daten von dem zurückgegebenen <see cref="T:System.Collections.Generic.IEnumerable`1" />-Objekt werden als Ausgabe dieses <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" />-Objekts zur Verfügung gestellt.</param>
        <param name="dataflowBlockOptions">Die Optionen, mit denen dieser <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" /> zu konfigurieren ist.</param>
        <summary>Initialisiert ein neues <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" /> mit der angegebenen Funktion und <see cref="T:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="transform" /> ist <see langword="null" />.  
  
Oder 
<paramref name="dataflowBlockOptions" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TransformManyBlock (Func&lt;TInput,System.Threading.Tasks.Task&lt;System.Collections.Generic.IEnumerable&lt;TOutput&gt;&gt;&gt; transform, System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions dataflowBlockOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`2&lt;!TInput, class System.Threading.Tasks.Task`1&lt;class System.Collections.Generic.IEnumerable`1&lt;!TOutput&gt;&gt;&gt; transform, class System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions dataflowBlockOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.#ctor(System.Func{`0,System.Threading.Tasks.Task{System.Collections.Generic.IEnumerable{`1}}},System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (transform As Func(Of TInput, Task(Of IEnumerable(Of TOutput))), dataflowBlockOptions As ExecutionDataflowBlockOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TransformManyBlock(Func&lt;TInput, System::Threading::Tasks::Task&lt;System::Collections::Generic::IEnumerable&lt;TOutput&gt; ^&gt; ^&gt; ^ transform, System::Threading::Tasks::Dataflow::ExecutionDataflowBlockOptions ^ dataflowBlockOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Dataflow.TransformManyBlock&lt;'Input, 'Output&gt; : Func&lt;'Input, System.Threading.Tasks.Task&lt;seq&lt;'Output&gt;&gt;&gt; * System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions -&gt; System.Threading.Tasks.Dataflow.TransformManyBlock&lt;'Input, 'Output&gt;" Usage="new System.Threading.Tasks.Dataflow.TransformManyBlock&lt;'Input, 'Output&gt; (transform, dataflowBlockOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="transform" Type="System.Func&lt;TInput,System.Threading.Tasks.Task&lt;System.Collections.Generic.IEnumerable&lt;TOutput&gt;&gt;&gt;" />
        <Parameter Name="dataflowBlockOptions" Type="System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions" />
      </Parameters>
      <Docs>
        <param name="transform">Die Funktion, die für jedes empfangene Datenelement aufzurufen ist. Alle Daten, die asynchron in <see cref="T:System.Collections.Generic.IEnumerable`1" /> zurückgegeben werden, werden als Ausgabe aus diesem <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" />-Objekt zur Verfügung gestellt.</param>
        <param name="dataflowBlockOptions">Die Optionen, mit denen dieser <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" /> zu konfigurieren ist.</param>
        <summary>Initialisiert ein neues <see cref="T:System.Threading.Tasks.Dataflow.TransformManyBlock`2" /> mit der angegebenen Funktion und <see cref="T:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="transform" /> ist <see langword="null" />.  
  
Oder 
<paramref name="dataflowBlockOptions" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Complete">
      <MemberSignature Language="C#" Value="public void Complete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Complete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.Complete" />
      <MemberSignature Language="VB.NET" Value="Public Sub Complete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Complete();" />
      <MemberSignature Language="F#" Value="abstract member Complete : unit -&gt; unit&#xA;override this.Complete : unit -&gt; unit" Usage="transformManyBlock.Complete " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Signalisiert <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />, dass es keine Nachrichten mehr akzeptieren und keine produzieren und keine weiteren zurückgestellten Nachrichten verarbeiten soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nachdem <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602.Complete%2A> für einen Datenfluss Block aufgerufen wurde, wird dieser Block abgeschlossen, und seine Aufgabe wechselt <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602.Completion%2A> in einen Endzustand, nachdem alle zuvor verfügbaren Daten verarbeitet wurden. <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602.Complete%2A> blockiert nicht, dass auf den Abschluss gewartet wird, sondern initiiert die Anforderung. um zu warten, bis der Vorgang abgeschlossen ist, <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602.Completion%2A> kann der Task verwendet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Completion">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task Completion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.Task Completion" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.TransformManyBlock`2.Completion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Completion As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::Task ^ Completion { System::Threading::Tasks::Task ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Completion : System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Dataflow.TransformManyBlock&lt;'Input, 'Output&gt;.Completion" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Threading.Tasks.Task" /> ab, das den asynchronen Vorgang und die Beendigung des Datenflussblocks darstellt.</summary>
        <value>Der Task.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Datenfluss Block wird als abgeschlossen betrachtet, wenn er zurzeit keine Nachricht verarbeitet, und wenn sichergestellt ist, dass keine weiteren Nachrichten verarbeitet werden. Der zurückgegebene wechselt <xref:System.Threading.Tasks.Task> in den abgeschlossenen Zustand, wenn der zugeordnete-Block abgeschlossen wurde. Der Übergang in den-Zustand erfolgt, <xref:System.Threading.Tasks.TaskStatus> <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Wenn der-Block seine Verarbeitung gemäß der definierten Semantik des Datenfluss Blocks erfolgreich abgeschlossen hat. Es wechselt in den- <xref:System.Threading.Tasks.TaskStatus> <xref:System.Threading.Tasks.TaskStatus.Faulted> Status, wenn der Datenfluss Block die Verarbeitung aufgrund einer nicht behandelten Ausnahme vorzeitig abgeschlossen hat, und wechselt in den- <xref:System.Threading.Tasks.TaskStatus> <xref:System.Threading.Tasks.TaskStatus.Canceled> Zustand, wenn der Datenfluss Block die Verarbeitung vorzeitig abgeschlossen hat, weil eine Abbruch Anforderung empfangen wurde. Wenn die Aufgabe im- <xref:System.Threading.Tasks.TaskStatus.Faulted> Zustand abgeschlossen ist, `Exception` gibt die-Eigenschaft einen-Wert zurück, <xref:System.AggregateException> der die mindestens eine Ausnahme enthält, durch die der-Block fehlgeschlagen ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputCount">
      <MemberSignature Language="C#" Value="public int InputCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InputCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.TransformManyBlock`2.InputCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int InputCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.InputCount : int" Usage="System.Threading.Tasks.Dataflow.TransformManyBlock&lt;'Input, 'Output&gt;.InputCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Eingabeelemente ab, die darauf warten, von diesem Block verarbeitet zu werden.</summary>
        <value>Die Anzahl von Eingabe-Elementen in.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602.InputCount%2A>Enthält keine Elemente, die gerade vom-Block verarbeitet werden, oder Elemente, die bereits vom-Block verarbeitet wurden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LinkTo">
      <MemberSignature Language="C#" Value="public IDisposable LinkTo (System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt; target, System.Threading.Tasks.Dataflow.DataflowLinkOptions linkOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IDisposable LinkTo(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!TOutput&gt; target, class System.Threading.Tasks.Dataflow.DataflowLinkOptions linkOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{`1},System.Threading.Tasks.Dataflow.DataflowLinkOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function LinkTo (target As ITargetBlock(Of TOutput), linkOptions As DataflowLinkOptions) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IDisposable ^ LinkTo(System::Threading::Tasks::Dataflow::ITargetBlock&lt;TOutput&gt; ^ target, System::Threading::Tasks::Dataflow::DataflowLinkOptions ^ linkOptions);" />
      <MemberSignature Language="F#" Value="abstract member LinkTo : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Output&gt; * System.Threading.Tasks.Dataflow.DataflowLinkOptions -&gt; IDisposable&#xA;override this.LinkTo : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Output&gt; * System.Threading.Tasks.Dataflow.DataflowLinkOptions -&gt; IDisposable" Usage="transformManyBlock.LinkTo (target, linkOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Threading.Tasks.Dataflow.DataflowLinkOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt;" />
        <Parameter Name="linkOptions" Type="System.Threading.Tasks.Dataflow.DataflowLinkOptions" />
      </Parameters>
      <Docs>
        <param name="target">Das <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />-Objekt, das mit dieser Quelle verbunden werden soll.</param>
        <param name="linkOptions">Eine <see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" />-Instanz, die den Link konfiguriert.</param>
        <summary>Verbindet <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> mit dem angegebenen <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />-Objekt.</summary>
        <returns>Ein IDisposable, der nach dem Aufrufen von Dispose, die Quelle vom Ziel trennt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> ist NULL (Nothing in Visual Basic), oder <paramref name="linkOptions" /> ist NULL (Nothing in Visual Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="OutputCount">
      <MemberSignature Language="C#" Value="public int OutputCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 OutputCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.TransformManyBlock`2.OutputCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutputCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int OutputCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.OutputCount : int" Usage="System.Threading.Tasks.Dataflow.TransformManyBlock&lt;'Input, 'Output&gt;.OutputCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Ausgabe-Elementen ab, die von diesem Block empfangen werden können.</summary>
        <value>Die Anzahl von Ausgabe-Elementen in.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.IDataflowBlock.Fault">
      <MemberSignature Language="C#" Value="void IDataflowBlock.Fault (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Sub Fault (exception As Exception) Implements IDataflowBlock.Fault" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception ^ exception) = System::Threading::Tasks::Dataflow::IDataflowBlock::Fault;" />
      <MemberSignature Language="F#" Value="abstract member System.Threading.Tasks.Dataflow.IDataflowBlock.Fault : Exception -&gt; unit&#xA;override this.System.Threading.Tasks.Dataflow.IDataflowBlock.Fault : Exception -&gt; unit" Usage="transformManyBlock.System.Threading.Tasks.Dataflow.IDataflowBlock.Fault exception" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(System.Exception)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="exception">Die <see cref="T:System.Exception" />, die den Fehler verursacht hat.</param>
        <summary>Hat zur Folge, dass <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> im Status <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> abgeschlossen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nachdem <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602.System%23Threading%23Tasks%23Dataflow%23IDataflowBlock%23Fault%2A> für einen Datenfluss Block aufgerufen wurde, wird dieser Block abgeschlossen, und seine Aufgabe wechselt <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602.Completion%2A> in einen Endzustand. Ein Fehler bei einem-Block, wie beim Abbrechen eines-Blocks, bewirkt, dass gepufferte Nachrichten (nicht verarbeitete Eingabe Meldungen und nicht angebotene Ausgabe Nachrichten) verloren gehen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="exception" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;.ConsumeMessage">
      <MemberSignature Language="C#" Value="TOutput ISourceBlock&lt;TOutput&gt;.ConsumeMessage (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt; target, out bool messageConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance !TOutput System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;.ConsumeMessage(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!TOutput&gt; target, [out] bool&amp; messageConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock&lt;TOutput&gt;#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`1},System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Function ConsumeMessage (messageHeader As DataflowMessageHeader, target As ITargetBlock(Of TOutput), ByRef messageConsumed As Boolean) As TOutput Implements ISourceBlock(Of TOutput).ConsumeMessage" />
      <MemberSignature Language="C++ CLI" Value=" virtual TOutput System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;.ConsumeMessage(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, System::Threading::Tasks::Dataflow::ITargetBlock&lt;TOutput&gt; ^ target, [Runtime::InteropServices::Out] bool % messageConsumed) = System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt;::ConsumeMessage;" />
      <MemberSignature Language="F#" Value="abstract member System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;.ConsumeMessage : System.Threading.Tasks.Dataflow.DataflowMessageHeader * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Output&gt; * bool -&gt; 'Output&#xA;override this.System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;.ConsumeMessage : System.Threading.Tasks.Dataflow.DataflowMessageHeader * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Output&gt; * bool -&gt; 'Output" Usage="transformManyBlock.System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;.ConsumeMessage (messageHeader, target, messageConsumed)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt;" />
        <Parameter Name="messageConsumed" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="messageHeader"><see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> der Meldung, die verarbeitet wird.</param>
        <param name="target">Die <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, die die Nachricht verwendet.</param>
        <param name="messageConsumed"><see langword="true" />, wenn die Nachricht erfolgreich verarbeitet wurde, andernfalls <see langword="false" />.</param>
        <summary>Wird von verknüpften <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> aufgerufen, um einen <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> zu akzeptieren und verarbeiten, die zuvor durch dieses <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> angeboten werden.</summary>
        <returns>Der Wert der verarbeiteten Meldung. Dies entspricht möglicherweise einer anderen <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />-Instanz als die zuvor reservierte und die als <paramref name="messageHeader" /> an <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" /> übergebene. Der <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> muss den zurückgegebenen Wert benutzen und nicht den Wert, der als <paramref name="messageValue" /> von OfferMessage <see cref="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.System#Threading#Tasks#Dataflow#ITargetBlock{TInput}#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" /> übergeben wird.  
  
Wenn die Meldung, die angefordert wird, nicht verfügbar ist, ist der Rückgabewert <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> Instanzen, die mit dieser Instanz verknüpft sind <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> , können verwenden <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A> , und Sie müssen nur zum Verarbeiten von Instanzen verwendet werden, <xref:System.Threading.Tasks.Dataflow.DataflowMessageHeader> die zuvor von dieser Quelle für das Ziel angeboten wurden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="messageHeader" /> ist ungültig.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;.ReleaseReservation">
      <MemberSignature Language="C#" Value="void ISourceBlock&lt;TOutput&gt;.ReleaseReservation (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt; target);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;.ReleaseReservation(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!TOutput&gt; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock&lt;TOutput&gt;#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`1})" />
      <MemberSignature Language="VB.NET" Value="Sub ReleaseReservation (messageHeader As DataflowMessageHeader, target As ITargetBlock(Of TOutput)) Implements ISourceBlock(Of TOutput).ReleaseReservation" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;.ReleaseReservation(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, System::Threading::Tasks::Dataflow::ITargetBlock&lt;TOutput&gt; ^ target) = System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt;::ReleaseReservation;" />
      <MemberSignature Language="F#" Value="abstract member System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;.ReleaseReservation : System.Threading.Tasks.Dataflow.DataflowMessageHeader * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Output&gt; -&gt; unit&#xA;override this.System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;.ReleaseReservation : System.Threading.Tasks.Dataflow.DataflowMessageHeader * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Output&gt; -&gt; unit" Usage="transformManyBlock.System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;.ReleaseReservation (messageHeader, target)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt;" />
      </Parameters>
      <Docs>
        <param name="messageHeader"><see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> der reservierten Meldung, die freigegeben wird.</param>
        <param name="target"><see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, der die Nachricht freigibt, die er vorher reserviert hat.</param>
        <summary>Wird von einem verknüpften <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, um einen <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />, der von diesem <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> zuvor reserviert wurde, freizugeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> Instanzen, die mit dieser Instanz verknüpft sind <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> , können verwenden <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A> . Sie dürfen nur zum Freigeben von Instanzen verwendet werden, <xref:System.Threading.Tasks.Dataflow.DataflowMessageHeader> die zuvor vom Ziel reserviert wurden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="messageHeader" /> ist ungültig.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Das <paramref name="target" /> hatte die Meldung nicht reserviert.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;.ReserveMessage">
      <MemberSignature Language="C#" Value="bool ISourceBlock&lt;TOutput&gt;.ReserveMessage (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt; target);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;.ReserveMessage(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!TOutput&gt; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock&lt;TOutput&gt;#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`1})" />
      <MemberSignature Language="VB.NET" Value="Function ReserveMessage (messageHeader As DataflowMessageHeader, target As ITargetBlock(Of TOutput)) As Boolean Implements ISourceBlock(Of TOutput).ReserveMessage" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;.ReserveMessage(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, System::Threading::Tasks::Dataflow::ITargetBlock&lt;TOutput&gt; ^ target) = System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt;::ReserveMessage;" />
      <MemberSignature Language="F#" Value="abstract member System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;.ReserveMessage : System.Threading.Tasks.Dataflow.DataflowMessageHeader * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Output&gt; -&gt; bool&#xA;override this.System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;.ReserveMessage : System.Threading.Tasks.Dataflow.DataflowMessageHeader * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Output&gt; -&gt; bool" Usage="transformManyBlock.System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;.ReserveMessage (messageHeader, target)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt;" />
      </Parameters>
      <Docs>
        <param name="messageHeader"><see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> der Meldung, die reserviert wird.</param>
        <param name="target">Die <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> der Meldung empfängt.</param>
        <summary>Wird von einem verknüpften <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> aufgerufen, um ein <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />-Objekt, das von diesem <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />-Objekt zuvor angeboten wurde, zu reservieren.</summary>
        <returns><see langword="true" />, wenn die Nachricht erfolgreich reserviert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> Instanzen, die mit dieser Instanz verknüpft sind <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> , können verwenden <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A> . Sie dürfen nur zum Reservieren von Instanzen verwendet werden, <xref:System.Threading.Tasks.Dataflow.DataflowMessageHeader> die zuvor von dieser Quelle für das Ziel angeboten wurden.  
  
 Wenn `true` zurückgegeben wird, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> muss der anschließend entweder <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A> oder <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A> für diese Nachricht anrufen. Wenn dies nicht der Fall ist, kann es dazu kommen, dass die Quelle keine weiteren Nachrichten mehr an dieses oder andere Ziele weitergeben kann.  
  
 <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A> darf nicht aufgerufen werden, wenn das Ziel interne Sperren enthält. Dies verstößt gegen die Sperr Hierarchie, die notwendig ist, um Deadlocks in einem Datenfluss Netzwerk zu vermeiden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="messageHeader" /> ist ungültig.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;.OfferMessage">
      <MemberSignature Language="C#" Value="System.Threading.Tasks.Dataflow.DataflowMessageStatus ITargetBlock&lt;TInput&gt;.OfferMessage (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, TInput messageValue, System.Threading.Tasks.Dataflow.ISourceBlock&lt;TInput&gt; source, bool consumeToAccept);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Threading.Tasks.Dataflow.DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;.OfferMessage(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, !TInput messageValue, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!TInput&gt; source, bool consumeToAccept) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.System#Threading#Tasks#Dataflow#ITargetBlock&lt;TInput&gt;#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function OfferMessage (messageHeader As DataflowMessageHeader, messageValue As TInput, source As ISourceBlock(Of TInput), consumeToAccept As Boolean) As DataflowMessageStatus Implements ITargetBlock(Of TInput).OfferMessage" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Threading::Tasks::Dataflow::DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;.OfferMessage(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, TInput messageValue, System::Threading::Tasks::Dataflow::ISourceBlock&lt;TInput&gt; ^ source, bool consumeToAccept) = System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt;::OfferMessage;" />
      <MemberSignature Language="F#" Value="abstract member System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;.OfferMessage : System.Threading.Tasks.Dataflow.DataflowMessageHeader * 'Input * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Input&gt; * bool -&gt; System.Threading.Tasks.Dataflow.DataflowMessageStatus&#xA;override this.System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;.OfferMessage : System.Threading.Tasks.Dataflow.DataflowMessageHeader * 'Input * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Input&gt; * bool -&gt; System.Threading.Tasks.Dataflow.DataflowMessageStatus" Usage="transformManyBlock.System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;.OfferMessage (messageHeader, messageValue, source, consumeToAccept)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Dataflow.DataflowMessageStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="messageValue" Type="TInput" />
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TInput&gt;" />
        <Parameter Name="consumeToAccept" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="messageHeader">Eine <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />-Instanz, die die Header der Nachricht darstellt, die bereitgestellt wird.</param>
        <param name="messageValue">Der Wert der Nachricht, die bereitgestellt wird.</param>
        <param name="source">Die <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />, die die Nachricht anbietet. Dieser Wert kann <see langword="null" /> sein.</param>
        <param name="consumeToAccept"><see langword="true" />, wenn das Ziel während des Aufrufs von <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" /> und vor dem Zurückgeben von <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /><see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" /> synchron aufrufen muss, um die Meldung zu verarbeiten.</param>
        <summary>Bietet eine Meldung für <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> an und gibt dem Ziel die Möglichkeit, die Nachricht zu verarbeiten oder zurückzustellen.</summary>
        <returns>Der Status der angebotenen Meldung. Wenn die Meldung vom Ziel akzeptiert wurde, wird <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" /> zurückgegeben, und die Quelle sollte die angebotene Meldung nicht mehr verwenden, da sie jetzt dem Ziel gehört. Wenn die Nachricht vom Ziel zurückgestellt wurde, wird <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed" /> als Benachrichtigung zurückgegeben, dass das Ziel später möglicherweise versucht, die Nachricht zu verarbeiten oder zu reservieren. Zwischenzeitlich besitzt die Quelle die Nachricht weiterhin und bietet sie möglicherweise anderen Blöcke an.  
  
Wenn das Ziel andernfalls eine Aufschiebung veranlasst hätte, die Quelle jedoch <see langword="null" /> war, wird stattdessen <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" /> zurückgegeben.  
  
Wenn das Ziel versucht hat, die Nachricht zu akzeptieren, diese aber verpasst hat, weil die Quelle die die Meldung an ein anderes Ziel übermittelt oder einfach verworfen hat, wird <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable" /> zurückgegeben.  
  
Wenn das Ziel beschlossen hat, die Nachricht nicht zu akzeptieren, wird <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" /> zurückgegeben. Wenn das Ziel beschlossen hat, die Meldung nicht zu akzeptieren und niemals eine weitere Meldung von dieser Quelle akzeptieren wird, wird <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently" /> zurückgegeben.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="messageHeader" /> ist ungültig.  
  
Oder 
 <paramref name="consumeToAccept" /> kann nur true sein, wenn eine <paramref name="source" /> bereitgestellt wird, die nicht NULL ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="transformManyBlock.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Zeichenfolge zurück, die den formatierten Namen dieser <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />-Instanz darstellt.</summary>
        <returns>Eine Zeichenfolge, die den formatierten Namen dieser <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />-Instanz darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird von geerbt  <xref:System.Object> . Verwendet die-  <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.NameFormat%2A> Option.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReceive">
      <MemberSignature Language="C#" Value="public bool TryReceive (Predicate&lt;TOutput&gt; filter, out TOutput item);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryReceive(class System.Predicate`1&lt;!TOutput&gt; filter, [out] !TOutput&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.TryReceive(System.Predicate{`1},`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReceive (filter As Predicate(Of TOutput), ByRef item As TOutput) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryReceive(Predicate&lt;TOutput&gt; ^ filter, [Runtime::InteropServices::Out] TOutput % item);" />
      <MemberSignature Language="F#" Value="abstract member TryReceive : Predicate&lt;'Output&gt; * 'Output -&gt; bool&#xA;override this.TryReceive : Predicate&lt;'Output&gt; * 'Output -&gt; bool" Usage="transformManyBlock.TryReceive (filter, item)" />
      <MemberSignature Language="C#" Value="public bool TryReceive (Predicate&lt;TOutput&gt;? filter, out TOutput item);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1.TryReceive(System.Predicate{`0},`0@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Predicate&lt;TOutput&gt;" />
        <Parameter Name="item" Type="TOutput" RefType="out" />
      </Parameters>
      <Docs>
        <param name="filter">Der Prädikatswert muss erfolgreich übergeben werden, damit er empfangen wird.  <paramref name="filter" /> ist möglicherweise <see langword="null" />, in diesem Fall werden alle Elemente übergeben.</param>
        <param name="item">Das von der Quelle empfangene Element.</param>
        <summary>Versucht, ein verfügbares Output-Element von<see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" /> synchron zu empfangen.</summary>
        <returns><see langword="true" />, wenn ein Element empfangen werden konnte; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode blockiert nicht, wenn Sie darauf wartet, dass die Quelle ein Element bereitstellt.  
  
 Es wird nach dem Überprüfen auf ein Element zurückgegeben, unabhängig davon, ob ein Element verfügbar war.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReceiveAll">
      <MemberSignature Language="C#" Value="public bool TryReceiveAll (out System.Collections.Generic.IList&lt;TOutput&gt; items);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryReceiveAll([out] class System.Collections.Generic.IList`1&lt;!TOutput&gt;&amp; items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.TransformManyBlock`2.TryReceiveAll(System.Collections.Generic.IList{`1}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReceiveAll (ByRef items As IList(Of TOutput)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryReceiveAll([Runtime::InteropServices::Out] System::Collections::Generic::IList&lt;TOutput&gt; ^ % items);" />
      <MemberSignature Language="F#" Value="abstract member TryReceiveAll : IList -&gt; bool&#xA;override this.TryReceiveAll : IList -&gt; bool" Usage="transformManyBlock.TryReceiveAll items" />
      <MemberSignature Language="C#" Value="public bool TryReceiveAll (out System.Collections.Generic.IList&lt;TOutput&gt;? items);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1.TryReceiveAll(System.Collections.Generic.IList{`0}@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="System.Collections.Generic.IList&lt;TOutput&gt;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="items">Die von der Quelle empfangenen Elemente.</param>
        <summary>Versucht, alle verfügbaren Elemente aus <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" /> synchron zu empfangen.</summary>
        <returns><see langword="true" />, wenn ein oder mehrere Elemente empfangen werden konnten; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode blockiert nicht, wenn Sie darauf wartet, dass die Quelle ein Element bereitstellt.  
  
 Es wird nach der Überprüfung auf Elemente zurückgegeben, unabhängig davon, ob ein Element verfügbar war.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
