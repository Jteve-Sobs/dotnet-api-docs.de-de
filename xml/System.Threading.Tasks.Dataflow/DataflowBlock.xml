<Type Name="DataflowBlock" FullName="System.Threading.Tasks.Dataflow.DataflowBlock">
  <Metadata><Meta Name="ms.openlocfilehash" Value="619c37dae0d34137464488ce19920259b14fa058" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/25/2018" /><Meta Name="ms.locfileid" Value="39758897" /></Metadata><TypeSignature Language="C#" Value="public static class DataflowBlock" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit DataflowBlock extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Dataflow.DataflowBlock" />
  <TypeSignature Language="VB.NET" Value="Public Module DataflowBlock" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataflowBlock abstract sealed" />
  <TypeSignature Language="F#" Value="type DataflowBlock = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
    <AssemblyVersion>4.6.0.0</AssemblyVersion>
    <AssemblyVersion>4.6.1.0</AssemblyVersion>
    <AssemblyVersion>4.6.2.0</AssemblyVersion>
    <AssemblyVersion>4.6.3.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt einen Satz mit statischen (Shared in Visual Basic) Methoden für die Arbeit mit Datenflussblöcken bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
[!INCLUDE [tpl-install-instructions](~/includes/tpl-install-instructions.md)]
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AsObservable&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static IObservable&lt;TOutput&gt; AsObservable&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IObservable`1&lt;!!TOutput&gt; AsObservable&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.AsObservable``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsObservable(Of TOutput) (source As ISourceBlock(Of TOutput)) As IObservable(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static IObservable&lt;TOutput&gt; ^ AsObservable(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsObservable : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; -&gt; IObservable&lt;'Output&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.AsObservable source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IObservable&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Gibt den Datentyp an, der in der Quelle enthalten ist.</typeparam>
        <param name="source">Die Quelle, die umschlossen werden soll.</param>
        <summary>Erstellt eine neue <see cref="T:System.IObservable`1" /> Abstraktion über <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</summary>
        <returns>Ein <see cref="T:System.IObservable`1" />, das Beobachtern erlaubt, die Quelle zu abonnieren.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsObserver&lt;TInput&gt;">
      <MemberSignature Language="C#" Value="public static IObserver&lt;TInput&gt; AsObserver&lt;TInput&gt; (this System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt; target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IObserver`1&lt;!!TInput&gt; AsObserver&lt;TInput&gt;(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TInput&gt; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.AsObserver``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsObserver(Of TInput) (target As ITargetBlock(Of TInput)) As IObserver(Of TInput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static IObserver&lt;TInput&gt; ^ AsObserver(System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt; ^ target);" />
      <MemberSignature Language="F#" Value="static member AsObserver : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Input&gt; -&gt; IObserver&lt;'Input&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.AsObserver target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IObserver&lt;TInput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Gibt den Typ der Eingabe an, die vom Zielblock akzeptiert wird.</typeparam>
        <param name="target">Das zu umschließende Ziel</param>
        <summary>Erstellt eine neue <see cref="T:System.IObserver`1" />-Abstraktion über <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</summary>
        <returns>Ein Beobachter, der den Zielblock umschließt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Choose&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;int&gt; Choose&lt;T1,T2&gt; (System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt; source1, Action&lt;T1&gt; action1, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt; source2, Action&lt;T2&gt; action2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;int32&gt; Choose&lt;T1, T2&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T1&gt; source1, class System.Action`1&lt;!!T1&gt; action1, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T2&gt; source2, class System.Action`1&lt;!!T2&gt; action2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Choose``2(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Action{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Function Choose(Of T1, T2) (source1 As ISourceBlock(Of T1), action1 As Action(Of T1), source2 As ISourceBlock(Of T2), action2 As Action(Of T2)) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2&gt;&#xA; static System::Threading::Tasks::Task&lt;int&gt; ^ Choose(System::Threading::Tasks::Dataflow::ISourceBlock&lt;T1&gt; ^ source1, Action&lt;T1&gt; ^ action1, System::Threading::Tasks::Dataflow::ISourceBlock&lt;T2&gt; ^ source2, Action&lt;T2&gt; ^ action2);" />
      <MemberSignature Language="F#" Value="static member Choose : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T1&gt; * Action&lt;'T1&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T2&gt; * Action&lt;'T2&gt; -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Choose (source1, action1, source2, action2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt;" />
        <Parameter Name="action1" Type="System.Action&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt;" />
        <Parameter Name="action2" Type="System.Action&lt;T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">Gibt den Typ der Daten an, die in der ersten Quelle enthalten sind.</typeparam>
        <typeparam name="T2">Gibt den Typ der Daten an, die in der zweiten Quelle enthalten sind.</typeparam>
        <param name="source1">Die erste Quelle.</param>
        <param name="action1">Der Handler zu Ausführen von Daten aus der ersten Quelle.</param>
        <param name="source2">Die zweite Quelle.</param>
        <param name="action2">Der Handler zu Ausführen von Daten aus der zweiten Quelle.</param>
        <summary>Überwacht zwei Datenflussquellen, wobei der angegebene Handler für eine beliebige Quelle aufgerufen wird, die Daten zuerst verfügbar macht.</summary>
        <returns>Eine <see cref="T:System.Threading.Tasks.Task`1" />, die die asynchrone Auswahl darstellt. Wenn beide Quellen vor dem Abschluss der Auswahl beendet werden, wird die resultierende Aufgabe abgebrochen. Wenn eine der Datenquellen verfügbare Daten hat und erfolgreich an die Auswahl weitergibt, wird die resultierende Aufgabe abgeschlossen, wenn der Handler abgeschlossen wird. Wenn der Handler eine Ausnahme auslöst, endet die Aufgabe im Zustand <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> und enthält den Ausnahmefehler. Andernfalls wird die Aufgabe mit dem <see cref="P:System.Threading.Tasks.Task`1.Result" /> beendet, das entweder auf 0 oder 1 festgelegt ist, um jeweils die erste oder zweite Quelle darzustellen.  
  
Diese Methode verwendet nur ein Element aus einer der beiden Datenquellen, nie beide.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> ist <see langword="null" />.  
  
- oder -  
<paramref name="action1" /> ist <see langword="null" />.  
  
- oder -  
<paramref name="source2" /> ist <see langword="null" />.  
  
- oder -  
<paramref name="action2" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Choose&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;int&gt; Choose&lt;T1,T2&gt; (System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt; source1, Action&lt;T1&gt; action1, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt; source2, Action&lt;T2&gt; action2, System.Threading.Tasks.Dataflow.DataflowBlockOptions dataflowBlockOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;int32&gt; Choose&lt;T1, T2&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T1&gt; source1, class System.Action`1&lt;!!T1&gt; action1, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T2&gt; source2, class System.Action`1&lt;!!T2&gt; action2, class System.Threading.Tasks.Dataflow.DataflowBlockOptions dataflowBlockOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Choose``2(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Action{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1},System.Action{``1},System.Threading.Tasks.Dataflow.DataflowBlockOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2&gt;&#xA; static System::Threading::Tasks::Task&lt;int&gt; ^ Choose(System::Threading::Tasks::Dataflow::ISourceBlock&lt;T1&gt; ^ source1, Action&lt;T1&gt; ^ action1, System::Threading::Tasks::Dataflow::ISourceBlock&lt;T2&gt; ^ source2, Action&lt;T2&gt; ^ action2, System::Threading::Tasks::Dataflow::DataflowBlockOptions ^ dataflowBlockOptions);" />
      <MemberSignature Language="F#" Value="static member Choose : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T1&gt; * Action&lt;'T1&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T2&gt; * Action&lt;'T2&gt; * System.Threading.Tasks.Dataflow.DataflowBlockOptions -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Choose (source1, action1, source2, action2, dataflowBlockOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt;" />
        <Parameter Name="action1" Type="System.Action&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt;" />
        <Parameter Name="action2" Type="System.Action&lt;T2&gt;" />
        <Parameter Name="dataflowBlockOptions" Type="System.Threading.Tasks.Dataflow.DataflowBlockOptions" />
      </Parameters>
      <Docs>
        <typeparam name="T1">Gibt den Typ der Daten an, die in der ersten Quelle enthalten sind.</typeparam>
        <typeparam name="T2">Gibt den Typ der Daten an, die in der zweiten Quelle enthalten sind.</typeparam>
        <param name="source1">Die erste Quelle.</param>
        <param name="action1">Der Handler zu Ausführen von Daten aus der ersten Quelle.</param>
        <param name="source2">Die zweite Quelle.</param>
        <param name="action2">Der Handler zu Ausführen von Daten aus der zweiten Quelle.</param>
        <param name="dataflowBlockOptions">Die Optionen, mit denen diese Wahl zu konfigurieren ist.</param>
        <summary>Überwacht zwei Datenflussquellen, wobei der angegebene Handler für eine beliebige Quelle aufgerufen wird, die Daten zuerst verfügbar macht.</summary>
        <returns>Eine <see cref="T:System.Threading.Tasks.Task`1" />, die die asynchrone Auswahl darstellt. Wenn alle Quellen vor dem Abschließen der Auswahl abgeschlossen werden oder wenn <see cref="T:System.Threading.CancellationToken" />, das als Teil von <paramref name="dataflowBlockOptions" /> bereitgestellt wird, vor dem Abschließen der Auswahl abgebrochen wird, wird die resultierende Aufgabe abgebrochen. Wenn eine der Datenquellen verfügbare Daten hat und erfolgreich an die Auswahl weitergibt, wird die resultierende Aufgabe abgeschlossen, wenn der Handler abgeschlossen wird. Wenn der Handler eine Ausnahme auslöst, endet die Aufgabe im Zustand <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> und enthält den Ausnahmefehler. Andernfalls wird die Aufgabe mit dem <see cref="P:System.Threading.Tasks.Task`1.Result" /> beendet, das entweder auf 0 oder 1 festgelegt ist, um jeweils die erste oder zweite Quelle darzustellen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> ist <see langword="null" />.  
  
- oder -  
<paramref name="action1" /> ist <see langword="null" />.  
  
- oder -  
<paramref name="source2" /> ist <see langword="null" />.  
  
- oder -  
<paramref name="action2" /> ist <see langword="null" />.  
  
- oder -  
<paramref name="dataflowBlockOptions" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Choose&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;int&gt; Choose&lt;T1,T2,T3&gt; (System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt; source1, Action&lt;T1&gt; action1, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt; source2, Action&lt;T2&gt; action2, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T3&gt; source3, Action&lt;T3&gt; action3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;int32&gt; Choose&lt;T1, T2, T3&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T1&gt; source1, class System.Action`1&lt;!!T1&gt; action1, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T2&gt; source2, class System.Action`1&lt;!!T2&gt; action2, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T3&gt; source3, class System.Action`1&lt;!!T3&gt; action3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Choose``3(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Action{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1},System.Action{``1},System.Threading.Tasks.Dataflow.ISourceBlock{``2},System.Action{``2})" />
      <MemberSignature Language="VB.NET" Value="Public Function Choose(Of T1, T2, T3) (source1 As ISourceBlock(Of T1), action1 As Action(Of T1), source2 As ISourceBlock(Of T2), action2 As Action(Of T2), source3 As ISourceBlock(Of T3), action3 As Action(Of T3)) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2, typename T3&gt;&#xA; static System::Threading::Tasks::Task&lt;int&gt; ^ Choose(System::Threading::Tasks::Dataflow::ISourceBlock&lt;T1&gt; ^ source1, Action&lt;T1&gt; ^ action1, System::Threading::Tasks::Dataflow::ISourceBlock&lt;T2&gt; ^ source2, Action&lt;T2&gt; ^ action2, System::Threading::Tasks::Dataflow::ISourceBlock&lt;T3&gt; ^ source3, Action&lt;T3&gt; ^ action3);" />
      <MemberSignature Language="F#" Value="static member Choose : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T1&gt; * Action&lt;'T1&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T2&gt; * Action&lt;'T2&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T3&gt; * Action&lt;'T3&gt; -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Choose (source1, action1, source2, action2, source3, action3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt;" />
        <Parameter Name="action1" Type="System.Action&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt;" />
        <Parameter Name="action2" Type="System.Action&lt;T2&gt;" />
        <Parameter Name="source3" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T3&gt;" />
        <Parameter Name="action3" Type="System.Action&lt;T3&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">Gibt den Typ der Daten an, die in der ersten Quelle enthalten sind.</typeparam>
        <typeparam name="T2">Gibt den Typ der Daten an, die in der zweiten Quelle enthalten sind.</typeparam>
        <typeparam name="T3">Gibt den Datentyp an, der in der dritten Quelle enthalten ist.</typeparam>
        <param name="source1">Die erste Quelle.</param>
        <param name="action1">Der Handler zu Ausführen von Daten aus der ersten Quelle.</param>
        <param name="source2">Die zweite Quelle.</param>
        <param name="action2">Der Handler zu Ausführen von Daten aus der zweiten Quelle.</param>
        <param name="source3">Die dritte Quelle.</param>
        <param name="action3">Die Handler zu Ausführen von Daten aus der dritten Quelle.</param>
        <summary>Überwacht drei Datenflussquellen, wobei der angegebene Handler für eine beliebige Quelle aufgerufen wird, die Daten zuerst verfügbar macht.</summary>
        <returns>Eine <see cref="T:System.Threading.Tasks.Task`1" />, die die asynchrone Auswahl darstellt. Wenn alle Quellen vor dem Abschluss der Auswahl beendet werden, wird die resultierende Aufgabe abgebrochen. Wenn eine der Datenquellen verfügbare Daten hat und erfolgreich an die Auswahl weitergibt, wird die resultierende Aufgabe abgeschlossen, wenn der Handler abgeschlossen wird. Wenn der Handler eine Ausnahme auslöst, endet die Aufgabe im Zustand <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> und enthält den Ausnahmefehler. Andernfalls wird die Aufgabe mit dem <see cref="P:System.Threading.Tasks.Task`1.Result" /> beendet, das auf den 0-basierten Index der Quelle festgelegt ist.  
  
Diese Methode verwendet nur ein Element aus einer der Datenquellen, nie mehr als eine.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> ist <see langword="null" />.  
  
- oder -  
<paramref name="action1" /> ist <see langword="null" />.  
  
- oder -  
<paramref name="source2" /> ist <see langword="null" />.  
  
- oder -  
<paramref name="action2" /> ist <see langword="null" />.  
  
- oder -  
<paramref name="source3" /> ist <see langword="null" />.  
  
- oder -  
<paramref name="action3" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Choose&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;int&gt; Choose&lt;T1,T2,T3&gt; (System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt; source1, Action&lt;T1&gt; action1, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt; source2, Action&lt;T2&gt; action2, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T3&gt; source3, Action&lt;T3&gt; action3, System.Threading.Tasks.Dataflow.DataflowBlockOptions dataflowBlockOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;int32&gt; Choose&lt;T1, T2, T3&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T1&gt; source1, class System.Action`1&lt;!!T1&gt; action1, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T2&gt; source2, class System.Action`1&lt;!!T2&gt; action2, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!T3&gt; source3, class System.Action`1&lt;!!T3&gt; action3, class System.Threading.Tasks.Dataflow.DataflowBlockOptions dataflowBlockOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Choose``3(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Action{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1},System.Action{``1},System.Threading.Tasks.Dataflow.ISourceBlock{``2},System.Action{``2},System.Threading.Tasks.Dataflow.DataflowBlockOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T1, typename T2, typename T3&gt;&#xA; static System::Threading::Tasks::Task&lt;int&gt; ^ Choose(System::Threading::Tasks::Dataflow::ISourceBlock&lt;T1&gt; ^ source1, Action&lt;T1&gt; ^ action1, System::Threading::Tasks::Dataflow::ISourceBlock&lt;T2&gt; ^ source2, Action&lt;T2&gt; ^ action2, System::Threading::Tasks::Dataflow::ISourceBlock&lt;T3&gt; ^ source3, Action&lt;T3&gt; ^ action3, System::Threading::Tasks::Dataflow::DataflowBlockOptions ^ dataflowBlockOptions);" />
      <MemberSignature Language="F#" Value="static member Choose : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T1&gt; * Action&lt;'T1&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T2&gt; * Action&lt;'T2&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'T3&gt; * Action&lt;'T3&gt; * System.Threading.Tasks.Dataflow.DataflowBlockOptions -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Choose (source1, action1, source2, action2, source3, action3, dataflowBlockOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T1&gt;" />
        <Parameter Name="action1" Type="System.Action&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T2&gt;" />
        <Parameter Name="action2" Type="System.Action&lt;T2&gt;" />
        <Parameter Name="source3" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T3&gt;" />
        <Parameter Name="action3" Type="System.Action&lt;T3&gt;" />
        <Parameter Name="dataflowBlockOptions" Type="System.Threading.Tasks.Dataflow.DataflowBlockOptions" />
      </Parameters>
      <Docs>
        <typeparam name="T1">Gibt den Typ der Daten an, die in der ersten Quelle enthalten sind.</typeparam>
        <typeparam name="T2">Gibt den Typ der Daten an, die in der zweiten Quelle enthalten sind.</typeparam>
        <typeparam name="T3">Gibt den Datentyp an, der in der dritten Quelle enthalten ist.</typeparam>
        <param name="source1">Die erste Quelle.</param>
        <param name="action1">Der Handler zu Ausführen von Daten aus der ersten Quelle.</param>
        <param name="source2">Die zweite Quelle.</param>
        <param name="action2">Der Handler zu Ausführen von Daten aus der zweiten Quelle.</param>
        <param name="source3">Die dritte Quelle.</param>
        <param name="action3">Die Handler zu Ausführen von Daten aus der dritten Quelle.</param>
        <param name="dataflowBlockOptions">Die Optionen, mit denen diese Wahl zu konfigurieren ist.</param>
        <summary>Überwacht drei Datenflussquellen, wobei der angegebene Handler für eine beliebige Quelle aufgerufen wird, die Daten zuerst verfügbar macht.</summary>
        <returns>Eine <see cref="T:System.Threading.Tasks.Task`1" />, die die asynchrone Auswahl darstellt. Wenn alle Quellen vor dem Abschließen der Auswahl abgeschlossen werden oder wenn <see cref="T:System.Threading.CancellationToken" />, das als Teil von <paramref name="dataflowBlockOptions" /> bereitgestellt wird, vor dem Abschließen der AUswahl abgebrochen wird, wird die resultierende Aufgabe abgebrochen. Wenn eine der Datenquellen verfügbare Daten hat und erfolgreich an die Auswahl weitergibt, wird die resultierende Aufgabe abgeschlossen, wenn der Handler abgeschlossen wird. Wenn der Handler eine Ausnahme auslöst, endet die Aufgabe im Zustand <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> und enthält den Ausnahmefehler. Andernfalls wird die Aufgabe mit dem <see cref="P:System.Threading.Tasks.Task`1.Result" /> beendet, das auf den 0-basierten Index der Quelle festgelegt ist.  
  
Diese Methode verwendet nur ein Element aus einer der Datenquellen, nie mehr als eine. Wenn der Abbruch angefordert wird, nachdem ein Element empfangen wurde, wird die Abbruchanforderung ignoriert, und der entsprechende Handler ist zulässig.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> ist <see langword="null" />.  
  
- oder -  
<paramref name="action1" /> ist <see langword="null" />.  
  
- oder -  
<paramref name="source2" /> ist <see langword="null" />.  
  
- oder -  
<paramref name="action2" /> ist <see langword="null" />.  
  
- oder -  
<paramref name="source3" /> ist <see langword="null" />.  
  
- oder -  
<paramref name="action3" /> ist <see langword="null" />.  
  
- oder -  
<paramref name="dataflowBlockOptions" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Encapsulate&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Dataflow.IPropagatorBlock&lt;TInput,TOutput&gt; Encapsulate&lt;TInput,TOutput&gt; (System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt; target, System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Dataflow.IPropagatorBlock`2&lt;!!TInput, !!TOutput&gt; Encapsulate&lt;TInput, TOutput&gt;(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TInput&gt; target, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate``2(System.Threading.Tasks.Dataflow.ITargetBlock{``0},System.Threading.Tasks.Dataflow.ISourceBlock{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Function Encapsulate(Of TInput, TOutput) (target As ITargetBlock(Of TInput), source As ISourceBlock(Of TOutput)) As IPropagatorBlock(Of TInput, TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static System::Threading::Tasks::Dataflow::IPropagatorBlock&lt;TInput, TOutput&gt; ^ Encapsulate(System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt; ^ target, System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Encapsulate : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Input&gt; * System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; -&gt; System.Threading.Tasks.Dataflow.IPropagatorBlock&lt;'Input, 'Output&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate (target, source)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Dataflow.IPropagatorBlock&lt;TInput,TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;" />
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Gibt den Typ der Eingabe an, die vom Ziel erwartet wird.</typeparam>
        <typeparam name="TOutput">Gibt den Typ der Ausgabe an, die von der Quelle erzeugt wurde.</typeparam>
        <param name="target">Das zu kapselnde Ziel</param>
        <param name="source">Die zu kapselnde Quelle.</param>
        <summary>Kapselt ein Ziel und eine Quelle in eine einzelne Propagierung.</summary>
        <returns>Die gekapselte Quelle und Ziel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> Methode erfordert zwei vorhandene Blöcke: ein Zielblock (eine Instanz einer Klasse, die implementiert <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>) und ein Quellblock (eine Instanz einer Klasse, die implementiert <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>). <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> erstellt eine neue Instanz einer internen Klasse, die eine Verbindung herstellt der <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> Schnittstellenmember, die `target` Parameter und die <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> Schnittstellenmember, die `source` Parameter.  Beide <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> und <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> abgeleitet <xref:System.Threading.Tasks.Dataflow.IDataflowBlock>. Block-Abschluss wird explizit von Quellen an Ziele übergeben. Aus diesem Grund die <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> und <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Fault%2A> Methoden verbunden sind, an das Ziel bei der <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> Eigenschaft mit der Datenquelle verbunden ist.  Sie müssen sicherstellen, dass beim Ziel Hälfte abgeschlossen ist, die Hälfte abgeschlossen Ruft ab, auf die am besten geeignete Weise; Quelle Zum Beispiel:  
  
 `target.Completion.ContinueWith(completion => source.Complete());`  
  
 Oder, wenn es sich bei abschlusstyps weitergegeben werden sollen, können Sie diesen höher entwickelten Code verwenden:  
  
```  
target.Completion.ContinueWith(completion => { if (completion.IsFaulted)    
  
((IDataflowBlock)batchBlock).Fault(completion.Exception);   
else   
batchBlock.Complete();   
});  
  
```  
  
 Sie müssen die Nachrichtenweitergabe vom Ziel mit Quelle auch explizit angeben. Der Vorteil dieser explizite Verbindung ist, dass Sie die Freiheit gibt, die alle zwischen den beiden Blöcken des gekapselten uneingeschränkte Verarbeitungsschritte erhalten. Sie können dies tun, indem Sie die erforderliche Verarbeitung in die Blöcke Delegaten (wenn die Blöcke Delegaten in Anspruch nehmen) Codierung oder durch die Einbettung eine Subnetzwerk Blöcke zwischen ihnen. Die einfachste Methode ist die Verwendung ein Blocks, das Delegaten akzeptiert; Verwenden Sie z. B. <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> (falls zutreffend), oder einen benutzerdefinierten Block.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LinkTo&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static IDisposable LinkTo&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt; target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IDisposable LinkTo&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TOutput&gt; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.Tasks.Dataflow.ITargetBlock{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LinkTo(Of TOutput) (source As ISourceBlock(Of TOutput), target As ITargetBlock(Of TOutput)) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static IDisposable ^ LinkTo(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, System::Threading::Tasks::Dataflow::ITargetBlock&lt;TOutput&gt; ^ target);" />
      <MemberSignature Language="F#" Value="static member LinkTo : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Output&gt; -&gt; IDisposable" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo (source, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Gibt den Datentyp an, der in der Quelle enthalten ist.</typeparam>
        <param name="source">Die zu verknüpfende Quelle.</param>
        <param name="target">Der <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, an den die Quelle verbunden werden soll.</param>
        <summary>Verbindet <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> mit dem angegebenen <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />-Objekt.</summary>
        <returns>Ein <see cref="T:System.IDisposable" />, der nach dem Aufrufen von <see langword="Dispose" />, die Quelle vom Ziel löst.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.  
  
- oder -  
<paramref name="target" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LinkTo&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static IDisposable LinkTo&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt; target, Predicate&lt;TOutput&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IDisposable LinkTo&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TOutput&gt; target, class System.Predicate`1&lt;!!TOutput&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.Tasks.Dataflow.ITargetBlock{``0},System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LinkTo(Of TOutput) (source As ISourceBlock(Of TOutput), target As ITargetBlock(Of TOutput), predicate As Predicate(Of TOutput)) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static IDisposable ^ LinkTo(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, System::Threading::Tasks::Dataflow::ITargetBlock&lt;TOutput&gt; ^ target, Predicate&lt;TOutput&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LinkTo : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Output&gt; * Predicate&lt;'Output&gt; -&gt; IDisposable" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo (source, target, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt;" />
        <Parameter Name="predicate" Type="System.Predicate&lt;TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Gibt den Datentyp an, der in der Quelle enthalten ist.</typeparam>
        <param name="source">Die zu verknüpfende Quelle.</param>
        <param name="target"><see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, an den die Quelle gebunden werden soll.</param>
        <param name="predicate">Der Filter, den eine Meldung übergeben muss, damit er von der Quelle an das Ziel weitergegeben wird.</param>
        <summary>Verknüpft <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> mit der angegebenen <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />-Objekt mithilfe des angegebenen Filters.</summary>
        <returns>Ein <see cref="T:System.IDisposable" />, der nach dem Aufrufen von <see langword="Dispose" />, die Quelle vom Ziel löst.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.  
  
- oder -  
<paramref name="target" /> ist <see langword="null" />.  
  
- oder -  
<paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LinkTo&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static IDisposable LinkTo&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt; target, System.Threading.Tasks.Dataflow.DataflowLinkOptions linkOptions, Predicate&lt;TOutput&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IDisposable LinkTo&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TOutput&gt; target, class System.Threading.Tasks.Dataflow.DataflowLinkOptions linkOptions, class System.Predicate`1&lt;!!TOutput&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.Tasks.Dataflow.ITargetBlock{``0},System.Threading.Tasks.Dataflow.DataflowLinkOptions,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LinkTo(Of TOutput) (source As ISourceBlock(Of TOutput), target As ITargetBlock(Of TOutput), linkOptions As DataflowLinkOptions, predicate As Predicate(Of TOutput)) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static IDisposable ^ LinkTo(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, System::Threading::Tasks::Dataflow::ITargetBlock&lt;TOutput&gt; ^ target, System::Threading::Tasks::Dataflow::DataflowLinkOptions ^ linkOptions, Predicate&lt;TOutput&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LinkTo : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Output&gt; * System.Threading.Tasks.Dataflow.DataflowLinkOptions * Predicate&lt;'Output&gt; -&gt; IDisposable" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.LinkTo (source, target, linkOptions, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TOutput&gt;" />
        <Parameter Name="linkOptions" Type="System.Threading.Tasks.Dataflow.DataflowLinkOptions" />
        <Parameter Name="predicate" Type="System.Predicate&lt;TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Gibt den Datentyp an, der in der Quelle enthalten ist.</typeparam>
        <param name="source">Die zu verknüpfende Quelle.</param>
        <param name="target"><see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, an den die Quelle gebunden werden soll.</param>
        <param name="linkOptions">Einer der Enumerationswerte, der angibt, wie ein Link zwischen Datenflussblöcken konfiguriert werden kann.</param>
        <param name="predicate">Der Filter, den eine Meldung übergeben muss, damit er von der Quelle an das Ziel weitergegeben wird.</param>
        <summary>Verknüpft <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> mit der angegebenen <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />-Objekt mithilfe des angegebenen Filters.</summary>
        <returns>Ein <see cref="T:System.IDisposable" />, der nach dem Aufrufen von <see langword="Dispose" />, die Quelle vom Ziel löst.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist null (Nothing in Visual Basic).  
  
- oder -  
<paramref name="target" /> ist null (Nothing in Visual Basic).  
  
- oder -  
<paramref name="linkOptions" /> ist null (Nothing in Visual Basic).  
  
- oder -  
<paramref name="predicate" /> ist null (Nothing in Visual Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="NullTarget&lt;TInput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt; NullTarget&lt;TInput&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TInput&gt; NullTarget&lt;TInput&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.NullTarget``1" />
      <MemberSignature Language="VB.NET" Value="Public Function NullTarget(Of TInput) () As ITargetBlock(Of TInput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput&gt;&#xA; static System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt; ^ NullTarget();" />
      <MemberSignature Language="F#" Value="static member NullTarget : unit -&gt; System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Input&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.NullTarget " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TInput">Der Typ der Nachrichten, die dieser Block annehmen kann.</typeparam>
        <summary>Ruft ab einen Zielblock ab, der alle Meldungen synchron akzeptiert, die für ihn bereitgestellt werden, und diese dann ablegt.</summary>
        <returns>Ein <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, die alle angebotenen Nachrichten akzeptiert und anschließend ablegt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputAvailableAsync&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; OutputAvailableAsync&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; OutputAvailableAsync&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.OutputAvailableAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OutputAvailableAsync(Of TOutput) (source As ISourceBlock(Of TOutput)) As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;bool&gt; ^ OutputAvailableAsync(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member OutputAvailableAsync : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.OutputAvailableAsync source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Gibt den Datentyp an, der in der Quelle enthalten ist.</typeparam>
        <param name="source">Die zu überwachende Quelle.</param>
        <summary>Stellt eine <see cref="T:System.Threading.Tasks.Task`1" /> bereit, die asynchron die Quelle für verfügbare Ausgabe überwacht.</summary>
        <returns>Ein <see cref="T:System.Threading.Tasks.Task`1" />, das darüber informiert, ob und wann mehr Ausgaben zur Verfügung steht. Wenn bei Beenden der Aufgabe <see cref="P:System.Threading.Tasks.Task`1.Result" /> gleich <see langword="true" /> ist, sind in der Quelle mehr Ausgabedaten verfügbar (obwohl ein anderer Consumer der Quelle möglicherweise die Daten abruft).  
  
Wenn sie <see langword="false" /> zurückgibt, ist und wird wird niemals mehr Output verfügbar sein, da die Quelle vor der Ausgabe abgeschlossen wird, bevor der Output verfügbar ist.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputAvailableAsync&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; OutputAvailableAsync&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; OutputAvailableAsync&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.OutputAvailableAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;bool&gt; ^ OutputAvailableAsync(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member OutputAvailableAsync : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.OutputAvailableAsync (source, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Gibt den Datentyp an, der in der Quelle enthalten ist.</typeparam>
        <param name="source">Die zu überwachende Quelle.</param>
        <param name="cancellationToken">Das Abbruchtoken, um den asynchronen Vorgang abzubrechen.</param>
        <summary>Stellt ein <see cref="T:System.Threading.Tasks.Task`1" />-Objekt bereit, das asynchron die Quelle für eine verfügbare Ausgabe überwacht.</summary>
        <returns>Ein <see cref="T:System.Threading.Tasks.Task`1" />, das darüber informiert, ob und wann mehr Ausgaben zur Verfügung steht. Wenn bei Beenden der Aufgabe <see cref="P:System.Threading.Tasks.Task`1.Result" /> gleich <see langword="true" /> ist, sind in der Quelle mehr Ausgabedaten verfügbar (obwohl ein anderer Consumer der Quelle möglicherweise die Daten abruft). Wenn sie <see langword="false" /> zurückgibt, ist und wird wird niemals mehr Output verfügbar sein, da die Quelle vor der Ausgabe abgeschlossen wird, bevor der Output verfügbar ist.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Post&lt;TInput&gt;">
      <MemberSignature Language="C#" Value="public static bool Post&lt;TInput&gt; (this System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt; target, TInput item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Post&lt;TInput&gt;(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TInput&gt; target, !!TInput item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Post``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Post(Of TInput) (target As ITargetBlock(Of TInput), item As TInput) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Post(System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt; ^ target, TInput item);" />
      <MemberSignature Language="F#" Value="static member Post : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Input&gt; * 'Input -&gt; bool" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Post (target, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;" RefType="this" />
        <Parameter Name="item" Type="TInput" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Gibt den Typ der Daten an, die vom Zielblock akzeptiert werden.</typeparam>
        <param name="target">Zielblock</param>
        <param name="item">Das Element, das dem Ziel bereitgestellt wird.</param>
        <summary>Fügt dem <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> ein Element hinzu.</summary>
        <returns><see langword="true" />, wenn das Element vom Zielblock angenommen wurde; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt zurück, wenn der Zielblock hat entschieden, zum annehmen oder Ablehnen des Elements, aber es sei denn, die andernfalls durch die spezielle Semantik der Zielblock wird festgelegt, es wartet nicht auf das Element, das tatsächlich verarbeitet werden. Z. B. <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> zurück <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> , sobald sie das bereitgestellte Element in der Eingabewarteschlange gespeichert hat). Aus der Perspektive der Verarbeitung des Blocks `Post` ist asynchron. Zielblöcke, Unterstützung angeboten von Nachrichten zurück, oder für die Blöcke, die weitere Verarbeitung ausführen können, in deren `Post` -Implementierung in Betracht <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A>, die sofort zurück und ermöglicht das Ziel, die gesendete Nachricht verschieben und höher nutzen ihn nach dem `SendAsync` zurückgibt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput Receive&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput Receive&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Receive``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Receive(Of TOutput) (source As ISourceBlock(Of TOutput)) As TOutput" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TOutput Receive(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Receive : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; -&gt; 'Output" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Receive source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Der Datentyp, der in der Datenquelle enthalten ist.</typeparam>
        <param name="source">Die Quelle, aus der der Wert empfangen werden soll.</param>
        <summary>Empfängt synchron einen Wert aus der angegebenen Quelle.</summary>
        <returns>Der empfangene Wert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Kein Element konnte von der Quelle empfangen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput Receive&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput Receive&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Receive``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TOutput Receive(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Receive : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * System.Threading.CancellationToken -&gt; 'Output" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Receive (source, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Der Datentyp, der in der Datenquelle enthalten ist.</typeparam>
        <param name="source">Die Quelle, aus der der Wert empfangen werden soll.</param>
        <param name="cancellationToken">Das Token, das verwendet wird, um den Empfangsvorgang abzubrechen.</param>
        <summary>Erhält synchron einen Wert aus einer angegebenen Quelle und stellt ein Token bereit, um die Operation abzubrechen.</summary>
        <returns>Der empfangene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Quelle wurde erfolgreich ein Element, die durch diesen Vorgang empfangen wurde angeboten, wird dieses Element zurückgegeben, auch bei gleichzeitiger abbruchanforderungen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Kein Element konnte von der Quelle empfangen werden.</exception>
        <exception cref="T:System.OperationCanceledException">Der Vorgang wurde abgebrochen, bevor ein Element aus der Quelle empfangen wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput Receive&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput Receive&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Receive``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Receive(Of TOutput) (source As ISourceBlock(Of TOutput), timeout As TimeSpan) As TOutput" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TOutput Receive(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Receive : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * TimeSpan -&gt; 'Output" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Receive (source, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Der Datentyp, der in der Datenquelle enthalten ist.</typeparam>
        <param name="source">Die Quelle, aus der der Wert empfangen werden soll.</param>
        <param name="timeout">Das maximale Zeitintervall, in Millisekunden, der gewartet werden muss, bis der synchrone Vorgang abgeschlossen wurde, oder auf ein Intervall, der -1 Millisekunden darstellt, um unbegrenzt zu warten.</param>
        <summary>Empfängt synchron einen Wert aus einer angegebenen Quelle und beachtet ein optionales Timeout.</summary>
        <returns>Der empfangene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Quelle wurde erfolgreich ein Element, die durch diesen Vorgang empfangen wurde angeboten, wird dieses Element zurückgegeben, auch wenn ein gleichzeitiger Timeout auftritt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> ist eine negative Zahl, aber nicht -1 Millisekunde. Ein Wert von -1 Millisekunde gibt eine Endlostimeoutperiode an.  
  
- oder -  
 <paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Kein Element konnte von der Quelle empfangen werden.</exception>
        <exception cref="T:System.TimeoutException">Das angegebene Timeout ist abgelaufen, bevor ein Element von der Quelle empfangen wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput Receive&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput Receive&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.Receive``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TOutput Receive(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, TimeSpan timeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Receive : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * TimeSpan * System.Threading.CancellationToken -&gt; 'Output" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.Receive (source, timeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Der Datentyp, der in der Datenquelle enthalten ist.</typeparam>
        <param name="source">Die Quelle, aus der der Wert empfangen werden soll.</param>
        <param name="timeout">Das maximale Zeitintervall, in Millisekunden, der gewartet werden muss, bis der synchrone Vorgang abgeschlossen wurde, oder auf ein Intervall, der -1 Millisekunden darstellt, um unbegrenzt zu warten.</param>
        <param name="cancellationToken">Das Token, das verwendet wird, um den Empfangsvorgang abzubrechen.</param>
        <summary>Empfängt synchron einen Wert aus einer angegebenen Quelle, stellt ein Token bereit, um den Vorgang abzubrechen und beachtet ein optionales Timeoutintervall.</summary>
        <returns>Der empfangene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Quelle wurde erfolgreich ein Elementwert, die durch diesen Vorgang empfangen wurde angeboten, wird dieser Wert zurückgegeben, auch bei eine gleichzeitige Timeout oder Abbruch der Anforderung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> ist eine negative Zahl, aber nicht -1 Millisekunde. Ein Wert von -1 Millisekunde gibt eine Endlostimeoutperiode an.  
  
- oder -  
 <paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.InvalidOperationException">Kein Element konnte von der Quelle empfangen werden.</exception>
        <exception cref="T:System.TimeoutException">Das angegebene Timeout ist abgelaufen, bevor ein Element von der Quelle empfangen wurde.</exception>
        <exception cref="T:System.OperationCanceledException">Der Vorgang wurde abgebrochen, bevor ein Element aus der Quelle empfangen wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TOutput&gt; ReceiveAsync&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TOutput&gt; ReceiveAsync&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReceiveAsync(Of TOutput) (source As ISourceBlock(Of TOutput)) As Task(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;TOutput&gt; ^ ReceiveAsync(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member ReceiveAsync : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; -&gt; System.Threading.Tasks.Task&lt;'Output&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Der Datentyp, der in der Datenquelle enthalten ist.</typeparam>
        <param name="source">Die Quelle, aus der der Wert empfangen werden soll.</param>
        <summary>Empfängt asynchron einen Wert aus der angegebenen Quelle.</summary>
        <returns>Eine Aufgabe, die den asynchronen Empfangsvorgang darstellt. Wenn ein Elementwert erfolgreich aus der Quelle empfangen wird, wird die zurückgegebene Aufgabe abgeschlossen, und ihr <see cref="P:System.Threading.Tasks.Task`1.Result" /> gibt den empfangene Elementwert zurück. Wenn ein Elementwert nicht abgerufen werden kann, weil die Quelle leer ist und abgeschlossen wurde, wird eine <see cref="T:System.InvalidOperationException" />-Ausnahme in der zurückgegebenen Aufgabe ausgelöst.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TOutput&gt; ReceiveAsync&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TOutput&gt; ReceiveAsync&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;TOutput&gt; ^ ReceiveAsync(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member ReceiveAsync : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Output&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync (source, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Gibt den Datentyp an, der in der Quelle enthalten ist.</typeparam>
        <param name="source">Die Quelle, aus der der Wert empfangen werden soll.</param>
        <param name="cancellationToken">Das Token, das verwendet wird, um den Empfangsvorgang abzubrechen.</param>
        <summary>Erhält asynchron einen Wert aus einer angegebenen Quelle und stellt ein Token bereit, um die Operation abzubrechen.</summary>
        <returns>Eine Aufgabe, die den asynchronen Empfangsvorgang darstellt. Wenn ein Wert erfolgreich aus der Quelle empfangen wird, wird die zurückgegebene Aufgabe fertig gestellt und ihr <see cref="P:System.Threading.Tasks.Task`1.Result" /> gibt den Wert zurück. Wenn ein Wert nicht abgerufen werden kann, da ein Abbruch angefordert wurde, wird die zurückgegebene Aufgabe abgebrochen. Wenn der Wert nicht abgerufen werden kann, weil die Quelle leer ist und abgeschlossen wurde, wird eine <see cref="T:System.InvalidOperationException" />-Ausnahme in der zurückgegebene Aufgabe ausgelöst.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TOutput&gt; ReceiveAsync&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TOutput&gt; ReceiveAsync&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ReceiveAsync(Of TOutput) (source As ISourceBlock(Of TOutput), timeout As TimeSpan) As Task(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;TOutput&gt; ^ ReceiveAsync(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member ReceiveAsync : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * TimeSpan -&gt; System.Threading.Tasks.Task&lt;'Output&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync (source, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Der Datentyp, der in der Datenquelle enthalten ist.</typeparam>
        <param name="source">Die Quelle, aus der der Wert empfangen werden soll.</param>
        <param name="timeout">Das maximale Zeitintervall, in Millisekunden, der gewartet werden muss, bis der synchrone Vorgang abgeschlossen wurde, oder auf ein Intervall, der -1 Millisekunden darstellt, um unbegrenzt zu warten.</param>
        <summary>Empfängt asynchron einen Wert aus einer angegebenen Quelle und beachtet ein optionales Timeout.</summary>
        <returns>Eine Aufgabe, die den asynchronen Empfangsvorgang darstellt. Wenn ein Wert erfolgreich aus der Quelle empfangen wird, wird die zurückgegebene Aufgabe fertig gestellt und ihr <see cref="P:System.Threading.Tasks.Task`1.Result" /> gibt den Wert zurück. Wenn ein Wert nicht abgerufen werden kann, da das Timeout abgelaufen ist, wird die zurückgegebene Aufgabe abgebrochen. Wenn der Wert nicht abgerufen werden kann, weil die Quelle leer ist und abgeschlossen wurde, wird eine <see cref="T:System.InvalidOperationException" />-Ausnahme in der zurückgegebene Aufgabe ausgelöst.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> ist eine negative Zahl, aber nicht -1 Millisekunde. Ein Wert von -1 Millisekunde gibt eine Endlostimeoutperiode an.  
  
- oder -  
 <paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TOutput&gt; ReceiveAsync&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt; source, TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TOutput&gt; ReceiveAsync&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!!TOutput&gt; source, valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync``1(System.Threading.Tasks.Dataflow.ISourceBlock{``0},System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;TOutput&gt; ^ ReceiveAsync(System::Threading::Tasks::Dataflow::ISourceBlock&lt;TOutput&gt; ^ source, TimeSpan timeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member ReceiveAsync : System.Threading.Tasks.Dataflow.ISourceBlock&lt;'Output&gt; * TimeSpan * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Output&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync (source, timeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Der Datentyp, der in der Datenquelle enthalten ist.</typeparam>
        <param name="source">Die Quelle, aus der der Wert empfangen werden soll.</param>
        <param name="timeout">Das maximale Zeitintervall, in Millisekunden, der gewartet werden muss, bis der synchrone Vorgang abgeschlossen wurde, oder auf ein Intervall, der -1 Millisekunden darstellt, um unbegrenzt zu warten.</param>
        <param name="cancellationToken">Das Token, das verwendet wird, um den Empfangsvorgang abzubrechen.</param>
        <summary>Empfängt asynchron einen Wert aus einer angegebenen Quelle, stellt ein Token bereit, um den Vorgang abzubrechen und beachtet ein optionales Timeoutintervall.</summary>
        <returns>Eine Aufgabe, die den asynchronen Empfangsvorgang darstellt. Wenn ein Wert erfolgreich aus der Quelle empfangen wird, wird die zurückgegebene Aufgabe fertig gestellt und ihr <see cref="P:System.Threading.Tasks.Task`1.Result" /> gibt den Wert zurück. Wenn ein Wert nicht abgerufen werden kann, da das Timeout abgelaufen ist oder der Abbruch angefordert wurden, wird die zurückgegebene Aufgabe abgebrochen. Wenn der Wert nicht abgerufen werden kann, weil die Quelle leer und abgeschlossen wurde, wird eine <see cref="T:System.InvalidOperationException" /> Ausnahme in der zurückgegebene Aufgabe ausgelöst.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> ist eine negative Zahl, aber nicht -1 Millisekunde. Ein Wert von -1 Millisekunde gibt eine Endlostimeoutperiode an.  
  
- oder -  
 <paramref name="timeout" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsync&lt;TInput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; SendAsync&lt;TInput&gt; (this System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt; target, TInput item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; SendAsync&lt;TInput&gt;(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TInput&gt; target, !!TInput item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SendAsync(Of TInput) (target As ITargetBlock(Of TInput), item As TInput) As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;bool&gt; ^ SendAsync(System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt; ^ target, TInput item);" />
      <MemberSignature Language="F#" Value="static member SendAsync : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Input&gt; * 'Input -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync (target, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;" RefType="this" />
        <Parameter Name="item" Type="TInput" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Gibt den Typ der Daten an, die an das Ziel gesendet werden sollen.</typeparam>
        <param name="target">Das Ziel, an das die Daten übermittelt werden sollen.</param>
        <param name="item">Das Element, das dem Ziel bereitgestellt wird.</param>
        <summary>Gewährt dem Zielmeldungsblock asynchron eine Meldung an und ermöglicht einen Aufschub.</summary>
        <returns>Ein <see cref="T:System.Threading.Tasks.Task`1" />-Element, das den asynchronen Sendevorgangs darstellt. Wenn das Ziel das angebotene Element während des Aufrufs von <see cref="M:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0},``0)" /> akzeptiert und nutzt, wird bei Rückgabe aus dem Aufruf das resultierende <see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen, und die <see cref="P:System.Threading.Tasks.Task`1.Result" />-Eigenschaft gibt <see langword="true" /> zurück. Wenn das Ziel das angebotene Element während des Aufrufs ablehnt, wird bei Rückgabe aus dem Aufruf das resultierende <see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen, und die <see cref="P:System.Threading.Tasks.Task`1.Result" />-Eigenschaft gibt <see langword="false" /> zurück. Wenn das Ziel das angebotene Element aufschiebt, wird das Element im Puffer gespeichert, bis es vom Ziel verwendet oder freigegeben wird. Zu diesem Punkt wird die Aufgabe ausgeführt, wobei <see cref="P:System.Threading.Tasks.Task`1.Result" /> angibt, ob die Meldung verarbeitet wurde. Wenn das Ziel nie versucht, die Nachricht zu verarbeiten oder herauszugeben, wird die zurückgegebene Aufgabe nie abgeschlossen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsync&lt;TInput&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;bool&gt; SendAsync&lt;TInput&gt; (this System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt; target, TInput item, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;bool&gt; SendAsync&lt;TInput&gt;(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!!TInput&gt; target, !!TInput item, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync``1(System.Threading.Tasks.Dataflow.ITargetBlock{``0},``0,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Threading::Tasks::Task&lt;bool&gt; ^ SendAsync(System::Threading::Tasks::Dataflow::ITargetBlock&lt;TInput&gt; ^ target, TInput item, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member SendAsync : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'Input&gt; * 'Input * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync (target, item, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;TInput&gt;" RefType="this" />
        <Parameter Name="item" Type="TInput" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Gibt den Typ der Daten an, die an das Ziel gesendet werden sollen.</typeparam>
        <param name="target">Das Ziel, an das die Daten übermittelt werden sollen.</param>
        <param name="item">Das Element, das dem Ziel bereitgestellt wird.</param>
        <param name="cancellationToken">Das Abbruchtoken, um den Abbruch des Sendevorgangs anzufordern.</param>
        <summary>Gewährt dem Zielmeldungsblock asynchron eine Meldung an und ermöglicht einen Aufschub.</summary>
        <returns>Ein <see cref="T:System.Threading.Tasks.Task`1" />-Element, das den asynchronen Sendevorgangs darstellt.  Wenn das Ziel das angebotene Element während des Aufrufs von SendAsync akzeptiert und verarbeitet, wird bei Rückgabe aus dem Aufruf das resultierende <see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen, und die <c>Result</c>-Eigenschaft gibt TRUE zurück.  Wenn das Ziel das angebotene Element während des Aufrufs ablehnt, wird bei Rückgabe aus dem Aufruf das resultierende <see cref="T:System.Threading.Tasks.Task`1" /> abgeschlossen, und die <c>Result</c>-Eigenschaft gibt FALSE zurück. Wenn das Ziel das angebotene Element aufschiebt, wird das Element im Puffer gespeichert, bis es vom Ziel verwendet oder freigegeben wird. Dann wird die Aufgabe ausgeführt, wobei <c>Result</c> angibt, ob die Meldung verarbeitet wurde. Wenn das Ziel nie versucht, die Nachricht zu verarbeiten oder herauszugeben, wird die zurückgegebene Aufgabe nie abgeschlossen.  
  
Wenn der Abbruch angefordert wird, bevor das Ziel erfolgreich die gesendeten Daten verarbeitet hat, wird die zurückgegebene Aufgabe im abgebrochenen Zustand abgeschlossen, und die Daten sind nicht mehr für das Ziel verfügbar.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> ist null (Nothing in Visual Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="TryReceive&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public static bool TryReceive&lt;TOutput&gt; (this System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;TOutput&gt; source, out TOutput item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReceive&lt;TOutput&gt;(class System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&lt;!!TOutput&gt; source, [out] !!TOutput&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive``1(System.Threading.Tasks.Dataflow.IReceivableSourceBlock{``0},``0@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TryReceive(Of TOutput) (source As IReceivableSourceBlock(Of TOutput), ByRef item As TOutput) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryReceive(System::Threading::Tasks::Dataflow::IReceivableSourceBlock&lt;TOutput&gt; ^ source, [Runtime::InteropServices::Out] TOutput % item);" />
      <MemberSignature Language="F#" Value="static member TryReceive : System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;'Output&gt; *  -&gt; bool" Usage="System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive (source, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;TOutput&gt;" RefType="this" />
        <Parameter Name="item" Type="TOutput" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Gibt den Datentyp an, der in der Quelle enthalten ist.</typeparam>
        <param name="source">Die Quelle, aus der empfangen werden soll.</param>
        <param name="item">Das von der Quelle empfangene Element.</param>
        <summary>Versucht, ein Element von <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> synchron zu empfangen.</summary>
        <returns><see langword="true" />, wenn ein Element empfangen werden konnte; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wartet nicht, bis die Quelle ein Elements zu bieten hat.  
  
 Es wird zurückgegeben, und zwar unabhängig davon, ob ein Element verfügbar war.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>