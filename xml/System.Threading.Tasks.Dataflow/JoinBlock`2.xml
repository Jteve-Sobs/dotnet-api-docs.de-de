<Type Name="JoinBlock&lt;T1,T2&gt;" FullName="System.Threading.Tasks.Dataflow.JoinBlock&lt;T1,T2&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a6f8d35b67774086284d1ea8f9078b3490072a83" />
    <Meta Name="ms.sourcegitcommit" Value="723b8a6d92667ba86fcda96190bad3b4a03283b3" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/09/2018" />
    <Meta Name="ms.locfileid" Value="51303269" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class JoinBlock&lt;T1,T2&gt; : System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;Tuple&lt;T1,T2&gt;&gt;, System.Threading.Tasks.Dataflow.ISourceBlock&lt;Tuple&lt;T1,T2&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit JoinBlock`2&lt;T1, T2&gt; extends System.Object implements class System.Threading.Tasks.Dataflow.IDataflowBlock, class System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&lt;class System.Tuple`2&lt;!T1, !T2&gt;&gt;, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;class System.Tuple`2&lt;!T1, !T2&gt;&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Dataflow.JoinBlock`2" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class JoinBlock(Of T1, T2)&#xA;Implements IReceivableSourceBlock(Of Tuple(Of T1, T2)), ISourceBlock(Of Tuple(Of T1, T2))" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T1, typename T2&gt;&#xA;public ref class JoinBlock sealed : System::Threading::Tasks::Dataflow::IReceivableSourceBlock&lt;Tuple&lt;T1, T2&gt; ^&gt;, System::Threading::Tasks::Dataflow::ISourceBlock&lt;Tuple&lt;T1, T2&gt; ^&gt;" />
  <TypeSignature Language="F#" Value="type JoinBlock&lt;'T1, 'T2&gt; = class&#xA;    interface IDataflowBlock&#xA;    interface IReceivableSourceBlock&lt;'T1 * 'T2&gt;&#xA;    interface ISourceBlock&lt;'T1 * 'T2&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
    <AssemblyVersion>4.6.0.0</AssemblyVersion>
    <AssemblyVersion>4.6.1.0</AssemblyVersion>
    <AssemblyVersion>4.6.2.0</AssemblyVersion>
    <AssemblyVersion>4.6.3.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T1" />
    <TypeParameter Name="T2" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.IDataflowBlock</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;System.Tuple&lt;T1,T2&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1">
      <AttributeName>System.Diagnostics.DebuggerDisplay("{DebuggerDisplayContent,nq}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.Dataflow.JoinBlock`2/DebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T1">
      <span data-ttu-id="3c907-101">Gibt den Typ der Daten an, die vom ersten Ziel des Blocks akzeptiert werden.</span>
      <span class="sxs-lookup">
        <span data-stu-id="3c907-101">Specifies the type of data accepted by the block's first target.</span>
      </span>
    </typeparam>
    <typeparam name="T2">
      <span data-ttu-id="3c907-102">Gibt den Typ der Daten an, die vom zweiten Ziel des Blocks akzeptiert werden.</span>
      <span class="sxs-lookup">
        <span data-stu-id="3c907-102">Specifies the type of data accepted by the block's second target.</span>
      </span>
    </typeparam>
    <summary>
      <span data-ttu-id="3c907-103">Stellt einen Datenflussblock bereit, der sich über mehrere Datenflussquellen verbindet, nicht unbedingt desselben Typs, und wartet auf ein ankommendes Element für jeden Typ, bevor sie alle zusammen als Tupel freigegeben werden, das aus einem Element pro Typ besteht.</span>
      <span class="sxs-lookup">
        <span data-stu-id="3c907-103">Provides a dataflow block that joins across multiple dataflow sources, not necessarily of the same type, waiting for one item to arrive for each type before they’re all released together as a tuple consisting of one item per type.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [tpl-install-instructions](~/includes/tpl-install-instructions.md)]
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public JoinBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.JoinBlock`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; JoinBlock();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3c907-104">Initialisiert eine neue <see cref="T:System.Threading.Tasks.Dataflow.JoinBlock`2" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-104">Initializes a new <see cref="T:System.Threading.Tasks.Dataflow.JoinBlock`2" />.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public JoinBlock (System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions dataflowBlockOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions dataflowBlockOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.JoinBlock`2.#ctor(System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataflowBlockOptions As GroupingDataflowBlockOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; JoinBlock(System::Threading::Tasks::Dataflow::GroupingDataflowBlockOptions ^ dataflowBlockOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Dataflow.JoinBlock&lt;'T1, 'T2&gt; : System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions -&gt; System.Threading.Tasks.Dataflow.JoinBlock&lt;'T1, 'T2&gt;" Usage="new System.Threading.Tasks.Dataflow.JoinBlock&lt;'T1, 'T2&gt; dataflowBlockOptions" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataflowBlockOptions" Type="System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions" />
      </Parameters>
      <Docs>
        <param name="dataflowBlockOptions">
          <span data-ttu-id="3c907-105">Die Optionen, mit denen dieser <see cref="T:System.Threading.Tasks.Dataflow.JoinBlock`2" /> zu konfigurieren ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-105">The options with which to configure this <see cref="T:System.Threading.Tasks.Dataflow.JoinBlock`2" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c907-106">Initialisiert eine neue <see cref="T:System.Threading.Tasks.Dataflow.JoinBlock`2" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-106">Initializes a new <see cref="T:System.Threading.Tasks.Dataflow.JoinBlock`2" />.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3c907-107">
            <paramref name="dataflowBlockOptions" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-107">The <paramref name="dataflowBlockOptions" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Complete">
      <MemberSignature Language="C#" Value="public void Complete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Complete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.JoinBlock`2.Complete" />
      <MemberSignature Language="VB.NET" Value="Public Sub Complete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Complete();" />
      <MemberSignature Language="F#" Value="abstract member Complete : unit -&gt; unit&#xA;override this.Complete : unit -&gt; unit" Usage="joinBlock.Complete " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3c907-108">Signalisiert <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />, dass es keine Nachrichten mehr akzeptieren und keine produzieren und keine weiteren zurückgestellten Nachrichten verarbeiten soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-108">Signals to the <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> that it should not accept nor produce any more messages nor consume any more postponed messages.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c907-109">Nach dem <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Complete%2A> war aufgerufen wird, in einem Datenflussblock, der Block ausgeführt, und die zugehörige <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Completion%2A> Aufgabe wird einen abschließenden Zustand versetzt, nachdem sie alle zuvor verfügbare Daten verarbeitet hat.</span><span class="sxs-lookup"><span data-stu-id="3c907-109">After <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Complete%2A> has been called on a dataflow block, that block will complete, and its <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Completion%2A> task will enter a final state after it has processed all previously available data.</span></span> <span data-ttu-id="3c907-110"><xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Complete%2A> wird nicht blockiert, die Abschluss vorgenommen wird, wartet aber stattdessen wird die Anforderung initiiert Warten, bis hin zu auftreten, die <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Completion%2A> Aufgabe kann verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="3c907-110"><xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Complete%2A> will not block waiting for completion to occur, but rather will initiate the request; to wait for completion to occur, the <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Completion%2A> task may be used.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Completion">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task Completion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.Task Completion" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.JoinBlock`2.Completion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Completion As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::Task ^ Completion { System::Threading::Tasks::Task ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Completion : System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Dataflow.JoinBlock&lt;'T1, 'T2&gt;.Completion" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3c907-111">Ruft ein <see cref="T:System.Threading.Tasks.Task" /> ab, das den asynchronen Vorgang und die Beendigung des Datenflussblocks darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-111">Gets a <see cref="T:System.Threading.Tasks.Task" /> that represents the asynchronous operation and completion of the dataflow block.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3c907-112">Die Aufgabe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-112">The task.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c907-113">Ein Datenflussblock gilt als abgeschlossen, wenn er nicht gerade verarbeitet, eine Nachricht, und wenn diese garantiert, dass es keine weiteren Nachrichten nicht verarbeitet werden.</span><span class="sxs-lookup"><span data-stu-id="3c907-113">A dataflow block is considered completed when it is not currently processing a message and when it has guaranteed that it will not process any more messages.</span></span> <span data-ttu-id="3c907-114">Das zurückgegebene <xref:System.Threading.Tasks.Task> Übergang in Status "abgeschlossen" wird, wenn der zugeordnete Block abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="3c907-114">The returned <xref:System.Threading.Tasks.Task> will transition to a completed state when the associated block has completed.</span></span> <span data-ttu-id="3c907-115">Es erfolgt ein Wechsel in den <xref:System.Threading.Tasks.TaskStatus> <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Status, wenn der Block die Verarbeitung gemäß des datenflussblocks erfolgreich abgeschlossen ist, definierte Semantik.</span><span class="sxs-lookup"><span data-stu-id="3c907-115">It will transition to the <xref:System.Threading.Tasks.TaskStatus><xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state when the block completes its processing successfully according to the dataflow block’s defined semantics.</span></span> <span data-ttu-id="3c907-116">Es erfolgt ein Wechsel in die <xref:System.Threading.Tasks.TaskStatus> <xref:System.Threading.Tasks.TaskStatus.Faulted> Status, wenn der Datenflussblock Verarbeitung vorzeitig aufgrund einer nicht behandelten Ausnahme abgeschlossen ist, und es ein in Wechsel erfolgt den <xref:System.Threading.Tasks.TaskStatus> <xref:System.Threading.Tasks.TaskStatus.Canceled> Zustand nach Abschluss der Datenflussblock die Verarbeitung aufgrund von vorzeitig eine abbruchanforderung empfangen.</span><span class="sxs-lookup"><span data-stu-id="3c907-116">It will transition to the <xref:System.Threading.Tasks.TaskStatus><xref:System.Threading.Tasks.TaskStatus.Faulted> state when the dataflow block has completed processing prematurely due to an unhandled exception, and it will transition to the <xref:System.Threading.Tasks.TaskStatus><xref:System.Threading.Tasks.TaskStatus.Canceled> state when the dataflow block has completed processing prematurely due to receiving a cancellation request.</span></span> <span data-ttu-id="3c907-117">Wenn die Aufgabe abgeschlossen, in ist der <xref:System.Threading.Tasks.TaskStatus.Faulted> Status, seine `Exception` Eigenschaft zurückgegeben wird ein <xref:System.AggregateException> mit der eine oder mehrere Ausnahmen, die Fehlschlagen des Blockes verursacht hat.</span><span class="sxs-lookup"><span data-stu-id="3c907-117">If the task completes in the <xref:System.Threading.Tasks.TaskStatus.Faulted> state, its `Exception` property will return an <xref:System.AggregateException> containing the one or more exceptions that caused the block to fail.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LinkTo">
      <MemberSignature Language="C#" Value="public IDisposable LinkTo (System.Threading.Tasks.Dataflow.ITargetBlock&lt;Tuple&lt;T1,T2&gt;&gt; target, System.Threading.Tasks.Dataflow.DataflowLinkOptions linkOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IDisposable LinkTo(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;class System.Tuple`2&lt;!T1, !T2&gt;&gt; target, class System.Threading.Tasks.Dataflow.DataflowLinkOptions linkOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.JoinBlock`2.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{`0,`1}},System.Threading.Tasks.Dataflow.DataflowLinkOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function LinkTo (target As ITargetBlock(Of Tuple(Of T1, T2)), linkOptions As DataflowLinkOptions) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IDisposable ^ LinkTo(System::Threading::Tasks::Dataflow::ITargetBlock&lt;Tuple&lt;T1, T2&gt; ^&gt; ^ target, System::Threading::Tasks::Dataflow::DataflowLinkOptions ^ linkOptions);" />
      <MemberSignature Language="F#" Value="abstract member LinkTo : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T1 * 'T2&gt; * System.Threading.Tasks.Dataflow.DataflowLinkOptions -&gt; IDisposable&#xA;override this.LinkTo : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T1 * 'T2&gt; * System.Threading.Tasks.Dataflow.DataflowLinkOptions -&gt; IDisposable" Usage="joinBlock.LinkTo (target, linkOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Threading.Tasks.Dataflow.DataflowLinkOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;System.Tuple&lt;T1,T2&gt;&gt;" />
        <Parameter Name="linkOptions" Type="System.Threading.Tasks.Dataflow.DataflowLinkOptions" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="3c907-118">Verbindet <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> mit dem angegebenen <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />-Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-118">Links the  <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> to the specified  <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> .</span>
          </span>
        </param>
        <param name="linkOptions">
          <span data-ttu-id="3c907-119">Eine <see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" />-Instanz, die den Link konfiguriert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-119">A <see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" /> instance that configures the link.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c907-120">Verbindet <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> mit dem angegebenen <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />-Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-120">Links the  <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> to the specified  <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> .</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c907-121">Ein IDisposable, der nach dem Aufrufen von Dispose, die Quelle vom Ziel trennt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-121">An IDisposable that, upon calling Dispose, will unlink the source from the target.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3c907-122">
            <paramref name="target" /> ist NULL (Nothing in Visual Basic), oder <paramref name="linkOptions" /> ist NULL (Nothing in Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-122">
              <paramref name="target" /> is null (Nothing in Visual Basic) or  <paramref name="linkOptions" /> is null (Nothing in Visual Basic).</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="OutputCount">
      <MemberSignature Language="C#" Value="public int OutputCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 OutputCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.JoinBlock`2.OutputCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutputCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int OutputCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.OutputCount : int" Usage="System.Threading.Tasks.Dataflow.JoinBlock&lt;'T1, 'T2&gt;.OutputCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3c907-123">Ruft die Anzahl der Ausgabe-Elementen ab, die von diesem Block empfangen werden können.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-123">Gets the number of output items available to be received from this block.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3c907-124">Die Anzahl von Ausgabe-Elementen in.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-124">The number of output items.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.IDataflowBlock.Fault">
      <MemberSignature Language="C#" Value="void IDataflowBlock.Fault (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.JoinBlock`2.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception ^ exception) = System::Threading::Tasks::Dataflow::IDataflowBlock::Fault;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(System.Exception)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="exception">
          <span data-ttu-id="3c907-125">Das <see cref="T:System.Exception" />-Objekt, das den Fehler verursacht hat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-125">The  <see cref="T:System.Exception" /> that caused the faulting.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c907-126">Bewirkt, <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> in einem <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> Zustand auszuführen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-126">Causes the <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> to complete in a <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> state.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c907-127">Nach dem <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.System%23Threading%23Tasks%23Dataflow%23IDataflowBlock%23Fault%2A> wurde für einen Datenflussblock aufgerufen wird, der Block ausgeführt, und die zugehörige <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Completion%2A> Aufgabe wird einen abschließenden Zustand versetzt.</span><span class="sxs-lookup"><span data-stu-id="3c907-127">After <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.System%23Threading%23Tasks%23Dataflow%23IDataflowBlock%23Fault%2A> has been called on a dataflow block, that block will complete, and its <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Completion%2A> task will enter a final state.</span></span> <span data-ttu-id="3c907-128">Fehler von einem Block, wird als mit Abbrechen eines Blocks gepufferte Nachrichten (nicht verarbeitet eingehende Nachrichten sowie unoffered ausgabemeldungen) verloren.</span><span class="sxs-lookup"><span data-stu-id="3c907-128">Faulting a block, as with canceling a block, causes buffered messages (unprocessed input messages as well as unoffered output messages) to be lost.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3c907-129">
            <paramref name="exception" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-129">The <paramref name="exception" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2&gt;&gt;.ConsumeMessage">
      <MemberSignature Language="C#" Value="Tuple&lt;T1,T2&gt; ISourceBlock&lt;Tuple&lt;T1,T2&gt;&gt;.ConsumeMessage (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, System.Threading.Tasks.Dataflow.ITargetBlock&lt;Tuple&lt;T1,T2&gt;&gt; target, out bool messageConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Tuple`2&lt;!T1, !T2&gt; System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2&gt;&gt;.ConsumeMessage(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;class System.Tuple`2&lt;!T1, !T2&gt;&gt; target, [out] bool&amp; messageConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.JoinBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock&lt;System#Tuple&lt;T1,T2&gt;&gt;#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{`0,`1}},System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Function ConsumeMessage (messageHeader As DataflowMessageHeader, target As ITargetBlock(Of Tuple(Of T1, T2)), ByRef messageConsumed As Boolean) As Tuple(Of T1, T2) Implements ISourceBlock(Of Tuple(Of T1, T2)).ConsumeMessage" />
      <MemberSignature Language="C++ CLI" Value=" virtual Tuple&lt;T1, T2&gt; ^ System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2&gt;&gt;.ConsumeMessage(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, System::Threading::Tasks::Dataflow::ITargetBlock&lt;Tuple&lt;T1, T2&gt; ^&gt; ^ target, [Runtime::InteropServices::Out] bool % messageConsumed) = System::Threading::Tasks::Dataflow::ISourceBlock&lt;Tuple&lt;T1, T2&gt; ^&gt;::ConsumeMessage;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;T1,T2&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;System.Tuple&lt;T1,T2&gt;&gt;" />
        <Parameter Name="messageConsumed" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="messageHeader">To be added.</param>
        <param name="target">To be added.</param>
        <param name="messageConsumed">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2&gt;&gt;.ReleaseReservation">
      <MemberSignature Language="C#" Value="void ISourceBlock&lt;Tuple&lt;T1,T2&gt;&gt;.ReleaseReservation (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, System.Threading.Tasks.Dataflow.ITargetBlock&lt;Tuple&lt;T1,T2&gt;&gt; target);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2&gt;&gt;.ReleaseReservation(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;class System.Tuple`2&lt;!T1, !T2&gt;&gt; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.JoinBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock&lt;System#Tuple&lt;T1,T2&gt;&gt;#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{`0,`1}})" />
      <MemberSignature Language="VB.NET" Value="Sub ReleaseReservation (messageHeader As DataflowMessageHeader, target As ITargetBlock(Of Tuple(Of T1, T2))) Implements ISourceBlock(Of Tuple(Of T1, T2)).ReleaseReservation" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2&gt;&gt;.ReleaseReservation(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, System::Threading::Tasks::Dataflow::ITargetBlock&lt;Tuple&lt;T1, T2&gt; ^&gt; ^ target) = System::Threading::Tasks::Dataflow::ISourceBlock&lt;Tuple&lt;T1, T2&gt; ^&gt;::ReleaseReservation;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;System.Tuple&lt;T1,T2&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="messageHeader">To be added.</param>
        <param name="target">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2&gt;&gt;.ReserveMessage">
      <MemberSignature Language="C#" Value="bool ISourceBlock&lt;Tuple&lt;T1,T2&gt;&gt;.ReserveMessage (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, System.Threading.Tasks.Dataflow.ITargetBlock&lt;Tuple&lt;T1,T2&gt;&gt; target);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2&gt;&gt;.ReserveMessage(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;class System.Tuple`2&lt;!T1, !T2&gt;&gt; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.JoinBlock`2.System#Threading#Tasks#Dataflow#ISourceBlock&lt;System#Tuple&lt;T1,T2&gt;&gt;#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{`0,`1}})" />
      <MemberSignature Language="VB.NET" Value="Function ReserveMessage (messageHeader As DataflowMessageHeader, target As ITargetBlock(Of Tuple(Of T1, T2))) As Boolean Implements ISourceBlock(Of Tuple(Of T1, T2)).ReserveMessage" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2&gt;&gt;.ReserveMessage(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, System::Threading::Tasks::Dataflow::ITargetBlock&lt;Tuple&lt;T1, T2&gt; ^&gt; ^ target) = System::Threading::Tasks::Dataflow::ISourceBlock&lt;Tuple&lt;T1, T2&gt; ^&gt;::ReserveMessage;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;System.Tuple&lt;T1,T2&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="messageHeader">To be added.</param>
        <param name="target">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Target1">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Dataflow.ITargetBlock&lt;T1&gt; Target1 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!T1&gt; Target1" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.JoinBlock`2.Target1" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target1 As ITargetBlock(Of T1)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::Dataflow::ITargetBlock&lt;T1&gt; ^ Target1 { System::Threading::Tasks::Dataflow::ITargetBlock&lt;T1&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target1 : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T1&gt;" Usage="System.Threading.Tasks.Dataflow.JoinBlock&lt;'T1, 'T2&gt;.Target1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Dataflow.ITargetBlock&lt;T1&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3c907-130">Ruft ein Ziel ab, das verwendet werden kann, um Meldungen des ersten Typs anzubieten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-130">Gets a target that may be used to offer messages of the first type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3c907-131">Das Ziel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-131">The target.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Target2">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Dataflow.ITargetBlock&lt;T2&gt; Target2 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!T2&gt; Target2" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.JoinBlock`2.Target2" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target2 As ITargetBlock(Of T2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::Dataflow::ITargetBlock&lt;T2&gt; ^ Target2 { System::Threading::Tasks::Dataflow::ITargetBlock&lt;T2&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target2 : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T2&gt;" Usage="System.Threading.Tasks.Dataflow.JoinBlock&lt;'T1, 'T2&gt;.Target2" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Dataflow.ITargetBlock&lt;T2&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3c907-132">Ruft ein Ziel ab, das verwendet werden kann, um Meldungen des zweiten Typs anzubieten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-132">Gets a target that may be used to offer messages of the second type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3c907-133">Das Ziel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-133">The target.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.JoinBlock`2.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="joinBlock.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3c907-134">Gibt eine Zeichenfolge zurück, die den formatierten Namen dieser <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />-Instanz darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-134">Returns a string that represents the formatted name of this  <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c907-135">Eine Zeichenfolge, die den formatierten Namen dieser <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />-Instanz darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-135">A string that represents the formatted name of this <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c907-136">Geerbt von <xref:System.Object> .</span><span class="sxs-lookup"><span data-stu-id="3c907-136">Inherited from  <xref:System.Object> .</span></span> <span data-ttu-id="3c907-137">Verwendet die <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.NameFormat%2A> Option.</span><span class="sxs-lookup"><span data-stu-id="3c907-137">Uses the  <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.NameFormat%2A> option.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReceive">
      <MemberSignature Language="C#" Value="public bool TryReceive (Predicate&lt;Tuple&lt;T1,T2&gt;&gt; filter, out Tuple&lt;T1,T2&gt; item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryReceive(class System.Predicate`1&lt;class System.Tuple`2&lt;!T1, !T2&gt;&gt; filter, [out] class System.Tuple`2&lt;!T1, !T2&gt;&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.JoinBlock`2.TryReceive(System.Predicate{System.Tuple{`0,`1}},System.Tuple{`0,`1}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReceive (filter As Predicate(Of Tuple(Of T1, T2)), ByRef item As Tuple(Of T1, T2)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryReceive(Predicate&lt;Tuple&lt;T1, T2&gt; ^&gt; ^ filter, [Runtime::InteropServices::Out] Tuple&lt;T1, T2&gt; ^ % item);" />
      <MemberSignature Language="F#" Value="abstract member TryReceive : Predicate&lt;'T1 * 'T2&gt; *  -&gt; bool&#xA;override this.TryReceive : Predicate&lt;'T1 * 'T2&gt; *  -&gt; bool" Usage="joinBlock.TryReceive (filter, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Predicate&lt;System.Tuple&lt;T1,T2&gt;&gt;" />
        <Parameter Name="item" Type="System.Tuple&lt;T1,T2&gt;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="filter">
          <span data-ttu-id="3c907-138">Der Prädikatswert muss erfolgreich übergeben werden, damit er empfangen wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-138">The predicate value must successfully pass in order for it to be received.</span>
          </span>
          <span data-ttu-id="3c907-139">Der <c>Filter</c> ist möglicherweise <see langword="null" />. Wenn dies der Fall ist, werden alle Elemente übergeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-139">
              <c>filter</c> may be <see langword="null" />, in which case all items will pass.</span>
          </span>
        </param>
        <param name="item">
          <span data-ttu-id="3c907-140">Das von der Quelle empfangene Element.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-140">The item received from the source.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c907-141">Versucht, ein verfügbares Output-Element von<see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" /> synchron zu empfangen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-141">Attempts to synchronously receive an available output item from the <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c907-142">
            <see langword="true" />, wenn ein Element empfangen werden konnte; andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-142">
              <see langword="true" /> if an item could be received; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c907-143">Diese Methode wird warten auf die Quelle, geben Sie ein Element nicht blockiert werden.</span><span class="sxs-lookup"><span data-stu-id="3c907-143">This method does not block waiting for the source to provide an item.</span></span>  
  
 <span data-ttu-id="3c907-144">Es wird nach der Überprüfung für ein Element zurückgegeben, und zwar unabhängig davon, ob ein Element verfügbar war.</span><span class="sxs-lookup"><span data-stu-id="3c907-144">It will return after checking for an element, whether or not an element was available.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReceiveAll">
      <MemberSignature Language="C#" Value="public bool TryReceiveAll (out System.Collections.Generic.IList&lt;Tuple&lt;T1,T2&gt;&gt; items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryReceiveAll([out] class System.Collections.Generic.IList`1&lt;class System.Tuple`2&lt;!T1, !T2&gt;&gt;&amp; items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.JoinBlock`2.TryReceiveAll(System.Collections.Generic.IList{System.Tuple{`0,`1}}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReceiveAll (ByRef items As IList(Of Tuple(Of T1, T2))) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryReceiveAll([Runtime::InteropServices::Out] System::Collections::Generic::IList&lt;Tuple&lt;T1, T2&gt; ^&gt; ^ % items);" />
      <MemberSignature Language="F#" Value="abstract member TryReceiveAll :  -&gt; bool&#xA;override this.TryReceiveAll :  -&gt; bool" Usage="joinBlock.TryReceiveAll items" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="System.Collections.Generic.IList&lt;System.Tuple&lt;T1,T2&gt;&gt;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="items">
          <span data-ttu-id="3c907-145">Die von der Quelle empfangenen Elemente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-145">The items received from the source.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3c907-146">Versucht, alle verfügbaren Elemente aus <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" /> synchron zu empfangen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-146">Attempts to synchronously receive all available items from the <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3c907-147">
            <see langword="true" />, wenn ein oder mehrere Elemente empfangen werden konnten; andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3c907-147">
              <see langword="true" /> if one or more items could be received; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3c907-148">Diese Methode wird warten auf die Quelle, geben Sie ein Element nicht blockiert werden.</span><span class="sxs-lookup"><span data-stu-id="3c907-148">This method does not block waiting for the source to provide an item.</span></span>  
  
 <span data-ttu-id="3c907-149">Es wird nach der Überprüfung für Elemente zurückgegeben, und zwar unabhängig davon, ob ein Element verfügbar war.</span><span class="sxs-lookup"><span data-stu-id="3c907-149">It will return after checking for elements, whether or not an element was available.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>