<Type Name="JoinBlock&lt;T1,T2,T3&gt;" FullName="System.Threading.Tasks.Dataflow.JoinBlock&lt;T1,T2,T3&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="84ca2d23a076c4f92e2552189b579bd54dbe66a2" /><Meta Name="ms.sourcegitcommit" Value="9506e50ec7beb4fa30206b9840dc546b035a6600" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/23/2020" /><Meta Name="ms.locfileid" Value="86989754" /></Metadata><TypeSignature Language="C#" Value="public sealed class JoinBlock&lt;T1,T2,T3&gt; : System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;Tuple&lt;T1,T2,T3&gt;&gt;, System.Threading.Tasks.Dataflow.ISourceBlock&lt;Tuple&lt;T1,T2,T3&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit JoinBlock`3&lt;T1, T2, T3&gt; extends System.Object implements class System.Threading.Tasks.Dataflow.IDataflowBlock, class System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&lt;class System.Tuple`3&lt;!T1, !T2, !T3&gt;&gt;, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;class System.Tuple`3&lt;!T1, !T2, !T3&gt;&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Dataflow.JoinBlock`3" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class JoinBlock(Of T1, T2, T3)&#xA;Implements IReceivableSourceBlock(Of Tuple(Of T1, T2, T3)), ISourceBlock(Of Tuple(Of T1, T2, T3))" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T1, typename T2, typename T3&gt;&#xA;public ref class JoinBlock sealed : System::Threading::Tasks::Dataflow::IReceivableSourceBlock&lt;Tuple&lt;T1, T2, T3&gt; ^&gt;, System::Threading::Tasks::Dataflow::ISourceBlock&lt;Tuple&lt;T1, T2, T3&gt; ^&gt;" />
  <TypeSignature Language="F#" Value="type JoinBlock&lt;'T1, 'T2, 'T3&gt; = class&#xA;    interface IReceivableSourceBlock&lt;'T1 * 'T2 * 'T3&gt;&#xA;    interface ISourceBlock&lt;'T1 * 'T2 * 'T3&gt;&#xA;    interface IDataflowBlock" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1" />
  <TypeSignature Language="F#" Value="type JoinBlock&lt;'T1, 'T2, 'T3&gt; = class&#xA;    interface IDataflowBlock&#xA;    interface IReceivableSourceBlock&lt;'T1 * 'T2 * 'T3&gt;&#xA;    interface ISourceBlock&lt;'T1 * 'T2 * 'T3&gt;" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
    <AssemblyVersion>4.5.25.0</AssemblyVersion>
    <AssemblyVersion>4.6.0.0</AssemblyVersion>
    <AssemblyVersion>4.6.1.0</AssemblyVersion>
    <AssemblyVersion>4.6.2.0</AssemblyVersion>
    <AssemblyVersion>4.6.3.0</AssemblyVersion>
    <AssemblyVersion>4.6.4.0</AssemblyVersion>
    <AssemblyVersion>4.6.5.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T1" />
    <TypeParameter Name="T2" />
    <TypeParameter Name="T3" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.IDataflowBlock</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.ISourceBlock&lt;TOutput&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1">
      <AttributeName Language="C#">[System.Diagnostics.DebuggerDisplay("{DebuggerDisplayContent,nq}")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerDisplay("{DebuggerDisplayContent,nq}")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1">
      <AttributeName Language="C#">[System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.Dataflow.JoinBlock`3/DebugView))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.Dataflow.JoinBlock`3/DebugView))&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T1"><span data-ttu-id="6e04a-101">Gibt den Typ der Daten an, die vom ersten Ziel des Blocks akzeptiert werden.</span><span class="sxs-lookup"><span data-stu-id="6e04a-101">Specifies the type of data accepted by the block's first target.</span></span></typeparam>
    <typeparam name="T2"><span data-ttu-id="6e04a-102">Gibt den Typ der Daten an, die vom zweiten Ziel des Blocks akzeptiert werden.</span><span class="sxs-lookup"><span data-stu-id="6e04a-102">Specifies the type of data accepted by the block's second target.</span></span></typeparam>
    <typeparam name="T3"><span data-ttu-id="6e04a-103">Gibt den Typ der Daten an, die vom dritten Ziel des Blocks akzeptiert werden.</span><span class="sxs-lookup"><span data-stu-id="6e04a-103">Specifies the type of data accepted by the block's third target.</span></span></typeparam>
    <summary><span data-ttu-id="6e04a-104">Stellt einen Datenflussblock bereit, der sich über mehrere Datenflussquellen erstreckt, die nicht unbedingt desselben Typs sind. Der Datenflussblock wartet auf ein ankommendes Element für jeden Typ, bevor sie alle zusammen als Tupel freigegeben werden, das ein Element pro Typ enthält.</span><span class="sxs-lookup"><span data-stu-id="6e04a-104">Provides a dataflow block that joins across multiple dataflow sources, which are not necessarily of the same type, waiting for one item to arrive for each type before they're all released together as a tuple that contains one item per type.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [tpl-install-instructions](~/includes/tpl-install-instructions.md)]
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public JoinBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.JoinBlock`3.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; JoinBlock();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6e04a-105">Initialisiert eine neue <see cref="T:System.Threading.Tasks.Dataflow.JoinBlock`3" />.</span><span class="sxs-lookup"><span data-stu-id="6e04a-105">Initializes a new <see cref="T:System.Threading.Tasks.Dataflow.JoinBlock`3" />.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public JoinBlock (System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions dataflowBlockOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions dataflowBlockOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.JoinBlock`3.#ctor(System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataflowBlockOptions As GroupingDataflowBlockOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; JoinBlock(System::Threading::Tasks::Dataflow::GroupingDataflowBlockOptions ^ dataflowBlockOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Dataflow.JoinBlock&lt;'T1, 'T2, 'T3&gt; : System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions -&gt; System.Threading.Tasks.Dataflow.JoinBlock&lt;'T1, 'T2, 'T3&gt;" Usage="new System.Threading.Tasks.Dataflow.JoinBlock&lt;'T1, 'T2, 'T3&gt; dataflowBlockOptions" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataflowBlockOptions" Type="System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions" />
      </Parameters>
      <Docs>
        <param name="dataflowBlockOptions"><span data-ttu-id="6e04a-106">Die Optionen, mit denen dieser <see cref="T:System.Threading.Tasks.Dataflow.JoinBlock`2" /> zu konfigurieren ist.</span><span class="sxs-lookup"><span data-stu-id="6e04a-106">The options with which to configure this <see cref="T:System.Threading.Tasks.Dataflow.JoinBlock`2" />.</span></span></param>
        <summary><span data-ttu-id="6e04a-107">Initialisiert eine neue <see cref="T:System.Threading.Tasks.Dataflow.JoinBlock`3" />.</span><span class="sxs-lookup"><span data-stu-id="6e04a-107">Initializes a new <see cref="T:System.Threading.Tasks.Dataflow.JoinBlock`3" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6e04a-108"><paramref name="dataflowBlockOptions" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="6e04a-108">The <paramref name="dataflowBlockOptions" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Complete">
      <MemberSignature Language="C#" Value="public void Complete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Complete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.JoinBlock`3.Complete" />
      <MemberSignature Language="VB.NET" Value="Public Sub Complete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Complete();" />
      <MemberSignature Language="F#" Value="abstract member Complete : unit -&gt; unit&#xA;override this.Complete : unit -&gt; unit" Usage="joinBlock.Complete " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6e04a-109">Signalisiert <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />, dass es keine Nachrichten mehr akzeptieren und keine produzieren und keine weiteren zurückgestellten Nachrichten verarbeiten soll.</span><span class="sxs-lookup"><span data-stu-id="6e04a-109">Signals to the <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> that it should not accept nor produce any more messages nor consume any more postponed messages.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6e04a-110">Nachdem <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Complete%2A> für einen Datenfluss Block aufgerufen wurde, wird dieser Block abgeschlossen, und seine Aufgabe wechselt  <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Completion%2A> in einen Endzustand, nachdem alle zuvor verfügbaren Daten verarbeitet wurden.</span><span class="sxs-lookup"><span data-stu-id="6e04a-110">After <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Complete%2A> has been called on a dataflow block, that block will complete, and its  <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Completion%2A> task will enter a final state after it has processed all previously available data.</span></span> <span data-ttu-id="6e04a-111"><xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Complete%2A> blockiert nicht, dass auf den Abschluss gewartet wird, sondern initiiert die Anforderung. um zu warten, bis der Vorgang abgeschlossen ist, <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Completion%2A> kann der Task verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="6e04a-111"><xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Complete%2A> will not block waiting for completion to occur, but rather will initiate the request; to wait for completion to occur, the <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Completion%2A> task may be used.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Completion">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task Completion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.Task Completion" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.JoinBlock`3.Completion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Completion As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::Task ^ Completion { System::Threading::Tasks::Task ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Completion : System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Dataflow.JoinBlock&lt;'T1, 'T2, 'T3&gt;.Completion" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6e04a-112">Ruft ein <see cref="T:System.Threading.Tasks.Task" /> ab, das den asynchronen Vorgang und die Beendigung des Datenflussblocks darstellt.</span><span class="sxs-lookup"><span data-stu-id="6e04a-112">Gets a <see cref="T:System.Threading.Tasks.Task" /> that represents the asynchronous operation and completion of the dataflow block.</span></span></summary>
        <value><span data-ttu-id="6e04a-113">Die Aufgabe.</span><span class="sxs-lookup"><span data-stu-id="6e04a-113">The task.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6e04a-114">Ein Datenfluss Block wird als abgeschlossen betrachtet, wenn er zurzeit keine Nachricht verarbeitet, und wenn sichergestellt ist, dass keine weiteren Nachrichten verarbeitet werden.</span><span class="sxs-lookup"><span data-stu-id="6e04a-114">A dataflow block is considered completed when it is not currently processing a message and when it has guaranteed that it will not process any more messages.</span></span> <span data-ttu-id="6e04a-115">Der zurückgegebene wechselt <xref:System.Threading.Tasks.Task> in den abgeschlossenen Zustand, wenn der zugeordnete-Block abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="6e04a-115">The returned <xref:System.Threading.Tasks.Task> will transition to a completed state when the associated block has completed.</span></span> <span data-ttu-id="6e04a-116">Der Übergang in den-Zustand erfolgt, <xref:System.Threading.Tasks.TaskStatus> <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> Wenn der-Block seine Verarbeitung gemäß der definierten Semantik des Datenfluss Blocks erfolgreich abgeschlossen hat.</span><span class="sxs-lookup"><span data-stu-id="6e04a-116">It will transition to the <xref:System.Threading.Tasks.TaskStatus><xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state when the block completes its processing successfully according to the dataflow block's defined semantics.</span></span> <span data-ttu-id="6e04a-117">Es wechselt in den- <xref:System.Threading.Tasks.TaskStatus> <xref:System.Threading.Tasks.TaskStatus.Faulted> Status, wenn der Datenfluss Block die Verarbeitung aufgrund einer nicht behandelten Ausnahme vorzeitig abgeschlossen hat, und wechselt in den- <xref:System.Threading.Tasks.TaskStatus> <xref:System.Threading.Tasks.TaskStatus.Canceled> Zustand, wenn der Datenfluss Block die Verarbeitung vorzeitig abgeschlossen hat, weil eine Abbruch Anforderung empfangen wurde.</span><span class="sxs-lookup"><span data-stu-id="6e04a-117">It will transition to the <xref:System.Threading.Tasks.TaskStatus><xref:System.Threading.Tasks.TaskStatus.Faulted> state when the dataflow block has completed processing prematurely due to an unhandled exception, and it will transition to the <xref:System.Threading.Tasks.TaskStatus><xref:System.Threading.Tasks.TaskStatus.Canceled> state when the dataflow block has completed processing prematurely due to receiving a cancellation request.</span></span> <span data-ttu-id="6e04a-118">Wenn die Aufgabe im- <xref:System.Threading.Tasks.TaskStatus.Faulted> Zustand abgeschlossen ist, `Exception` gibt die-Eigenschaft einen-Wert zurück, <xref:System.AggregateException> der die mindestens eine Ausnahme enthält, durch die der-Block fehlgeschlagen ist.</span><span class="sxs-lookup"><span data-stu-id="6e04a-118">If the task completes in the <xref:System.Threading.Tasks.TaskStatus.Faulted> state, its `Exception` property will return an <xref:System.AggregateException> containing the one or more exceptions that caused the block to fail.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LinkTo">
      <MemberSignature Language="C#" Value="public IDisposable LinkTo (System.Threading.Tasks.Dataflow.ITargetBlock&lt;Tuple&lt;T1,T2,T3&gt;&gt; target, System.Threading.Tasks.Dataflow.DataflowLinkOptions linkOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IDisposable LinkTo(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;class System.Tuple`3&lt;!T1, !T2, !T3&gt;&gt; target, class System.Threading.Tasks.Dataflow.DataflowLinkOptions linkOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.JoinBlock`3.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{`0,`1,`2}},System.Threading.Tasks.Dataflow.DataflowLinkOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function LinkTo (target As ITargetBlock(Of Tuple(Of T1, T2, T3)), linkOptions As DataflowLinkOptions) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IDisposable ^ LinkTo(System::Threading::Tasks::Dataflow::ITargetBlock&lt;Tuple&lt;T1, T2, T3&gt; ^&gt; ^ target, System::Threading::Tasks::Dataflow::DataflowLinkOptions ^ linkOptions);" />
      <MemberSignature Language="F#" Value="abstract member LinkTo : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T1 * 'T2 * 'T3&gt; * System.Threading.Tasks.Dataflow.DataflowLinkOptions -&gt; IDisposable&#xA;override this.LinkTo : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T1 * 'T2 * 'T3&gt; * System.Threading.Tasks.Dataflow.DataflowLinkOptions -&gt; IDisposable" Usage="joinBlock.LinkTo (target, linkOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Threading.Tasks.Dataflow.DataflowLinkOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;" />
        <Parameter Name="linkOptions" Type="System.Threading.Tasks.Dataflow.DataflowLinkOptions" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="6e04a-119">Der Zielblock, mit dem die Quelle verbunden werden soll.</span><span class="sxs-lookup"><span data-stu-id="6e04a-119">The target block to which to connect this source.</span></span></param>
        <param name="linkOptions"><span data-ttu-id="6e04a-120">Ein Objekt, das den Link konfiguriert.</span><span class="sxs-lookup"><span data-stu-id="6e04a-120">An object that configures the link.</span></span></param>
        <summary><span data-ttu-id="6e04a-121">Verknüpft den Quellblock mit dem angegebenen Zielblock.</span><span class="sxs-lookup"><span data-stu-id="6e04a-121">Links the   source block to the specified target block.</span></span></summary>
        <returns><span data-ttu-id="6e04a-122">Ein verwerfbares Objekt, dass die Verknüpfung der Quelle mit dem Ziel auflöst, wenn die <see cref="M:System.IDisposable.Dispose" />-Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="6e04a-122">A disposable object that unlinks the source from the target when its <see cref="M:System.IDisposable.Dispose" /> method is called.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6e04a-123"><paramref name="target" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="6e04a-123"><paramref name="target" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="6e04a-124">- oder -</span><span class="sxs-lookup"><span data-stu-id="6e04a-124">-or-</span></span> 
 <span data-ttu-id="6e04a-125"><paramref name="linkOptions" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="6e04a-125"><paramref name="linkOptions" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OutputCount">
      <MemberSignature Language="C#" Value="public int OutputCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 OutputCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.JoinBlock`3.OutputCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutputCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int OutputCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.OutputCount : int" Usage="System.Threading.Tasks.Dataflow.JoinBlock&lt;'T1, 'T2, 'T3&gt;.OutputCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6e04a-126">Ruft die Anzahl der Ausgabe-Elementen ab, die von diesem Block empfangen werden können.</span><span class="sxs-lookup"><span data-stu-id="6e04a-126">Gets the number of output items available to be received from this block.</span></span></summary>
        <value><span data-ttu-id="6e04a-127">Die Anzahl von Ausgabe-Elementen in.</span><span class="sxs-lookup"><span data-stu-id="6e04a-127">The number of output items.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.IDataflowBlock.Fault">
      <MemberSignature Language="C#" Value="void IDataflowBlock.Fault (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.JoinBlock`3.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Sub Fault (exception As Exception) Implements IDataflowBlock.Fault" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception ^ exception) = System::Threading::Tasks::Dataflow::IDataflowBlock::Fault;" />
      <MemberSignature Language="F#" Value="abstract member System.Threading.Tasks.Dataflow.IDataflowBlock.Fault : Exception -&gt; unit&#xA;override this.System.Threading.Tasks.Dataflow.IDataflowBlock.Fault : Exception -&gt; unit" Usage="joinBlock.System.Threading.Tasks.Dataflow.IDataflowBlock.Fault exception" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(System.Exception)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="exception"><span data-ttu-id="6e04a-128">Das <see cref="T:System.Exception" />-Objekt, das den Fehler verursacht hat.</span><span class="sxs-lookup"><span data-stu-id="6e04a-128">The  <see cref="T:System.Exception" /> that caused the faulting.</span></span></param>
        <summary><span data-ttu-id="6e04a-129">Hat zur Folge, dass <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> im Status <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="6e04a-129">Causes the <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> to complete in a  <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6e04a-130">Nachdem <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.System%23Threading%23Tasks%23Dataflow%23IDataflowBlock%23Fault%2A> für einen Datenfluss Block aufgerufen wurde, wird dieser Block abgeschlossen, und seine Aufgabe wechselt <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Completion%2A> in einen Endzustand.</span><span class="sxs-lookup"><span data-stu-id="6e04a-130">After <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.System%23Threading%23Tasks%23Dataflow%23IDataflowBlock%23Fault%2A> has been called on a dataflow block, that block will complete, and its <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Completion%2A> task will enter a final state.</span></span> <span data-ttu-id="6e04a-131">Ein Fehler bei einem-Block, wie beim Abbrechen eines-Blocks, bewirkt, dass gepufferte Nachrichten (nicht verarbeitete Eingabe Meldungen und nicht angebotene Ausgabe Nachrichten) verloren gehen.</span><span class="sxs-lookup"><span data-stu-id="6e04a-131">Faulting a block, as with canceling a block, causes buffered messages (unprocessed input messages as well as unoffered output messages) to be lost.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6e04a-132"><paramref name="exception" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="6e04a-132">The <paramref name="exception" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;.ConsumeMessage">
      <MemberSignature Language="C#" Value="(T1,T2,T3) ISourceBlock&lt;Tuple&lt;T1,T2,T3&gt;&gt;.ConsumeMessage (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, System.Threading.Tasks.Dataflow.ITargetBlock&lt;Tuple&lt;T1,T2,T3&gt;&gt; target, out bool messageConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Tuple`3&lt;!T1, !T2, !T3&gt; System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;.ConsumeMessage(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;class System.Tuple`3&lt;!T1, !T2, !T3&gt;&gt; target, [out] bool&amp; messageConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.JoinBlock`3.System#Threading#Tasks#Dataflow#ISourceBlock&lt;System#Tuple&lt;T1,T2,T3&gt;&gt;#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{`0,`1,`2}},System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Function ConsumeMessage (messageHeader As DataflowMessageHeader, target As ITargetBlock(Of Tuple(Of T1, T2, T3)), ByRef messageConsumed As Boolean) As Tuple(Of T1, T2, T3) Implements ISourceBlock(Of Tuple(Of T1, T2, T3)).ConsumeMessage" />
      <MemberSignature Language="C++ CLI" Value=" virtual Tuple&lt;T1, T2, T3&gt; ^ System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;.ConsumeMessage(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, System::Threading::Tasks::Dataflow::ITargetBlock&lt;Tuple&lt;T1, T2, T3&gt; ^&gt; ^ target, [Runtime::InteropServices::Out] bool % messageConsumed) = System::Threading::Tasks::Dataflow::ISourceBlock&lt;Tuple&lt;T1, T2, T3&gt; ^&gt;::ConsumeMessage;" />
      <MemberSignature Language="F#" Value="abstract member System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;.ConsumeMessage : System.Threading.Tasks.Dataflow.DataflowMessageHeader * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T1 * 'T2 * 'T3&gt; * bool -&gt; 'T1 * 'T2 * 'T3&#xA;override this.System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;.ConsumeMessage : System.Threading.Tasks.Dataflow.DataflowMessageHeader * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T1 * 'T2 * 'T3&gt; * bool -&gt; 'T1 * 'T2 * 'T3" Usage="joinBlock.System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;.ConsumeMessage (messageHeader, target, messageConsumed)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;T1,T2,T3&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;" />
        <Parameter Name="messageConsumed" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="messageHeader"><span data-ttu-id="6e04a-133">Die <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />-Struktur der Nachricht, die verarbeitet werden soll</span><span class="sxs-lookup"><span data-stu-id="6e04a-133">The <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> of the message that is to be consumed.</span></span></param>
        <param name="target"><span data-ttu-id="6e04a-134">Die <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />-Struktur, für die die Nachricht verarbeitet werden soll</span><span class="sxs-lookup"><span data-stu-id="6e04a-134">The <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> for which the message is to be consumed.</span></span></param>
        <param name="messageConsumed"><span data-ttu-id="6e04a-135"><see langword="true" />, wenn die Nachricht erfolgreich verarbeitet wurde.</span><span class="sxs-lookup"><span data-stu-id="6e04a-135"><see langword="true" /> if the message was successfully consumed.</span></span> <span data-ttu-id="6e04a-136">Andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="6e04a-136"><see langword="false" /> otherwise.</span></span></param>
        <summary><span data-ttu-id="6e04a-137">Übergibt den Besitz der durch die <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />-Struktur identifizierten Nachricht von dieser <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />-Instanz an die <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />-Schnittstelle</span><span class="sxs-lookup"><span data-stu-id="6e04a-137">Passes the ownership of the message identified by the <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> from this  <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> instance to the <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</span></span></summary>
        <returns><span data-ttu-id="6e04a-138">Der Wert der verarbeiteten Meldung.</span><span class="sxs-lookup"><span data-stu-id="6e04a-138">The value of the consumed message.</span></span> <span data-ttu-id="6e04a-139">Dies kann einer anderen <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />-Instanz entsprechen, die zuvor reserviert war und als <paramref name="messageHeader" /> an diese Methode übergeben wurde.</span><span class="sxs-lookup"><span data-stu-id="6e04a-139">This may correspond to a different <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> instance than was previously reserved and passed as the <paramref name="messageHeader" /> to this method.</span></span> <span data-ttu-id="6e04a-140">Der nutzende <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> muss den zurückgegebenen Wert anstelle des als <paramref name="messageValue" /> an <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" /> übergebenen Werts verwenden.</span><span class="sxs-lookup"><span data-stu-id="6e04a-140">The consuming <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> must use the returned value instead of the value passed as <paramref name="messageValue" /> to <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />.</span></span> <span data-ttu-id="6e04a-141">Wenn die angeforderte Nachricht nicht verfügbar ist, ist der Rückgabewert <see langword="null" /> (<see langword="Nothing" /> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="6e04a-141">If the message requested is not available, the return value is <see langword="null" /> (<see langword="Nothing" /> in Visual Basic).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 <span data-ttu-id="6e04a-142">Der, <xref:System.Threading.Tasks.Dataflow.ITargetBlock`1> für den die Nachricht verwendet werden soll, muss von dieser Instanz nicht verknüpft werden <xref:System.Threading.Tasks.Dataflow.ISourceBlock`1> .</span><span class="sxs-lookup"><span data-stu-id="6e04a-142">The <xref:System.Threading.Tasks.Dataflow.ITargetBlock`1> for which the message is to be consumed need not be linked from this <xref:System.Threading.Tasks.Dataflow.ISourceBlock`1> instance.</span></span> <span data-ttu-id="6e04a-143">Außerdem hat diese <xref:System.Threading.Tasks.Dataflow.ISourceBlock`1> Instanz die Nachricht möglicherweise niemals direkt dem bereitgestellt <xref:System.Threading.Tasks.Dataflow.ITargetBlock`1> .</span><span class="sxs-lookup"><span data-stu-id="6e04a-143">Moreover, this <xref:System.Threading.Tasks.Dataflow.ISourceBlock`1> instance may have never offered the message directly to the <xref:System.Threading.Tasks.Dataflow.ITargetBlock`1>.</span></span>  

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6e04a-144">Der <paramref name="messageHeader" /> ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="6e04a-144">The <paramref name="messageHeader" /> is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6e04a-145">Der <paramref name="target" />-Parameter ist <see langword="null" /> (Nichts in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="6e04a-145">The <paramref name="target" /> is <see langword="null" /> (Nothing in Visual Basic).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;.ReleaseReservation">
      <MemberSignature Language="C#" Value="void ISourceBlock&lt;Tuple&lt;T1,T2,T3&gt;&gt;.ReleaseReservation (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, System.Threading.Tasks.Dataflow.ITargetBlock&lt;Tuple&lt;T1,T2,T3&gt;&gt; target);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;.ReleaseReservation(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;class System.Tuple`3&lt;!T1, !T2, !T3&gt;&gt; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.JoinBlock`3.System#Threading#Tasks#Dataflow#ISourceBlock&lt;System#Tuple&lt;T1,T2,T3&gt;&gt;#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{`0,`1,`2}})" />
      <MemberSignature Language="VB.NET" Value="Sub ReleaseReservation (messageHeader As DataflowMessageHeader, target As ITargetBlock(Of Tuple(Of T1, T2, T3))) Implements ISourceBlock(Of Tuple(Of T1, T2, T3)).ReleaseReservation" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;.ReleaseReservation(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, System::Threading::Tasks::Dataflow::ITargetBlock&lt;Tuple&lt;T1, T2, T3&gt; ^&gt; ^ target) = System::Threading::Tasks::Dataflow::ISourceBlock&lt;Tuple&lt;T1, T2, T3&gt; ^&gt;::ReleaseReservation;" />
      <MemberSignature Language="F#" Value="abstract member System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;.ReleaseReservation : System.Threading.Tasks.Dataflow.DataflowMessageHeader * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T1 * 'T2 * 'T3&gt; -&gt; unit&#xA;override this.System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;.ReleaseReservation : System.Threading.Tasks.Dataflow.DataflowMessageHeader * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T1 * 'T2 * 'T3&gt; -&gt; unit" Usage="joinBlock.System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;.ReleaseReservation (messageHeader, target)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="messageHeader"><span data-ttu-id="6e04a-146"><see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> der reservierten Meldung</span><span class="sxs-lookup"><span data-stu-id="6e04a-146">The <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> of the reserved message.</span></span></param>
        <param name="target"><span data-ttu-id="6e04a-147">Die Schnittstelle <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, die aktuell die Reservierung enthält</span><span class="sxs-lookup"><span data-stu-id="6e04a-147">The <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> that currently holds the reservation.</span></span></param>
        <summary><span data-ttu-id="6e04a-148">Übergibt das Recht, den Besitz der durch die <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />-Struktur identifizierten Nachricht von dieser <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> an die <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />-Schnittstelle zu übergeben</span><span class="sxs-lookup"><span data-stu-id="6e04a-148">Releases the right to pass the ownership of the message identified by the <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> from this <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> to the <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 <span data-ttu-id="6e04a-149">Die <xref:System.Threading.Tasks.Dataflow.ITargetBlock`1> , die die Reservierung enthält, muss von dieser Instanz nicht verknüpft werden <xref:System.Threading.Tasks.Dataflow.ISourceBlock`1> .</span><span class="sxs-lookup"><span data-stu-id="6e04a-149">The <xref:System.Threading.Tasks.Dataflow.ITargetBlock`1> that holds the reservation need not be linked from this <xref:System.Threading.Tasks.Dataflow.ISourceBlock`1> instance.</span></span> <span data-ttu-id="6e04a-150">Außerdem hat diese <xref:System.Threading.Tasks.Dataflow.ISourceBlock`1> Instanz die Nachricht möglicherweise niemals direkt dem bereitgestellt <xref:System.Threading.Tasks.Dataflow.ITargetBlock`1> .</span><span class="sxs-lookup"><span data-stu-id="6e04a-150">Moreover, this <xref:System.Threading.Tasks.Dataflow.ISourceBlock`1> instance may have never offered the message directly to the <xref:System.Threading.Tasks.Dataflow.ITargetBlock`1>.</span></span>
<span data-ttu-id="6e04a-151">Es ist erforderlich, dass diese Nachricht zuvor für denselben reserviert wurde <xref:System.Threading.Tasks.Dataflow.ITargetBlock`1> .</span><span class="sxs-lookup"><span data-stu-id="6e04a-151">It is required that this message has been previously reserved for the same <xref:System.Threading.Tasks.Dataflow.ITargetBlock`1>.</span></span>
 

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6e04a-152">Der <paramref name="messageHeader" /> ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="6e04a-152">The <paramref name="messageHeader" /> is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6e04a-153">Der <paramref name="target" />-Parameter ist <see langword="null" /> (Nichts in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="6e04a-153">The <paramref name="target" /> is <see langword="null" /> (Nothing in Visual Basic).</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6e04a-154">Das <paramref name="target" /> hatte die Meldung nicht reserviert.</span><span class="sxs-lookup"><span data-stu-id="6e04a-154">The <paramref name="target" /> did not have the message reserved.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;.ReserveMessage">
      <MemberSignature Language="C#" Value="bool ISourceBlock&lt;Tuple&lt;T1,T2,T3&gt;&gt;.ReserveMessage (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, System.Threading.Tasks.Dataflow.ITargetBlock&lt;Tuple&lt;T1,T2,T3&gt;&gt; target);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;.ReserveMessage(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;class System.Tuple`3&lt;!T1, !T2, !T3&gt;&gt; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.JoinBlock`3.System#Threading#Tasks#Dataflow#ISourceBlock&lt;System#Tuple&lt;T1,T2,T3&gt;&gt;#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{System.Tuple{`0,`1,`2}})" />
      <MemberSignature Language="VB.NET" Value="Function ReserveMessage (messageHeader As DataflowMessageHeader, target As ITargetBlock(Of Tuple(Of T1, T2, T3))) As Boolean Implements ISourceBlock(Of Tuple(Of T1, T2, T3)).ReserveMessage" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;.ReserveMessage(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, System::Threading::Tasks::Dataflow::ITargetBlock&lt;Tuple&lt;T1, T2, T3&gt; ^&gt; ^ target) = System::Threading::Tasks::Dataflow::ISourceBlock&lt;Tuple&lt;T1, T2, T3&gt; ^&gt;::ReserveMessage;" />
      <MemberSignature Language="F#" Value="abstract member System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;.ReserveMessage : System.Threading.Tasks.Dataflow.DataflowMessageHeader * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T1 * 'T2 * 'T3&gt; -&gt; bool&#xA;override this.System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;.ReserveMessage : System.Threading.Tasks.Dataflow.DataflowMessageHeader * System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T1 * 'T2 * 'T3&gt; -&gt; bool" Usage="joinBlock.System.Threading.Tasks.Dataflow.ISourceBlock&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;.ReserveMessage (messageHeader, target)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="messageHeader"><span data-ttu-id="6e04a-155">Die <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />-Struktur der Nachricht, die reserviert werden soll</span><span class="sxs-lookup"><span data-stu-id="6e04a-155">The <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> of the message that is to be reserved.</span></span></param>
        <param name="target"><span data-ttu-id="6e04a-156">Die <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />-Struktur, für die die Nachricht reserviert werden soll</span><span class="sxs-lookup"><span data-stu-id="6e04a-156">The <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> for which the message is to be reserved.</span></span></param>
        <summary><span data-ttu-id="6e04a-157">Behält sich das Recht vor, den Besitz der durch die <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" />-Struktur identifizierten Nachricht von dieser <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> an die <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />-Schnittstelle zu übergeben</span><span class="sxs-lookup"><span data-stu-id="6e04a-157">Reserves the right to pass the ownership of the message identified by the <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> from this <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> to the <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />.</span></span></summary>
        <returns><span data-ttu-id="6e04a-158"><see langword="true" />, wenn die Nachricht erfolgreich reserviert wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="6e04a-158"><see langword="true" /> if the message was successfully reserved; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="6e04a-159">Der <xref:System.Threading.Tasks.Dataflow.ITargetBlock`1> , für den die Nachricht reserviert werden soll, muss von dieser Instanz nicht verknüpft werden <xref:System.Threading.Tasks.Dataflow.ISourceBlock`1> .</span><span class="sxs-lookup"><span data-stu-id="6e04a-159">The <xref:System.Threading.Tasks.Dataflow.ITargetBlock`1> for which the message is to be reserved need not be linked from this <xref:System.Threading.Tasks.Dataflow.ISourceBlock`1> instance.</span></span> <span data-ttu-id="6e04a-160">Außerdem hat diese <xref:System.Threading.Tasks.Dataflow.ISourceBlock`1> Instanz die Nachricht möglicherweise niemals direkt dem bereitgestellt <xref:System.Threading.Tasks.Dataflow.ITargetBlock`1> .</span><span class="sxs-lookup"><span data-stu-id="6e04a-160">Moreover, this <xref:System.Threading.Tasks.Dataflow.ISourceBlock`1> instance may have never offered the message directly to the <xref:System.Threading.Tasks.Dataflow.ITargetBlock`1>.</span></span>

<span data-ttu-id="6e04a-161">Wenn `true` zurückgegeben wird, müssen Sie anschließend entweder <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A> oder <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A> für diese Nachricht mit dem gleichen <xref:System.Threading.Tasks.Dataflow.DataflowMessageHeader> und dem-Befehl Abrufen <xref:System.Threading.Tasks.Dataflow.ITargetBlock`1> .</span><span class="sxs-lookup"><span data-stu-id="6e04a-161">If `true` is returned, you must subsequently call either <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A> or <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A> for this message with the same <xref:System.Threading.Tasks.Dataflow.DataflowMessageHeader> and <xref:System.Threading.Tasks.Dataflow.ITargetBlock`1>.</span></span> <span data-ttu-id="6e04a-162">Wenn Sie dies nicht tun, kann die Quelle eventuell keine weiteren Nachrichten an ein Ziel weitergeben.</span><span class="sxs-lookup"><span data-stu-id="6e04a-162">If you don't, the source may be unable to propagate any further messages to any target.</span></span>

<span data-ttu-id="6e04a-163"><xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A>Wenn das Ziel interne Sperren speichert, wird nicht aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="6e04a-163">Don't call <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A> while the target is holding any internal locks.</span></span> <span data-ttu-id="6e04a-164">Dies verstößt gegen die Sperr Hierarchie, die notwendig ist, um Deadlocks in einem Datenfluss Netzwerk zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="6e04a-164">Doing so will violate the lock hierarchy necessary to avoid deadlocks in a dataflow network.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6e04a-165">Der <paramref name="messageHeader" /> ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="6e04a-165">The <paramref name="messageHeader" /> is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6e04a-166">Der <paramref name="target" />-Parameter ist <see langword="null" /> (Nichts in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="6e04a-166">The <paramref name="target" /> is <see langword="null" /> (Nothing in Visual Basic).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Target1">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Dataflow.ITargetBlock&lt;T1&gt; Target1 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!T1&gt; Target1" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.JoinBlock`3.Target1" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target1 As ITargetBlock(Of T1)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::Dataflow::ITargetBlock&lt;T1&gt; ^ Target1 { System::Threading::Tasks::Dataflow::ITargetBlock&lt;T1&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target1 : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T1&gt;" Usage="System.Threading.Tasks.Dataflow.JoinBlock&lt;'T1, 'T2, 'T3&gt;.Target1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Dataflow.ITargetBlock&lt;T1&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6e04a-167">Ruft ein Ziel ab, das verwendet werden kann, um Meldungen des ersten Typs anzubieten.</span><span class="sxs-lookup"><span data-stu-id="6e04a-167">Gets a target that may be used to offer messages of the first type.</span></span></summary>
        <value><span data-ttu-id="6e04a-168">Das Ziel.</span><span class="sxs-lookup"><span data-stu-id="6e04a-168">The target.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Target2">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Dataflow.ITargetBlock&lt;T2&gt; Target2 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!T2&gt; Target2" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.JoinBlock`3.Target2" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target2 As ITargetBlock(Of T2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::Dataflow::ITargetBlock&lt;T2&gt; ^ Target2 { System::Threading::Tasks::Dataflow::ITargetBlock&lt;T2&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target2 : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T2&gt;" Usage="System.Threading.Tasks.Dataflow.JoinBlock&lt;'T1, 'T2, 'T3&gt;.Target2" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Dataflow.ITargetBlock&lt;T2&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6e04a-169">Ruft ein Ziel ab, das verwendet werden kann, um Meldungen des zweiten Typs anzubieten.</span><span class="sxs-lookup"><span data-stu-id="6e04a-169">Gets a target that may be used to offer messages of the second type.</span></span></summary>
        <value><span data-ttu-id="6e04a-170">Das Ziel.</span><span class="sxs-lookup"><span data-stu-id="6e04a-170">The target.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Target3">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Dataflow.ITargetBlock&lt;T3&gt; Target3 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!T3&gt; Target3" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.JoinBlock`3.Target3" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target3 As ITargetBlock(Of T3)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::Dataflow::ITargetBlock&lt;T3&gt; ^ Target3 { System::Threading::Tasks::Dataflow::ITargetBlock&lt;T3&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target3 : System.Threading.Tasks.Dataflow.ITargetBlock&lt;'T3&gt;" Usage="System.Threading.Tasks.Dataflow.JoinBlock&lt;'T1, 'T2, 'T3&gt;.Target3" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Dataflow.ITargetBlock&lt;T3&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6e04a-171">Ruft ein Ziel ab, das verwendet werden kann, um Meldungen des dritten Typs anzubieten.</span><span class="sxs-lookup"><span data-stu-id="6e04a-171">Gets a target that may be used to offer messages of the third type.</span></span></summary>
        <value><span data-ttu-id="6e04a-172">Das Ziel.</span><span class="sxs-lookup"><span data-stu-id="6e04a-172">The target.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.JoinBlock`3.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="joinBlock.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6e04a-173">Gibt eine Zeichenfolge zurück, die den formatierten Namen dieser <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />-Instanz darstellt.</span><span class="sxs-lookup"><span data-stu-id="6e04a-173">Returns a string that represents the formatted name of this  <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> instance.</span></span></summary>
        <returns><span data-ttu-id="6e04a-174">Eine Zeichenfolge, die den formatierten Namen dieser <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />-Instanz darstellt.</span><span class="sxs-lookup"><span data-stu-id="6e04a-174">A string that represents the formatted name of this <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6e04a-175">Wird von geerbt  <xref:System.Object> .</span><span class="sxs-lookup"><span data-stu-id="6e04a-175">Inherited from  <xref:System.Object> .</span></span> <span data-ttu-id="6e04a-176">Verwendet die-  <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.NameFormat%2A> Option.</span><span class="sxs-lookup"><span data-stu-id="6e04a-176">Uses the  <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.NameFormat%2A> option.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReceive">
      <MemberSignature Language="C#" Value="public bool TryReceive (Predicate&lt;Tuple&lt;T1,T2,T3&gt;&gt; filter, out Tuple&lt;T1,T2,T3&gt; item);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryReceive(class System.Predicate`1&lt;class System.Tuple`3&lt;!T1, !T2, !T3&gt;&gt; filter, [out] class System.Tuple`3&lt;!T1, !T2, !T3&gt;&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.JoinBlock`3.TryReceive(System.Predicate{System.Tuple{`0,`1,`2}},System.Tuple{`0,`1,`2}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReceive (filter As Predicate(Of Tuple(Of T1, T2, T3)), ByRef item As Tuple(Of T1, T2, T3)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryReceive(Predicate&lt;Tuple&lt;T1, T2, T3&gt; ^&gt; ^ filter, [Runtime::InteropServices::Out] Tuple&lt;T1, T2, T3&gt; ^ % item);" />
      <MemberSignature Language="F#" Value="abstract member TryReceive : Predicate&lt;'T1 * 'T2 * 'T3&gt; * Tuple -&gt; bool&#xA;override this.TryReceive : Predicate&lt;'T1 * 'T2 * 'T3&gt; * Tuple -&gt; bool" Usage="joinBlock.TryReceive (filter, item)" />
      <MemberSignature Language="C#" Value="public bool TryReceive (Predicate&lt;Tuple&lt;T1,T2,T3&gt;&gt;? filter, out Tuple&lt;T1,T2,T3&gt;? item);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Predicate&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;" />
        <Parameter Name="item" Type="System.Tuple&lt;T1,T2,T3&gt;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="filter"><span data-ttu-id="6e04a-177">Der Prädikatswert muss erfolgreich übergeben werden, damit er empfangen wird.</span><span class="sxs-lookup"><span data-stu-id="6e04a-177">The predicate value must successfully pass in order for it to be received.</span></span>  <span data-ttu-id="6e04a-178"><paramref name="filter" /> ist möglicherweise <see langword="null" />, in diesem Fall werden alle Elemente übergeben.</span><span class="sxs-lookup"><span data-stu-id="6e04a-178"><paramref name="filter" /> may be <see langword="null" />, in which case all items will pass.</span></span></param>
        <param name="item"><span data-ttu-id="6e04a-179">Das von der Quelle empfangene Element.</span><span class="sxs-lookup"><span data-stu-id="6e04a-179">The item received from the source.</span></span></param>
        <summary><span data-ttu-id="6e04a-180">Versucht, ein verfügbares Output-Element von<see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" /> synchron zu empfangen.</span><span class="sxs-lookup"><span data-stu-id="6e04a-180">Attempts to synchronously receive an available output item from the <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</span></span></summary>
        <returns><span data-ttu-id="6e04a-181"><see langword="true" />, wenn ein Element empfangen werden konnte; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="6e04a-181"><see langword="true" /> if an item could be received; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6e04a-182">Diese Methode blockiert nicht, wenn Sie darauf wartet, dass die Quelle ein Element bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="6e04a-182">This method does not block waiting for the source to provide an item.</span></span>  
  
 <span data-ttu-id="6e04a-183">Es wird nach dem Überprüfen auf ein Element zurückgegeben, unabhängig davon, ob ein Element verfügbar war.</span><span class="sxs-lookup"><span data-stu-id="6e04a-183">It will return after checking for an element, whether or not an element was available.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReceiveAll">
      <MemberSignature Language="C#" Value="public bool TryReceiveAll (out System.Collections.Generic.IList&lt;Tuple&lt;T1,T2,T3&gt;&gt; items);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryReceiveAll([out] class System.Collections.Generic.IList`1&lt;class System.Tuple`3&lt;!T1, !T2, !T3&gt;&gt;&amp; items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.JoinBlock`3.TryReceiveAll(System.Collections.Generic.IList{System.Tuple{`0,`1,`2}}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReceiveAll (ByRef items As IList(Of Tuple(Of T1, T2, T3))) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryReceiveAll([Runtime::InteropServices::Out] System::Collections::Generic::IList&lt;Tuple&lt;T1, T2, T3&gt; ^&gt; ^ % items);" />
      <MemberSignature Language="F#" Value="abstract member TryReceiveAll : IList -&gt; bool&#xA;override this.TryReceiveAll : IList -&gt; bool" Usage="joinBlock.TryReceiveAll items" />
      <MemberSignature Language="C#" Value="public bool TryReceiveAll (out System.Collections.Generic.IList&lt;Tuple&lt;T1,T2,T3&gt;&gt;? items);" FrameworkAlternate="net-5.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.5.25.0</AssemblyVersion>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
        <AssemblyVersion>4.6.4.0</AssemblyVersion>
        <AssemblyVersion>4.6.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="System.Collections.Generic.IList&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="items"><span data-ttu-id="6e04a-184">Die von der Quelle empfangenen Elemente.</span><span class="sxs-lookup"><span data-stu-id="6e04a-184">The items received from the source.</span></span></param>
        <summary><span data-ttu-id="6e04a-185">Versucht, alle verfügbaren Elemente aus <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" /> synchron zu empfangen.</span><span class="sxs-lookup"><span data-stu-id="6e04a-185">Attempts to synchronously receive all available items from the <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</span></span></summary>
        <returns><span data-ttu-id="6e04a-186"><see langword="true" />, wenn ein oder mehrere Elemente empfangen werden konnten; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="6e04a-186"><see langword="true" /> if one or more items could be received; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6e04a-187">Diese Methode blockiert nicht, wenn Sie darauf wartet, dass die Quelle ein Element bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="6e04a-187">This method does not block waiting for the source to provide an item.</span></span>  
  
 <span data-ttu-id="6e04a-188">Es wird nach der Überprüfung auf Elemente zurückgegeben, unabhängig davon, ob ein Element verfügbar war.</span><span class="sxs-lookup"><span data-stu-id="6e04a-188">It will return after checking for elements, whether or not an element was available.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
