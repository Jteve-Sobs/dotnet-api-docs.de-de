<Type Name="ILGenerator" FullName="System.Reflection.Emit.ILGenerator">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f8c6c6a27f5c1a529835042fd82865692f2b3388" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75169371" /></Metadata><TypeSignature Language="C#" Value="public class ILGenerator : System.Runtime.InteropServices._ILGenerator" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi beforefieldinit ILGenerator extends System.Object implements class System.Runtime.InteropServices._ILGenerator" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.ILGenerator" />
  <TypeSignature Language="VB.NET" Value="Public Class ILGenerator&#xA;Implements _ILGenerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class ILGenerator : System::Runtime::InteropServices::_ILGenerator" />
  <TypeSignature Language="F#" Value="type ILGenerator = class&#xA;    interface _ILGenerator" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._ILGenerator</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._ILGenerator))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="1699d-101">Generiert MSIL-Anweisungen (Microsoft Intermediate Language).</span><span class="sxs-lookup"><span data-stu-id="1699d-101">Generates Microsoft intermediate language (MSIL) instructions.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-102"><xref:System.Reflection.Emit.ILGenerator> wird verwendet, um Methoden Körper für Methoden und Konstruktoren in dynamischen Assemblys (dargestellt durch die Klassen <xref:System.Reflection.Emit.MethodBuilder> und <xref:System.Reflection.Emit.ConstructorBuilder>) und für eigenständige dynamische Methoden (dargestellt durch die <xref:System.Reflection.Emit.DynamicMethod>-Klasse) zu generieren.</span><span class="sxs-lookup"><span data-stu-id="1699d-102"><xref:System.Reflection.Emit.ILGenerator> is used to generate method bodies for methods and constructors in dynamic assemblies (represented by the <xref:System.Reflection.Emit.MethodBuilder> and <xref:System.Reflection.Emit.ConstructorBuilder> classes) and for standalone dynamic methods (represented by the <xref:System.Reflection.Emit.DynamicMethod> class).</span></span> <span data-ttu-id="1699d-103">Verwenden Sie zum Abrufen eines <xref:System.Reflection.Emit.ILGenerator>die Methoden <xref:System.Reflection.Emit.ConstructorBuilder.GetILGenerator%2A?displayProperty=nameWithType>, <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A?displayProperty=nameWithType>und <xref:System.Reflection.Emit.MethodBuilder.GetILGenerator%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1699d-103">To obtain an <xref:System.Reflection.Emit.ILGenerator>, use the <xref:System.Reflection.Emit.ConstructorBuilder.GetILGenerator%2A?displayProperty=nameWithType>, <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Emit.MethodBuilder.GetILGenerator%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="1699d-104">MSIL wird als Eingabe für einen JIT-Compiler (Just-in-Time) verwendet.</span><span class="sxs-lookup"><span data-stu-id="1699d-104">MSIL is used as input to a just-in-time (JIT) compiler.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="BeginCatchBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginCatchBlock (Type exceptionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginCatchBlock(class System.Type exceptionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginCatchBlock(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginCatchBlock (exceptionType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginCatchBlock(Type ^ exceptionType);" />
      <MemberSignature Language="F#" Value="abstract member BeginCatchBlock : Type -&gt; unit&#xA;override this.BeginCatchBlock : Type -&gt; unit" Usage="iLGenerator.BeginCatchBlock exceptionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exceptionType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="exceptionType"><span data-ttu-id="1699d-105">Das <see cref="T:System.Type" />-Objekt, das die Ausnahme darstellt.</span><span class="sxs-lookup"><span data-stu-id="1699d-105">The <see cref="T:System.Type" /> object that represents the exception.</span></span></param>
        <summary><span data-ttu-id="1699d-106">Beginnt einen Catch-Block.</span><span class="sxs-lookup"><span data-stu-id="1699d-106">Begins a catch block.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-107">Gibt eine Verzweigungs Anweisung am Ende des aktuellen Ausnahme Blocks aus.</span><span class="sxs-lookup"><span data-stu-id="1699d-107">Emits a branch instruction to the end of the current exception block.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1699d-108">Wenn der Filter Exception-Block die `constant exception_execute_handler` zurückgibt (siehe Dokumentation für den Common Language Infrastructure-Anweisungs Satz), wird das Argument für die `BeginCatchBlock` nicht geprüft.</span><span class="sxs-lookup"><span data-stu-id="1699d-108">If the filter exception block returns the `constant exception_execute_handler` (see the documentation for the Common Language Infrastructure Instruction Set), the argument to the `BeginCatchBlock` is not checked.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1699d-109">Im folgenden Codebeispiel wird die kontextabhängige Verwendung der `BeginCatchBlock`-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="1699d-109">The code sample below demonstrates the contextual usage of the `BeginCatchBlock` method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1699d-110">Der Catch-Block befindet sich in einer gefilterten Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="1699d-110">The catch block is within a filtered exception.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1699d-111"><paramref name="exceptionType" /> ist <see langword="null" />, und der Ausnahmefilterblock hat keinen Wert zurückgegeben, der anzeigt, dass Finally-Blöcke bis zum Auffinden dieses Catch-Blocks ausgeführt werden sollen.</span><span class="sxs-lookup"><span data-stu-id="1699d-111"><paramref name="exceptionType" /> is <see langword="null" />, and the exception filter block has not returned a value that indicates that finally blocks should be run until this catch block is located.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1699d-112">Die Microsoft Intermediate Language (MSIL), die generiert wird, befindet sich derzeit nicht in einem Ausnahmeblock.</span><span class="sxs-lookup"><span data-stu-id="1699d-112">The Microsoft intermediate language (MSIL) being generated is not currently in an exception block.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginExceptFilterBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginExceptFilterBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginExceptFilterBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginExceptFilterBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginExceptFilterBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginExceptFilterBlock();" />
      <MemberSignature Language="F#" Value="abstract member BeginExceptFilterBlock : unit -&gt; unit&#xA;override this.BeginExceptFilterBlock : unit -&gt; unit" Usage="iLGenerator.BeginExceptFilterBlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1699d-113">Beginnt einen Ausnahmeblock für eine gefilterte Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="1699d-113">Begins an exception block for a filtered exception.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-114">Gibt eine Verzweigungs Anweisung am Ende des aktuellen Ausnahme Blocks aus.</span><span class="sxs-lookup"><span data-stu-id="1699d-114">Emits a branch instruction to the end of the current exception block.</span></span>  
  
 <span data-ttu-id="1699d-115">Wenn die aktuelle <xref:System.Reflection.Emit.ILGenerator> einem <xref:System.Reflection.Emit.DynamicMethod> Objekt zugeordnet ist, wird das Ausgeben von gefilterten Ausnahme Blöcken nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1699d-115">If the current <xref:System.Reflection.Emit.ILGenerator> is associated with a <xref:System.Reflection.Emit.DynamicMethod> object, emitting filtered exception blocks is not supported.</span></span> <span data-ttu-id="1699d-116"><xref:System.Reflection.Emit.DynamicILInfo> kann verwendet werden, um eine dynamische Methode zu erstellen, die gefilterte Ausnahme Blöcke verwendet.</span><span class="sxs-lookup"><span data-stu-id="1699d-116"><xref:System.Reflection.Emit.DynamicILInfo> can be used to construct a dynamic method that uses filtered exception blocks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1699d-117">Die Microsoft Intermediate Language (MSIL), die generiert wird, befindet sich derzeit nicht in einem Ausnahmeblock.</span><span class="sxs-lookup"><span data-stu-id="1699d-117">The Microsoft intermediate language (MSIL) being generated is not currently in an exception block.</span></span>  
  
<span data-ttu-id="1699d-118">- oder -</span><span class="sxs-lookup"><span data-stu-id="1699d-118">-or-</span></span> 
<span data-ttu-id="1699d-119">Dieser <see cref="T:System.Reflection.Emit.ILGenerator" /> gehört zu einer <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span><span class="sxs-lookup"><span data-stu-id="1699d-119">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginExceptionBlock">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.Label BeginExceptionBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.Emit.Label BeginExceptionBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginExceptionBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginExceptionBlock () As Label" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::Label BeginExceptionBlock();" />
      <MemberSignature Language="F#" Value="abstract member BeginExceptionBlock : unit -&gt; System.Reflection.Emit.Label&#xA;override this.BeginExceptionBlock : unit -&gt; System.Reflection.Emit.Label" Usage="iLGenerator.BeginExceptionBlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.Label</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1699d-120">Beginnt einen Ausnahmeblock für eine nicht gefilterte Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="1699d-120">Begins an exception block for a non-filtered exception.</span></span></summary>
        <returns><span data-ttu-id="1699d-121">Die Sprungmarke für das Ende des Blocks.</span><span class="sxs-lookup"><span data-stu-id="1699d-121">The label for the end of the block.</span></span> <span data-ttu-id="1699d-122">Durch diese befinden Sie sich an der richtigen Stelle zum Ausführen von finally-Blöcken oder zum Beenden von try.</span><span class="sxs-lookup"><span data-stu-id="1699d-122">This will leave you in the correct place to execute finally blocks or to finish the try.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-123">Beim Erstellen eines Ausnahme Blocks werden einige Informationen aufgezeichnet, aber es wird nicht tatsächlich eine Microsoft Intermediate Language (MSIL) auf den Stream ausgegeben.</span><span class="sxs-lookup"><span data-stu-id="1699d-123">Creating an exception block records some information, but does not actually emit any Microsoft intermediate language (MSIL) onto the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1699d-124">Im folgenden Codebeispiel wird die kontextabhängige Verwendung der `BeginExceptionBlock`-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="1699d-124">The code sample below demonstrates the contextual usage of the `BeginExceptionBlock` method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginFaultBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginFaultBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginFaultBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginFaultBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginFaultBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginFaultBlock();" />
      <MemberSignature Language="F#" Value="abstract member BeginFaultBlock : unit -&gt; unit&#xA;override this.BeginFaultBlock : unit -&gt; unit" Usage="iLGenerator.BeginFaultBlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1699d-125">Beginnt einen Ausnahmefehlerblock im MSIL-Stream (Microsoft Intermediate Language).</span><span class="sxs-lookup"><span data-stu-id="1699d-125">Begins an exception fault block in the Microsoft intermediate language (MSIL) stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-126">Wenn die aktuelle <xref:System.Reflection.Emit.ILGenerator> einem <xref:System.Reflection.Emit.DynamicMethod>-Objekt zugeordnet ist, wird das Ausgeben von Ausnahme Fehler Blöcken nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1699d-126">If the current <xref:System.Reflection.Emit.ILGenerator> is associated with a <xref:System.Reflection.Emit.DynamicMethod> object, emitting exception fault blocks is not supported.</span></span> <span data-ttu-id="1699d-127"><xref:System.Reflection.Emit.DynamicILInfo> kann verwendet werden, um eine dynamische Methode zu erstellen, die Ausnahme Fehler Blöcke verwendet.</span><span class="sxs-lookup"><span data-stu-id="1699d-127"><xref:System.Reflection.Emit.DynamicILInfo> can be used to construct a dynamic method that uses exception fault blocks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1699d-128">Im folgenden Codebeispiel wird die Verwendung von `BeginFaultBlock`veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="1699d-128">The following code sample illustrates the use of `BeginFaultBlock`.</span></span>  
  
 [!code-cpp[ILGenerator_BeginFaultBlock#1](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_BeginFaultBlock/CPP/ilgenerator_beginfaultblock.cpp#1)]
 [!code-csharp[ILGenerator_BeginFaultBlock#1](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_BeginFaultBlock/CS/ilgenerator_beginfaultblock.cs#1)]
 [!code-vb[ILGenerator_BeginFaultBlock#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_BeginFaultBlock/VB/ilgenerator_beginfaultblock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1699d-129">Die generierte MSIL befindet sich derzeit nicht in einem Ausnahmeblock.</span><span class="sxs-lookup"><span data-stu-id="1699d-129">The MSIL being generated is not currently in an exception block.</span></span>  
  
<span data-ttu-id="1699d-130">- oder -</span><span class="sxs-lookup"><span data-stu-id="1699d-130">-or-</span></span> 
<span data-ttu-id="1699d-131">Dieser <see cref="T:System.Reflection.Emit.ILGenerator" /> gehört zu einer <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span><span class="sxs-lookup"><span data-stu-id="1699d-131">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFinallyBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginFinallyBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginFinallyBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginFinallyBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginFinallyBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginFinallyBlock();" />
      <MemberSignature Language="F#" Value="abstract member BeginFinallyBlock : unit -&gt; unit&#xA;override this.BeginFinallyBlock : unit -&gt; unit" Usage="iLGenerator.BeginFinallyBlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1699d-132">Beginnt einen finally-Block im MSIL-Anweisungsstream (Microsoft Intermediate Language).</span><span class="sxs-lookup"><span data-stu-id="1699d-132">Begins a finally block in the Microsoft intermediate language (MSIL) instruction stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="1699d-133">Im folgenden Codebeispiel wird die Verwendung von `BeginFinallyBlock`veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="1699d-133">The following code sample illustrates the use of `BeginFinallyBlock`.</span></span>  
  
 [!code-cpp[ILGenerator_BeginFinallyBlock_2#2](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_BeginFinallyBlock_2/CPP/ILGenerator_BeginFinallyBlock_2.cpp#2)]
 [!code-csharp[ILGenerator_BeginFinallyBlock_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_BeginFinallyBlock_2/CS/ilgenerator_beginfinallyblock_2.cs#2)]
 [!code-vb[ILGenerator_BeginFinallyBlock_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_BeginFinallyBlock_2/VB/ilgenerator_beginfinallyblock_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1699d-134">Die generierte MSIL befindet sich derzeit nicht in einem Ausnahmeblock.</span><span class="sxs-lookup"><span data-stu-id="1699d-134">The MSIL being generated is not currently in an exception block.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginScope">
      <MemberSignature Language="C#" Value="public virtual void BeginScope ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginScope" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginScope ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginScope();" />
      <MemberSignature Language="F#" Value="abstract member BeginScope : unit -&gt; unit&#xA;override this.BeginScope : unit -&gt; unit" Usage="iLGenerator.BeginScope " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1699d-135">Leitet einen lexikalischen Gültigkeitsbereich ein.</span><span class="sxs-lookup"><span data-stu-id="1699d-135">Begins a lexical scope.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-136">Diese Methode wird verwendet, um symbolische Informationen auszugeben.</span><span class="sxs-lookup"><span data-stu-id="1699d-136">This method is used to emit symbolic information.</span></span> <span data-ttu-id="1699d-137">Lokale Variablen, die nach <xref:System.Reflection.Emit.ILGenerator.BeginScope%2A> deklariert werden, werden so lange begrenzt, bis die entsprechende <xref:System.Reflection.Emit.ILGenerator.EndScope%2A> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="1699d-137">Local variables declared after <xref:System.Reflection.Emit.ILGenerator.BeginScope%2A> are scoped until the corresponding <xref:System.Reflection.Emit.ILGenerator.EndScope%2A> is called.</span></span>  
  
 <span data-ttu-id="1699d-138">Wenn die aktuelle <xref:System.Reflection.Emit.ILGenerator> einem <xref:System.Reflection.Emit.DynamicMethod> Objekt zugeordnet ist, werden keine symbolischen Informationen unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1699d-138">If the current <xref:System.Reflection.Emit.ILGenerator> is associated with a <xref:System.Reflection.Emit.DynamicMethod> object, it does not support symbolic information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1699d-139">Im folgenden Codebeispiel wird die Verwendung von `BeginScope` und `EndScope`veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="1699d-139">The following code sample illustrates the use of `BeginScope` and `EndScope`.</span></span>  
  
 [!code-cpp[ILGenerator_Begin_EndScope#2](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CPP/ilgenerator_begin_endscope.cpp#2)]
 [!code-csharp[ILGenerator_Begin_EndScope#2](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CS/ilgenerator_begin_endscope.cs#2)]
 [!code-vb[ILGenerator_Begin_EndScope#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_Begin_EndScope/VB/ilgenerator_begin_endscope.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1699d-140">Dieser <see cref="T:System.Reflection.Emit.ILGenerator" /> gehört zu einer <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span><span class="sxs-lookup"><span data-stu-id="1699d-140">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeclareLocal">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1699d-141">Deklariert eine lokale Variable.</span><span class="sxs-lookup"><span data-stu-id="1699d-141">Declares a local variable.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeclareLocal">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.LocalBuilder DeclareLocal (Type localType);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.LocalBuilder DeclareLocal(class System.Type localType) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.DeclareLocal(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeclareLocal (localType As Type) As LocalBuilder" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::LocalBuilder ^ DeclareLocal(Type ^ localType);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member DeclareLocal : Type -&gt; System.Reflection.Emit.LocalBuilder&#xA;override this.DeclareLocal : Type -&gt; System.Reflection.Emit.LocalBuilder" Usage="iLGenerator.DeclareLocal localType" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.LocalBuilder DeclareLocal (Type localType);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.LocalBuilder DeclareLocal(class System.Type localType) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Function DeclareLocal (localType As Type) As LocalBuilder" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::LocalBuilder ^ DeclareLocal(Type ^ localType);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="member this.DeclareLocal : Type -&gt; System.Reflection.Emit.LocalBuilder" Usage="iLGenerator.DeclareLocal localType" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.LocalBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="localType"><span data-ttu-id="1699d-142">Ein <see cref="T:System.Type" />-Objekt, das den Typ der lokalen Variablen darstellt.</span><span class="sxs-lookup"><span data-stu-id="1699d-142">A <see cref="T:System.Type" /> object that represents the type of the local variable.</span></span></param>
        <summary><span data-ttu-id="1699d-143">Deklariert eine lokale Variable vom angegebenen Typ.</span><span class="sxs-lookup"><span data-stu-id="1699d-143">Declares a local variable of the specified type.</span></span></summary>
        <returns><span data-ttu-id="1699d-144">Die deklarierte lokale Variable.</span><span class="sxs-lookup"><span data-stu-id="1699d-144">The declared local variable.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-145">Die lokale Variable wird im aktuellen lexikalischen Gültigkeitsbereich erstellt. Wenn z. b. Code in einer `for` Schleife (`For` Schleife in Visual Basic) ausgegeben wird, ist der Gültigkeitsbereich der Variablen die Schleife.</span><span class="sxs-lookup"><span data-stu-id="1699d-145">The local variable is created in the current lexical scope; for example, if code is being emitted in a `for` loop (`For` loop in Visual Basic), the scope of the variable is the loop.</span></span>  
  
 <span data-ttu-id="1699d-146">Eine lokale Variable, die mit dieser Überladung erstellt wurde, ist nicht fixiert.</span><span class="sxs-lookup"><span data-stu-id="1699d-146">A local variable created with this overload is not pinned.</span></span> <span data-ttu-id="1699d-147">Um eine angeheftete Variable für die Verwendung mit nicht verwalteten Zeigern zu erstellen, verwenden Sie die <xref:System.Reflection.Emit.ILGenerator.DeclareLocal%28System.Type%2CSystem.Boolean%29>-Methoden Überladung.</span><span class="sxs-lookup"><span data-stu-id="1699d-147">To create a pinned variable for use with unmanaged pointers, use the <xref:System.Reflection.Emit.ILGenerator.DeclareLocal%28System.Type%2CSystem.Boolean%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1699d-148">Im folgenden Codebeispiel wird die Verwendung der `DeclareLocal`-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="1699d-148">The following code example demonstrates the use of the `DeclareLocal` method.</span></span> <span data-ttu-id="1699d-149">Dieser Code ist Teil eines größeren Code Beispiels für die <xref:System.Reflection.Emit.LocalBuilder>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="1699d-149">This code is part of a larger code example for the <xref:System.Reflection.Emit.LocalBuilder> class.</span></span>  
  
 [!code-cpp[LocalBuilder_Sample_SetLocalSymInfo#2](~/samples/snippets/cpp/VS_Snippets_CLR/LocalBuilder_Sample_SetLocalSymInfo/CPP/localbuilder_sample_4.cpp#2)]
 [!code-csharp[LocalBuilder_Sample_SetLocalSymInfo#2](~/samples/snippets/csharp/VS_Snippets_CLR/LocalBuilder_Sample_SetLocalSymInfo/CS/localbuilder_sample_4.cs#2)]
 [!code-vb[LocalBuilder_Sample_SetLocalSymInfo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/LocalBuilder_Sample_SetLocalSymInfo/VB/localbuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1699d-150"><paramref name="localType" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1699d-150"><paramref name="localType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1699d-151">Der enthaltende Typ wurde von der <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />-Methode erstellt.</span><span class="sxs-lookup"><span data-stu-id="1699d-151">The containing type has been created by the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DeclareLocal">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.LocalBuilder DeclareLocal (Type localType, bool pinned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.LocalBuilder DeclareLocal(class System.Type localType, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.DeclareLocal(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeclareLocal (localType As Type, pinned As Boolean) As LocalBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::LocalBuilder ^ DeclareLocal(Type ^ localType, bool pinned);" />
      <MemberSignature Language="F#" Value="abstract member DeclareLocal : Type * bool -&gt; System.Reflection.Emit.LocalBuilder&#xA;override this.DeclareLocal : Type * bool -&gt; System.Reflection.Emit.LocalBuilder" Usage="iLGenerator.DeclareLocal (localType, pinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.LocalBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localType" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pinned" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localType"><span data-ttu-id="1699d-152">Ein <see cref="T:System.Type" />-Objekt, das den Typ der lokalen Variablen darstellt.</span><span class="sxs-lookup"><span data-stu-id="1699d-152">A <see cref="T:System.Type" /> object that represents the type of the local variable.</span></span></param>
        <param name="pinned"><span data-ttu-id="1699d-153"><see langword="true" />, um das Objekt im Arbeitsspeicher zu fixieren; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="1699d-153"><see langword="true" /> to pin the object in memory; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1699d-154">Deklariert eine lokale Variable des angegebenen Typs und fixiert optional das Objekt, auf das von der Variablen verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="1699d-154">Declares a local variable of the specified type, optionally pinning the object referred to by the variable.</span></span></summary>
        <returns><span data-ttu-id="1699d-155">Ein <see cref="T:System.Reflection.Emit.LocalBuilder" />-Objekt, das die lokale Variable darstellt.</span><span class="sxs-lookup"><span data-stu-id="1699d-155">A <see cref="T:System.Reflection.Emit.LocalBuilder" /> object that represents the local variable.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-156">Die lokale Variable wird im aktuellen lexikalischen Gültigkeitsbereich erstellt. Wenn z. b. Code in einer `for` Schleife (`For` Schleife in Visual Basic) ausgegeben wird, ist der Gültigkeitsbereich der Variablen die Schleife.</span><span class="sxs-lookup"><span data-stu-id="1699d-156">The local variable is created in the current lexical scope; for example, if code is being emitted in a `for` loop (`For` loop in Visual Basic), the scope of the variable is the loop.</span></span>  
  
 <span data-ttu-id="1699d-157">In unsicherem Code muss ein Objekt fixiert werden, bevor ein nicht verwalteter Zeiger darauf verweisen kann.</span><span class="sxs-lookup"><span data-stu-id="1699d-157">In unsafe code, an object must be pinned before it can be referred to by an unmanaged pointer.</span></span> <span data-ttu-id="1699d-158">Obwohl das Objekt, auf das verwiesen wird, fixiert ist, kann es nicht von Garbage Collection verschoben werden.</span><span class="sxs-lookup"><span data-stu-id="1699d-158">While the referenced object is pinned, it cannot be moved by garbage collection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1699d-159"><paramref name="localType" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1699d-159"><paramref name="localType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1699d-160">Der enthaltende Typ wurde von der <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />-Methode erstellt.</span><span class="sxs-lookup"><span data-stu-id="1699d-160">The containing type has been created by the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span></span>  
  
<span data-ttu-id="1699d-161">- oder -</span><span class="sxs-lookup"><span data-stu-id="1699d-161">-or-</span></span> 
<span data-ttu-id="1699d-162">Der Methodentext der einschließenden Methode wurde von der <see cref="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)" />-Methode erstellt.</span><span class="sxs-lookup"><span data-stu-id="1699d-162">The method body of the enclosing method has been created by the <see cref="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)" /> method.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1699d-163">Die Methode, der dieser <see cref="T:System.Reflection.Emit.ILGenerator" /> zugeordnet ist, wird nicht von einem <see cref="T:System.Reflection.Emit.MethodBuilder" /> dargestellt.</span><span class="sxs-lookup"><span data-stu-id="1699d-163">The method with which this <see cref="T:System.Reflection.Emit.ILGenerator" /> is associated is not represented by a <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineLabel">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.Label DefineLabel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.Emit.Label DefineLabel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.DefineLabel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DefineLabel () As Label" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::Label DefineLabel();" />
      <MemberSignature Language="F#" Value="abstract member DefineLabel : unit -&gt; System.Reflection.Emit.Label&#xA;override this.DefineLabel : unit -&gt; System.Reflection.Emit.Label" Usage="iLGenerator.DefineLabel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.Label</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1699d-164">Deklariert eine neue Sprungmarke.</span><span class="sxs-lookup"><span data-stu-id="1699d-164">Declares a new label.</span></span></summary>
        <returns><span data-ttu-id="1699d-165">Eine neue Bezeichnung, die als Token für Verzweigungen verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="1699d-165">A new label that can be used as a token for branching.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-166">Um die Position der Bezeichnung innerhalb des Streams festzulegen, müssen Sie <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>abrufen.</span><span class="sxs-lookup"><span data-stu-id="1699d-166">To set the position of the label within the stream, you must call <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>.</span></span> <span data-ttu-id="1699d-167">Andernfalls führt dies zu einer <xref:System.ArgumentException>, wenn <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="1699d-167">Failure to do so will cause an <xref:System.ArgumentException> when <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> is called.</span></span>
  
 <span data-ttu-id="1699d-168">Dies ist nur ein Token, das noch keine bestimmte Position innerhalb des Streams darstellt.</span><span class="sxs-lookup"><span data-stu-id="1699d-168">This is just a token and does not yet represent any particular location within the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1699d-169">Im folgenden Codebeispiel wird die kontextabhängige Verwendung der `DefineLabel`-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="1699d-169">The code sample below demonstrates the contextual usage of the `DefineLabel` method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.Label Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.Label Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.Label Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.Label Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.Label Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.Label Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Emit">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1699d-170">Fügt eine Anweisung in den MSIL-Stream (Microsoft Intermediate Language) für den JIT-Compiler (Just-In-Time) ein.</span><span class="sxs-lookup"><span data-stu-id="1699d-170">Puts an instruction onto the Microsoft Intermediate Language (MSIL) stream for the just-in-time (JIT) compiler.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode -&gt; unit" Usage="iLGenerator.Emit opcode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="1699d-171">Die in den Stream einzufügende MSIL-Anweisung (Microsoft Intermediate Language).</span><span class="sxs-lookup"><span data-stu-id="1699d-171">The Microsoft Intermediate Language (MSIL) instruction to be put onto the stream.</span></span></param>
        <summary><span data-ttu-id="1699d-172">Fügt die angegebene Anweisung in den Anweisungsstream ein.</span><span class="sxs-lookup"><span data-stu-id="1699d-172">Puts the specified instruction onto the stream of instructions.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-173">Wenn der `opcode`-Parameter ein Argument erfordert, muss der Aufrufer sicherstellen, dass die Argument Länge mit der Länge des deklarierten Parameters übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="1699d-173">If the `opcode` parameter requires an argument, the caller must ensure that the argument length matches the length of the declared parameter.</span></span> <span data-ttu-id="1699d-174">Andernfalls sind die Ergebnisse unvorhersehbar.</span><span class="sxs-lookup"><span data-stu-id="1699d-174">Otherwise, results will be unpredictable.</span></span> <span data-ttu-id="1699d-175">Wenn die Ausgabe Anweisung z. b. einen 2-Byte-Operanden erfordert und der Aufrufer einen 4-Byte-Operanden bereitstellt, gibt die Laufzeit zwei zusätzliche Bytes an den Anweisungs Datenstrom aus.</span><span class="sxs-lookup"><span data-stu-id="1699d-175">For example, if the Emit instruction requires a 2-byte operand and the caller supplies a 4-byte operand, the runtime will emit two additional bytes to the instruction stream.</span></span> <span data-ttu-id="1699d-176">Diese zusätzlichen Bytes werden <xref:System.Reflection.Emit.OpCodes.Nop> Anweisungen.</span><span class="sxs-lookup"><span data-stu-id="1699d-176">These extra bytes will be <xref:System.Reflection.Emit.OpCodes.Nop> instructions.</span></span>  
  
 <span data-ttu-id="1699d-177">Die Anweisungs Werte werden in <xref:System.Reflection.Emit.OpCodes>definiert.</span><span class="sxs-lookup"><span data-stu-id="1699d-177">The instruction values are defined in <xref:System.Reflection.Emit.OpCodes>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1699d-178">Das folgende Codebeispiel veranschaulicht die Verwendung von `Emit`, um eine MSIL-Ausgabe über eine Instanz von <xref:System.Reflection.Emit.ILGenerator>zu generieren.</span><span class="sxs-lookup"><span data-stu-id="1699d-178">The code sample below demonstrates the use of `Emit` to generate MSIL output via an instance of <xref:System.Reflection.Emit.ILGenerator>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, byte arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, unsigned int8 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Byte arg);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * byte -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * byte -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="1699d-179">Die an den Stream auszugebende MSIL-Anweisung.</span><span class="sxs-lookup"><span data-stu-id="1699d-179">The MSIL instruction to be put onto the stream.</span></span></param>
        <param name="arg"><span data-ttu-id="1699d-180">Das unmittelbar hinter der Anweisung in den Stream eingefügte Zeichenargument.</span><span class="sxs-lookup"><span data-stu-id="1699d-180">The character argument pushed onto the stream immediately after the instruction.</span></span></param>
        <summary><span data-ttu-id="1699d-181">Fügt die angegebene Anweisung und das Zeichenargument in den MSIL-Anweisungsstream (Microsoft Intermediate Language) ein.</span><span class="sxs-lookup"><span data-stu-id="1699d-181">Puts the specified instruction and character argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-182">Die Anweisungs Werte werden in der `OpCodes`-Enumeration definiert.</span><span class="sxs-lookup"><span data-stu-id="1699d-182">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, double arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, float64 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, double arg);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * double -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * double -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="1699d-183">Die an den Stream auszugebende MSIL-Anweisung.</span><span class="sxs-lookup"><span data-stu-id="1699d-183">The MSIL instruction to be put onto the stream.</span></span> <span data-ttu-id="1699d-184">In der <see langword="OpCodes" />-Enumeration definiert.</span><span class="sxs-lookup"><span data-stu-id="1699d-184">Defined in the <see langword="OpCodes" /> enumeration.</span></span></param>
        <param name="arg"><span data-ttu-id="1699d-185">Das unmittelbar hinter der Anweisung in den Stream eingefügte numerische Argument.</span><span class="sxs-lookup"><span data-stu-id="1699d-185">The numerical argument pushed onto the stream immediately after the instruction.</span></span></param>
        <summary><span data-ttu-id="1699d-186">Fügt die angegebene Anweisung und das numerische Argument in den MSIL-Anweisungsstream (Microsoft Intermediate Language) ein.</span><span class="sxs-lookup"><span data-stu-id="1699d-186">Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-187">Die Anweisungs Werte werden in der `OpCodes`-Enumeration definiert.</span><span class="sxs-lookup"><span data-stu-id="1699d-187">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, short arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int16 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Int16)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, short arg);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * int16 -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * int16 -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="1699d-188">Die MSIL-Anweisung, die in den Datenstrom ausgegeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="1699d-188">The MSIL instruction to be emitted onto the stream.</span></span></param>
        <param name="arg"><span data-ttu-id="1699d-189">Das unmittelbar hinter der Anweisung in den Stream eingefügte <see langword="Int" />-Argument.</span><span class="sxs-lookup"><span data-stu-id="1699d-189">The <see langword="Int" /> argument pushed onto the stream immediately after the instruction.</span></span></param>
        <summary><span data-ttu-id="1699d-190">Fügt die angegebene Anweisung und das numerische Argument in den MSIL-Anweisungsstream (Microsoft Intermediate Language) ein.</span><span class="sxs-lookup"><span data-stu-id="1699d-190">Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-191">Die Anweisungs Werte werden in der `OpCodes`-Enumeration definiert.</span><span class="sxs-lookup"><span data-stu-id="1699d-191">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, int arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int32 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, int arg);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * int -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * int -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="1699d-192">Die an den Stream auszugebende MSIL-Anweisung.</span><span class="sxs-lookup"><span data-stu-id="1699d-192">The MSIL instruction to be put onto the stream.</span></span></param>
        <param name="arg"><span data-ttu-id="1699d-193">Das unmittelbar hinter der Anweisung in den Stream eingefügte numerische Argument.</span><span class="sxs-lookup"><span data-stu-id="1699d-193">The numerical argument pushed onto the stream immediately after the instruction.</span></span></param>
        <summary><span data-ttu-id="1699d-194">Fügt die angegebene Anweisung und das numerische Argument in den MSIL-Anweisungsstream (Microsoft Intermediate Language) ein.</span><span class="sxs-lookup"><span data-stu-id="1699d-194">Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-195">Die Anweisungs Werte werden in der `OpCodes`-Enumeration definiert.</span><span class="sxs-lookup"><span data-stu-id="1699d-195">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, long arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int64 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, long arg);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * int64 -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * int64 -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="1699d-196">Die an den Stream auszugebende MSIL-Anweisung.</span><span class="sxs-lookup"><span data-stu-id="1699d-196">The MSIL instruction to be put onto the stream.</span></span></param>
        <param name="arg"><span data-ttu-id="1699d-197">Das unmittelbar hinter der Anweisung in den Stream eingefügte numerische Argument.</span><span class="sxs-lookup"><span data-stu-id="1699d-197">The numerical argument pushed onto the stream immediately after the instruction.</span></span></param>
        <summary><span data-ttu-id="1699d-198">Fügt die angegebene Anweisung und das numerische Argument in den MSIL-Anweisungsstream (Microsoft Intermediate Language) ein.</span><span class="sxs-lookup"><span data-stu-id="1699d-198">Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-199">Die Anweisungs Werte werden in der `OpCodes`-Enumeration definiert.</span><span class="sxs-lookup"><span data-stu-id="1699d-199">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.ConstructorInfo con);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.ConstructorInfo con) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::ConstructorInfo ^ con);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.ConstructorInfo -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.ConstructorInfo -&gt; unit" Usage="iLGenerator.Emit (opcode, con)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="1699d-200">Die MSIL-Anweisung, die in den Datenstrom ausgegeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="1699d-200">The MSIL instruction to be emitted onto the stream.</span></span></param>
        <param name="con"><span data-ttu-id="1699d-201">Eine <see langword="ConstructorInfo" />, die einen Konstruktor darstellt.</span><span class="sxs-lookup"><span data-stu-id="1699d-201">A <see langword="ConstructorInfo" /> representing a constructor.</span></span></param>
        <summary><span data-ttu-id="1699d-202">Fügt die angegebene Anweisung und das Metadatentoken für den angegebenen Konstruktor in den MSIL-Anweisungsstream (Microsoft Intermediate Language) ein.</span><span class="sxs-lookup"><span data-stu-id="1699d-202">Puts the specified instruction and metadata token for the specified constructor onto the Microsoft intermediate language (MSIL) stream of instructions.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-203">Die Anweisungs Werte werden in der `OpCodes`-Enumeration definiert.</span><span class="sxs-lookup"><span data-stu-id="1699d-203">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 <span data-ttu-id="1699d-204">Der Speicherort `con` wird aufgezeichnet, sodass der Anweisungs Datenstrom bei Bedarf gepatcht werden kann, wenn das Modul in einer portablen ausführbaren Datei (PE) beibehalten wird.</span><span class="sxs-lookup"><span data-stu-id="1699d-204">The location of `con` is recorded so that the instruction stream can be patched if necessary when persisting the module to a portable executable (PE) file.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1699d-205"><paramref name="con" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1699d-205"><paramref name="con" /> is <see langword="null" />.</span></span> <span data-ttu-id="1699d-206">Diese Ausnahme ist in [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] neu.</span><span class="sxs-lookup"><span data-stu-id="1699d-206">This exception is new in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)].</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.Label label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Reflection.Emit.Label label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::Emit::Label label);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.Label -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.Label -&gt; unit" Usage="iLGenerator.Emit (opcode, label)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="label" Type="System.Reflection.Emit.Label" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="1699d-207">Die MSIL-Anweisung, die in den Datenstrom ausgegeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="1699d-207">The MSIL instruction to be emitted onto the stream.</span></span></param>
        <param name="label"><span data-ttu-id="1699d-208">Die Sprungmarke, zu der von dieser Position aus verzweigt werden soll.</span><span class="sxs-lookup"><span data-stu-id="1699d-208">The label to which to branch from this location.</span></span></param>
        <summary><span data-ttu-id="1699d-209">Fügt die angegebene Anweisung in den MSIL-Stream (Microsoft Intermediate Language) ein und lässt für den Fall von Korrekturen Platz zum Einfügen einer Sprungmarke.</span><span class="sxs-lookup"><span data-stu-id="1699d-209">Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream and leaves space to include a label when fixes are done.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-210">Die Anweisungs Werte werden in der `OpCodes`-Enumeration definiert.</span><span class="sxs-lookup"><span data-stu-id="1699d-210">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 <span data-ttu-id="1699d-211">Bezeichnungen werden mithilfe von <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A>erstellt, und ihre Position im Stream wird mithilfe <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>korrigiert.</span><span class="sxs-lookup"><span data-stu-id="1699d-211">Labels are created using <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A>, and their location within the stream is fixed by using <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>.</span></span> <span data-ttu-id="1699d-212">Wenn eine Einzel Byte Anweisung verwendet wird, kann die Bezeichnung einen Sprung von höchstens 127 Bytes entlang des Streams darstellen.</span><span class="sxs-lookup"><span data-stu-id="1699d-212">If a single-byte instruction is used, the label can represent a jump of at most 127 bytes along the stream.</span></span> <span data-ttu-id="1699d-213">`opcode` müssen eine Verzweigungs Anweisung darstellen.</span><span class="sxs-lookup"><span data-stu-id="1699d-213">`opcode` must represent a branch instruction.</span></span> <span data-ttu-id="1699d-214">Da branches relative Anweisungen sind, werden `label` während des fixupprozesses durch den korrekten Offset zum Branch ersetzt.</span><span class="sxs-lookup"><span data-stu-id="1699d-214">Because branches are relative instructions, `label` will be replaced with the correct offset to branch during the fixup process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1699d-215">Das folgende Codebeispiel veranschaulicht die Erstellung einer dynamischen Methode mit einer Sprung Tabelle.</span><span class="sxs-lookup"><span data-stu-id="1699d-215">The code sample below illustrates the creation of a dynamic method with a jump table.</span></span> <span data-ttu-id="1699d-216">Die Sprung Tabelle wird mit einem Array von <xref:System.Reflection.Emit.Label>erstellt.</span><span class="sxs-lookup"><span data-stu-id="1699d-216">The jump table is built using an array of <xref:System.Reflection.Emit.Label>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.Label[] labels);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Reflection.Emit.Label[] labels) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, cli::array &lt;System::Reflection::Emit::Label&gt; ^ labels);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.Label[] -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.Label[] -&gt; unit" Usage="iLGenerator.Emit (opcode, labels)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="labels" Type="System.Reflection.Emit.Label[]" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="1699d-217">Die MSIL-Anweisung, die in den Datenstrom ausgegeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="1699d-217">The MSIL instruction to be emitted onto the stream.</span></span></param>
        <param name="labels"><span data-ttu-id="1699d-218">Das Array von Sprungmarkenobjekten, zu denen von dieser Position aus verzweigt werden soll.</span><span class="sxs-lookup"><span data-stu-id="1699d-218">The array of label objects to which to branch from this location.</span></span> <span data-ttu-id="1699d-219">Es werden alle Sprungmarken verwendet.</span><span class="sxs-lookup"><span data-stu-id="1699d-219">All of the labels will be used.</span></span></param>
        <summary><span data-ttu-id="1699d-220">Fügt die angegebene Anweisung in den MSIL-Stream (Microsoft Intermediate Language) ein und lässt für den Fall von Korrekturen Platz zum Einfügen einer Sprungmarke.</span><span class="sxs-lookup"><span data-stu-id="1699d-220">Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream and leaves space to include a label when fixes are done.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-221">Gibt eine switchtabelle aus.</span><span class="sxs-lookup"><span data-stu-id="1699d-221">Emits a switch table.</span></span>  
  
 <span data-ttu-id="1699d-222">Die Anweisungs Werte werden in der `OpCodes`-Enumeration definiert.</span><span class="sxs-lookup"><span data-stu-id="1699d-222">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 <span data-ttu-id="1699d-223">Bezeichnungen werden mithilfe von <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A> erstellt, und ihre Position im Stream wird mithilfe <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>korrigiert.</span><span class="sxs-lookup"><span data-stu-id="1699d-223">Labels are created using <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A> and their location within the stream is fixed by using <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>.</span></span> <span data-ttu-id="1699d-224">Wenn eine Einzel Byte Anweisung verwendet wird, kann die Bezeichnung einen Sprung von höchstens 127 Bytes entlang des Streams darstellen.</span><span class="sxs-lookup"><span data-stu-id="1699d-224">If a single-byte instruction is used, the label can represent a jump of at most 127 bytes along the stream.</span></span> <span data-ttu-id="1699d-225">`opcode` müssen eine Verzweigungs Anweisung darstellen.</span><span class="sxs-lookup"><span data-stu-id="1699d-225">`opcode` must represent a branch instruction.</span></span> <span data-ttu-id="1699d-226">Da branches relative Anweisungen sind, werden `label` während des fixupprozesses durch den korrekten Offset zum Branch ersetzt.</span><span class="sxs-lookup"><span data-stu-id="1699d-226">Because branches are relative instructions, `label` will be replaced with the correct offset to branch during the fixup process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1699d-227">Das folgende Codebeispiel veranschaulicht die Erstellung einer dynamischen Methode mit einer Sprung Tabelle.</span><span class="sxs-lookup"><span data-stu-id="1699d-227">The code sample below illustrates the creation of a dynamic method with a jump table.</span></span> <span data-ttu-id="1699d-228">Die Sprung Tabelle wird mit einem Array von <xref:System.Reflection.Emit.Label>erstellt.</span><span class="sxs-lookup"><span data-stu-id="1699d-228">The jump table is built using an array of <xref:System.Reflection.Emit.Label>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1699d-229"><paramref name="con" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1699d-229"><paramref name="con" /> is <see langword="null" />.</span></span> <span data-ttu-id="1699d-230">Diese Ausnahme ist in [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] neu.</span><span class="sxs-lookup"><span data-stu-id="1699d-230">This exception is new in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)].</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.LocalBuilder local);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.Emit.LocalBuilder local) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.LocalBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::Emit::LocalBuilder ^ local);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.LocalBuilder -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.LocalBuilder -&gt; unit" Usage="iLGenerator.Emit (opcode, local)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="local" Type="System.Reflection.Emit.LocalBuilder" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="1699d-231">Die MSIL-Anweisung, die in den Datenstrom ausgegeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="1699d-231">The MSIL instruction to be emitted onto the stream.</span></span></param>
        <param name="local"><span data-ttu-id="1699d-232">Eine lokale Variable.</span><span class="sxs-lookup"><span data-stu-id="1699d-232">A local variable.</span></span></param>
        <summary><span data-ttu-id="1699d-233">Fügt die angegebene Anweisung in den MSIL-Stream (Microsoft Intermediate Language) ein, gefolgt vom Index der angegebenen lokalen Variable.</span><span class="sxs-lookup"><span data-stu-id="1699d-233">Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the index of the given local variable.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-234">Die Anweisungs Werte werden in der `OpCodes`-Enumeration definiert.</span><span class="sxs-lookup"><span data-stu-id="1699d-234">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1699d-235">Die übergeordnete Methode des <paramref name="local" />-Parameters stimmt nicht mit der Methode überein, die diesem <see cref="T:System.Reflection.Emit.ILGenerator" /> zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="1699d-235">The parent method of the <paramref name="local" /> parameter does not match the method associated with this <see cref="T:System.Reflection.Emit.ILGenerator" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1699d-236"><paramref name="local" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1699d-236"><paramref name="local" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1699d-237"><paramref name="opcode" /> ist eine Einzelbyteanweisung, und <paramref name="local" /> stellt eine lokale Variable mit einem Index dar, der größer als <see langword="Byte.MaxValue" /> ist.</span><span class="sxs-lookup"><span data-stu-id="1699d-237"><paramref name="opcode" /> is a single-byte instruction, and <paramref name="local" /> represents a local variable with an index greater than <see langword="Byte.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.SignatureHelper signature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.Emit.SignatureHelper signature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.SignatureHelper)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::Emit::SignatureHelper ^ signature);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.SignatureHelper -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.Emit.SignatureHelper -&gt; unit" Usage="iLGenerator.Emit (opcode, signature)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="signature" Type="System.Reflection.Emit.SignatureHelper" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="1699d-238">Die MSIL-Anweisung, die in den Datenstrom ausgegeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="1699d-238">The MSIL instruction to be emitted onto the stream.</span></span></param>
        <param name="signature"><span data-ttu-id="1699d-239">Ein Helper zum Erstellen eines Signaturtokens.</span><span class="sxs-lookup"><span data-stu-id="1699d-239">A helper for constructing a signature token.</span></span></param>
        <summary><span data-ttu-id="1699d-240">Fügt die angegebene Anweisung und ein Signaturtoken in den MSIL-Anweisungsstream (Microsoft Intermediate Language) ein.</span><span class="sxs-lookup"><span data-stu-id="1699d-240">Puts the specified instruction and a signature token onto the Microsoft intermediate language (MSIL) stream of instructions.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-241">Die Anweisungs Werte werden in der `OpCodes`-Enumeration definiert.</span><span class="sxs-lookup"><span data-stu-id="1699d-241">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1699d-242"><paramref name="signature" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1699d-242"><paramref name="signature" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::FieldInfo ^ field);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.FieldInfo -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.FieldInfo -&gt; unit" Usage="iLGenerator.Emit (opcode, field)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="1699d-243">Die MSIL-Anweisung, die in den Datenstrom ausgegeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="1699d-243">The MSIL instruction to be emitted onto the stream.</span></span></param>
        <param name="field"><span data-ttu-id="1699d-244">Eine <see langword="FieldInfo" />, die ein Feld darstellt.</span><span class="sxs-lookup"><span data-stu-id="1699d-244">A <see langword="FieldInfo" /> representing a field.</span></span></param>
        <summary><span data-ttu-id="1699d-245">Fügt die angegebene Anweisung und das Metadatentoken für das angegebene Feld in den MSIL-Anweisungsstream (Microsoft Intermediate Language) ein.</span><span class="sxs-lookup"><span data-stu-id="1699d-245">Puts the specified instruction and metadata token for the specified field onto the Microsoft intermediate language (MSIL) stream of instructions.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-246">Die Anweisungs Werte werden in der `OpCodes`-Enumeration definiert.</span><span class="sxs-lookup"><span data-stu-id="1699d-246">The instruction values are defined in the `OpCodes` enumeration.</span></span> <span data-ttu-id="1699d-247">Der Speicherort `field` wird aufgezeichnet, sodass der Anweisungs Datenstrom bei Bedarf gepatcht werden kann, wenn das Modul in einer portablen ausführbaren Datei (PE) beibehalten wird.</span><span class="sxs-lookup"><span data-stu-id="1699d-247">The location of `field` is recorded so that the instruction stream can be patched if necessary when persisting the module to a portable executable (PE) file.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.MethodInfo meth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.MethodInfo meth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::MethodInfo ^ meth);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * System.Reflection.MethodInfo -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * System.Reflection.MethodInfo -&gt; unit" Usage="iLGenerator.Emit (opcode, meth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="meth" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="1699d-248">Die MSIL-Anweisung, die in den Datenstrom ausgegeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="1699d-248">The MSIL instruction to be emitted onto the stream.</span></span></param>
        <param name="meth"><span data-ttu-id="1699d-249">Eine <see langword="MethodInfo" />, die eine Methode darstellt.</span><span class="sxs-lookup"><span data-stu-id="1699d-249">A <see langword="MethodInfo" /> representing a method.</span></span></param>
        <summary><span data-ttu-id="1699d-250">Fügt die angegebene Anweisung in den MSIL-Stream (Microsoft Intermediate Language) ein, gefolgt vom Metadatentoken für die angegebene Methode.</span><span class="sxs-lookup"><span data-stu-id="1699d-250">Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the metadata token for the given method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-251">Die Anweisungs Werte werden in der `OpCodes`-Enumeration definiert.</span><span class="sxs-lookup"><span data-stu-id="1699d-251">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 <span data-ttu-id="1699d-252">Der Speicherort `meth` wird aufgezeichnet, sodass der Anweisungs Datenstrom bei Bedarf gepatcht werden kann, wenn das Modul in einer portablen ausführbaren Datei (PE) beibehalten wird.</span><span class="sxs-lookup"><span data-stu-id="1699d-252">The location of `meth` is recorded so that the instruction stream can be patched if necessary when persisting the module to a portable executable (PE) file.</span></span>  
  
 <span data-ttu-id="1699d-253">Wenn `meth` eine generische Methode darstellt, muss es sich um eine generische Methoden Definition handeln.</span><span class="sxs-lookup"><span data-stu-id="1699d-253">If `meth` represents a generic method, it must be a generic method definition.</span></span> <span data-ttu-id="1699d-254">Das heißt, die zugehörige [MethodInfo. IsGenericMethodDefinition](xref:System.Reflection.MethodBase.IsGenericMethodDefinition) -Eigenschaft muss `true`werden.</span><span class="sxs-lookup"><span data-stu-id="1699d-254">That is, its [MethodInfo.IsGenericMethodDefinition](xref:System.Reflection.MethodBase.IsGenericMethodDefinition) property must be `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1699d-255"><paramref name="meth" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1699d-255"><paramref name="meth" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1699d-256"><paramref name="meth" /> ist eine generische Methode, für die die <see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />-Eigenschaft <see langword="false" /> ist.</span><span class="sxs-lookup"><span data-stu-id="1699d-256"><paramref name="meth" /> is a generic method for which the <see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public void Emit (System.Reflection.Emit.OpCode opcode, sbyte arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int8 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Emit(System::Reflection::Emit::OpCode opcode, System::SByte arg);" />
      <MemberSignature Language="F#" Value="member this.Emit : System.Reflection.Emit.OpCode * sbyte -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="1699d-257">Die an den Stream auszugebende MSIL-Anweisung.</span><span class="sxs-lookup"><span data-stu-id="1699d-257">The MSIL instruction to be put onto the stream.</span></span></param>
        <param name="arg"><span data-ttu-id="1699d-258">Das unmittelbar hinter der Anweisung in den Stream eingefügte Zeichenargument.</span><span class="sxs-lookup"><span data-stu-id="1699d-258">The character argument pushed onto the stream immediately after the instruction.</span></span></param>
        <summary><span data-ttu-id="1699d-259">Fügt die angegebene Anweisung und das Zeichenargument in den MSIL-Anweisungsstream (Microsoft Intermediate Language) ein.</span><span class="sxs-lookup"><span data-stu-id="1699d-259">Puts the specified instruction and character argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-260">Die Anweisungs Werte werden in der `OpCodes`-Enumeration definiert.</span><span class="sxs-lookup"><span data-stu-id="1699d-260">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, float arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, float32 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, float arg);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * single -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * single -&gt; unit" Usage="iLGenerator.Emit (opcode, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="1699d-261">Die an den Stream auszugebende MSIL-Anweisung.</span><span class="sxs-lookup"><span data-stu-id="1699d-261">The MSIL instruction to be put onto the stream.</span></span></param>
        <param name="arg"><span data-ttu-id="1699d-262">Das unmittelbar hinter der Anweisung in den Stream eingefügte <see langword="Single" />-Argument.</span><span class="sxs-lookup"><span data-stu-id="1699d-262">The <see langword="Single" /> argument pushed onto the stream immediately after the instruction.</span></span></param>
        <summary><span data-ttu-id="1699d-263">Fügt die angegebene Anweisung und das numerische Argument in den MSIL-Anweisungsstream (Microsoft Intermediate Language) ein.</span><span class="sxs-lookup"><span data-stu-id="1699d-263">Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-264">Die Anweisungs Werte werden in der `OpCodes`-Enumeration definiert.</span><span class="sxs-lookup"><span data-stu-id="1699d-264">The instruction values are defined in the `OpCodes` enumeration.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, string str);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::String ^ str);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * string -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * string -&gt; unit" Usage="iLGenerator.Emit (opcode, str)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="1699d-265">Die MSIL-Anweisung, die in den Datenstrom ausgegeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="1699d-265">The MSIL instruction to be emitted onto the stream.</span></span></param>
        <param name="str"><span data-ttu-id="1699d-266">Der auszugebende <see langword="String" />.</span><span class="sxs-lookup"><span data-stu-id="1699d-266">The <see langword="String" /> to be emitted.</span></span></param>
        <summary><span data-ttu-id="1699d-267">Fügt die angegebene Anweisung in den MSIL-Stream (Microsoft Intermediate Language) ein, gefolgt vom Metadatentoken für die angegebene Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1699d-267">Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the metadata token for the given string.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-268">Die Anweisungs Werte werden in der `OpCodes`-Enumeration definiert.</span><span class="sxs-lookup"><span data-stu-id="1699d-268">The instruction values are defined in the `OpCodes` enumeration.</span></span> <span data-ttu-id="1699d-269">Der Speicherort `str` wird für zukünftige Fixups aufgezeichnet, wenn das Modul in einer portablen ausführbaren Datei (PE) gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="1699d-269">The location of `str` is recorded for future fixups if the module is persisted to a portable executable (PE) file.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, Type cls);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Type cls) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, Type ^ cls);" />
      <MemberSignature Language="F#" Value="abstract member Emit : System.Reflection.Emit.OpCode * Type -&gt; unit&#xA;override this.Emit : System.Reflection.Emit.OpCode * Type -&gt; unit" Usage="iLGenerator.Emit (opcode, cls)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="cls" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="1699d-270">Die an den Stream auszugebende MSIL-Anweisung.</span><span class="sxs-lookup"><span data-stu-id="1699d-270">The MSIL instruction to be put onto the stream.</span></span></param>
        <param name="cls"><span data-ttu-id="1699d-271">Ein <see langword="Type" />.</span><span class="sxs-lookup"><span data-stu-id="1699d-271">A <see langword="Type" />.</span></span></param>
        <summary><span data-ttu-id="1699d-272">Fügt die angegebene Anweisung in den MSIL-Stream (Microsoft Intermediate Language) ein, gefolgt vom Metadatentoken für den angegebenen Typ.</span><span class="sxs-lookup"><span data-stu-id="1699d-272">Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the metadata token for the given type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-273">Die Anweisungs Werte werden in der `OpCodes`-Enumeration definiert.</span><span class="sxs-lookup"><span data-stu-id="1699d-273">The instruction values are defined in the `OpCodes` enumeration.</span></span> <span data-ttu-id="1699d-274">Der Speicherort `cls` wird aufgezeichnet, damit das Token bei Bedarf gepatcht werden kann, wenn das Modul in einer portablen ausführbaren Datei (PE) beibehalten wird.</span><span class="sxs-lookup"><span data-stu-id="1699d-274">The location of `cls` is recorded so that the token can be patched if necessary when persisting the module to a portable executable (PE) file.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1699d-275"><paramref name="cls" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1699d-275"><paramref name="cls" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EmitCall">
      <MemberSignature Language="C#" Value="public virtual void EmitCall (System.Reflection.Emit.OpCode opcode, System.Reflection.MethodInfo methodInfo, Type[] optionalParameterTypes);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitCall(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.MethodInfo methodInfo, class System.Type[] optionalParameterTypes) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitCall(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo,System.Type[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitCall(System::Reflection::Emit::OpCode opcode, System::Reflection::MethodInfo ^ methodInfo, cli::array &lt;Type ^&gt; ^ optionalParameterTypes);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member EmitCall : System.Reflection.Emit.OpCode * System.Reflection.MethodInfo * Type[] -&gt; unit&#xA;override this.EmitCall : System.Reflection.Emit.OpCode * System.Reflection.MethodInfo * Type[] -&gt; unit" Usage="iLGenerator.EmitCall (opcode, methodInfo, optionalParameterTypes)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public void EmitCall (System.Reflection.Emit.OpCode opcode, System.Reflection.MethodInfo methodInfo, Type[] optionalParameterTypes);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EmitCall(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.MethodInfo methodInfo, class System.Type[] optionalParameterTypes) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EmitCall(System::Reflection::Emit::OpCode opcode, System::Reflection::MethodInfo ^ methodInfo, cli::array &lt;Type ^&gt; ^ optionalParameterTypes);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="member this.EmitCall : System.Reflection.Emit.OpCode * System.Reflection.MethodInfo * Type[] -&gt; unit" Usage="iLGenerator.EmitCall (opcode, methodInfo, optionalParameterTypes)" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="optionalParameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="1699d-276">Die MSIL-Anweisung, die in den Datenstrom ausgegeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="1699d-276">The MSIL instruction to be emitted onto the stream.</span></span> <span data-ttu-id="1699d-277">Muss <see cref="F:System.Reflection.Emit.OpCodes.Call" />, <see cref="F:System.Reflection.Emit.OpCodes.Callvirt" /> oder <see cref="F:System.Reflection.Emit.OpCodes.Newobj" /> sein.</span><span class="sxs-lookup"><span data-stu-id="1699d-277">Must be <see cref="F:System.Reflection.Emit.OpCodes.Call" />, <see cref="F:System.Reflection.Emit.OpCodes.Callvirt" />, or <see cref="F:System.Reflection.Emit.OpCodes.Newobj" />.</span></span></param>
        <param name="methodInfo"><span data-ttu-id="1699d-278">Ruft die <see langword="varargs" />-Methode ab, die aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="1699d-278">The <see langword="varargs" /> method to be called.</span></span></param>
        <param name="optionalParameterTypes"><span data-ttu-id="1699d-279">Die Typen der optionalen Argumente, wenn die Methode eine <see langword="varargs" />-Methode ist, andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1699d-279">The types of the optional arguments if the method is a <see langword="varargs" /> method; otherwise, <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="1699d-280">Fügt eine <see langword="call" />- oder <see langword="callvirt" />-Anweisung in den MSIL-Datenstrom (Microsoft Intermediate Language) ein, um eine <see langword="varargs" />-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1699d-280">Puts a <see langword="call" /> or <see langword="callvirt" /> instruction onto the Microsoft intermediate language (MSIL) stream to call a <see langword="varargs" /> method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-281">Die <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A>-Methode wird verwendet, um Aufrufe an `varargs` Methoden auszugeben, da keine Überladung der <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methode vorhanden ist, die die Parametertypen der Variablen Argumente angibt.</span><span class="sxs-lookup"><span data-stu-id="1699d-281">The <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> method is used to emit calls to `varargs` methods because there is no overload of the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method that specifies the parameter types of the variable arguments.</span></span>  
  
 <span data-ttu-id="1699d-282">Verwenden Sie die <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29>-Methoden Überladung, um Aufrufe von Methoden auszugeben, die nicht die <xref:System.Reflection.CallingConventions.VarArgs> Aufruf Konvention verwenden.</span><span class="sxs-lookup"><span data-stu-id="1699d-282">To emit calls to methods that do not use the <xref:System.Reflection.CallingConventions.VarArgs> calling convention, use the <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29> method overload.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="1699d-283">Versionsinformationen</span><span class="sxs-lookup"><span data-stu-id="1699d-283">Version Information</span></span>  
 <span data-ttu-id="1699d-284">Ab der .NET Framework Version 2,0 löst die <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A>-Methode keine Ausnahme aus, wenn optionale Parametertypen für eine Methode angegeben werden, die nicht `varargs`ist.</span><span class="sxs-lookup"><span data-stu-id="1699d-284">Beginning with the .NET Framework version 2.0, the <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> method does not throw an exception when optional parameter types are specified for a method that is not `varargs`.</span></span> <span data-ttu-id="1699d-285"><xref:System.InvalidProgramException> wird ausgelöst, wenn der-Befehl ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="1699d-285"><xref:System.InvalidProgramException> is thrown when the call is executed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1699d-286">Im folgenden Codebeispiel werden zwei Methoden ausgegeben, eine `varargs`-Methode und eine-Methode, die die `varargs`-Methode aufruft.</span><span class="sxs-lookup"><span data-stu-id="1699d-286">The following code example emits two methods, a `varargs` method and a method that calls the `varargs` method.</span></span> <span data-ttu-id="1699d-287">Die `EmitCall`-Methode wird verwendet, um den aufzurufenden `varargs` Methode auszugeben.</span><span class="sxs-lookup"><span data-stu-id="1699d-287">The `EmitCall` method is used to emit the call to the `varargs` method.</span></span>  
  
 [!code-cpp[Emit.ArgIterator#1](~/samples/snippets/cpp/VS_Snippets_CLR/Emit.ArgIterator/cpp/source.cpp#1)]
 [!code-csharp[Emit.ArgIterator#1](~/samples/snippets/csharp/VS_Snippets_CLR/Emit.ArgIterator/cs/source.cs#1)]
 [!code-vb[Emit.ArgIterator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Emit.ArgIterator/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1699d-288"><paramref name="opcode" /> gibt keinen Methodenaufruf an.</span><span class="sxs-lookup"><span data-stu-id="1699d-288"><paramref name="opcode" /> does not specify a method call.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1699d-289"><paramref name="methodInfo" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1699d-289"><paramref name="methodInfo" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1699d-290">Die Aufrufkonvention für die Methode ist nicht <see langword="varargs" />, aber es werden optionale Parametertypen bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="1699d-290">The calling convention for the method is not <see langword="varargs" />, but optional parameter types are supplied.</span></span> <span data-ttu-id="1699d-291">Diese Ausnahme wird in den .NET Framework-Versionen 1.0 und 1.1 ausgelöst. In höheren Versionen wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="1699d-291">This exception is thrown in the .NET Framework versions 1.0 and 1.1, In subsequent versions, no exception is thrown.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EmitCalli">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1699d-292">Fügt eine <see cref="F:System.Reflection.Emit.OpCodes.Calli" />-Anweisung in den MSIL-Stream (Microsoft Intermediate Language) ein.</span><span class="sxs-lookup"><span data-stu-id="1699d-292">Puts a <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> instruction onto the Microsoft intermediate language (MSIL) stream.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EmitCalli">
      <MemberSignature Language="C#" Value="public virtual void EmitCalli (System.Reflection.Emit.OpCode opcode, System.Runtime.InteropServices.CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitCalli(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Runtime.InteropServices.CallingConvention unmanagedCallConv, class System.Type returnType, class System.Type[] parameterTypes) cil managed" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitCalli(System.Reflection.Emit.OpCode,System.Runtime.InteropServices.CallingConvention,System.Type,System.Type[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitCalli(System::Reflection::Emit::OpCode opcode, System::Runtime::InteropServices::CallingConvention unmanagedCallConv, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member EmitCalli : System.Reflection.Emit.OpCode * System.Runtime.InteropServices.CallingConvention * Type * Type[] -&gt; unit&#xA;override this.EmitCalli : System.Reflection.Emit.OpCode * System.Runtime.InteropServices.CallingConvention * Type * Type[] -&gt; unit" Usage="iLGenerator.EmitCalli (opcode, unmanagedCallConv, returnType, parameterTypes)" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public void EmitCalli (System.Reflection.Emit.OpCode opcode, System.Runtime.InteropServices.CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EmitCalli(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Runtime.InteropServices.CallingConvention unmanagedCallConv, class System.Type returnType, class System.Type[] parameterTypes) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EmitCalli(System::Reflection::Emit::OpCode opcode, System::Runtime::InteropServices::CallingConvention unmanagedCallConv, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="member this.EmitCalli : System.Reflection.Emit.OpCode * System.Runtime.InteropServices.CallingConvention * Type * Type[] -&gt; unit" Usage="iLGenerator.EmitCalli (opcode, unmanagedCallConv, returnType, parameterTypes)" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="unmanagedCallConv" Type="System.Runtime.InteropServices.CallingConvention" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="returnType" Type="System.Type" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="parameterTypes" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="1699d-293">Die MSIL-Anweisung, die in den Datenstrom ausgegeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="1699d-293">The MSIL instruction to be emitted onto the stream.</span></span> <span data-ttu-id="1699d-294">Dieser Wert muss <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> sein.</span><span class="sxs-lookup"><span data-stu-id="1699d-294">Must be <see cref="F:System.Reflection.Emit.OpCodes.Calli" />.</span></span></param>
        <param name="unmanagedCallConv"><span data-ttu-id="1699d-295">Die zu verwendende nicht verwaltete Aufrufkonvention.</span><span class="sxs-lookup"><span data-stu-id="1699d-295">The unmanaged calling convention to be used.</span></span></param>
        <param name="returnType"><span data-ttu-id="1699d-296">Der <see cref="T:System.Type" /> des Ergebnisses.</span><span class="sxs-lookup"><span data-stu-id="1699d-296">The <see cref="T:System.Type" /> of the result.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="1699d-297">Die Typen der für die Anweisung erforderlichen Argumente.</span><span class="sxs-lookup"><span data-stu-id="1699d-297">The types of the required arguments to the instruction.</span></span></param>
        <summary><span data-ttu-id="1699d-298">Fügt eine <see cref="F:System.Reflection.Emit.OpCodes.Calli" />-Anweisung in den MSIL-Stream (Microsoft Intermediate Language) ein, die eine nicht verwaltete Aufrufkonvention für den indirekten Aufruf angibt.</span><span class="sxs-lookup"><span data-stu-id="1699d-298">Puts a <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> instruction onto the Microsoft intermediate language (MSIL) stream, specifying an unmanaged calling convention for the indirect call.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-299">Verwenden Sie <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A>, um eine <xref:System.Reflection.Emit.OpCodes.Calli> Anweisung in den Stream einzufügen.</span><span class="sxs-lookup"><span data-stu-id="1699d-299">Use <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> to put a <xref:System.Reflection.Emit.OpCodes.Calli> instruction onto the stream.</span></span> <span data-ttu-id="1699d-300">Verwenden Sie nicht <xref:System.Reflection.Emit.ILGenerator.Emit%2A>.</span><span class="sxs-lookup"><span data-stu-id="1699d-300">Do not use <xref:System.Reflection.Emit.ILGenerator.Emit%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1699d-301">Im folgenden Codebeispiel wird die kontextbezogene Verwendung der <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A>-Methode veranschaulicht, um eine nicht verwaltete Typmethode außerhalb der dynamischen Klasse aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="1699d-301">The following code sample demonstrates the contextual usage of the <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> method to call an unmanaged type method external to the dynamic class.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.EmitCalli Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.EmitCalli Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.EmitCalli Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.EmitCalli Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.EmitCalli Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.EmitCalli Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmitCalli">
      <MemberSignature Language="C#" Value="public virtual void EmitCalli (System.Reflection.Emit.OpCode opcode, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitCalli(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type[] optionalParameterTypes) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitCalli(System.Reflection.Emit.OpCode,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitCalli(System::Reflection::Emit::OpCode opcode, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;Type ^&gt; ^ optionalParameterTypes);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member EmitCalli : System.Reflection.Emit.OpCode * System.Reflection.CallingConventions * Type * Type[] * Type[] -&gt; unit&#xA;override this.EmitCalli : System.Reflection.Emit.OpCode * System.Reflection.CallingConventions * Type * Type[] * Type[] -&gt; unit" Usage="iLGenerator.EmitCalli (opcode, callingConvention, returnType, parameterTypes, optionalParameterTypes)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public void EmitCalli (System.Reflection.Emit.OpCode opcode, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EmitCalli(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type[] optionalParameterTypes) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EmitCalli(System::Reflection::Emit::OpCode opcode, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;Type ^&gt; ^ optionalParameterTypes);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="member this.EmitCalli : System.Reflection.Emit.OpCode * System.Reflection.CallingConventions * Type * Type[] * Type[] -&gt; unit" Usage="iLGenerator.EmitCalli (opcode, callingConvention, returnType, parameterTypes, optionalParameterTypes)" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="optionalParameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="opcode"><span data-ttu-id="1699d-302">Die MSIL-Anweisung, die in den Datenstrom ausgegeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="1699d-302">The MSIL instruction to be emitted onto the stream.</span></span> <span data-ttu-id="1699d-303">Dieser Wert muss <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> sein.</span><span class="sxs-lookup"><span data-stu-id="1699d-303">Must be <see cref="F:System.Reflection.Emit.OpCodes.Calli" />.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="1699d-304">Die zu verwendende verwaltete Aufrufkonvention.</span><span class="sxs-lookup"><span data-stu-id="1699d-304">The managed calling convention to be used.</span></span></param>
        <param name="returnType"><span data-ttu-id="1699d-305">Der <see cref="T:System.Type" /> des Ergebnisses.</span><span class="sxs-lookup"><span data-stu-id="1699d-305">The <see cref="T:System.Type" /> of the result.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="1699d-306">Die Typen der für die Anweisung erforderlichen Argumente.</span><span class="sxs-lookup"><span data-stu-id="1699d-306">The types of the required arguments to the instruction.</span></span></param>
        <param name="optionalParameterTypes"><span data-ttu-id="1699d-307">Die Typen der optionalen Argumente für <see langword="varargs" />-Aufrufe.</span><span class="sxs-lookup"><span data-stu-id="1699d-307">The types of the optional arguments for <see langword="varargs" /> calls.</span></span></param>
        <summary><span data-ttu-id="1699d-308">Fügt eine <see cref="F:System.Reflection.Emit.OpCodes.Calli" />-Anweisung in den MSIL-Stream (Microsoft Intermediate Language) ein, die eine verwaltete Aufrufkonvention für den indirekten Aufruf angibt.</span><span class="sxs-lookup"><span data-stu-id="1699d-308">Puts a <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> instruction onto the Microsoft intermediate language (MSIL) stream, specifying a managed calling convention for the indirect call.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-309">Verwenden Sie <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A>, um eine <xref:System.Reflection.Emit.OpCodes.Calli> Anweisung in den Stream einzufügen.</span><span class="sxs-lookup"><span data-stu-id="1699d-309">Use <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> to put a <xref:System.Reflection.Emit.OpCodes.Calli> instruction onto the stream.</span></span> <span data-ttu-id="1699d-310">Verwenden Sie nicht <xref:System.Reflection.Emit.ILGenerator.Emit%2A>.</span><span class="sxs-lookup"><span data-stu-id="1699d-310">Do not use <xref:System.Reflection.Emit.ILGenerator.Emit%2A>.</span></span>  
  
 <span data-ttu-id="1699d-311">Wenn `optionalParameterTypes` optionale Argumente angibt, muss `callingConvention` das <xref:System.Reflection.CallingConventions.VarArgs?displayProperty=nameWithType>-Flag enthalten.</span><span class="sxs-lookup"><span data-stu-id="1699d-311">If `optionalParameterTypes` specifies optional arguments, `callingConvention` must include the <xref:System.Reflection.CallingConventions.VarArgs?displayProperty=nameWithType> flag.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1699d-312"><paramref name="optionalParameterTypes" /> ist <see langword="null" />, aber <paramref name="callingConvention" /> schließt das <see cref="F:System.Reflection.CallingConventions.VarArgs" />-Flag nicht ein.</span><span class="sxs-lookup"><span data-stu-id="1699d-312"><paramref name="optionalParameterTypes" /> is not <see langword="null" />, but <paramref name="callingConvention" /> does not include the <see cref="F:System.Reflection.CallingConventions.VarArgs" /> flag.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EmitWriteLine">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1699d-313">Hilfsfunktionen zum Ausgeben eines Aufrufs der <see cref="M:System.Console.WriteLine" />-Methode mit verschiedenen Werttypen.</span><span class="sxs-lookup"><span data-stu-id="1699d-313">Helper functions to emit a call to <see cref="M:System.Console.WriteLine" /> with different types of values.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EmitWriteLine">
      <MemberSignature Language="C#" Value="public virtual void EmitWriteLine (System.Reflection.Emit.LocalBuilder localBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitWriteLine(class System.Reflection.Emit.LocalBuilder localBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitWriteLine(System.Reflection.Emit.LocalBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitWriteLine(System::Reflection::Emit::LocalBuilder ^ localBuilder);" />
      <MemberSignature Language="F#" Value="abstract member EmitWriteLine : System.Reflection.Emit.LocalBuilder -&gt; unit&#xA;override this.EmitWriteLine : System.Reflection.Emit.LocalBuilder -&gt; unit" Usage="iLGenerator.EmitWriteLine localBuilder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localBuilder" Type="System.Reflection.Emit.LocalBuilder" />
      </Parameters>
      <Docs>
        <param name="localBuilder"><span data-ttu-id="1699d-314">Die lokale Variable, deren Wert in die Konsole geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="1699d-314">The local variable whose value is to be written to the console.</span></span></param>
        <summary><span data-ttu-id="1699d-315">Gibt die für einen Aufruf von <see cref="Overload:System.Console.WriteLine" /> mit der angegebenen lokalen Variable benötigte Microsoft Intermediate Language (MSIL) aus.</span><span class="sxs-lookup"><span data-stu-id="1699d-315">Emits the Microsoft intermediate language (MSIL) necessary to call <see cref="Overload:System.Console.WriteLine" /> with the given local variable.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-316">Der Typ der `localBuilder` muss dem Parametertyp einer Überladung der <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> Methode entsprechen.</span><span class="sxs-lookup"><span data-stu-id="1699d-316">The type of `localBuilder` must match the parameter type of an overload of the <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1699d-317">Das folgende Codebeispiel veranschaulicht die kontextbezogene Verwendung der <xref:System.Reflection.Emit.ILGenerator.EmitWriteLine%2A>-Methode, um eine Zeichenfolge in der Konsole in einer dynamischen Methode zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1699d-317">The code sample below demonstrates the contextual usage of the <xref:System.Reflection.Emit.ILGenerator.EmitWriteLine%2A> method to write a string to the console in a dynamic method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1699d-318">Der Typ von <paramref name="localBuilder" /> ist <see cref="T:System.Reflection.Emit.TypeBuilder" /> oder <see cref="T:System.Reflection.Emit.EnumBuilder" />, die nicht unterstützt werden.</span><span class="sxs-lookup"><span data-stu-id="1699d-318">The type of <paramref name="localBuilder" /> is <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.EnumBuilder" />, which are not supported.</span></span>  
  
<span data-ttu-id="1699d-319">- oder -</span><span class="sxs-lookup"><span data-stu-id="1699d-319">-or-</span></span> 
<span data-ttu-id="1699d-320">Es gibt keine Überladung von <see cref="Overload:System.Console.WriteLine" />, die den Typ von <paramref name="localBuilder" /> akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="1699d-320">There is no overload of <see cref="Overload:System.Console.WriteLine" /> that accepts the type of <paramref name="localBuilder" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1699d-321"><paramref name="localBuilder" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1699d-321"><paramref name="localBuilder" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EmitWriteLine">
      <MemberSignature Language="C#" Value="public virtual void EmitWriteLine (System.Reflection.FieldInfo fld);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitWriteLine(class System.Reflection.FieldInfo fld) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitWriteLine(System.Reflection.FieldInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EmitWriteLine (fld As FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitWriteLine(System::Reflection::FieldInfo ^ fld);" />
      <MemberSignature Language="F#" Value="abstract member EmitWriteLine : System.Reflection.FieldInfo -&gt; unit&#xA;override this.EmitWriteLine : System.Reflection.FieldInfo -&gt; unit" Usage="iLGenerator.EmitWriteLine fld" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fld" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="fld"><span data-ttu-id="1699d-322">Das Feld, dessen Wert in der Konsole ausgegeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="1699d-322">The field whose value is to be written to the console.</span></span></param>
        <summary><span data-ttu-id="1699d-323">Gibt die für einen Aufruf von <see cref="Overload:System.Console.WriteLine" /> mit dem angegebenen Feld benötigte Microsoft Intermediate Language (MSIL) aus.</span><span class="sxs-lookup"><span data-stu-id="1699d-323">Emits the Microsoft intermediate language (MSIL) necessary to call <see cref="Overload:System.Console.WriteLine" /> with the given field.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-324">Der Typ der `fld` muss dem Parametertyp einer Überladung der <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> Methode entsprechen.</span><span class="sxs-lookup"><span data-stu-id="1699d-324">The type of `fld` must match the parameter type of an overload of the <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1699d-325">Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Reflection.Emit.ILGenerator.EmitWriteLine%2A>-Methode verwendet wird, um eine Zeichenfolge in der Konsole in einer dynamischen Methode zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1699d-325">The following code sample demonstrates the use of the <xref:System.Reflection.Emit.ILGenerator.EmitWriteLine%2A> method to write a string to the console in a dynamic method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1699d-326">Es ist keine Überladung der <see cref="Overload:System.Console.WriteLine" />-Methode vorhanden, die den Typ des angegebenen Felds akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="1699d-326">There is no overload of the <see cref="Overload:System.Console.WriteLine" /> method that accepts the type of the specified field.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1699d-327"><paramref name="fld" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1699d-327"><paramref name="fld" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1699d-328">Der Feldtyp ist <see cref="T:System.Reflection.Emit.TypeBuilder" /> oder <see cref="T:System.Reflection.Emit.EnumBuilder" />. Beide Typen werden nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1699d-328">The type of the field is <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.EnumBuilder" />, which are not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EmitWriteLine">
      <MemberSignature Language="C#" Value="public virtual void EmitWriteLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitWriteLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitWriteLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EmitWriteLine (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitWriteLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member EmitWriteLine : string -&gt; unit&#xA;override this.EmitWriteLine : string -&gt; unit" Usage="iLGenerator.EmitWriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="1699d-329">Die auszugebende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="1699d-329">The string to be printed.</span></span></param>
        <summary><span data-ttu-id="1699d-330">Gibt die Microsoft Intermediate Language (MSIL) für einen Aufruf von <see cref="Overload:System.Console.WriteLine" /> mit einer Zeichenfolge aus.</span><span class="sxs-lookup"><span data-stu-id="1699d-330">Emits the Microsoft intermediate language (MSIL) to call <see cref="Overload:System.Console.WriteLine" /> with a string.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-331">Die Zeichenfolge muss bereits definiert worden sein.</span><span class="sxs-lookup"><span data-stu-id="1699d-331">The string must have already been defined.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1699d-332">Das folgende Codebeispiel veranschaulicht die kontextbezogene Verwendung der `EmitWriteLine`-Methode, um eine Zeichenfolge in der Konsole in einer dynamischen Methode zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="1699d-332">The code sample below demonstrates the contextual usage of the `EmitWriteLine` method to write a string to the console in a dynamic method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndExceptionBlock">
      <MemberSignature Language="C#" Value="public virtual void EndExceptionBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndExceptionBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EndExceptionBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndExceptionBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndExceptionBlock();" />
      <MemberSignature Language="F#" Value="abstract member EndExceptionBlock : unit -&gt; unit&#xA;override this.EndExceptionBlock : unit -&gt; unit" Usage="iLGenerator.EndExceptionBlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1699d-333">Beendet einen Ausnahmeblock.</span><span class="sxs-lookup"><span data-stu-id="1699d-333">Ends an exception block.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="1699d-334">Im folgenden Codebeispiel wird die kontextabhängige Verwendung der `EndExceptionBlock`-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="1699d-334">The code sample below demonstrates the contextual usage of the `EndExceptionBlock` method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1699d-335">Das Ende des Ausnahmeblocks tritt an einer unerwarteten Stelle im Codestream auf.</span><span class="sxs-lookup"><span data-stu-id="1699d-335">The end exception block occurs in an unexpected place in the code stream.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1699d-336">Die Microsoft Intermediate Language (MSIL), die generiert wird, befindet sich derzeit nicht in einem Ausnahmeblock.</span><span class="sxs-lookup"><span data-stu-id="1699d-336">The Microsoft intermediate language (MSIL) being generated is not currently in an exception block.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndScope">
      <MemberSignature Language="C#" Value="public virtual void EndScope ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EndScope" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndScope ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndScope();" />
      <MemberSignature Language="F#" Value="abstract member EndScope : unit -&gt; unit&#xA;override this.EndScope : unit -&gt; unit" Usage="iLGenerator.EndScope " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1699d-337">Beendet einen lexikalischen Gültigkeitsbereich.</span><span class="sxs-lookup"><span data-stu-id="1699d-337">Ends a lexical scope.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-338">Diese Methode wird verwendet, um symbolische Informationen auszugeben.</span><span class="sxs-lookup"><span data-stu-id="1699d-338">This method is used to emit symbolic information.</span></span> <span data-ttu-id="1699d-339">Sie wird mit <xref:System.Reflection.Emit.ILGenerator.BeginScope%2A>verwendet.</span><span class="sxs-lookup"><span data-stu-id="1699d-339">It is used with <xref:System.Reflection.Emit.ILGenerator.BeginScope%2A>.</span></span>  
  
 <span data-ttu-id="1699d-340">Wenn die aktuelle <xref:System.Reflection.Emit.ILGenerator> einem <xref:System.Reflection.Emit.DynamicMethod> Objekt zugeordnet ist, werden keine symbolischen Informationen unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1699d-340">If the current <xref:System.Reflection.Emit.ILGenerator> is associated with a <xref:System.Reflection.Emit.DynamicMethod> object, it does not support symbolic information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1699d-341">Im folgenden Codebeispiel wird die Verwendung von `BeginScope` und `EndScope`veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="1699d-341">The following code sample illustrates the use of `BeginScope` and `EndScope`.</span></span>  
  
 [!code-cpp[ILGenerator_Begin_EndScope#2](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CPP/ilgenerator_begin_endscope.cpp#2)]
 [!code-csharp[ILGenerator_Begin_EndScope#2](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CS/ilgenerator_begin_endscope.cs#2)]
 [!code-vb[ILGenerator_Begin_EndScope#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_Begin_EndScope/VB/ilgenerator_begin_endscope.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1699d-342">Dieser <see cref="T:System.Reflection.Emit.ILGenerator" /> gehört zu einer <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span><span class="sxs-lookup"><span data-stu-id="1699d-342">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ILOffset">
      <MemberSignature Language="C#" Value="public virtual int ILOffset { get; }" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ILOffset" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ILGenerator.ILOffset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ILOffset As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ILOffset { int get(); };" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.ILOffset : int" Usage="System.Reflection.Emit.ILGenerator.ILOffset" />
      <MemberSignature Language="C#" Value="public int ILOffset { get; }" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ILOffset As Integer" FrameworkAlternate="xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ILOffset { int get(); };" FrameworkAlternate="xamarinios-10.8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1699d-343">Ruft den aktuellen Offset in Bytes im MSIL-Datenstrom (Microsoft Intermediate Language) ab, der vom <see cref="T:System.Reflection.Emit.ILGenerator" /> ausgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="1699d-343">Gets the current offset, in bytes, in the Microsoft intermediate language (MSIL) stream that is being emitted by the <see cref="T:System.Reflection.Emit.ILGenerator" />.</span></span></summary>
        <value><span data-ttu-id="1699d-344">Der Offset im MSIL-Datenstrom, bei dem die nächste Anweisung ausgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="1699d-344">The offset in the MSIL stream at which the next instruction will be emitted.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-345">Diese Methode ist transparent und kann von teilweise vertrauenswürdigem Code aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="1699d-345">This method is transparent, and can be called from partially trusted code.</span></span>  
  
 <span data-ttu-id="1699d-346">Wenn auf die <xref:System.Reflection.Emit.ILGenerator.ILOffset%2A>-Eigenschaft zugegriffen wird, bevor MSIL-Anweisungen ausgegeben wurden, wird 0 (null) zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="1699d-346">If the <xref:System.Reflection.Emit.ILGenerator.ILOffset%2A> property is accessed before any MSIL instructions have been emitted, it returns 0 (zero).</span></span>  
  
 <span data-ttu-id="1699d-347">Wenn MSIL für dynamische Sprachen generiert wird, kann diese Eigenschaft verwendet werden, um Offsets im MSIL-Stream den Quell Codezeilen Nummern zuzuordnen.</span><span class="sxs-lookup"><span data-stu-id="1699d-347">When MSIL is generated for dynamic languages, this property can be used to map offsets in the MSIL stream to source code line numbers.</span></span> <span data-ttu-id="1699d-348">Die resultierenden Informationen können zum Bereitstellen von Stapel Überwachungen verwendet werden, wenn Ausnahmen ausgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="1699d-348">The resulting information can be used to provide stack traces when exceptions are thrown.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkLabel">
      <MemberSignature Language="C#" Value="public virtual void MarkLabel (System.Reflection.Emit.Label loc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MarkLabel(valuetype System.Reflection.Emit.Label loc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.MarkLabel(System.Reflection.Emit.Label)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MarkLabel (loc As Label)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MarkLabel(System::Reflection::Emit::Label loc);" />
      <MemberSignature Language="F#" Value="abstract member MarkLabel : System.Reflection.Emit.Label -&gt; unit&#xA;override this.MarkLabel : System.Reflection.Emit.Label -&gt; unit" Usage="iLGenerator.MarkLabel loc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loc" Type="System.Reflection.Emit.Label" />
      </Parameters>
      <Docs>
        <param name="loc"><span data-ttu-id="1699d-349">Die Sprungmarke, für die ein Index festzulegen ist.</span><span class="sxs-lookup"><span data-stu-id="1699d-349">The label for which to set an index.</span></span></param>
        <summary><span data-ttu-id="1699d-350">Markiert die aktuelle Position des MSIL-Streams (Microsoft Intermediate Language) mit der angegebenen Sprungmarke.</span><span class="sxs-lookup"><span data-stu-id="1699d-350">Marks the Microsoft intermediate language (MSIL) stream's current position with the given label.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-351">Eine Bezeichnung kann nicht mehrmals definiert werden.</span><span class="sxs-lookup"><span data-stu-id="1699d-351">A label cannot be defined more than once.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1699d-352">Das folgende Codebeispiel veranschaulicht die kontextbezogene Verwendung von `MarkLabel`, um MSIL-Verzweigungen in einer dynamischen Methode zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="1699d-352">The code sample below demonstrates the contextual usage of `MarkLabel` to implement MSIL branching in a dynamic method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1699d-353"><paramref name="loc" /> stellt einen unzulässigen Index im Sprungmarkenarray dar.</span><span class="sxs-lookup"><span data-stu-id="1699d-353"><paramref name="loc" /> represents an invalid index into the label array.</span></span>  
  
<span data-ttu-id="1699d-354">- oder -</span><span class="sxs-lookup"><span data-stu-id="1699d-354">-or-</span></span> 
<span data-ttu-id="1699d-355">Es wurde bereits ein Index für <paramref name="loc" /> definiert.</span><span class="sxs-lookup"><span data-stu-id="1699d-355">An index for <paramref name="loc" /> has already been defined.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MarkSequencePoint">
      <MemberSignature Language="C#" Value="public virtual void MarkSequencePoint (System.Diagnostics.SymbolStore.ISymbolDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MarkSequencePoint(class System.Diagnostics.SymbolStore.ISymbolDocumentWriter document, int32 startLine, int32 startColumn, int32 endLine, int32 endColumn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.MarkSequencePoint(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MarkSequencePoint (document As ISymbolDocumentWriter, startLine As Integer, startColumn As Integer, endLine As Integer, endColumn As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MarkSequencePoint(System::Diagnostics::SymbolStore::ISymbolDocumentWriter ^ document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="F#" Value="abstract member MarkSequencePoint : System.Diagnostics.SymbolStore.ISymbolDocumentWriter * int * int * int * int -&gt; unit&#xA;override this.MarkSequencePoint : System.Diagnostics.SymbolStore.ISymbolDocumentWriter * int * int * int * int -&gt; unit" Usage="iLGenerator.MarkSequencePoint (document, startLine, startColumn, endLine, endColumn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Diagnostics.SymbolStore.ISymbolDocumentWriter" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="startLine" Type="System.Int32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="startColumn" Type="System.Int32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="endLine" Type="System.Int32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="endColumn" Type="System.Int32" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="document"><span data-ttu-id="1699d-356">Das Dokument, für das der Sequenzpunkt definiert wird.</span><span class="sxs-lookup"><span data-stu-id="1699d-356">The document for which the sequence point is being defined.</span></span></param>
        <param name="startLine"><span data-ttu-id="1699d-357">Die Zeile, in der der Sequenzpunkt beginnt.</span><span class="sxs-lookup"><span data-stu-id="1699d-357">The line where the sequence point begins.</span></span></param>
        <param name="startColumn"><span data-ttu-id="1699d-358">Die Spalte in der Zeile, in der der Sequenzpunkt beginnt.</span><span class="sxs-lookup"><span data-stu-id="1699d-358">The column in the line where the sequence point begins.</span></span></param>
        <param name="endLine"><span data-ttu-id="1699d-359">Die Zeile, in der der Sequenzpunkt endet.</span><span class="sxs-lookup"><span data-stu-id="1699d-359">The line where the sequence point ends.</span></span></param>
        <param name="endColumn"><span data-ttu-id="1699d-360">Die Spalte in der Zeile, in der der Sequenzpunkt endet.</span><span class="sxs-lookup"><span data-stu-id="1699d-360">The column in the line where the sequence point ends.</span></span></param>
        <summary><span data-ttu-id="1699d-361">Markiert einen Sequenzpunkt im MSIL-Stream (Microsoft Intermediate Language).</span><span class="sxs-lookup"><span data-stu-id="1699d-361">Marks a sequence point in the Microsoft intermediate language (MSIL) stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-362">Zeilennummern werden von 1 indiziert.</span><span class="sxs-lookup"><span data-stu-id="1699d-362">Line numbers are indexed from 1.</span></span> <span data-ttu-id="1699d-363">Die Spalten werden von 0 indiziert.</span><span class="sxs-lookup"><span data-stu-id="1699d-363">Columns are indexed from 0.</span></span>  
  
 <span data-ttu-id="1699d-364">Die symbolischen Informationen enthalten normalerweise mindestens einen MSIL-Offset für jede Quellzeile.</span><span class="sxs-lookup"><span data-stu-id="1699d-364">The symbolic information normally includes at least one MSIL offset for each source line.</span></span> <span data-ttu-id="1699d-365">Bevor der JIT-Compiler (Just-In-Time) eine Methode kompiliert, fordert er von den Profilerstellungsdiensten eine Liste der zu speichernden MSIL-Offsets an.</span><span class="sxs-lookup"><span data-stu-id="1699d-365">When the just-in-time (JIT) compiler is about to compile a method, it asks the profiling services for a list of MSIL offsets that should be preserved.</span></span> <span data-ttu-id="1699d-366">Diese MSIL-Offsets werden als *Sequenz Punkte*bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="1699d-366">These MSIL offsets are called *sequence points*.</span></span>  
  
 <span data-ttu-id="1699d-367">Wenn die aktuelle <xref:System.Reflection.Emit.ILGenerator> einem <xref:System.Reflection.Emit.DynamicMethod> Objekt zugeordnet ist, werden keine symbolischen Informationen unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1699d-367">If the current <xref:System.Reflection.Emit.ILGenerator> is associated with a <xref:System.Reflection.Emit.DynamicMethod> object, it does not support symbolic information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1699d-368"><paramref name="startLine" /> oder <paramref name="endLine" /> ist &lt;= 0.</span><span class="sxs-lookup"><span data-stu-id="1699d-368"><paramref name="startLine" /> or <paramref name="endLine" /> is &lt;= 0.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1699d-369">Dieser <see cref="T:System.Reflection.Emit.ILGenerator" /> gehört zu einer <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span><span class="sxs-lookup"><span data-stu-id="1699d-369">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _ILGenerator.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _ILGenerator.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_ILGenerator::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="1699d-370">Für zukünftige Verwendung reserviert.</span><span class="sxs-lookup"><span data-stu-id="1699d-370">Reserved for future use.</span></span> <span data-ttu-id="1699d-371">Muss IID_NULL sein.</span><span class="sxs-lookup"><span data-stu-id="1699d-371">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="1699d-372">Das übergebene Array von zuzuordnenden Namen.</span><span class="sxs-lookup"><span data-stu-id="1699d-372">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="1699d-373">Die Anzahl der zuzuordnenden Namen.</span><span class="sxs-lookup"><span data-stu-id="1699d-373">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="1699d-374">Der Gebietsschemakontext, in dem die Namen interpretiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="1699d-374">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="1699d-375">Das vom Aufrufer zugeordnete Array, das die IDs entsprechend den Namen empfängt.</span><span class="sxs-lookup"><span data-stu-id="1699d-375">Caller-allocated array that receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="1699d-376">Ordnet eine Reihe von Namen einer entsprechenden Reihe von Dispatchbezeichnern zu.</span><span class="sxs-lookup"><span data-stu-id="1699d-376">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-377">Diese Methode ist für den Zugriff auf verwaltete Klassen von nicht verwaltetem Code aus vorgesehen und sollte nicht aus verwaltetem Code aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="1699d-377">This method is for accessing managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="1699d-378">Weitere Informationen zu `IDispatch::GetIDsOfNames`finden Sie in der MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="1699d-378">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="1699d-379">Die Methode wird unter Verwendung der <c>IDispatch</c>-Schnittstelle in COM mit spät gebundenem Zugriff aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="1699d-379">The method is called late-bound using the COM <c>IDispatch</c> interface.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _ILGenerator.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _ILGenerator.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_ILGenerator::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="1699d-380">Die zurückzugebenden Typinformationen.</span><span class="sxs-lookup"><span data-stu-id="1699d-380">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="1699d-381">Der Gebietsschemabezeichner für die Typinformationen.</span><span class="sxs-lookup"><span data-stu-id="1699d-381">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="1699d-382">Empfängt einen Zeiger auf das angeforderte Objekt mit den Typinformationen.</span><span class="sxs-lookup"><span data-stu-id="1699d-382">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="1699d-383">Ruft die Typinformationen für ein Objekt ab, die dann zum Abrufen der Typinformationen für eine Schnittstelle verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="1699d-383">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-384">Diese Methode ist für den Zugriff auf verwaltete Klassen von nicht verwaltetem Code aus vorgesehen und sollte nicht aus verwaltetem Code aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="1699d-384">This method is for accessing managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="1699d-385">Weitere Informationen zu `IDispatch::GetTypeInfo`finden Sie in der MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="1699d-385">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="1699d-386">Die Methode wird unter Verwendung der <c>IDispatch</c>-Schnittstelle in COM mit spät gebundenem Zugriff aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="1699d-386">The method is called late-bound using the COM <c>IDispatch</c> interface.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _ILGenerator.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _ILGenerator.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_ILGenerator::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="1699d-387">Zeigt auf einen Speicherort, der die Anzahl der Schnittstellen mit Typinformationen empfängt, die vom Objekt bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="1699d-387">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="1699d-388">Ruft die Anzahl der Schnittstellen mit Typinformationen ab, die von einem Objekt bereitgestellt werden (0 oder 1).</span><span class="sxs-lookup"><span data-stu-id="1699d-388">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-389">Diese Methode ist für den Zugriff auf verwaltete Klassen von nicht verwaltetem Code aus vorgesehen und sollte nicht aus verwaltetem Code aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="1699d-389">This method is for accessing managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="1699d-390">Weitere Informationen zu `IDispatch::GetTypeInfoCount`finden Sie in der MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="1699d-390">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="1699d-391">Die Methode wird unter Verwendung der <c>IDispatch</c>-Schnittstelle in COM mit spät gebundenem Zugriff aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="1699d-391">The method is called late-bound using the COM <c>IDispatch</c> interface.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.Invoke">
      <MemberSignature Language="C#" Value="void _ILGenerator.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _ILGenerator.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_ILGenerator::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="1699d-392">Bezeichnet den Member.</span><span class="sxs-lookup"><span data-stu-id="1699d-392">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="1699d-393">Für zukünftige Verwendung reserviert.</span><span class="sxs-lookup"><span data-stu-id="1699d-393">Reserved for future use.</span></span> <span data-ttu-id="1699d-394">Muss IID_NULL sein.</span><span class="sxs-lookup"><span data-stu-id="1699d-394">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="1699d-395">Der Gebietsschemakontext, in dem Argumente interpretiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="1699d-395">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="1699d-396">Flags, die den Kontext des Aufrufs beschreiben.</span><span class="sxs-lookup"><span data-stu-id="1699d-396">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="1699d-397">Ein Zeiger auf eine Struktur, die ein Array von Argumenten und ein Array von Argument-DISPIDs für benannte Argumente sowie Zähler für die Anzahl der Elemente in jedem Array enthält.</span><span class="sxs-lookup"><span data-stu-id="1699d-397">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="1699d-398">Ein Verweis auf den Speicherort, an dem das Ergebnis gespeichert werden soll.</span><span class="sxs-lookup"><span data-stu-id="1699d-398">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="1699d-399">Ein Zeiger auf eine Struktur mit Ausnahmeinformationen.</span><span class="sxs-lookup"><span data-stu-id="1699d-399">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="1699d-400">Der Index des ersten Arguments mit einem Fehler.</span><span class="sxs-lookup"><span data-stu-id="1699d-400">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="1699d-401">Stellt den Zugriff auf von einem Objekt verfügbar gemachte Eigenschaften und Methoden bereit.</span><span class="sxs-lookup"><span data-stu-id="1699d-401">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-402">Diese Methode ist für den Zugriff auf verwaltete Klassen von nicht verwaltetem Code aus vorgesehen und sollte nicht aus verwaltetem Code aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="1699d-402">This method is for accessing managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="1699d-403">Weitere Informationen zu `IDispatch::Invoke`finden Sie in der MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="1699d-403">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="1699d-404">Die Methode wird unter Verwendung der <c>IDispatch</c>-Schnittstelle in COM mit spät gebundenem Zugriff aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="1699d-404">The method is called late-bound using the COM <c>IDispatch</c> interface.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ThrowException">
      <MemberSignature Language="C#" Value="public virtual void ThrowException (Type excType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ThrowException(class System.Type excType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.ThrowException(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ThrowException (excType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ThrowException(Type ^ excType);" />
      <MemberSignature Language="F#" Value="abstract member ThrowException : Type -&gt; unit&#xA;override this.ThrowException : Type -&gt; unit" Usage="iLGenerator.ThrowException excType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="excType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="excType"><span data-ttu-id="1699d-405">Die Klasse für den Typ der auszulösenden Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="1699d-405">The class of the type of exception to throw.</span></span></param>
        <summary><span data-ttu-id="1699d-406">Gibt eine Anweisung zum Auslösen einer Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="1699d-406">Emits an instruction to throw an exception.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="1699d-407">Im folgenden Codebeispiel wird die kontextabhängige Verwendung von `ThrowException` veranschaulicht, um eine Ausnahme innerhalb der MSIL einer dynamischen Methode auszulösen.</span><span class="sxs-lookup"><span data-stu-id="1699d-407">The following code sample demonstrates the contextual usage of `ThrowException` to throw an exception inside the MSIL of a dynamic method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1699d-408"><paramref name="excType" /> ist nicht die <see cref="T:System.Exception" />-Klasse oder eine von <see cref="T:System.Exception" /> abgeleitete Klasse.</span><span class="sxs-lookup"><span data-stu-id="1699d-408"><paramref name="excType" /> is not the <see cref="T:System.Exception" /> class or a derived class of <see cref="T:System.Exception" />.</span></span>  
  
<span data-ttu-id="1699d-409">- oder -</span><span class="sxs-lookup"><span data-stu-id="1699d-409">-or-</span></span> 
<span data-ttu-id="1699d-410">Der Typ weist keinen parameterlosen Konstruktor auf.</span><span class="sxs-lookup"><span data-stu-id="1699d-410">The type does not have a parameterless constructor.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1699d-411"><paramref name="excType" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1699d-411"><paramref name="excType" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UsingNamespace">
      <MemberSignature Language="C#" Value="public virtual void UsingNamespace (string usingNamespace);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UsingNamespace(string usingNamespace) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.UsingNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UsingNamespace (usingNamespace As String)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UsingNamespace(System::String ^ usingNamespace);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member UsingNamespace : string -&gt; unit&#xA;override this.UsingNamespace : string -&gt; unit" Usage="iLGenerator.UsingNamespace usingNamespace" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public void UsingNamespace (string usingNamespace);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UsingNamespace(string usingNamespace) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Sub UsingNamespace (usingNamespace As String)" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UsingNamespace(System::String ^ usingNamespace);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="member this.UsingNamespace : string -&gt; unit" Usage="iLGenerator.UsingNamespace usingNamespace" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="usingNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="usingNamespace"><span data-ttu-id="1699d-412">Der Namespace, der zur Auswertung der lokalen Variablen und Überwachungen für den derzeit aktiven lexikalischen Gültigkeitsbereich verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="1699d-412">The namespace to be used in evaluating locals and watches for the current active lexical scope</span></span></param>
        <summary><span data-ttu-id="1699d-413">Gibt den Namespace an, der zur Auswertung der lokalen Variablen und Überwachungen für den derzeit aktiven lexikalischen Gültigkeitsbereich verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="1699d-413">Specifies the namespace to be used in evaluating locals and watches for the current active lexical scope.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1699d-414">Wenn die aktuelle <xref:System.Reflection.Emit.ILGenerator> einem <xref:System.Reflection.Emit.DynamicMethod>-Objekt zugeordnet ist, wird diese Methode nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="1699d-414">If the current <xref:System.Reflection.Emit.ILGenerator> is associated with a <xref:System.Reflection.Emit.DynamicMethod> object, this method is not supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1699d-415">Die Länge von <paramref name="usingNamespace" /> ist 0 (null).</span><span class="sxs-lookup"><span data-stu-id="1699d-415">Length of <paramref name="usingNamespace" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1699d-416"><paramref name="usingNamespace" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="1699d-416"><paramref name="usingNamespace" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1699d-417">Dieser <see cref="T:System.Reflection.Emit.ILGenerator" /> gehört zu einer <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span><span class="sxs-lookup"><span data-stu-id="1699d-417">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
