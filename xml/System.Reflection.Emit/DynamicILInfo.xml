<Type Name="DynamicILInfo" FullName="System.Reflection.Emit.DynamicILInfo">
  <Metadata><Meta Name="ms.openlocfilehash" Value="36eadc6d371a1d0ac5227307f24baef341f175db" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69110214" /></Metadata><TypeSignature Language="C#" Value="public class DynamicILInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DynamicILInfo extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.DynamicILInfo" />
  <TypeSignature Language="VB.NET" Value="Public Class DynamicILInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicILInfo" />
  <TypeSignature Language="F#" Value="type DynamicILInfo = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt Unterstützung für eine alternative Vorgehensweise zum Generieren von MSIL (Microsoft Intermediate Language) und von Metadaten für eine dynamische Methode bereit. Dabei sind Methoden zum Erstellen von Token und zum Einfügen des Codes, Ausnahmenbehandlung sowie Signatur-BLOBs für lokale Variablen inbegriffen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.Emit.DynamicILInfo> -Klasse ermöglicht Entwicklern das Schreiben eigener MSIL-Generatoren, anstatt <xref:System.Reflection.Emit.ILGenerator>zu verwenden.  
  
 Um Instanzen anderer Typen zu erstellen, Methoden aufzurufen usw., muss die MSIL, die Sie generieren, Token für diese Entitäten enthalten. Die <xref:System.Reflection.Emit.DynamicILInfo> -Klasse stellt mehrere über Ladungen <xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%2A> der-Methode bereit, die Token zurückgeben, die im Gültigkeitsbereich des aktuellen <xref:System.Reflection.Emit.DynamicILInfo>gültig sind. Wenn Sie z. b. eine Überladung der <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> -Methode aufrufen müssen, können Sie einen <xref:System.RuntimeMethodHandle> für diese Überladung abrufen und ihn an die <xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%2A> -Methode übergeben, um ein Token zum Einbetten in die MSIL zu erhalten.  
  
 Nachdem Sie Arrays für <xref:System.Byte> die Signatur, die Ausnahmen und den Code Körper Ihrer lokalen Variablen erstellt haben, können Sie <xref:System.Reflection.Emit.DynamicILInfo.SetCode%2A>die <xref:System.Reflection.Emit.DynamicILInfo.SetExceptions%2A>Methoden, <xref:System.Reflection.Emit.DynamicILInfo.SetLocalSignature%2A> und verwenden, um Sie in <xref:System.Reflection.Emit.DynamicMethod> die einzufügen, <xref:System.Reflection.Emit.DynamicILInfo> die Ihrem Objekt.  
  
 Das Erstellen eigener Metadaten und MSIL erfordert Vertrautheit mit der Common Language Infrastructure (CLI)-Dokumentation, insbesondere "Partition II: Metadatendefinition und Semantik) und „Partition III: CIL Instruction Set“ (Partition III: CIL-Anweisungen). Die Dokumentation ist online verfügbar. Sie finden sie unter [ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)](https://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))](https://go.microsoft.com/fwlink/?LinkID=65552) auf der Ecma International-Website.  
  
> [!NOTE]
>  Verwenden <xref:System.Reflection.Emit.DynamicILInfo> Sie nicht, um Code zu generieren, der einen Delegaten zu einer anderen dynamischen Methode erstellt, indem Sie den Delegatkonstruktor direkt aufrufen. Verwenden Sie stattdessen die <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> -Methode, um den Delegaten zu erstellen. Ein Delegat, der mit dem Delegatkonstruktor erstellt wird, verfügt über keinen Verweis auf die dynamische Ziel Methode. Die dynamische Methode wird möglicherweise von Garbage Collection freigegeben, während der Delegat noch verwendet wird.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="DynamicMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.DynamicMethod DynamicMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Emit.DynamicMethod DynamicMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicILInfo.DynamicMethod" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicMethod As DynamicMethod" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::DynamicMethod ^ DynamicMethod { System::Reflection::Emit::DynamicMethod ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicMethod : System.Reflection.Emit.DynamicMethod" Usage="System.Reflection.Emit.DynamicILInfo.DynamicMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.DynamicMethod</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die dynamische Methode ab, deren Text von der aktuellen Instanz generiert wird.</summary>
        <value>Ein <see cref="T:System.Reflection.Emit.DynamicMethod" />-Objekt, das die dynamische Methode darstellt, für die das aktuelle <see cref="T:System.Reflection.Emit.DynamicILInfo" />-Objekt Code generiert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Reflection.Emit.DynamicILInfo> -Objekt ist immer einer dynamischen Methode zugeordnet. Der Zweck <xref:System.Reflection.Emit.DynamicILInfo> der-Klasse besteht darin, eine weitere Möglichkeit zum Einfügen des MSIL-Streams, der Ausnahmebehandlung und der lokalen Variablen Signatur in eine dynamische Methode für Entwickler bereitzustellen, die MSIL ohne <xref:System.Reflection.Emit.ILGenerator> Verwendung der-Klasse generieren möchten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTokenFor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft ein im Bereich der aktuellen <see cref="T:System.Reflection.Emit.DynamicILInfo" /> gültiges Token ab, das eine Zeichenfolge, ein Feld, eine Methode, einen Typ oder eine Signatur im MSIL-Stream für die zugeordnete dynamische Methode darstellt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (byte[] signature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(unsigned int8[] signature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (signature As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(cli::array &lt;System::Byte&gt; ^ signature);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : byte[] -&gt; int" Usage="dynamicILInfo.GetTokenFor signature" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="signature" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="signature">Ein Array, das die Signatur enthält.</param>
        <summary>Ruft ein im Bereich der aktuellen <see cref="T:System.Reflection.Emit.DynamicILInfo" /> gültiges Token ab, das die Signatur für die zugeordnete dynamische Methode darstellt.</summary>
        <returns>Ein Token, das in die Metadaten und in den MSIL-Stream für die zugeordnete dynamische Methode eingebettet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informationen zu Signatur-blobdaten finden Sie in der Common Language Infrastructure-Dokumentation (CLI), insbesondere unter "Partition II: Metadatendefinition und-Semantik ". Die Dokumentation ist online verfügbar. Sie finden sie unter [ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)](https://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))](https://go.microsoft.com/fwlink/?LinkID=65552) auf der Ecma International-Website.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (System.Reflection.Emit.DynamicMethod method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(class System.Reflection.Emit.DynamicMethod method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Reflection.Emit.DynamicMethod)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (method As DynamicMethod) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(System::Reflection::Emit::DynamicMethod ^ method);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : System.Reflection.Emit.DynamicMethod -&gt; int" Usage="dynamicILInfo.GetTokenFor method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.Emit.DynamicMethod" />
      </Parameters>
      <Docs>
        <param name="method">Die aufzurufende dynamische Methode.</param>
        <summary>Ruft ein im Bereich der aktuellen <see cref="T:System.Reflection.Emit.DynamicILInfo" /> gültiges Token ab, das eine aus der zugeordneten Methode aufzurufende dynamische Methode darstellt.</summary>
        <returns>Ein Token, das in den MSIL-Stream für die zugeordnete dynamische Methode als Ziel einer MSIL-Anweisung eingebettet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das von dieser Methoden Überladung zurückgegebene Token ermöglicht Ihnen das Aufrufen einer dynamischen Methode aus der dynamischen Methode, die <xref:System.Reflection.Emit.DynamicILInfo> dem aktuellen-Objekt zugeordnet ist. Um die zugeordnete dynamische Methode rekursiv aufzurufen, übergeben Sie <xref:System.Reflection.Emit.DynamicILInfo.DynamicMethod%2A> den Wert der-Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (RuntimeFieldHandle field);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(valuetype System.RuntimeFieldHandle field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (field As RuntimeFieldHandle) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(RuntimeFieldHandle field);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : RuntimeFieldHandle -&gt; int" Usage="dynamicILInfo.GetTokenFor field" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="field" Type="System.RuntimeFieldHandle" />
      </Parameters>
      <Docs>
        <param name="field">Das Feld, auf das zugegriffen werden soll.</param>
        <summary>Ruft ein im Bereich der aktuellen <see cref="T:System.Reflection.Emit.DynamicILInfo" /> gültiges Token ab, das ein Feld darstellt, auf das aus der zugeordneten dynamischen Methode zugegriffen werden soll.</summary>
        <returns>Ein Token im Bereich des aktuellen <see cref="T:System.Reflection.Emit.DynamicILInfo" />-Objekts, das als Operand einer MSIL-Anweisung verwendet werden kann, mit der auf Felder zugegriffen wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen ein Token für ein beliebiges Feld abrufen, auf das von der dynamischen Methode zugegriffen wird, <xref:System.Reflection.Emit.DynamicILInfo> die dem aktuellen-Objekt zugeordnet ist. Verwenden Sie <xref:System.Type.GetField%2A?displayProperty=nameWithType> die-Methode, <xref:System.Reflection.FieldInfo> um einen für das Feld zu erhalten, auf das Sie <xref:System.Reflection.FieldInfo.FieldHandle%2A> zugreifen möchten, und <xref:System.RuntimeFieldHandle>verwenden Sie dann die-Eigenschaft, um den  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (RuntimeMethodHandle method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(valuetype System.RuntimeMethodHandle method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (method As RuntimeMethodHandle) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(RuntimeMethodHandle method);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : RuntimeMethodHandle -&gt; int" Usage="dynamicILInfo.GetTokenFor method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.RuntimeMethodHandle" />
      </Parameters>
      <Docs>
        <param name="method">Die Methode, auf die zugegriffen werden soll.</param>
        <summary>Ruft ein im Bereich der aktuellen <see cref="T:System.Reflection.Emit.DynamicILInfo" /> gültiges Token ab, das eine Methode darstellt, auf die aus der zugeordneten dynamischen Methode zugegriffen werden soll.</summary>
        <returns>Ein Token im Bereich des aktuellen <see cref="F:System.Reflection.Emit.OpCodes.Call" />-Objekts, das als Operand einer MSIL-Anweisung verwendet werden kann, mit der auf Methoden zugegriffen wird, z. B. <see cref="F:System.Reflection.Emit.OpCodes.Ldtoken" /> oder <see cref="T:System.Reflection.Emit.DynamicILInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen ein Token für jede Methode abrufen, auf die von der dynamischen Methode, die dem aktuellen <xref:System.Reflection.Emit.DynamicILInfo> -Objekt zugeordnet ist, zugegriffen wird. Verwenden Sie <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> die-Methode, <xref:System.Reflection.MethodInfo> um einen für die Methode, auf die Sie zugreifen möchten, <xref:System.Reflection.MethodBase.MethodHandle%2A> zu erhalten, und <xref:System.RuntimeMethodHandle>verwenden Sie dann die-Eigenschaft, um das  
  
> [!NOTE]
>  Verwenden Sie für eine Methode, die zu einem generischen Typ <xref:System.Reflection.Emit.DynamicILInfo.GetTokenFor%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%29> gehört, die-Methoden <xref:System.RuntimeTypeHandle> Überladung, und geben Sie für den generischen Typ an.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (RuntimeTypeHandle type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(valuetype System.RuntimeTypeHandle type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (type As RuntimeTypeHandle) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(RuntimeTypeHandle type);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : RuntimeTypeHandle -&gt; int" Usage="dynamicILInfo.GetTokenFor type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="type">Der zu verwendende Typ.</param>
        <summary>Ruft ein im Bereich der aktuellen <see cref="T:System.Reflection.Emit.DynamicILInfo" /> gültiges Token ab, das einen Typ darstellt, der in der zugeordneten dynamischen Methode verwendet werden soll.</summary>
        <returns>Ein Token im Bereich des aktuellen <see cref="T:System.Reflection.Emit.DynamicILInfo" />-Objekts, das als Operand einer MSIL-Anweisung verwendet werden kann, die einen Typ erfordert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das von dieser Methoden Überladung zurückgegebene Token ermöglicht Ihnen das Definieren eines lokalen Variablen Typs und das Ausgeben von MSIL zum Erstellen einer Instanz eines Typs in der dynamischen Methode, die <xref:System.Reflection.Emit.DynamicILInfo> dem aktuellen-Objekt zugeordnet ist.  
  
 Verwenden Sie die <xref:System.RuntimeTypeHandle> <xref:System.Type.TypeHandle%2A?displayProperty=nameWithType> -Eigenschaft, um ein-Objekt für einen Typ zu erhalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (string literal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(string literal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (literal As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(System::String ^ literal);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : string -&gt; int" Usage="dynamicILInfo.GetTokenFor literal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="literal" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="literal">Die zu verwendende Zeichenfolge.</param>
        <summary>Ruft ein im Bereich der aktuellen <see cref="T:System.Reflection.Emit.DynamicILInfo" /> gültiges Token ab, das ein Zeichenfolgenliteral darstellt, das in der zugeordneten dynamischen Methode verwendet werden soll.</summary>
        <returns>Ein Token im Bereich des aktuellen <see cref="T:System.Reflection.Emit.DynamicILInfo" />-Objekts, das als Operand einer MSIL-Anweisung verwendet werden kann, die eine Zeichenfolge erfordert.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (RuntimeFieldHandle field, RuntimeTypeHandle contextType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(valuetype System.RuntimeFieldHandle field, valuetype System.RuntimeTypeHandle contextType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle,System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (field As RuntimeFieldHandle, contextType As RuntimeTypeHandle) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(RuntimeFieldHandle field, RuntimeTypeHandle contextType);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : RuntimeFieldHandle * RuntimeTypeHandle -&gt; int" Usage="dynamicILInfo.GetTokenFor (field, contextType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="field" Type="System.RuntimeFieldHandle" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="contextType" Type="System.RuntimeTypeHandle" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="field">Das Feld, auf das zugegriffen werden soll.</param>
        <param name="contextType">Der generische Typ, zu dem das Feld gehört.</param>
        <summary>Ruft ein im Bereich der aktuellen <see cref="T:System.Reflection.Emit.DynamicILInfo" /> gültiges Token ab, das ein Feld darstellt, auf das aus der zugeordneten dynamischen Methode zugegriffen werden soll. Das Feld ist vom angegebenen generischen Typ.</summary>
        <returns>Ein Token im Bereich des aktuellen <see cref="T:System.Reflection.Emit.DynamicILInfo" />-Objekts, das als Operand einer MSIL-Anweisung verwendet werden kann, mit der auf Felder zugegriffen wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen ein Token für ein beliebiges Feld abrufen, auf das von der dynamischen Methode zugegriffen wird, <xref:System.Reflection.Emit.DynamicILInfo> die dem aktuellen-Objekt zugeordnet ist. Verwenden Sie <xref:System.Type.GetField%2A?displayProperty=nameWithType> die-Methode, <xref:System.Reflection.FieldInfo> um ein-Objekt für das Feld zu erhalten, auf das <xref:System.Reflection.FieldInfo.FieldHandle%2A> Sie zugreifen möchten, <xref:System.RuntimeFieldHandle>und verwenden Sie dann die-Eigenschaft, um den  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenFor">
      <MemberSignature Language="C#" Value="public int GetTokenFor (RuntimeMethodHandle method, RuntimeTypeHandle contextType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTokenFor(valuetype System.RuntimeMethodHandle method, valuetype System.RuntimeTypeHandle contextType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle,System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTokenFor (method As RuntimeMethodHandle, contextType As RuntimeTypeHandle) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTokenFor(RuntimeMethodHandle method, RuntimeTypeHandle contextType);" />
      <MemberSignature Language="F#" Value="member this.GetTokenFor : RuntimeMethodHandle * RuntimeTypeHandle -&gt; int" Usage="dynamicILInfo.GetTokenFor (method, contextType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.RuntimeMethodHandle" />
        <Parameter Name="contextType" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="method">Die Methode.</param>
        <param name="contextType">Der generische Typ, zu dem die Methode gehört.</param>
        <summary>Ruft ein im Bereich der aktuellen <see cref="T:System.Reflection.Emit.DynamicILInfo" /> gültiges Token ab, das eine Methode für einen generischen Typ darstellt.</summary>
        <returns>Ein Token im Bereich des aktuellen <see cref="F:System.Reflection.Emit.OpCodes.Call" />-Objekts, das als Operand einer MSIL-Anweisung verwendet werden kann, mit der auf Methoden zugegriffen wird, z. B. <see cref="F:System.Reflection.Emit.OpCodes.Ldtoken" /> oder <see cref="T:System.Reflection.Emit.DynamicILInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen ein Token für jede Methode abrufen, die von der dynamischen Methode aufgerufen wird, die dem aktuellen <xref:System.Reflection.Emit.DynamicILInfo> -Objekt zugeordnet ist. Verwenden Sie <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> die-Methode, <xref:System.Reflection.MethodInfo> um einen für die aufzurufende Methode abzurufen, und <xref:System.Reflection.MethodBase.MethodHandle%2A> verwenden Sie dann die <xref:System.RuntimeMethodHandle>-Eigenschaft, um den abzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCode">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt den Codetext der zugeordneten dynamischen Methode fest.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCode">
      <MemberSignature Language="C#" Value="public void SetCode (byte[] code, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCode(unsigned int8[] code, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCode (code As Byte(), maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCode(cli::array &lt;System::Byte&gt; ^ code, int maxStackSize);" />
      <MemberSignature Language="F#" Value="member this.SetCode : byte[] * int -&gt; unit" Usage="dynamicILInfo.SetCode (code, maxStackSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="code" Type="System.Byte[]" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="code">Ein Array, das den MSIL-Stream enthält.</param>
        <param name="maxStackSize">Die maximale Anzahl von Elementen auf dem Operandenstapel beim Ausführen der Methode.</param>
        <summary>Legt den Codetext der zugeordneten dynamischen Methode fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für den MSIL-Stream werden keine Gültigkeits Überprüfungen ausgeführt.  
  
 Wenn Sie diese Methode ein zweites Mal aufrufen, wird der erste MSIL-Stream durch den zweiten ersetzt.  
  
 Das Erstellen eigener Metadaten und MSIL erfordert Vertrautheit mit der Common Language Infrastructure (CLI)-Dokumentation, insbesondere "Partition II: Metadatendefinition und Semantik) und „Partition III: CIL Instruction Set“ (Partition III: CIL-Anweisungen). Die Dokumentation ist online verfügbar. Sie finden sie unter [ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)](https://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))](https://go.microsoft.com/fwlink/?LinkID=65552) auf der Ecma International-Website.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCode">
      <MemberSignature Language="C#" Value="public void SetCode (byte* code, int codeSize, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCode(unsigned int8* code, int32 codeSize, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCode(System::Byte* code, int codeSize, int maxStackSize);" />
      <MemberSignature Language="F#" Value="member this.SetCode : nativeptr&lt;byte&gt; * int * int -&gt; unit" Usage="dynamicILInfo.SetCode (code, codeSize, maxStackSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="code" Type="System.Byte*" />
        <Parameter Name="codeSize" Type="System.Int32" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="code">Ein Zeiger auf ein Bytearray, das den MSIL-Stream enthält.</param>
        <param name="codeSize">Die Anzahl der Bytes im MSIL-Stream.</param>
        <param name="maxStackSize">Die maximale Anzahl von Elementen auf dem Operandenstapel beim Ausführen der Methode.</param>
        <summary>Legt den Codetext der zugeordneten dynamischen Methode fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für den MSIL-Stream werden keine Gültigkeits Überprüfungen ausgeführt.  
  
 Wenn Sie diese Methode ein zweites Mal aufrufen, wird der erste MSIL-Stream durch den zweiten ersetzt.  
  
 Das Erstellen eigener Metadaten und MSIL erfordert Vertrautheit mit der Common Language Infrastructure (CLI)-Dokumentation, insbesondere "Partition II: Metadatendefinition und Semantik) und „Partition III: CIL-Anweisungs Satz. " Die Dokumentation ist online verfügbar. Sie finden sie unter [ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)](https://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))](https://go.microsoft.com/fwlink/?LinkID=65552) auf der Ecma International-Website.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte[],System.Int32)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="code" /> ist <see langword="null" />, und <paramref name="codeSize" /> ist größer als 0 (null).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codeSize" /> ist kleiner als 0.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetExceptions">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt die Ausnahmemetadaten für die zugeordnete dynamische Methode fest.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetExceptions">
      <MemberSignature Language="C#" Value="public void SetExceptions (byte[] exceptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetExceptions(unsigned int8[] exceptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetExceptions (exceptions As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetExceptions(cli::array &lt;System::Byte&gt; ^ exceptions);" />
      <MemberSignature Language="F#" Value="member this.SetExceptions : byte[] -&gt; unit" Usage="dynamicILInfo.SetExceptions exceptions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exceptions" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="exceptions">Ein Array, das die Ausnahmemetadaten enthält.</param>
        <summary>Legt die Ausnahmemetadaten für die zugeordnete dynamische Methode fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Ausnahme Metadaten für eine Methode definieren die Position und Größe aller `try`- `finally`, `catch`-,-, Filter-und fault-Blöcke. Weitere Informationen zum Layout dieser Metadaten finden Sie in der Common Language Infrastructure-Dokumentation (CLI), insbesondere unter "Partition II: Metadatendefinition und-Semantik ". Die Dokumentation ist online verfügbar. Sie finden sie unter [ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)](https://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))](https://go.microsoft.com/fwlink/?LinkID=65552) auf der Ecma International-Website.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetExceptions">
      <MemberSignature Language="C#" Value="public void SetExceptions (byte* exceptions, int exceptionsSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetExceptions(unsigned int8* exceptions, int32 exceptionsSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetExceptions(System::Byte* exceptions, int exceptionsSize);" />
      <MemberSignature Language="F#" Value="member this.SetExceptions : nativeptr&lt;byte&gt; * int -&gt; unit" Usage="dynamicILInfo.SetExceptions (exceptions, exceptionsSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exceptions" Type="System.Byte*" />
        <Parameter Name="exceptionsSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exceptions">Ein Zeiger auf ein Bytearray, das die Ausnahmemetadaten enthält.</param>
        <param name="exceptionsSize">Die Bytezahl der Ausnahmemetadaten.</param>
        <summary>Legt die Ausnahmemetadaten für die zugeordnete dynamische Methode fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Ausnahme Metadaten für eine Methode definieren die Position und Größe aller `try`- `finally`, `catch`-,-, Filter-und fault-Blöcke. Weitere Informationen zum Layout dieser Metadaten finden Sie in der Common Language Infrastructure-Dokumentation (CLI), insbesondere unter "Partition II: Metadatendefinition und Semantik) und „Partition III: CIL Instruction Set“ (Partition III: CIL-Anweisungen). Die Dokumentation ist online verfügbar. Sie finden sie unter [ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)](https://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))](https://go.microsoft.com/fwlink/?LinkID=65552) auf der Ecma International-Website.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><paramref name="exceptions" /> ist <see langword="null" />, und <paramref name="exceptionSize" /> ist größer als 0 (null).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="exceptionSize" /> ist kleiner als 0.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetLocalSignature">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt die lokale Variablensignatur fest, in der das Layout von lokalen Variablen für die zugeordnete dynamische Methode beschrieben wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetLocalSignature">
      <MemberSignature Language="C#" Value="public void SetLocalSignature (byte[] localSignature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetLocalSignature(unsigned int8[] localSignature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetLocalSignature (localSignature As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetLocalSignature(cli::array &lt;System::Byte&gt; ^ localSignature);" />
      <MemberSignature Language="F#" Value="member this.SetLocalSignature : byte[] -&gt; unit" Usage="dynamicILInfo.SetLocalSignature localSignature" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localSignature" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="localSignature">Ein Array, das das Layout von lokalen Variablen für die zugeordnete <see cref="T:System.Reflection.Emit.DynamicMethod" /> enthält.</param>
        <summary>Legt die lokale Variablensignatur fest, in der das Layout von lokalen Variablen für die zugeordnete dynamische Methode beschrieben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Signatur der lokalen Variablen beschreibt das Layout der lokalen Variablen einer Methode. Um die Erstellung der lokalen Variablen Signatur zu vereinfachen, verwenden `static` Sie`Shared` die-Methode <xref:System.Reflection.Emit.SignatureHelper.GetLocalVarSigHelper%2A?displayProperty=nameWithType> (in Visual Basic) <xref:System.Reflection.Emit.SignatureHelper> , um einen für die lokale Signatur zu erhalten.  
  
 Informationen zu lokalen Variablen Signaturen finden Sie in der Common Language Infrastructure-Dokumentation (CLI), insbesondere unter "Partition II: Metadatendefinition und-Semantik ". Die Dokumentation ist online verfügbar. Sie finden sie unter [ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)](https://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))](https://go.microsoft.com/fwlink/?LinkID=65552) auf der Ecma International-Website.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetLocalSignature">
      <MemberSignature Language="C#" Value="public void SetLocalSignature (byte* localSignature, int signatureSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetLocalSignature(unsigned int8* localSignature, int32 signatureSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetLocalSignature(System::Byte* localSignature, int signatureSize);" />
      <MemberSignature Language="F#" Value="member this.SetLocalSignature : nativeptr&lt;byte&gt; * int -&gt; unit" Usage="dynamicILInfo.SetLocalSignature (localSignature, signatureSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localSignature" Type="System.Byte*" />
        <Parameter Name="signatureSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="localSignature">Ein Array, das das Layout von lokalen Variablen für die zugeordnete <see cref="T:System.Reflection.Emit.DynamicMethod" /> enthält.</param>
        <param name="signatureSize">Die Anzahl der Bytes in der Signatur.</param>
        <summary>Legt die lokale Variablensignatur fest, in der das Layout von lokalen Variablen für die zugeordnete dynamische Methode beschrieben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Signatur der lokalen Variablen beschreibt das Layout der lokalen Variablen einer Methode. Um die Erstellung der lokalen Variablen Signatur zu vereinfachen, verwenden `static` Sie`Shared` die-Methode <xref:System.Reflection.Emit.SignatureHelper.GetLocalVarSigHelper%2A?displayProperty=nameWithType> (in Visual Basic) <xref:System.Reflection.Emit.SignatureHelper> , um einen für die lokale Signatur zu erhalten.  
  
 Informationen zu lokalen Variablen Signaturen finden Sie in der Common Language Infrastructure-Dokumentation (CLI), insbesondere unter "Partition II: Metadatendefinition und-Semantik ". Die Dokumentation ist online verfügbar. Sie finden sie unter [ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)](https://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))](https://go.microsoft.com/fwlink/?LinkID=65552) auf der Ecma International-Website.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><paramref name="localSignature" /> ist <see langword="null" />, und <paramref name="signatureSize" /> ist größer als 0 (null).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="signatureSize" /> ist kleiner als 0.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
