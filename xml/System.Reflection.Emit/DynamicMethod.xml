<Type Name="DynamicMethod" FullName="System.Reflection.Emit.DynamicMethod">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7f0a6e450a4d87e00c2f05f1f2d4284889683bc5" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57963680" /></Metadata><TypeSignature Language="C#" Value="public sealed class DynamicMethod : System.Reflection.MethodInfo" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit DynamicMethod extends System.Reflection.MethodInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.DynamicMethod" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DynamicMethod&#xA;Inherits MethodInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicMethod sealed : System::Reflection::MethodInfo" />
  <TypeSignature Language="F#" Value="type DynamicMethod = class&#xA;    inherit MethodInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definiert und stellt eine dynamische Methode dar, die kompiliert ausgeführt und verworfen werden kann. Verworfene Methoden sind für die Garbage Collection verfügbar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Reflection.Emit.DynamicMethod> Klasse zum Generieren und eine Methode zur Laufzeit ausführen, ohne dass eine dynamische Assembly und eines dynamischen Typs, der die Methode enthält zu generieren. Der ausführbare Code, der vom Compiler just-in-Time (JIT) erstellten freigegeben wird bei der <xref:System.Reflection.Emit.DynamicMethod> Objekt wieder zugänglich gemacht wird. Dynamische Methoden sind die effizienteste Methode zum Generieren und Ausführen von kleine Mengen von Code.  
  
 Eine dynamische Methode anonym gehostet werden kann können, oder sie ein Modul oder mit einem Typ logisch zugeordnet.  
  
-   Wenn die dynamische Methode anonym gehostet wird, befindet sich in einer vom System bereitgestellten Assembly, und daher von anderem Code isoliert ist. Standardmäßig ist es nicht auf nicht öffentliche Daten zugreifen. Eine anonym gehostete dynamische Methode kann mit eingeschränkter Fähigkeit zum Überspringen von sichtbarkeitsprüfungen des JIT-Compilers, wenn sie erteilt wurde, <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flag. Die Vertrauensebene der Assembly, deren nicht öffentliche Member von der dynamischen Methode zugegriffen werden, muss, identisch ist oder eine Teilmenge der Vertrauensebene der Aufrufliste, die die dynamische Methode ausgegeben. Weitere Informationen zu anonym gehostete dynamische Methoden, finden Sie unter [Exemplarische Vorgehensweise: Ausgeben von Code in Szenarios mit teilweiser Vertrauenswürdigkeit](~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md).  
  
-   Wenn die dynamische Methode einem Modul zugeordnet, die Sie angeben ist, ist die dynamische Methode für das Modul global. Sie können Zugriff auf alle Typen im Modul und alle `internal` (`Friend` in Visual Basic) Member der Typen. Sie können eine dynamische zuordnen Methode jedem Modul, unabhängig davon, ob Sie das Modul erstellt bereitgestellt, die eine Anforderung für <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> Flag erfüllt werden kann, von der Aufrufliste, die Ihren Code enthält. Wenn die <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Flag im Berechtigungssatz enthalten ist, die dynamische Methode überspringen von sichtbarkeitsprüfungen des JIT-Compilers und Zugriff auf die privaten Daten aller Typen, die im Modul oder in andere Module in einer beliebigen Assembly deklariert werden kann.  
  
    > [!NOTE]
    >  Wenn Sie das Modul angeben, das eine dynamische Methode zugeordnet ist, muss das Modul nicht in der vom System bereitgestellten Assembly, die für das anonyme hosten verwendet wird.  
  
-   Wenn die dynamische Methode einem Typ zugeordnet, die Sie angeben ist, hat er Zugriff auf alle Elemente des Typs, unabhängig von der Zugriffsebene. Darüber hinaus können der JIT-sichtbarkeitsprüfungen übersprungen werden. Dadurch wird die dynamische Methodenzugriff auf die privaten Daten eines anderen Typs im selben Modul oder in andere Module in einer beliebigen Assembly deklariert. Sie können eine dynamische Methode mit einem beliebigen Typ zuordnen, jedoch muss Ihr Code erteilt <xref:System.Security.Permissions.ReflectionPermission> sowohl die <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> und <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess> Flags.  
  
 Die folgende Tabelle zeigt, welche Typen und Member sind zugegriffen werden kann, um eine anonym gehostete dynamische Methode, mit und ohne JIT-sichtbarkeitsprüfungen, je nachdem, ob <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> Flag erteilt wird.  
  
||Ohne <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|Mit <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|  
|-|-|-|  
|Ohne JIT-sichtbarkeitsprüfungen überspringen|Öffentliche Member öffentlicher Typen in einer beliebigen Assembly.|Öffentliche Member öffentlicher Typen in einer beliebigen Assembly.|  
|Überspringen von JIT-sichtbarkeitsprüfungen, mit Einschränkungen|Öffentliche Member öffentlicher Typen in einer beliebigen Assembly.|Alle Mitglieder aller Typen, die nur in Assemblys, deren Vertrauensebenen sind, gleich oder kleiner als die Vertrauensebene der Assembly, die die dynamische Methode ausgegeben, wird.|  
  
> [!NOTE]
>  Vor der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], Ausgeben von Code erforderliche <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> Flag. Durch diese Berechtigung ist standardmäßig in den FullTrust und benannte Berechtigungssätze LocalIntranet enthalten, aber nicht im Internet-Berechtigungssatz festgelegt. Aus diesem Grund in früheren Versionen von der [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] kann eine Bibliothek mit Internetberechtigungen verwendet nur dann, wenn sie die <xref:System.Security.SecurityCriticalAttribute> Attribut, und führt auch eine <xref:System.Security.PermissionSet.Assert%2A> für <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>. Diese Bibliotheken erfordern einen sorgfältigen Sicherheitsreview, da Codierungsfehler zu Sicherheitslücken führen können. In [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)] ist es möglich, Code in teilweise vertrauenswürdigen Szenarios ohne Sicherheitsanforderungen auszugeben, da das Generieren von Code an sich keinen privilegierten Vorgang darstellt. Das bedeutet, dass der generierte Code nicht mehr Berechtigungen aufweist als die Assembly, die ihn ausgibt. Dies ermöglicht es, dass Bibliotheken, die Code ausgeben, sicherheitstransparent sein können, und beseitigt die Notwendigkeit der Assertion von <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>, was das Schreiben einer sicheren Bibliothek vereinfacht. Um dieses Feature verwenden zu können, Ihre Anwendung abzielen soll die [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher.  
  
 Die folgende Tabelle zeigt, welche Typen und Member sind zugegriffen werden kann, um eine dynamische Methode, die mit einem Modul oder einen Typ in einem Modul zugeordnet ist.  
  
||Modul zugeordnet|Mit dem Typ verknüpft ist|  
|-|-|-|  
|Ohne JIT-sichtbarkeitsprüfungen überspringen|Öffentliche und interne Member public, private und interne Typen im Modul.<br /><br /> Öffentliche Member öffentlicher Typen in einer beliebigen Assembly.|Alle Mitglieder des zugeordneten Typs. Öffentliche und interne Member aller anderen Typen im Modul.<br /><br /> Öffentliche Member öffentlicher Typen in einer beliebigen Assembly.|  
|Das Überspringen von JIT-sichtbarkeitsprüfungen|Alle Mitglieder aller Typen in einer beliebigen Assembly.|Alle Mitglieder aller Typen in einer beliebigen Assembly.|  
  
 Eine dynamische Methode, die einem Modul zugeordnet ist, hat die Berechtigungen des Moduls. Eine dynamische Methode, die einem Typ zugeordnet ist, hat die Berechtigungen des Moduls, das den Typ.  
  
 Dynamische Methoden und deren Parameter müssen nicht benannt werden, aber Sie können Namen angeben, um Debuggen zu erleichtern. Benutzerdefinierte Attribute werden für dynamische Methoden oder ihre Parameter nicht unterstützt.  
  
 Obwohl dynamische Methoden werden `static` Methoden (`Shared` -Methoden in Visual Basic), die Regeln gelockert, für die delegatbindung eingeführt der [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] können Sie eine dynamische Methode, die auf ein Objekt gebunden werden, damit es wie eine Instanzmethode dient bei mit dieser Delegatinstanz aufgerufen. Ein Beispiel, die dies veranschaulicht wird bereitgestellt, für die <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> -methodenüberladung.  
  
> [!NOTE]
>  In der [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], dynamische Methoden unterstützen keine Symbolinformationen, die, die Namen lokaler Variablen und Zeilennummern Zuordnung. Diese Einschränkung kann in einer zukünftigen Version entfernt werden. Sie können <xref:System.Reflection.Emit.AssemblyBuilder> während der Entwicklung, um das Debuggen der generierten Microsoft intermediate Language (MSIL) vereinfachen, und wechseln Sie zu dynamischen Methoden während der letzten Bereitstellung, da die <xref:System.Reflection.Emit.ILGenerator> Aufrufe sind in beiden Fällen identisch.  
  
## <a name="verification"></a>Überprüfung  
 Die folgende Liste enthält die Bedingungen, unter denen dynamische Methoden nicht überprüfbaren Code enthalten können. (Z. B. eine dynamische Methode ist nicht überprüfbar wenn seine <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A> -Eigenschaftensatz auf `false`.)  
  
-   Eine dynamische Methode, die einen sicherheitskritischen Assembly zugeordnet ist, wird auch als sicherheitskritisch, und kann die Überprüfung überspringen. Beispielsweise wird eine Assembly ohne Sicherheitsattribute, die als eine desktop-Anwendung ausgeführt wird, von der Laufzeit der als sicherheitskritisch behandelt. Wenn Sie eine dynamische Methode mit der Assembly zuordnen, kann die dynamische Methode nicht überprüfbaren Code enthalten.  
  
-   Wenn eine dynamische Methode, die nicht überprüfbaren Code enthält eine Assembly zugeordnet, die Transparenz der Ebene 1 aufweist ist, wird der just-in-Time (JIT)-Compiler eine sicherheitsforderung eingefügt. Die Anforderung erfolgreich ist, nur dann, wenn die dynamische Methode durch voll vertrauenswürdigen Code ausgeführt wird. [Sicherheitstransparenter Code, Ebene 1](~/docs/framework/misc/security-transparent-code-level-1.md).  
  
-   Wenn eine dynamische Methode, die nicht überprüfbaren Code enthält eine Assembly zugeordnet, die Transparenz der Ebene 2 (z. B. "mscorlib.dll") verfügt ist, löst es eine Ausnahme, die (vom JIT-Compiler eingefügt) anstatt eine sicherheitsforderung. [Sicherheitstransparenter Code, Ebene 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
-   Eine anonym gehostete dynamische Methode, die nicht überprüfbaren Code immer enthält eine Ausnahme ausgelöst. Sie können nie die Überprüfung überspringen, auch wenn es erstellt und durch voll vertrauenswürdigen Code ausgeführt wird.  
  
 Die Ausnahme, die ausgelöst wird, nicht überprüfbaren Code hängt von der Methode, die die dynamische Methode aufgerufen wird. Wenn Sie eine dynamische Methode aufrufen, mit einem Delegaten, die von zurückgegeben der <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> -Methode, eine <xref:System.Security.VerificationException> ausgelöst. Wenn Sie die dynamische Methode mithilfe von Aufrufen der <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> -Methode, eine <xref:System.Reflection.TargetInvocationException> ausgelöst und eine innere <xref:System.Security.VerificationException>.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine dynamische Methode, die zwei Parameter akzeptiert. Im Beispiel gibt einen einfacher Funktionsrumpf, der den ersten Parameter an die Konsole ausgibt, und im Beispiel wird den zweiten Parameter als Rückgabewert der Methode verwendet. Im Beispiel wird die Methode durch Erstellen eines Delegaten, ruft den Delegaten mit verschiedenen Parametern und zum Schluss ruft die dynamische Methode mithilfe der <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> Methode.  
  
 [!code-cpp[Reflection.DynamicMethod.All#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.All#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.All#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Gewusst wie: Definieren und Ausführen von dynamischen Methoden</related>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Sicherheitsaspekte bei der Reflektionsausgabe</related>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">Exemplarische Vorgehensweise: Ausgeben von Code in Szenarien mit teilweiser Vertrauenswürdigkeit</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine dynamische Methode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der dynamischen Methode. Dies kann eine leere Zeichenfolge sein, sie darf aber nicht <see langword="null" /> sein.</param>
        <param name="returnType">Ein <see cref="T:System.Type" />-Objekt, das den Rückgabetyp der dynamischen Methode angibt, oder <see langword="null" />, wenn die Methode keinen Rückgabetyp hat.</param>
        <param name="parameterTypes">Ein Array von <see cref="T:System.Type" />-Objekten, die die Typen der Parameter der dynamischen Methode angeben, oder <see langword="null" />, wenn die Methode keine Parameter hat.</param>
        <summary>Initialisiert eine anonym gehostete dynamische Methode und gibt den Methodennamen, Rückgabetyp und Parametertypen an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die dynamische Methode, die von diesem Konstruktor erstellt wird, das eine anonyme Assembly anstatt einer vorhandenen Typ oder Modul zugeordnet ist. Die anonyme Assembly existiert nur, um eine Sandbox-Umgebung für dynamische Methoden, d. h. bereitzustellen, um sie von anderem Code zu isolieren. Diese Umgebung ist es für die dynamische Methode ausgegeben und Ausführen von teilweise vertrauenswürdigem Code sicher.  
  
 Dieser Konstruktor gibt an, dass die Sichtbarkeit von just-in-Time (JIT) der dynamischen Methode überprüft für die Microsoft intermediate Language (MSIL) erzwungen werden soll. Das verfügt über der Code in der dynamischen Methode Zugriff auf öffentliche Methoden von öffentlichen Klassen. Ausnahmen werden ausgelöst, wenn die Methode versucht, den Zugriff auf Typen oder Member, die `private`, `protected`, oder `internal` (`Friend` in Visual Basic). Verwenden Sie zum Erstellen einer dynamischen Methode, die über eingeschränkte Fähigkeit zum Überspringen von JIT-sichtbarkeitsprüfungen verfügt die <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29> Konstruktor.  
  
 Wenn eine anonym gehostete dynamische Methode erstellt wird, ist die Aufrufliste der ausgebenden Assembly enthalten. Wenn die Methode aufgerufen wird, werden die Berechtigungen der ausgebenden Assembly anstelle der Berechtigungen von der tatsächlichen Aufrufer verwendet. Daher kann die dynamische Methode auf einer höheren Ebene der Rechte als die der Assembly ausführen, die sie ausgegeben wurde, auch wenn es zu übergeben und von einer Assembly, die eine höhere Vertrauensebene ausgeführt wird.  
  
 Dieser Konstruktor gibt an, den Methodenattributen <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> und <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, und die Aufrufkonvention <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Dieser Konstruktor wurde eingeführt, der [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Element von <paramref name="parameterTypes" /> ist <see langword="null" /> oder <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> ist ein Typ, für den <see cref="P:System.Type.IsByRef" /> den Wert <see langword="true" /> zurückgibt.</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Gewusst wie: Definieren und Ausführen von dynamischen Methoden</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Sicherheitsaspekte bei der Reflektionsausgabe</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">Exemplarische Vorgehensweise: Ausgeben von Code in Szenarien mit teilweiser Vertrauenswürdigkeit</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, bool restrictedSkipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), restrictedSkipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, restrictedSkipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="restrictedSkipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der dynamischen Methode. Dies kann eine leere Zeichenfolge sein, sie darf aber nicht <see langword="null" /> sein.</param>
        <param name="returnType">Ein <see cref="T:System.Type" />-Objekt, das den Rückgabetyp der dynamischen Methode angibt, oder <see langword="null" />, wenn die Methode keinen Rückgabetyp hat.</param>
        <param name="parameterTypes">Ein Array von <see cref="T:System.Type" />-Objekten, die die Typen der Parameter der dynamischen Methode angeben, oder <see langword="null" />, wenn die Methode keine Parameter hat.</param>
        <param name="restrictedSkipVisibility"><see langword="true" />, wenn JIT-Sichtbarkeitsprüfungen für Typen und Member übersprungen werden sollen, auf die durch die MSIL der dynamischen Methode zugegriffen wird. Dafür gibt es folgende Einschränkung: Die Vertrauensebene der Assemblys, die diese Typen und Member enthalten, muss identisch sein mit oder kleiner sein als die Vertrauensebene der Aufrufliste, die die dynamische Methode ausgibt. Andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine anonym gehostete dynamische Methode. Dazu werden der Methodenname, der Rückgabetyp und die Parametertypen angegeben und wird angegeben, ob JIT-Sichtbarkeitsprüfungen (Just-In-Time) für Typen und Member übersprungen werden sollen, auf die von der MSIL (Microsoft Intermediate Language) der dynamischen Methode zugegriffen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die dynamische Methode, die von diesem Konstruktor erstellt wird, das eine anonyme Assembly anstatt einer vorhandenen Typ oder Modul zugeordnet ist. Die anonyme Assembly existiert nur, um eine Sandbox-Umgebung für dynamische Methoden, d. h. bereitzustellen, um sie von anderem Code zu isolieren. Diese Umgebung ist es für die dynamische Methode ausgegeben und Ausführen von teilweise vertrauenswürdigem Code sicher.  
  
 Anonym gehostete dynamische Methoden haben automatisch Zugriff auf Typen oder Member, die nicht `private`, `protected`, oder `internal` (`Friend` in Visual Basic). Dies unterscheidet sich von dynamischen Methoden, die mit einem vorhandenen Typ oder Modul, die Zugriff auf ausgeblendete Member in ihrem zugeordneten Bereich aufweisen.  
  
 Geben Sie `true` für `restrictedSkipVisibility` Wenn Ihrer dynamische Methode einen Zugriff auf Typen oder Member, die `private`, `protected`, oder `internal`. Dadurch wird die dynamische Methode, die eingeschränkten Zugriff auf diese Member. D. h. können die Member zugegriffen werden, nur dann, wenn die folgenden Bedingungen erfüllt sind:  
  
-   Die Zielelemente gehören zu einer Assembly, die ein Maß an Vertrauenswürdigkeit kleiner oder gleich der Aufrufliste, die die dynamische Methode ausgibt.  
  
-   Die Aufrufliste, die die dynamische Methode ausgibt erhält <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flag. Dies ist immer "true", wenn der Code mit voller Vertrauenswürdigkeit ausgeführt wird. Für teilweise vertrauenswürdigen Code ist so es nur dann, wenn der Host explizit die Berechtigung gewährt.  
  
    > [!IMPORTANT]
    >  Wenn die Berechtigung nicht erteilt wurde, eine Sicherheitsausnahme wird ausgelöst, wenn <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> aufgerufen wird oder wenn die dynamische Methode aufgerufen wird, nicht wenn dieser Konstruktor aufgerufen wird. Die dynamische Methode ausgeben, sind keine besonderen Berechtigungen erforderlich.  
  
 Z. B. eine dynamische Methode, die erstellt wird `restrictedSkipVisibility` festgelegt `true` können einen privaten Member jeder Assembly in der Aufrufliste zugreifen, wenn die Aufrufliste eingeschränkten Memberzugriffs erteilt wurde. Wenn die dynamische Methode mit teilweise vertrauenswürdigem Code in der Aufrufliste erstellt wird, kann nicht darauf zugreifen, einen privaten Member eines Typs in eine [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] Assembly, da diese Assemblys vollständig vertrauenswürdig sind.  
  
 Wenn `restrictedSkipVisibility` ist `false`, JIT-sichtbarkeitsprüfungen erzwungen werden. Der Code in der dynamischen Methode hat Zugriff auf öffentliche Methoden von öffentlichen Klassen und Ausnahmen werden ausgelöst, wenn versucht wird, Zugriff auf Typen oder Member, die `private`, `protected`, oder `internal`.  
  
 Wenn eine anonym gehostete dynamische Methode erstellt wird, ist die Aufrufliste der ausgebenden Assembly enthalten. Wenn die Methode aufgerufen wird, werden die Berechtigungen der ausgebenden Aufrufliste anstelle die Berechtigungen von der tatsächlichen Aufrufer verwendet. Daher kann die dynamische Methode auf einer höheren Ebene der Rechte als die der Assembly ausführen, die sie ausgegeben wurde, auch wenn es zu übergeben und von einer Assembly, die eine höhere Vertrauensebene ausgeführt wird.  
  
 Dieser Konstruktor gibt an, den Methodenattributen <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> und <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, und die Aufrufkonvention <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Dieser Konstruktor wurde eingeführt, der [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Element von <paramref name="parameterTypes" /> ist <see langword="null" /> oder <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> ist ein Typ, für den <see cref="P:System.Type.IsByRef" /> den Wert <see langword="true" /> zurückgibt.</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Gewusst wie: Definieren und Ausführen von dynamischen Methoden</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Sicherheitsaspekte bei der Reflektionsausgabe</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">Exemplarische Vorgehensweise: Ausgeben von Code in Szenarien mit teilweiser Vertrauenswürdigkeit</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der dynamischen Methode. Dies kann eine leere Zeichenfolge sein, sie darf aber nicht <see langword="null" /> sein.</param>
        <param name="returnType">Ein <see cref="T:System.Type" />-Objekt, das den Rückgabetyp der dynamischen Methode angibt, oder <see langword="null" />, wenn die Methode keinen Rückgabetyp hat.</param>
        <param name="parameterTypes">Ein Array von <see cref="T:System.Type" />-Objekten, die die Typen der Parameter der dynamischen Methode angeben, oder <see langword="null" />, wenn die Methode keine Parameter hat.</param>
        <param name="m">Ein <see cref="T:System.Reflection.Module" />, das das Modul darstellt, dem die dynamische Methode logisch zugeordnet ist.</param>
        <summary>Erstellt eine dynamische Methode, die zu einem Modul global ist, unter Angabe von Methodenname, Rückgabetyp, Parametertypen und Modul.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor gibt Methodenattribute <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> und <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, Aufrufkonvention <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>, und ist nicht just-in-Time (JIT)-sichtbarkeitsprüfungen überspringen.  
  
 Die dynamische Methode, die mit diesem Konstruktor erstellt hat, Zugriff auf öffentliche und `internal` (`Friend` in Visual Basic) Member aller Typen, die im Modul enthaltenen `m`.  
  
> [!NOTE]
>  Um Abwärtskompatibilität zu gewährleisten, erfordert dieser Konstruktor <xref:System.Security.Permissions.SecurityPermission> mit der <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> auszugeben, wenn die folgenden Bedingungen beide sind "true": `m` ist ein Modul als des aufrufenden Moduls und die Nachfrage nach <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Flag Fehler bei. Wenn die Nachfrage nach <xref:System.Security.Permissions.SecurityPermission> erfolgreich ist, der Vorgang ist zulässig.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], dieses Element ist nicht mehr erforderlich <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> Flag. (Finden Sie unter [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine dynamische Methode, die zwei Parameter akzeptiert. Im Beispiel gibt einen einfacher Funktionsrumpf, der den ersten Parameter an die Konsole ausgibt, und im Beispiel wird den zweiten Parameter als Rückgabewert der Methode verwendet. Im Beispiel wird die Methode durch Erstellen eines Delegaten, ruft den Delegaten mit verschiedenen Parametern und zum Schluss ruft die dynamische Methode mithilfe der <xref:System.Reflection.Emit.DynamicMethod.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> Methode.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Element von <paramref name="parameterTypes" /> ist <see langword="null" /> oder <see cref="T:System.Void" />.  
  
- oder - 
 <paramref name="m" /> ist ein Modul, das anonymes Hosting für dynamische Methoden bereitstellt.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="m" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> ist ein Typ, für den <see cref="P:System.Type.IsByRef" /> den Wert <see langword="true" /> zurückgibt.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Um ein Modul als des aufrufenden Moduls die dynamische Methode zuzuordnen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /></permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Gewusst wie: Definieren und Ausführen von dynamischen Methoden</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Sicherheitsaspekte bei der Reflektionsausgabe</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der dynamischen Methode. Dies kann eine leere Zeichenfolge sein, sie darf aber nicht <see langword="null" /> sein.</param>
        <param name="returnType">Ein <see cref="T:System.Type" />-Objekt, das den Rückgabetyp der dynamischen Methode angibt, oder <see langword="null" />, wenn die Methode keinen Rückgabetyp hat.</param>
        <param name="parameterTypes">Ein Array von <see cref="T:System.Type" />-Objekten, die die Typen der Parameter der dynamischen Methode angeben, oder <see langword="null" />, wenn die Methode keine Parameter hat.</param>
        <param name="owner">Ein <see cref="T:System.Type" />, dem die dynamische Methode logisch zugeordnet ist. Die dynamische Methode hat Zugriff auf alle Member des Typs.</param>
        <summary>Erstellt eine dynamische Methode unter Angabe von Methodenname, Rückgabetyp, Parametertypen und dem Typ, dem die dynamische Methode logisch zugeordnet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die dynamische Methode, die mit diesem Konstruktor erstellt hat, Zugriff auf alle Elemente des Typs `owner`, und klicken Sie auf öffentliche und `internal` (`Friend` in Visual Basic) Mitglied aller anderen Typen in das Modul mit `owner`.  
  
 Dieser Konstruktor gibt Methodenattribute <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> und <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, Aufrufkonvention <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>, und ist nicht just-in-Time (JIT)-sichtbarkeitsprüfungen überspringen.  
  
> [!NOTE]
>  Um Abwärtskompatibilität zu gewährleisten, erfordert dieser Konstruktor <xref:System.Security.Permissions.SecurityPermission> mit der <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> auszugeben, wenn die folgenden Bedingungen beide sind "true": `owner` befindet sich in einem anderen Modul als des aufrufenden Moduls und die Nachfrage nach <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Flag ist fehlgeschlagen. Wenn die Nachfrage nach <xref:System.Security.Permissions.SecurityPermission> erfolgreich ist, der Vorgang ist zulässig.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], dieses Element ist nicht mehr erforderlich <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> Flag. (Finden Sie unter [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine <xref:System.Reflection.Emit.DynamicMethod> , logisch ein Typ zugeordnet ist. Diese Zuordnung erhalten sie Zugriff auf die privaten Member dieses Typs.  
  
 Das Codebeispiel definiert eine Klasse namens `Example` mit einem privaten Feld, eine Klasse mit dem Namen `DerivedFromxample` abgeleitet, die die erste Klasse, ein Delegattyp namens `UseLikeStatic` zurückgibt <xref:System.Int32> und verfügt über Parameter des Typs `Example` und <xref:System.Int32>, und ein Delegattyp namens `UseLikeInstance` zurückgibt <xref:System.Int32> und verfügt über einen Parameter vom Typ <xref:System.Int32>.  
  
 Der Beispielcode erstellt eine <xref:System.Reflection.Emit.DynamicMethod> , ändert es sich um das private Feld einer Instanz von `Example` und gibt den vorherigen Wert zurück.  
  
> [!NOTE]
>  Im Allgemeinen ist die internen Felder von Klassen ändern nicht gut objektorientierter Vorgehensweise bei der Codierung.  
  
 Der Beispielcode erstellt eine Instanz von `Example` und anschließend werden zwei Delegaten erstellt. Die erste ist vom Typ `UseLikeStatic`, die über die gleichen Parameter wie die dynamische Methode verfügt. Die zweite ist vom Typ `UseLikeInstance`, das Fehlen des ersten Parameters (des Typs `Example`). Dieser Delegat wird erstellt, mit der <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> methodenüberladung; der zweite Parameter dieser methodenüberladung ist eine Instanz der `Example`, in diesem Fall die Instanz gerade erstellt haben, die auf den neu erstellten Delegaten gebunden ist. Wenn dieser Delegat aufgerufen wird, fungiert die dynamische Methode auf die gebundene Instanz von `Example`.  
  
> [!NOTE]
>  Dies ist ein Beispiel für die weniger strengen Regeln, für die delegatbindung eingeführt der [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], sowie neue Überladungen der <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> Methode. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Delegate>-Klasse.  
  
 Die `UseLikeStatic` Delegat aufgerufen wird, übergibt die Instanz von `Example` , gebunden ist, um die `UseLikeInstance` delegieren. Die `UseLikeInstance` Delegat wird aufgerufen, sodass beide Delegaten auf derselben Instanz ausgeführt `Example`. Nach jedem Aufruf werden die Änderungen die Werte für das interne Feld angezeigt. Zum Schluss eine `UseLikeInstance` Delegat gebunden ist, mit einer Instanz von `DerivedFromxample`, und der Delegat ruft wiederholt werden.  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Element von <paramref name="parameterTypes" /> ist <see langword="null" /> oder <see cref="T:System.Void" />.  
  
- oder - 
 <paramref name="owner" /> ist eine Schnittstelle, ein Array, ein offener generischer Typ oder ein Typparameter eines generischen Typs oder einer generischen Methode.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="owner" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> ist <see langword="null" /> oder ein Typ, für den <see cref="P:System.Type.IsByRef" /><see langword="true" /> zurückgibt.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">um die dynamische Methode mit einem Typ in einem Modul als des aufrufenden Moduls zuzuordnen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /></permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Gewusst wie: Definieren und Ausführen von dynamischen Methoden</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Sicherheitsaspekte bei der Reflektionsausgabe</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der dynamischen Methode. Dies kann eine leere Zeichenfolge sein, sie darf aber nicht <see langword="null" /> sein.</param>
        <param name="returnType">Ein <see cref="T:System.Type" />-Objekt, das den Rückgabetyp der dynamischen Methode angibt, oder <see langword="null" />, wenn die Methode keinen Rückgabetyp hat.</param>
        <param name="parameterTypes">Ein Array von <see cref="T:System.Type" />-Objekten, die die Typen der Parameter der dynamischen Methode angeben, oder <see langword="null" />, wenn die Methode keine Parameter hat.</param>
        <param name="m">Ein <see cref="T:System.Reflection.Module" />, das das Modul darstellt, dem die dynamische Methode logisch zugeordnet ist.</param>
        <param name="skipVisibility"><see langword="true" />, wenn bei Zugriffen durch die MSIL der dynamischen Methode JIT-Sichtbarkeitsprüfungen für Typen und Member übersprungen werden</param>
        <summary>Erstellt eine dynamische Methode, die in einem Modul global ist, unter Angabe von Methodenname, Rückgabetyp, Parametertypen und Modul sowie, ob Just-In-Time (JIT)-Sichtbarkeitsprüfungen für Typen und Member übersprungen werden sollen, auf die von der Microsoft intermediate language (MSIL) der dynamischen Methode zugegriffen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor gibt Methodenattribute <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> und <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, und die Aufrufkonvention <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
 Die dynamische Methode, die mit diesem Konstruktor erstellt hat, Zugriff auf öffentliche und `internal` (`Friend` in Visual Basic) Member aller Typen im Modul `m`. Überspringen der JIT-Compiler sichtbarkeitsprüfungen des Compilers ermöglicht die dynamische Methode, um private und geschützte Member sowie aller anderen Typen zuzugreifen. Dies empfiehlt sich beispielsweise beim Schreiben von Code, um Objekte zu serialisieren.  
  
> [!NOTE]
>  Um Abwärtskompatibilität zu gewährleisten, erfordert dieser Konstruktor <xref:System.Security.Permissions.SecurityPermission> mit der <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> auszugeben, wenn die folgenden Bedingungen beide sind "true": `m` ist ein Modul als des aufrufenden Moduls und die Nachfrage nach <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Flag Fehler bei. Wenn die Nachfrage nach <xref:System.Security.Permissions.SecurityPermission> erfolgreich ist, der Vorgang ist zulässig.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], dieses Element ist nicht mehr erforderlich <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> Flag. (Finden Sie unter [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Element von <paramref name="parameterTypes" /> ist <see langword="null" /> oder <see cref="T:System.Void" />.  
  
- oder - 
 <paramref name="m" /> ist ein Modul, das anonymes Hosting für dynamische Methoden bereitstellt.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="m" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> ist ein Typ, für den <see cref="P:System.Type.IsByRef" /> den Wert <see langword="true" /> zurückgibt.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Um ein Modul als des aufrufenden Moduls die dynamische Methode zuzuordnen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /></permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Gewusst wie: Definieren und Ausführen von dynamischen Methoden</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Sicherheitsaspekte bei der Reflektionsausgabe</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der dynamischen Methode. Dies kann eine leere Zeichenfolge sein, sie darf aber nicht <see langword="null" /> sein.</param>
        <param name="returnType">Ein <see cref="T:System.Type" />-Objekt, das den Rückgabetyp der dynamischen Methode angibt, oder <see langword="null" />, wenn die Methode keinen Rückgabetyp hat.</param>
        <param name="parameterTypes">Ein Array von <see cref="T:System.Type" />-Objekten, die die Typen der Parameter der dynamischen Methode angeben, oder <see langword="null" />, wenn die Methode keine Parameter hat.</param>
        <param name="owner">Ein <see cref="T:System.Type" />, dem die dynamische Methode logisch zugeordnet ist. Die dynamische Methode hat Zugriff auf alle Member des Typs.</param>
        <param name="skipVisibility"><see langword="true" />, wenn bei Zugriffen durch die MSIL der dynamischen Methode JIT-Sichtbarkeitsprüfungen für Typen und Member übersprungen werden, andernfalls <see langword="false" />.</param>
        <summary>Erstellt eine dynamische Methode unter Angabe von Methodenname, Rückgabetyp, Parametertypen, dem Typ, dem die dynamische Methode logisch zugeordnet ist, sowie, ob Just-In-Time (JIT)-Sichtbarkeitsprüfungen für Typen und Member bei Zugriffen durch die Microsoft Intermediate Language (MSIL) der dynamischen Methode übersprungen werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die dynamische Methode, die mit diesem Konstruktor erstellt hat, Zugriff auf alle Elemente des Typs `owner`, und klicken Sie auf öffentliche und `internal` (`Friend` in Visual Basic) Mitglied aller anderen Typen in das Modul mit `owner`. Überspringen der JIT-Compiler sichtbarkeitsprüfungen des Compilers ermöglicht die dynamische Methode, um private und geschützte Member sowie aller anderen Typen zuzugreifen. Dies empfiehlt sich beispielsweise beim Schreiben von Code, um Objekte zu serialisieren.  
  
 Dieser Konstruktor gibt Methodenattribute <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> und <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, und die Aufrufkonvention <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Um Abwärtskompatibilität zu gewährleisten, erfordert dieser Konstruktor <xref:System.Security.Permissions.SecurityPermission> mit der <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> auszugeben, wenn die folgenden Bedingungen beide sind "true": `owner` befindet sich in einem anderen Modul als des aufrufenden Moduls und die Nachfrage nach <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Flag ist fehlgeschlagen. Wenn die Nachfrage nach <xref:System.Security.Permissions.SecurityPermission> erfolgreich ist, der Vorgang ist zulässig.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], dieses Element ist nicht mehr erforderlich <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> Flag. (Finden Sie unter [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Element von <paramref name="parameterTypes" /> ist <see langword="null" /> oder <see cref="T:System.Void" />.  
  
- oder - 
 <paramref name="owner" /> ist eine Schnittstelle, ein Array, ein offener generischer Typ oder ein Typparameter eines generischen Typs oder einer generischen Methode.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="owner" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> ist <see langword="null" /> oder ein Typ, für den <see cref="P:System.Type.IsByRef" /><see langword="true" /> zurückgibt.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">um die dynamische Methode mit einem Typ in einem Modul als des aufrufenden Moduls zuzuordnen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /></permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Gewusst wie: Definieren und Ausführen von dynamischen Methoden</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Sicherheitsaspekte bei der Reflektionsausgabe</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der dynamischen Methode. Dies kann eine leere Zeichenfolge sein, sie darf aber nicht <see langword="null" /> sein.</param>
        <param name="attributes">Eine bitweise Kombination von <see cref="T:System.Reflection.MethodAttributes" />-Werten, die die Attribute der dynamischen Methode angibt. Die einzige zulässige Kombination ist <see cref="F:System.Reflection.MethodAttributes.Public" /> und <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">Die Aufrufkonvention für die dynamische Methode. Dieser Wert muss <see cref="F:System.Reflection.CallingConventions.Standard" /> sein.</param>
        <param name="returnType">Ein <see cref="T:System.Type" />-Objekt, das den Rückgabetyp der dynamischen Methode angibt, oder <see langword="null" />, wenn die Methode keinen Rückgabetyp hat.</param>
        <param name="parameterTypes">Ein Array von <see cref="T:System.Type" />-Objekten, die die Typen der Parameter der dynamischen Methode angeben, oder <see langword="null" />, wenn die Methode keine Parameter hat.</param>
        <param name="m">Ein <see cref="T:System.Reflection.Module" />, das das Modul darstellt, dem die dynamische Methode logisch zugeordnet ist.</param>
        <param name="skipVisibility"><see langword="true" />, wenn bei Zugriffen durch die MSIL der dynamischen Methode JIT-Sichtbarkeitsprüfungen für Typen und Member übersprungen werden, andernfalls <see langword="false" />.</param>
        <summary>Erstellt eine dynamische Methode, die in einem Modul global ist, unter Angabe von Methodenname, Attributen, Aufrufkonvention, Rückgabetyp, Parametertypen und Modul sowie, ob Just-In-Time (JIT)-Sichtbarkeitsprüfungen für Typen und Member übersprungen werden sollen, auf die von der Microsoft intermediate language (MSIL) der dynamischen Methode zugegriffen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die dynamische Methode, die mit diesem Konstruktor erstellt hat, Zugriff auf öffentliche und `internal` (`Friend` in Visual Basic) Member aller öffentlichen und internen Typen, die im Modul enthaltenen `m`.  
  
 Überspringen von JIT-sichtbarkeitsprüfungen des Compilers können privaten und geschützten Member aller anderen Typen in das Modul und alle anderen Assemblys den Zugriff auf die dynamische Methode. Dies empfiehlt sich beispielsweise beim Schreiben von Code, um Objekte zu serialisieren.  
  
> [!NOTE]
>  Um Abwärtskompatibilität zu gewährleisten, erfordert dieser Konstruktor <xref:System.Security.Permissions.SecurityPermission> mit der <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> auszugeben, wenn die folgenden Bedingungen beide sind "true": `m` ist ein Modul als des aufrufenden Moduls und die Nachfrage nach <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Flag Fehler bei. Wenn die Nachfrage nach <xref:System.Security.Permissions.SecurityPermission> erfolgreich ist, der Vorgang ist zulässig.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], dieses Element ist nicht mehr erforderlich <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> Flag. (Finden Sie unter [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Element von <paramref name="parameterTypes" /> ist <see langword="null" /> oder <see cref="T:System.Void" />.  
  
- oder - 
 <paramref name="m" /> ist ein Modul, das anonymes Hosting für dynamische Methoden bereitstellt.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="m" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="attributes" /> ist eine Kombination aus anderen Flags als <see cref="F:System.Reflection.MethodAttributes.Public" /> und <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
- oder - 
 <paramref name="callingConvention" /> ist nicht <see cref="F:System.Reflection.CallingConventions.Standard" />.  
  
- oder - 
 <paramref name="returnType" /> ist ein Typ, für den <see cref="P:System.Type.IsByRef" /> den Wert <see langword="true" /> zurückgibt.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Um ein Modul als des aufrufenden Moduls die dynamische Methode zuzuordnen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /></permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Gewusst wie: Definieren und Ausführen von dynamischen Methoden</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Sicherheitsaspekte bei der Reflektionsausgabe</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der dynamischen Methode. Dies kann eine leere Zeichenfolge sein, sie darf aber nicht <see langword="null" /> sein.</param>
        <param name="attributes">Eine bitweise Kombination von <see cref="T:System.Reflection.MethodAttributes" />-Werten, die die Attribute der dynamischen Methode angibt. Die einzige zulässige Kombination ist <see cref="F:System.Reflection.MethodAttributes.Public" /> und <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">Die Aufrufkonvention für die dynamische Methode. Dieser Wert muss <see cref="F:System.Reflection.CallingConventions.Standard" /> sein.</param>
        <param name="returnType">Ein <see cref="T:System.Type" />-Objekt, das den Rückgabetyp der dynamischen Methode angibt, oder <see langword="null" />, wenn die Methode keinen Rückgabetyp hat.</param>
        <param name="parameterTypes">Ein Array von <see cref="T:System.Type" />-Objekten, die die Typen der Parameter der dynamischen Methode angeben, oder <see langword="null" />, wenn die Methode keine Parameter hat.</param>
        <param name="owner">Ein <see cref="T:System.Type" />, dem die dynamische Methode logisch zugeordnet ist. Die dynamische Methode hat Zugriff auf alle Member des Typs.</param>
        <param name="skipVisibility"><see langword="true" />, wenn bei Zugriffen durch die MSIL der dynamischen Methode JIT-Sichtbarkeitsprüfungen für Typen und Member übersprungen werden, andernfalls <see langword="false" />.</param>
        <summary>Erstellt eine dynamische Methode unter Angabe von Methodenname, Attributen, Aufrufkonvention, Rückgabetyp, Parametertypen, dem Typ, dem die dynamische Methode logisch zugeordnet ist, sowie, ob Just-In-Time (JIT)-Sichtbarkeitsprüfungen für Typen und Member bei Zugriffen durch die Microsoft Intermediate Language (MSIL) der dynamischen Methode übersprungen werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die dynamische Methode ist global für das Modul, das den Typ enthält `owner`. Sie hat Zugriff auf alle Member des Typs `owner`.  
  
 Die dynamische Methode, die mit diesem Konstruktor erstellt hat, Zugriff auf alle Elemente des Typs `owner`, und auf öffentliche und `internal` (`Friend` in Visual Basic) Member aller Typen, die in das Modul mit enthaltenen `owner`. Überspringen der JIT-Compiler sichtbarkeitsprüfungen des Compilers ermöglicht die dynamische Methode, um private und geschützte Member sowie aller anderen Typen zuzugreifen. Dies empfiehlt sich beispielsweise beim Schreiben von Code, um Objekte zu serialisieren.  
  
> [!NOTE]
>  Um Abwärtskompatibilität zu gewährleisten, erfordert dieser Konstruktor <xref:System.Security.Permissions.SecurityPermission> mit der <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> auszugeben, wenn die folgenden Bedingungen beide sind "true": `owner` befindet sich in einem anderen Modul als des aufrufenden Moduls und die Nachfrage nach <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Flag ist fehlgeschlagen. Wenn die Nachfrage nach <xref:System.Security.Permissions.SecurityPermission> erfolgreich ist, der Vorgang ist zulässig.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], dieses Element ist nicht mehr erforderlich <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> Flag. (Finden Sie unter [Sicherheitsaspekte bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Element von <paramref name="parameterTypes" /> ist <see langword="null" /> oder <see cref="T:System.Void" />.  
  
- oder - 
 <paramref name="owner" /> ist eine Schnittstelle, ein Array, ein offener generischer Typ oder ein Typparameter eines generischen Typs oder einer generischen Methode.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="owner" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="attributes" /> ist eine Kombination aus anderen Flags als <see cref="F:System.Reflection.MethodAttributes.Public" /> und <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
- oder - 
 <paramref name="callingConvention" /> ist nicht <see cref="F:System.Reflection.CallingConventions.Standard" />.  
  
- oder - 
 <paramref name="returnType" /> ist ein Typ, für den <see cref="P:System.Type.IsByRef" /> den Wert <see langword="true" /> zurückgibt.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">um die dynamische Methode mit einem Typ in einem Modul als des aufrufenden Moduls zuzuordnen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /></permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Gewusst wie: Definieren und Ausführen von dynamischen Methoden</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Sicherheitsaspekte bei der Reflektionsausgabe</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.MethodAttributes" Usage="System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die beim Erstellen der dynamischen Methode angegebenen Attribute ab.</summary>
        <value>Eine bitweise Kombination der <see cref="T:System.Reflection.MethodAttributes" />-Werte, die die Attribute für die Methode darstellen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Derzeit sind die Attribute für eine dynamische Methode immer <xref:System.Reflection.MethodAttributes.Public> und <xref:System.Reflection.MethodAttributes.Static>.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die Attribute einer dynamischen Methode. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Reflection.Emit.DynamicMethod> Klasse.  
  
 [!code-cpp[Reflection.DynamicMethod.All#21](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#21)]
 [!code-csharp[Reflection.DynamicMethod.All#21](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#21)]
 [!code-vb[Reflection.DynamicMethod.All#21](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberSignature Language="F#" Value="member this.CallingConvention : System.Reflection.CallingConventions" Usage="System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die beim Erstellen der dynamischen Methode angegebene Aufrufkonvention ab.</summary>
        <value>Einer der <see cref="T:System.Reflection.CallingConventions" />-Werte, der die Aufrufkonvention der Methode angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Derzeit ist die Aufrufkonvention für eine dynamische Methode immer <xref:System.Reflection.CallingConventions.Standard>.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die Aufrufkonvention einer dynamischen Methode. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Reflection.Emit.DynamicMethod> Klasse.  
  
 [!code-cpp[Reflection.DynamicMethod.All#22](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#22)]
 [!code-csharp[Reflection.DynamicMethod.All#22](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#22)]
 [!code-vb[Reflection.DynamicMethod.All#22](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vervollständigt die dynamische Methode und erstellt einen Delegaten, mit dem die Methode ausgeführt werden kann.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type -&gt; Delegate" Usage="dynamicMethod.CreateDelegate delegateType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="delegateType">Ein Delegattyp, dessen Signatur der der dynamischen Methode entspricht.</param>
        <summary>Vervollständigt die dynamische Methode und erstellt einen Delegaten, mit dem die Methode ausgeführt werden kann.</summary>
        <returns>Ein Delegat des angegebenen Typs, mit dem die dynamische Methode ausgeführt werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen der <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> Methode oder der <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> Methode ausgeführt wird, die dynamische Methode. Eine weitere versuchen, die dynamische Methode, wie z. B. das Ändern von Parameterdefinitionen alter oder ausgeben Weitere Microsoft intermediate Language (MSIL), wird ignoriert; Es wird keine Ausnahme ausgelöst.  
  
 Um ein Methodentext für eine dynamische Methode zu erstellen, wenn Sie Ihre eigenen MSIL-Generator haben, rufen Sie die <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A> Methode zum Abrufen einer <xref:System.Reflection.Emit.DynamicILInfo> Objekt. Wenn Sie nicht Ihre eigenen MSIL-Generator haben, rufen Sie die <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A> Methode zum Abrufen einer <xref:System.Reflection.Emit.ILGenerator> -Objekt, das zum Generieren von Methodentext verwendet werden kann.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine dynamische Methode, die zwei Parameter akzeptiert. Im Beispiel gibt einen einfacher Funktionsrumpf, der den ersten Parameter an die Konsole ausgibt, und im Beispiel wird den zweiten Parameter als Rückgabewert der Methode verwendet. Im Beispiel wird die Methode durch Erstellen eines Delegaten, ruft den Delegaten mit verschiedenen Parametern und zum Schluss ruft die dynamische Methode mithilfe der <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> Methode.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die dynamische Methode verfügt über keinen Methodentext.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="delegateType" /> hat die falsche Anzahl von Parametern oder die falschen Parametertypen.</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Gewusst wie: Definieren und Ausführen von dynamischen Methoden</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType, object target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType, object target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type, target As Object) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType, System::Object ^ target);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type * obj -&gt; Delegate" Usage="dynamicMethod.CreateDelegate (delegateType, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="delegateType">Ein Delegattyp, dessen Signatur der der dynamischen Methode ohne den ersten Parameter entspricht.</param>
        <param name="target">Ein Objekt, an das der Delegat gebunden ist. Dieses muss von demselben Typ wie der erste Parameter der dynamischen Methode sein.</param>
        <summary>Vervollständigt die dynamische Methode und erstellt einen Delegaten, mit dem diese ausgeführt werden kann, unter Angabe des Delegattyps und eines Objekts, an das der Delegat gebunden ist.</summary>
        <returns>Ein Delegat des angegebenen Typs, mit dem die dynamische Methode für das angegebene Zielobjekt ausgeführt werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überladung dieser Methode erstellt einen Delegaten für ein bestimmtes Objekt gebunden. Ein solchen Delegaten spricht über das erste Argument geschlossen ist. Obwohl die Methode statisch ist, fungiert er als handele es sich um eine Instanzmethode; die Instanz ist `target`.  
  
 Diese methodenüberladung erfordert `target` des gleichen Typs wie der erste Parameter der dynamischen Methode werden oder auf diesen Typ (z. B. eine abgeleitete Klasse) zugewiesen werden können.  Die Signatur der `delegateType` verfügt über alle Parameter der dynamischen Methode mit Ausnahme der ersten. Wenn die dynamische Methode die Parameter hat z. B. <xref:System.String>, <xref:System.Int32>, und <xref:System.Byte>, klicken Sie dann `delegateType` verfügt über die Parameter <xref:System.Int32> und <xref:System.Byte>; `target` ist vom Typ <xref:System.String>.  
  
 Aufrufen der <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> Methode oder der <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> Methode ausgeführt wird, die dynamische Methode. Eine weitere versuchen, die dynamische Methode, wie z. B. das Ändern von Parameterdefinitionen alter oder ausgeben Weitere Microsoft intermediate Language (MSIL), wird ignoriert; Es wird keine Ausnahme ausgelöst.  
  
 Um ein Methodentext für eine dynamische Methode zu erstellen, wenn Sie Ihre eigenen MSIL-Generator haben, rufen Sie die <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A> Methode zum Abrufen einer <xref:System.Reflection.Emit.DynamicILInfo> Objekt. Wenn Sie nicht Ihre eigenen MSIL-Generator haben, rufen Sie die <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A> Methode zum Abrufen einer <xref:System.Reflection.Emit.ILGenerator> -Objekt, das zum Generieren von Methodentext verwendet werden kann.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt Delegat, der bindet ein <xref:System.Reflection.Emit.DynamicMethod> an eine Instanz eines Typs, damit die Methode in der gleichen Instanz jedes Mal fungiert er wird aufgerufen.  
  
 Das Codebeispiel definiert eine Klasse namens `Example` mit einem privaten Feld, eine Klasse mit dem Namen `DerivedFromxample` abgeleitet, die die erste Klasse, ein Delegattyp namens `UseLikeStatic` zurückgibt <xref:System.Int32> und verfügt über Parameter des Typs `Example` und <xref:System.Int32>, und ein Delegattyp namens `UseLikeInstance` zurückgibt <xref:System.Int32> und verfügt über einen Parameter vom Typ <xref:System.Int32>.  
  
 Der Beispielcode erstellt eine <xref:System.Reflection.Emit.DynamicMethod> , ändert es sich um das private Feld einer Instanz von `Example` und gibt den vorherigen Wert zurück.  
  
> [!NOTE]
>  Im Allgemeinen ist die internen Felder von Klassen ändern nicht gut objektorientierter Vorgehensweise bei der Codierung.  
  
 Der Beispielcode erstellt eine Instanz von `Example` und anschließend werden zwei Delegaten erstellt. Die erste ist vom Typ `UseLikeStatic`, die über die gleichen Parameter wie die dynamische Methode verfügt. Die zweite ist vom Typ `UseLikeInstance`, das Fehlen des ersten Parameters (des Typs `Example`). Dieser Delegat wird erstellt, mit der <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> methodenüberladung; der zweite Parameter dieser methodenüberladung ist eine Instanz der `Example`, in diesem Fall die Instanz gerade erstellt haben, die auf den neu erstellten Delegaten gebunden ist. Wenn dieser Delegat aufgerufen wird, fungiert die dynamische Methode auf die gebundene Instanz von `Example`.  
  
> [!NOTE]
>  Dies ist ein Beispiel für die weniger strengen Regeln, für die delegatbindung eingeführt der [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], sowie neue Überladungen der <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType> Methode. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Delegate>-Klasse.  
  
 Die `UseLikeStatic` Delegat aufgerufen wird, übergibt die Instanz von `Example` , gebunden ist, um die `UseLikeInstance` delegieren. Die `UseLikeInstance` Delegat wird aufgerufen, sodass beide Delegaten auf derselben Instanz ausgeführt `Example`. Nach jedem Aufruf werden die Änderungen die Werte für das interne Feld angezeigt. Zum Schluss eine `UseLikeInstance` Delegat gebunden ist, mit einer Instanz von `DerivedFromxample`, und der Delegat ruft wiederholt werden.  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die dynamische Methode verfügt über keinen Methodentext.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> ist nicht von demselben Typ wie der erste Parameter der dynamischen Methode und kann diesem Typ nicht zugeordnet werden.  
  
- oder - 
 <paramref name="delegateType" /> hat die falsche Anzahl von Parametern oder die falschen Parametertypen.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ ab, der die Methode deklariert, die für dynamische Methoden immer <see langword="null" /> ist.</summary>
        <value>Immer <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gibt diese Eigenschaft immer `null` für dynamische Methoden. Auch wenn eine dynamische Methode logisch zugeordnet ist, mit einem Typ ist, ist es nicht durch den Typ deklariert.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den deklarierenden Typ einer dynamischen Methode. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Reflection.Emit.DynamicMethod> Klasse.  
  
 [!code-cpp[Reflection.DynamicMethod.All#23](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#23)]
 [!code-csharp[Reflection.DynamicMethod.All#23](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#23)]
 [!code-vb[Reflection.DynamicMethod.All#23](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, parameterName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ parameterName);" />
      <MemberSignature Language="F#" Value="member this.DefineParameter : int * System.Reflection.ParameterAttributes * string -&gt; System.Reflection.Emit.ParameterBuilder" Usage="dynamicMethod.DefineParameter (position, attributes, parameterName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="parameterName" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="position">Die Position des Parameters in der Parameterliste. Parameter werden indiziert, beginnend mit der Zahl 1 für den ersten Parameter.</param>
        <param name="attributes">Eine bitweise Kombination von <see cref="T:System.Reflection.ParameterAttributes" />-Werten, die die Attribute des Parameters angibt.</param>
        <param name="parameterName">Der Name des Parameters. Der Name kann eine Zeichenfolge der Länge 0 (null) sein.</param>
        <summary>Definiert einen Parameter der dynamischen Methode.</summary>
        <returns>Gibt immer <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `position` 0 (null) ist die <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> Methode bezieht sich auf den Rückgabewert. Legt er Parameterinformationen hat keine Auswirkungen auf den Rückgabewert.  
  
 Wenn die dynamische Methode, durch den Aufruf wurde bereits abgeschlossen der <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> oder <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> -Methode, die <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> Methode hat keine Auswirkungen. Es werden keine Ausnahmen ausgelöst.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Parameterinformationen für eine dynamische Methode definiert wird. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Reflection.Emit.DynamicMethod> Klasse.  
  
 [!code-cpp[Reflection.DynamicMethod.All#33](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#33)]
 [!code-csharp[Reflection.DynamicMethod.All#33](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#33)]
 [!code-vb[Reflection.DynamicMethod.All#33](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Methode hat keine Parameter.  
  
- oder - 
 <paramref name="position" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="position" /> ist größer als die Anzahl der Parameter der Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetBaseDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="dynamicMethod.GetBaseDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Basisimplementierung der Methode zurück.</summary>
        <returns>Die Basisimplementierung der Methode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt immer die aktuelle `DynamicMethod` Objekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die auf die Methode angewendeten benutzerdefinierten Attribute zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="inherit"><see langword="true" />, wenn die Vererbungskette der Methode nach den benutzerdefinierten Attributen durchsucht werden soll, <see langword="false" />, wenn nur die aktuelle Methode überprüft werden soll.</param>
        <summary>Gibt alle benutzerdefinierten Attribute zurück, die für die Methode definiert sind.</summary>
        <returns>Ein Array von Objekten, die alle benutzerdefinierten Attribute der Methode darstellen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei dynamischen Methoden angeben `true` für `inherit` wirkt sich nicht, da die Methode nicht in einem Typ deklariert ist.  
  
> [!NOTE]
>  Benutzerdefinierte Attribute sind nicht aktuell zu dynamischen Methoden unterstützt. Das einzige Attribut zurückgegeben wird <xref:System.Runtime.CompilerServices.MethodImplAttribute>; erhalten Sie die Methode Implementierungsflags leichter mithilfe der <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A> Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="attributeType">Ein <see cref="T:System.Type" />, der den Typ des zurückzugebenden benutzerdefinierten Attributs darstellt.</param>
        <param name="inherit"><see langword="true" />, wenn die Vererbungskette der Methode nach den benutzerdefinierten Attributen durchsucht werden soll, <see langword="false" />, wenn nur die aktuelle Methode überprüft werden soll.</param>
        <summary>Gibt die auf die Methode angewendeten benutzerdefinierten Attribute des angegebenen Typs zurück.</summary>
        <returns>Ein Array von Objekten, die die Attribute der Methode darstellen und vom Typ <paramref name="attributeType" /> sind oder vom Typ <paramref name="attributeType" /> abgeleitet werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei dynamischen Methoden angeben `true` für `inherit` wirkt sich nicht, da die Methode nicht in einem Typ deklariert ist.  
  
> [!NOTE]
>  Benutzerdefinierte Attribute sind nicht aktuell zu dynamischen Methoden unterstützt. Das einzige Attribut zurückgegeben wird <xref:System.Runtime.CompilerServices.MethodImplAttribute>; erhalten Sie die Methode Implementierungsflags leichter mithilfe der <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="attributeType" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetDynamicILInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.DynamicILInfo GetDynamicILInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.DynamicILInfo GetDynamicILInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDynamicILInfo () As DynamicILInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::DynamicILInfo ^ GetDynamicILInfo();" />
      <MemberSignature Language="F#" Value="member this.GetDynamicILInfo : unit -&gt; System.Reflection.Emit.DynamicILInfo" Usage="dynamicMethod.GetDynamicILInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.DynamicILInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Reflection.Emit.DynamicILInfo" />-Objekt zurück, das zum Generieren von Methodentext aus Metadatentoken, Bereichen und MSIL-Streams (Microsoft Intermediate Language) verwendet werden kann.</summary>
        <returns>Ein <see cref="T:System.Reflection.Emit.DynamicILInfo" />-Objekt, das zum Generieren von Methodentext aus Metadatentoken, Bereichen und MSIL-Streams verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.Emit.DynamicILInfo> Klasse wird bereitgestellt, um die Generierung von nicht verwaltetem Code zu unterstützen.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Ausführen von nicht verwalteten Codes. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Reflection.Emit.DynamicILInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen MSIL-Generator zurück, mit dem Text für die dynamische Methode ausgegeben werden kann.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : unit -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen MSIL-Generator (Microsoft Intermediate Language) für die Methode mit einer MSIL-Standardstreamgröße von 64 Bytes zurück.</summary>
        <returns>Ein <see cref="T:System.Reflection.Emit.ILGenerator" />-Objekt für die Methode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nachdem eine dynamische Methode, durch den Aufruf abgeschlossen wurde der <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> oder <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> -Methode, weitere Versuche, MSIL hinzuzufügen, ignoriert. Es werden keine Ausnahmen ausgelöst.  
  
> [!NOTE]
>  Es gibt Einschränkungen für nicht überprüfbaren Code im dynamischen Methoden auch in einigen Szenarien voller Vertrauenswürdigkeit. Weitere Informationen finden Sie im Abschnitt „Überprüfung“ für <xref:System.Reflection.Emit.DynamicMethod>.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine dynamische Methode, die zwei Parameter akzeptiert. Im Beispiel gibt einen einfacher Funktionsrumpf, der den ersten Parameter an die Konsole ausgibt, und im Beispiel wird den zweiten Parameter als Rückgabewert der Methode verwendet. Im Beispiel wird die Methode durch Erstellen eines Delegaten, ruft den Delegaten mit verschiedenen Parametern und zum Schluss ruft die dynamische Methode mithilfe der <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> Methode.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Gewusst wie: Definieren und Ausführen von dynamischen Methoden</related>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int streamSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 streamSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (streamSize As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int streamSize);" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : int -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator streamSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="streamSize">Die Größe des MSIL-Streams in Bytes.</param>
        <summary>Gibt einen MSIL-Generator (Microsoft Intermediate Language) für die Methode mit der angegebenen MSIL-Streamgröße zurück.</summary>
        <returns>Ein <see cref="T:System.Reflection.Emit.ILGenerator" />-Objekt für die Methode mit der angegebenen MSIL-Streamgröße.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nachdem eine dynamische Methode, durch den Aufruf abgeschlossen wurde der <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> oder <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> -Methode, weitere Versuche, MSIL hinzuzufügen, ignoriert. Es werden keine Ausnahmen ausgelöst.  
  
> [!NOTE]
>  Es gibt Einschränkungen für nicht überprüfbaren Code im dynamischen Methoden auch in einigen Szenarien voller Vertrauenswürdigkeit. Weitere Informationen finden Sie im Abschnitt „Überprüfung“ für <xref:System.Reflection.Emit.DynamicMethod>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Überladung dieser Methode veranschaulicht. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Reflection.Emit.DynamicMethod> Klasse.  
  
 [!code-cpp[Reflection.DynamicMethod.All#2](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#2)]
 [!code-csharp[Reflection.DynamicMethod.All#2](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#2)]
 [!code-vb[Reflection.DynamicMethod.All#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Gewusst wie: Definieren und Ausführen von dynamischen Methoden</related>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberSignature Language="F#" Value="override this.GetMethodImplementationFlags : unit -&gt; System.Reflection.MethodImplAttributes" Usage="dynamicMethod.GetMethodImplementationFlags " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Implementierungsflags für die Methode zurück.</summary>
        <returns>Eine bitweise Kombination von <see cref="T:System.Reflection.MethodImplAttributes" />-Werten, die die Implementierungsflags für die Methode darstellen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Derzeit sind Implementierungsattribute für dynamische Methoden immer <xref:System.Reflection.MethodImplAttributes.IL> und <xref:System.Reflection.MethodImplAttributes.NoInlining>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberSignature Language="F#" Value="override this.GetParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="dynamicMethod.GetParameters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Parameter der dynamischen Methode zurück.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.ParameterInfo" />-Objekten, die die Parameter der dynamischen Methode darstellen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.ParameterInfo> Objekte, die von dieser Methode zurückgegebene dienen nur zu. Verwenden der <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> Methode zum Festlegen oder Ändern der Eigenschaften der Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die Parameter einer dynamischen Methode angezeigt. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Reflection.Emit.DynamicMethod> Klasse.  
  
 [!code-cpp[Reflection.DynamicMethod.All#34](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#34)]
 [!code-csharp[Reflection.DynamicMethod.All#34](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#34)]
 [!code-vb[Reflection.DynamicMethod.All#34](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#34)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InitLocals : bool with get, set" Usage="System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die lokalen Variablen in der Methode mit 0 (null) initialisiert werden, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die lokalen Variablen in der Methode mit 0 (null) initialisiert werden, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft, um festgelegt wird `true`, die ausgegebene Microsoft intermediate Language (MSIL) schließt die Initialisierung von lokalen Variablen. Wenn sie, um festgelegt ist `false`, lokale Variablen werden nicht initialisiert und der generierte Code kann nicht überprüft werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A> Eigenschaft einer dynamischen Methode. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Reflection.Emit.DynamicMethod> Klasse.  
  
 [!code-cpp[Reflection.DynamicMethod.All#24](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#24)]
 [!code-csharp[Reflection.DynamicMethod.All#24](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#24)]
 [!code-vb[Reflection.DynamicMethod.All#24](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="override this.Invoke : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="dynamicMethod.Invoke (obj, invokeAttr, binder, parameters, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="parameters" Type="System.Object[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Dieser Parameter wird bei dynamischen Methoden ignoriert, da sie statisch sind. Geben Sie <see langword="null" />an.</param>
        <param name="invokeAttr">Eine bitweise Kombination von <see cref="T:System.Reflection.BindingFlags" />-Werten.</param>
        <param name="binder">Ein <see cref="T:System.Reflection.Binder" />-Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see cref="T:System.Reflection.MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn <paramref name="binder" /> den Wert <see langword="null" /> aufweist, wird der Standardbinder verwendet. Weitere Informationen finden Sie unter <see cref="T:System.Reflection.Binder" />.</param>
        <param name="parameters">Eine Argumentliste. Dies ist ein Array von Argumenten deren Anzahl, Reihenfolge und Typ mit denen der Parameter der aufzurufenden Methode identisch ist. Wenn keine Parameter vorhanden sind, muss dieser Parameter gleich <see langword="null" /> sein.</param>
        <param name="culture">Eine Instanz von <see cref="T:System.Globalization.CultureInfo" /> für die Steuerung der Umwandlung von Typen. Wenn dies <see langword="null" /> ist, wird die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet. Diese Informationen sind z.B. erforderlich, um ein <see cref="T:System.String" />, das 1000 darstellt, ordnungsgemäß in einen <see cref="T:System.Double" />-Wert zu konvertieren, da 1000 in verschiedenen Kulturen unterschiedlich dargestellt wird.</param>
        <summary>Ruft die dynamische Methode mit den angegebenen Parametern, den Einschränkungen des angegebenen Binders und den angegebenen Kulturinformationen auf.</summary>
        <returns>Ein <see cref="T:System.Object" />, das den Rückgabewert der aufgerufenen Methode enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zusätzlich zu den aufgelisteten Ausnahmen sollten der aufrufende Code darauf vorbereitet sein, um von der dynamischen Methode ausgelösten Ausnahmen abzufangen.  
  
 Eine dynamische Methode mit einem Delegaten erstellt, indem Sie Ausführung der <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> Methode ist effizienter als die Ausführung mit der <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> Methode.  
  
 Aufrufen der <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> Methode oder der <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> Methode ausgeführt wird, die dynamische Methode. Eine weitere versuchen, die dynamische Methode, wie z. B. das Ändern von Parameterdefinitionen alter oder ausgeben Weitere Microsoft intermediate Language (MSIL), wird ignoriert; Es wird keine Ausnahme ausgelöst.  
  
 Alle dynamische Methoden sind statisch, sodass die `obj` Parameter wird immer ignoriert. Eine dynamische Methode als handele es sich um eine Instanzmethode verwenden, um die <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> -Überladung mit einer Objektinstanz.  
  
 Wenn die dynamische Methode ohne Parameter den Wert der `parameters` muss `null`. Andernfalls sollte die Anzahl, Typ und Reihenfolge der Elemente im Parameterarray mit Anzahl, Typ und Reihenfolge der Parameter der dynamischen Methode identisch sein.  
  
> [!NOTE]
>  Überladung dieser Methode wird aufgerufen, indem die <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29> -methodenüberladung, geerbt von der <xref:System.Reflection.MethodBase> Klasse, also die obigen Hinweisen auf beide Überladungen anwenden.  
  
 Diese Methode ist keine Berechtigungen fordern direkt, aber die dynamische Methode aufrufen kann dazu führen, sicherheitsanforderungen, abhängig von der Methode. Z. B. keine Forderungen gestellt, für die anonym gehostete dynamische Methoden, die mit erstellt werden die `restrictedSkipVisibility` Parametersatz zu `false`. Andererseits, wenn Sie eine Methode mit erstellen `restrictedSkipVisibility` festgelegt `true` , sodass er einen ausgeblendeten Member eine Zielassembly zugreifen kann, die Methode führt dazu, dass eine Anforderung für die Berechtigungen der Zielassembly plus <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Flag.  
  
> [!NOTE]
>  Vor der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode, die erforderlichen <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess> Flag.  
  
   
  
## Examples  
 Im folgenden Codebeispiel ruft eine dynamische Methode mit genauen Bindung, die mit der Kultur Englisch (USA). Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Reflection.Emit.DynamicMethod> Klasse.  
  
 [!code-cpp[Reflection.DynamicMethod.All#4](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#4)]
 [!code-csharp[Reflection.DynamicMethod.All#4](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#4)]
 [!code-vb[Reflection.DynamicMethod.All#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die <see cref="F:System.Reflection.CallingConventions.VarArgs" />-Aufrufkonvention wird nicht unterstützt.</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">Die Anzahl der Elemente in <paramref name="parameters" /> stimmt nicht mit der Anzahl der Parameter in der dynamischen Methode überein.</exception>
        <exception cref="T:System.ArgumentException">Der Typ eines oder mehrerer Elemente von <paramref name="parameters" /> entspricht nicht dem Typ des entsprechenden Parameters der dynamischen Methode.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Die dynamische Methode ist einem Modul zugeordnet, nicht anonym gehostet und wurde mit <paramref name="skipVisibility" /> (festgelegt auf <see langword="false" />) erstellt, aber die dynamische Methode greift auf die Member zu, die nicht <see langword="public" /> oder <see langword="internal" /> sind (<see langword="Friend" /> in Visual Basic).  
  
- oder - 
Die dynamische Methode wird anonym gehostet und wurde mit <paramref name="skipVisibility" /> (festgelegt auf <see langword="false" />) erstellt, aber sie greift auf Member zu, die nicht <see langword="public" /> sind.  
  
- oder - 
Die dynamische Methode enthält nicht überprüfbaren Code. Weitere Informationen finden Sie im Abschnitt „Überprüfung“ für <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="dynamicMethod.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="attributeType">Ein <see cref="T:System.Type" />, der den Typ des benutzerdefinierten Attributs darstellt, nach dem gesucht werden soll.</param>
        <param name="inherit"><see langword="true" />, wenn die Vererbungskette der Methode nach den benutzerdefinierten Attributen durchsucht werden soll, <see langword="false" />, wenn nur die aktuelle Methode überprüft werden soll.</param>
        <summary>Gibt an, ob der angegebene Typ des benutzerdefinierten Attributs definiert ist.</summary>
        <returns><see langword="true" />, wenn der Typ des angegebenen benutzerdefinierten Attributs definiert ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei dynamischen Methoden angeben `true` für `inherit` hat keine Auswirkungen. Dynamische Methoden verfügen über keine Vererbungskette.  
  
> [!NOTE]
>  Benutzerdefinierte Attribute sind nicht aktuell zu dynamischen Methoden unterstützt.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die aktuelle dynamische Methode sicherheitsrelevant oder sicherheitsrelevant und sicher zugänglich ist und daher wichtige Vorgänge ausführen darf.</summary>
        <value><see langword="true" />, wenn die aktuelle dynamische Methode sicherheitsrelevant oder sicherheitsrelevant und sicher zugänglich ist, <see langword="false" />, wenn er transparent ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, und <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> Eigenschaften gemeldet, die Transparenz auf der dynamischen Methode wie durch die common Language Runtime (CLR) festgelegt. Die Kombinationen dieser Eigenschaften werden in der folgenden Tabelle dargestellt:  
  
|Sicherheitsstufe|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Kritisch|`true`|`false`|`false`|  
|Safe ist kritisch|`true`|`true`|`false`|  
|Transparent|`false`|`false`|`true`|  
  
 Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.  
  
 Die Transparenz einer dynamischen Methode abhängig ist, auf das Modul, dem diesem zugeordnet ist. Wenn die dynamische Methode eines Typs, die eher als ein Modul zugeordnet ist, hängt die Transparenz das Modul, das den Typ enthält. Dynamische Methoden müssen nicht sicherheitsanmerkungen, sodass diese die standardtransparenzebene für das zugeordnete Modul zugeordnet werden.  
  
-   Anonym gehostete dynamische Methoden sind immer transparent, da das System bereitgestellten-Modul, das sie enthält transparent ist.  
  
-   Die Transparenz einer dynamischen Methode, die eine vertrauenswürdige Assembly (d. h. eine Assembly mit starkem Namen, die im globalen Assemblycache installiert ist) zugeordnet ist, wird in der folgenden Tabelle beschrieben.  
  
    |Assemblyanmerkung|Transparenz der Ebene 1|Transparenz der Ebene 2|  
    |-------------------------|--------------------------|--------------------------|  
    |Vollständig transparent.|Transparent|Transparent|  
    |Vollständig wichtig|Kritisch|Kritisch|  
    |Gemischte Transparenz|Transparent|Transparent|  
    |Security-agnostic|Sicherheitskritisch|Kritisch|  
  
     Z. B. Wenn Sie eine dynamische Methode mit einem Typ, die in "mscorlib.dll", die 2 gemischten Transparenz der Ebene hat zuordnen wird, die dynamische Methode ist transparent und kritischen Code kann nicht ausgeführt werden. Informationen zu Transparenzebenen, finden Sie unter [Sicherheitstransparenter Code, Ebene 1](~/docs/framework/misc/security-transparent-code-level-1.md) und [Sicherheitstransparenter Code, Ebene 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Ein Modul in eine vertrauenswürdige-Ebene-1-Assembly, die Sicherheit unabhängig, z. B. System.dll, ist eine dynamische Methode zuordnen lässt sich nicht auf Erhöhung des Vertrauens. Wenn der Berechtigungssatz der Code, der die dynamische Methode ruft keine den Berechtigungssatz "System.dll" (d. h. volle Vertrauenswürdigkeit), umfasst <xref:System.Security.SecurityException> wird ausgelöst, wenn die dynamische Methode aufgerufen wird.  
  
-   Die Transparenz einer dynamischen Methode, die mit einer teilweise vertrauenswürdigen Assembly verknüpft ist, hängt davon ab, wie die Assembly geladen wird. Wenn die Assembly mit teilweiser Vertrauenswürdigkeit (z. B. in einer Sandkastenanwendungsdomäne) geladen wird, ignoriert die Laufzeit die sicherheitsanmerkungen der Assembly an. Die Assembly und alle zugehörigen Typen und Member, einschließlich der dynamische Methoden werden als transparent behandelt. Die Runtime achtet auf sicherheitsanmerkungen an, nur, wenn die teilweise vertrauenswürdigen Assembly mit voller Vertrauenswürdigkeit (z. B. in der Standardanwendungsdomäne einer Desktopanwendung) geladen ist. In diesem Fall weist die Runtime der dynamischen Methode die standardtransparenzebene für Methoden gemäß der Assembly-Anmerkungen.  
  
 Geben Sie für Weitere Informationen über Reflektion und Transparenz, finden Sie unter [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Weitere Informationen zur Transparenz, finden Sie unter [Sicherheitsänderungen](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die dynamische Methode verfügt über keinen Methodentext.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Sicherheitsaspekte bei der Reflektionsausgabe</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Sicherheitsüberlegungen für die Reflektion</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Änderungen der Sicherheit in .NET Framework 4.0</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">Sicherheitstransparenter Code, Ebene 1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">Sicherheitstransparenter Code, Ebene 2</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die aktuelle dynamische Methode auf der aktuellen Vertrauensebene sicherheitsrelevant ist, d. h., ob sie wichtige Vorgänge ausführen darf und ob von transparentem Code auf sie zugegriffen werden kann.</summary>
        <value><see langword="true" />, wenn die dynamische Methode auf der aktuellen Vertrauensebene sicherheitsrelevant und sicher zugänglich ist, <see langword="false" />, wenn sie sicherheitsrelevant oder sicherheitstransparent ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, und <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> Eigenschaften gemeldet, die Transparenz auf der dynamischen Methode wie durch die common Language Runtime (CLR) festgelegt. Die Kombinationen dieser Eigenschaften werden in der folgenden Tabelle dargestellt:  
  
|Sicherheitsstufe|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Kritisch|`true`|`false`|`false`|  
|Safe ist kritisch|`true`|`true`|`false`|  
|Transparent|`false`|`false`|`true`|  
  
 Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.  
  
 Die Transparenz einer dynamischen Methode abhängig ist, auf das Modul, dem diesem zugeordnet ist. Wenn die dynamische Methode eines Typs, die eher als ein Modul zugeordnet ist, hängt die Transparenz das Modul, das den Typ enthält. Dynamische Methoden müssen nicht sicherheitsanmerkungen, sodass diese die standardtransparenzebene für das zugeordnete Modul zugeordnet werden.  
  
-   Anonym gehostete dynamische Methoden sind immer transparent, da das System bereitgestellten-Modul, das sie enthält transparent ist.  
  
-   Die Transparenz einer dynamischen Methode, die eine vertrauenswürdige Assembly (d. h. eine Assembly mit starkem Namen, die im globalen Assemblycache installiert ist) zugeordnet ist, wird in der folgenden Tabelle beschrieben.  
  
    |Assemblyanmerkung|Transparenz der Ebene 1|Transparenz der Ebene 2|  
    |-------------------------|--------------------------|--------------------------|  
    |Vollständig transparent.|Transparent|Transparent|  
    |Vollständig wichtig|Kritisch|Kritisch|  
    |Gemischte Transparenz|Transparent|Transparent|  
    |Security-agnostic|Sicherheitskritisch|Kritisch|  
  
     Z. B. Wenn Sie eine dynamische Methode mit einem Typ, die in "mscorlib.dll", die 2 gemischten Transparenz der Ebene hat zuordnen wird, die dynamische Methode ist transparent und kritischen Code kann nicht ausgeführt werden. Informationen zu Transparenzebenen, finden Sie unter [Sicherheitstransparenter Code, Ebene 1](~/docs/framework/misc/security-transparent-code-level-1.md) und [Sicherheitstransparenter Code, Ebene 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Ein Modul in eine vertrauenswürdige-Ebene-1-Assembly, die Sicherheit unabhängig, z. B. System.dll, ist eine dynamische Methode zuordnen lässt sich nicht auf Erhöhung des Vertrauens. Wenn der Berechtigungssatz der Code, der die dynamische Methode ruft keine den Berechtigungssatz "System.dll" (d. h. volle Vertrauenswürdigkeit), umfasst <xref:System.Security.SecurityException> wird ausgelöst, wenn die dynamische Methode aufgerufen wird.  
  
-   Die Transparenz einer dynamischen Methode, die mit einer teilweise vertrauenswürdigen Assembly verknüpft ist, hängt davon ab, wie die Assembly geladen wird. Wenn die Assembly mit teilweiser Vertrauenswürdigkeit (z. B. in einer Sandkastenanwendungsdomäne) geladen wird, ignoriert die Laufzeit die sicherheitsanmerkungen der Assembly an. Die Assembly und alle zugehörigen Typen und Member, einschließlich der dynamische Methoden werden als transparent behandelt. Die Runtime achtet auf sicherheitsanmerkungen an, nur, wenn die teilweise vertrauenswürdigen Assembly mit voller Vertrauenswürdigkeit (z. B. in der Standardanwendungsdomäne einer Desktopanwendung) geladen ist. In diesem Fall weist die Runtime der dynamischen Methode die standardtransparenzebene für Methoden gemäß der Assembly-Anmerkungen.  
  
 Geben Sie für Weitere Informationen über Reflektion und Transparenz, finden Sie unter [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Weitere Informationen zur Transparenz, finden Sie unter [Sicherheitsänderungen](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die dynamische Methode verfügt über keinen Methodentext.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Sicherheitsaspekte bei der Reflektionsausgabe</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Sicherheitsüberlegungen für die Reflektion</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Änderungen der Sicherheit in .NET Framework 4.0</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">Sicherheitstransparenter Code, Ebene 1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">Sicherheitstransparenter Code, Ebene 2</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die aktuelle dynamische Methode auf der aktuellen Vertrauensebene sicherheitstransparent ist und daher keine wichtigen Vorgänge ausführen kann.</summary>
        <value><see langword="true" />, wenn die dynamische Methode auf der aktuellen Vertrauensebene sicherheitstransparent ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>, und <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> Eigenschaften gemeldet, die Transparenz auf der dynamischen Methode wie durch die common Language Runtime (CLR) festgelegt. Die Kombinationen dieser Eigenschaften werden in der folgenden Tabelle dargestellt:  
  
|Sicherheitsstufe|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Kritisch|`true`|`false`|`false`|  
|Safe ist kritisch|`true`|`true`|`false`|  
|Transparent|`false`|`false`|`true`|  
  
 Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.  
  
 Die Transparenz einer dynamischen Methode abhängig ist, auf das Modul, dem diesem zugeordnet ist. Wenn die dynamische Methode eines Typs, die eher als ein Modul zugeordnet ist, hängt die Transparenz das Modul, das den Typ enthält. Dynamische Methoden müssen nicht sicherheitsanmerkungen, sodass diese die standardtransparenzebene für das zugeordnete Modul zugeordnet werden.  
  
-   Anonym gehostete dynamische Methoden sind immer transparent, da das System bereitgestellten-Modul, das sie enthält transparent ist.  
  
-   Die Transparenz einer dynamischen Methode, die eine vertrauenswürdige Assembly (d. h. eine Assembly mit starkem Namen, die im globalen Assemblycache installiert ist) zugeordnet ist, wird in der folgenden Tabelle beschrieben.  
  
    |Assemblyanmerkung|Transparenz der Ebene 1|Transparenz der Ebene 2|  
    |-------------------------|--------------------------|--------------------------|  
    |Vollständig transparent.|Transparent|Transparent|  
    |Vollständig wichtig|Kritisch|Kritisch|  
    |Gemischte Transparenz|Transparent|Transparent|  
    |Security-agnostic|Sicherheitskritisch|Kritisch|  
  
     Z. B. Wenn Sie eine dynamische Methode mit einem Typ, die in "mscorlib.dll", die 2 gemischten Transparenz der Ebene hat zuordnen wird, die dynamische Methode ist transparent und kritischen Code kann nicht ausgeführt werden. Informationen zu Transparenzebenen, finden Sie unter [Sicherheitstransparenter Code, Ebene 1](~/docs/framework/misc/security-transparent-code-level-1.md) und [Sicherheitstransparenter Code, Ebene 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Ein Modul in eine vertrauenswürdige-Ebene-1-Assembly, die Sicherheit unabhängig, z. B. System.dll, ist eine dynamische Methode zuordnen lässt sich nicht auf Erhöhung des Vertrauens. Wenn der Berechtigungssatz der Code, der die dynamische Methode ruft keine den Berechtigungssatz "System.dll" (d. h. volle Vertrauenswürdigkeit), umfasst <xref:System.Security.SecurityException> wird ausgelöst, wenn die dynamische Methode aufgerufen wird.  
  
-   Die Transparenz einer dynamischen Methode, die mit einer teilweise vertrauenswürdigen Assembly verknüpft ist, hängt davon ab, wie die Assembly geladen wird. Wenn die Assembly mit teilweiser Vertrauenswürdigkeit (z. B. in einer Sandkastenanwendungsdomäne) geladen wird, ignoriert die Laufzeit die sicherheitsanmerkungen der Assembly an. Die Assembly und alle zugehörigen Typen und Member, einschließlich der dynamische Methoden werden als transparent behandelt. Die Runtime achtet auf sicherheitsanmerkungen an, nur, wenn die teilweise vertrauenswürdigen Assembly mit voller Vertrauenswürdigkeit (z. B. in der Standardanwendungsdomäne einer Desktopanwendung) geladen ist. In diesem Fall weist die Runtime der dynamischen Methode die standardtransparenzebene für Methoden gemäß der Assembly-Anmerkungen.  
  
 Geben Sie für Weitere Informationen über Reflektion und Transparenz, finden Sie unter [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Weitere Informationen zur Transparenz, finden Sie unter [Sicherheitsänderungen](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die dynamische Methode verfügt über keinen Methodentext.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Sicherheitsaspekte bei der Reflektionsausgabe</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Sicherheitsüberlegungen für die Reflektion</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Änderungen der Sicherheit in .NET Framework 4.0</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">Sicherheitstransparenter Code, Ebene 1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">Sicherheitstransparenter Code, Ebene 2</related>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodHandle : RuntimeMethodHandle" Usage="System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird bei dynamischen Methoden nicht unterstützt.</summary>
        <value>Wird bei dynamischen Methoden nicht unterstützt.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Für dynamische Methoden nicht zulässig.</exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodImplementationFlags : System.Reflection.MethodImplAttributes" Usage="System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.DynamicMethod.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Modul ab, dem die dynamische Methode logisch zugeordnet ist.</summary>
        <value>Das <see cref="T:System.Reflection.Module" />, dem die aktuelle dynamische Methode zugeordnet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Modul angegeben wurde, wenn die dynamische Methode erstellt wurde, gibt diese Eigenschaft das Modul an. Wenn ein Typ als Besitzer angegeben wurde, wenn die dynamische Methode erstellt wurde, gibt diese Eigenschaft das Modul, das diesen Typ enthält.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Reflection.Emit.DynamicMethod.Module%2A> Eigenschaft einer dynamischen Methode. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Reflection.Emit.DynamicMethod> Klasse.  
  
 [!code-cpp[Reflection.DynamicMethod.All#26](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#26)]
 [!code-csharp[Reflection.DynamicMethod.All#26](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#26)]
 [!code-vb[Reflection.DynamicMethod.All#26](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.DynamicMethod.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen der dynamischen Methode ab.</summary>
        <value>Der einfache Name der Methode.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Es ist nicht notwendig, dynamischen Methoden Namen.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Namen einer dynamischen Methode. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Reflection.Emit.DynamicMethod> Klasse.  
  
 [!code-cpp[Reflection.DynamicMethod.All#27](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#27)]
 [!code-csharp[Reflection.DynamicMethod.All#27](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#27)]
 [!code-vb[Reflection.DynamicMethod.All#27](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Klasse ab, die bei der Reflektion zum Abrufen der Methode verwendet wurde.</summary>
        <value>Immer <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gibt diese Eigenschaft immer `null` für dynamische Methoden.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den reflektierten Typ eine dynamische Methode. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Reflection.Emit.DynamicMethod> Klasse.  
  
 [!code-cpp[Reflection.DynamicMethod.All#28](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#28)]
 [!code-csharp[Reflection.DynamicMethod.All#28](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#28)]
 [!code-vb[Reflection.DynamicMethod.All#28](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnParameter : System.Reflection.ParameterInfo" Usage="System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Rückgabeparameter der dynamischen Methode ab.</summary>
        <value>Immer <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gibt diese Eigenschaft immer `null` für dynamische Methoden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ des Rückgabewerts für die dynamische Methode ab.</summary>
        <value>Ein <see cref="T:System.Type" />, der den Typ des Rückgabewerts der aktuellen Methode darstellt, <see cref="T:System.Void" />, wenn die Methode über keinen Rückgabetyp verfügt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `null` für den Rückgabetyp angegeben wurde, als die dynamische Methode erstellt wurde, gibt diese Eigenschaft zurück, <xref:System.Void?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Rückgabetyp einer dynamischen Methode. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Reflection.Emit.DynamicMethod> Klasse.  
  
 [!code-cpp[Reflection.DynamicMethod.All#30](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#30)]
 [!code-csharp[Reflection.DynamicMethod.All#30](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#30)]
 [!code-vb[Reflection.DynamicMethod.All#30](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnTypeCustomAttributes : System.Reflection.ICustomAttributeProvider" Usage="System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die benutzerdefinierten Attribute des Rückgabetyps der dynamischen Methode ab.</summary>
        <value>Ein <see cref="T:System.Reflection.ICustomAttributeProvider" />, der die benutzerdefinierten Attribute des Rückgabetyps der dynamischen Methode darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Benutzerdefinierte Attribute werden für den Rückgabetyp einer dynamischen Methode, nicht unterstützt, damit das Array von benutzerdefinierten Attributen von zurückgegeben der <xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A> Methode ist immer leer.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die benutzerdefinierten Attribute des Rückgabetyps einer dynamischen Methode angezeigt. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Reflection.Emit.DynamicMethod> Klasse.  
  
 [!code-cpp[Reflection.DynamicMethod.All#31](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#31)]
 [!code-csharp[Reflection.DynamicMethod.All#31](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#31)]
 [!code-vb[Reflection.DynamicMethod.All#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#31)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dynamicMethod.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Signatur der Methode als Zeichenfolge zurück.</summary>
        <returns>Eine Zeichenfolge, die die Methodensignatur darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Signatur enthält nur die Typen und den Methodennamen angeben, sofern vorhanden. Parameternamen sind nicht enthalten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Reflection.Emit.DynamicMethod.ToString%2A> -Methode der eine dynamische Methode. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Reflection.Emit.DynamicMethod> Klasse.  
  
 [!code-cpp[Reflection.DynamicMethod.All#32](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#32)]
 [!code-csharp[Reflection.DynamicMethod.All#32](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#32)]
 [!code-vb[Reflection.DynamicMethod.All#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>