<Type Name="DynamicMethod" FullName="System.Reflection.Emit.DynamicMethod">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5e049b78ceaff8eb6e9539e74d53442deee7935b" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73337138" /></Metadata><TypeSignature Language="C#" Value="public sealed class DynamicMethod : System.Reflection.MethodInfo" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit DynamicMethod extends System.Reflection.MethodInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.DynamicMethod" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DynamicMethod&#xA;Inherits MethodInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicMethod sealed : System::Reflection::MethodInfo" />
  <TypeSignature Language="F#" Value="type DynamicMethod = class&#xA;    inherit MethodInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definiert eine dynamische Methode, die kompiliert, ausgeführt und verworfen werden kann, und stellt diese dar. Verworfene Methoden sind für die Garbage Collection verfügbar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Reflection.Emit.DynamicMethod>-Klasse verwenden, um eine Methode zur Laufzeit zu generieren und auszuführen, ohne dass eine dynamische Assembly und ein dynamischer Typ zum enthalten der Methode generiert werden müssen. Der ausführbare Code, der vom JIT-Compiler (Just-in-Time) erstellt wurde, wird freigegeben, wenn das <xref:System.Reflection.Emit.DynamicMethod> Objekt freigegeben wird. Dynamische Methoden sind die effizienteste Methode, um kleine Mengen an Code zu generieren und auszuführen.  
  
 Eine dynamische Methode kann anonym gehostet werden, oder Sie kann logisch einem Modul oder einem Typ zugeordnet werden.  
  
-   Wenn die dynamische Methode anonym gehostet wird, befindet Sie sich in einer vom System bereitgestellten Assembly und ist daher von anderem Code isoliert. Standardmäßig hat Sie keinen Zugriff auf nicht öffentliche Daten. Eine anonym gehostete dynamische Methode kann die Möglichkeit haben, die Sichtbarkeits Prüfungen des JIT-Compilers zu überspringen, wenn Sie <xref:System.Security.Permissions.ReflectionPermission> mit dem <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>-Flag erteilt wurden. Die Vertrauens Ebene der Assembly, auf deren nicht öffentliche Member von der dynamischen Methode zugegriffen wird, muss gleich oder eine Teilmenge der Vertrauens Ebene der aufrufsstapel sein, die die dynamische Methode ausgegeben hat. Weitere Informationen zu anonym gehosteten dynamischen Methoden finden Sie unter Exemplarische Vorgehensweise: Ausgeben von [Code in Szenarien mit teilweiser Vertrauens](~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md)Würdigkeit.  
  
-   Wenn die dynamische Methode einem von Ihnen angegebenen Modul zugeordnet ist, ist die dynamische Methode für dieses Modul effektiv Global. Sie kann auf alle Typen im Modul und alle `internal` (`Friend` in Visual Basic) der Typen zugreifen. Sie können jedem Modul eine dynamische Methode zuordnen, unabhängig davon, ob Sie das Modul erstellt haben, vorausgesetzt, dass eine Nachfrage nach <xref:System.Security.Permissions.ReflectionPermission> mit dem <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>-Flag durch die Aufruf Stapel, die den Code enthält, erfüllt werden kann. Wenn das <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>-Flag in der Gewährung enthalten ist, kann die dynamische Methode die Sichtbarkeits Prüfungen des JIT-Compilers überspringen und auf die privaten Daten aller Typen, die im Modul oder in einem anderen Modul in einer Assembly deklariert sind, zugreifen.  
  
    > [!NOTE]
    >  Wenn Sie das Modul angeben, dem eine dynamische Methode zugeordnet ist, darf dieses Modul nicht in der vom System bereitgestellten Assembly enthalten sein, die für das anonyme Hosting verwendet wird.  
  
-   Wenn die dynamische Methode einem Typ zugeordnet ist, den Sie angeben, kann Sie unabhängig von der Zugriffsebene auf alle Member des Typs zugreifen. Darüber hinaus können JIT-Sichtbarkeits Prüfungen übersprungen werden. Dadurch erhält die dynamische Methode Zugriff auf die privaten Daten anderer Typen, die im selben Modul oder in einem anderen Modul in einer Assembly deklariert sind. Sie können einer dynamischen Methode einen beliebigen Typ zuordnen, aber Ihrem Code müssen <xref:System.Security.Permissions.ReflectionPermission> mit den <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>-und <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess>-Flags erteilt werden.  
  
 In der folgenden Tabelle ist aufgeführt, welche Typen und Member für eine anonym gehostete dynamische Methode mit und ohne JIT-Sichtbarkeits Prüfungen zugänglich sind, je nachdem, ob <xref:System.Security.Permissions.ReflectionPermission> mit dem <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>-Flag erteilt wurden.  
  
||Ohne <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|Mit <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|  
|-|-|-|  
|Ohne Überspringen von JIT-Sichtbarkeits Prüfungen|Öffentliche Member öffentlicher Typen in beliebigen Assemblys.|Öffentliche Member öffentlicher Typen in beliebigen Assemblys.|  
|Überspringen von JIT-Sichtbarkeits Prüfungen mit Einschränkungen|Öffentliche Member öffentlicher Typen in beliebigen Assemblys.|Alle Elemente aller Typen, nur in Assemblys, deren Vertrauens Ebene gleich oder kleiner als die Vertrauens Ebene der Assembly ist, die die dynamische Methode ausgegeben hat.|  
  
> [!NOTE]
>  Vor der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]war das Ausgeben von Code erforderlich <xref:System.Security.Permissions.ReflectionPermission> mit dem <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>-Flag. Diese Berechtigung ist standardmäßig in den benannten Berechtigungs Sätzen FullTrust und LocalIntranet enthalten, jedoch nicht im Internet-Berechtigungs Satz. Aus diesem Grund in früheren Versionen von der [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] kann eine Bibliothek mit Internetberechtigungen verwendet nur dann, wenn sie die <xref:System.Security.SecurityCriticalAttribute> Attribut, und führt auch eine <xref:System.Security.PermissionSet.Assert%2A> für <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>. Diese Bibliotheken erfordern einen sorgfältigen Sicherheitsreview, da Codierungsfehler zu Sicherheitslücken führen können. In [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)] ist es möglich, Code in teilweise vertrauenswürdigen Szenarios ohne Sicherheitsanforderungen auszugeben, da das Generieren von Code an sich keinen privilegierten Vorgang darstellt. Das bedeutet, dass der generierte Code nicht mehr Berechtigungen aufweist als die Assembly, die ihn ausgibt. Dies ermöglicht es, dass Bibliotheken, die Code ausgeben, sicherheitstransparent sein können, und beseitigt die Notwendigkeit der Assertion von <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>, was das Schreiben einer sicheren Bibliothek vereinfacht. Um dieses Feature verwenden zu können, sollte Ihre Anwendung auf [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgerichtet sein.  
  
 Die folgende Tabelle zeigt, welche Typen und Member für eine dynamische Methode, die einem Modul oder einem Typ in einem Modul zugeordnet ist, zugänglich sind.  
  
||Mit Modul verknüpft|Dem Typ zugeordnet|  
|-|-|-|  
|Ohne Überspringen von JIT-Sichtbarkeits Prüfungen|Öffentliche und interne Member von öffentlichen, internen und privaten Typen im Modul.<br /><br /> Öffentliche Member öffentlicher Typen in beliebigen Assemblys.|Alle Member des zugeordneten Typs. Öffentliche und interne Member aller anderen Typen im Modul.<br /><br /> Öffentliche Member öffentlicher Typen in beliebigen Assemblys.|  
|Überspringen von JIT-Sichtbarkeits Prüfungen|Alle Elemente aller Typen in einer beliebigen Assembly.|Alle Elemente aller Typen in einer beliebigen Assembly.|  
  
 Eine dynamische Methode, die einem Modul zugeordnet ist, verfügt über die Berechtigungen dieses Moduls. Eine dynamische Methode, die einem Typ zugeordnet ist, verfügt über die Berechtigungen des Moduls, das diesen Typ enthält.  
  
 Dynamische Methoden und deren Parameter müssen nicht benannt werden, Sie können jedoch Namen angeben, um das Debuggen zu unterstützen. Benutzerdefinierte Attribute werden für dynamische Methoden oder deren Parameter nicht unterstützt.  
  
 Obwohl dynamische Methoden `static` Methoden (`Shared` Methoden in Visual Basic) sind, ermöglichen die gelockerten Regeln für die Delegatbindung, die in den [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] eingeführt wurden, eine dynamische Methode an ein Objekt zu binden, sodass Sie wie eine Instanzmethode funktioniert, wenn Sie mit aufgerufen wird. Delegatinstanz. Ein Beispiel, das dies veranschaulicht, wird für die <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29>-Methoden Überladung bereitgestellt.  
  
> [!NOTE]
>  In der [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]unterstützen dynamische Methoden keine Symbol Informationen, d. h. lokale Variablennamen und Zeilennummern Zuordnung. Diese Einschränkung wird in einer zukünftigen Version möglicherweise entfernt. Sie können <xref:System.Reflection.Emit.AssemblyBuilder> während der Entwicklung verwenden, um das Debuggen der generierten MSIL (Microsoft Intermediate Language) zu vereinfachen und dann während der letzten Bereitstellung zu dynamischen Methoden zu wechseln, da die <xref:System.Reflection.Emit.ILGenerator> Aufrufe in beiden Fällen gleich sind.  
  
## <a name="verification"></a>Überprüfung  
 In der folgenden Liste sind die Bedingungen zusammengefasst, unter denen dynamische Methoden nicht verifizierbaren Code enthalten können. (Beispielsweise ist eine dynamische Methode nicht überprüfbar, wenn die <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A>-Eigenschaft auf `false`festgelegt ist.)  
  
-   Eine dynamische Methode, die mit einer sicherheitskritischen Assembly verknüpft ist, ist ebenfalls sicherheitskritisch und kann die Überprüfung überspringen. Beispielsweise wird eine Assembly ohne Sicherheits Attribute, die als Desktop Anwendung ausgeführt wird, von der Laufzeit als sicherheitskritisch behandelt. Wenn Sie der Assembly eine dynamische Methode zuordnen, kann die dynamische Methode nicht überprüfbaren Code enthalten.  
  
-   Wenn eine dynamische Methode, die nicht überprüfbaren Code enthält, einer Assembly mit Transparenz der Ebene 1 zugeordnet ist, fügt der JIT-Compiler (Just-in-Time) eine Sicherheitsanforderung ein. Die Anforderung ist nur erfolgreich, wenn die dynamische Methode von voll vertrauenswürdigem Code ausgeführt wird. [Sicherheitstransparenter Code, Ebene 1](~/docs/framework/misc/security-transparent-code-level-1.md).  
  
-   Wenn eine dynamische Methode, die nicht überprüfbaren Code enthält, einer Assembly zugeordnet ist, die Transparenz der Ebene 2 (z. b. "mscorlib. dll") aufweist, wird eine Ausnahme ausgelöst (durch den JIT-Compiler eingefügt), anstatt eine Sicherheitsanforderung zu erstellen. [Sicherheitstransparenter Code, Ebene 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
-   Eine anonym gehostete dynamische Methode, die nicht überprüfbaren Code enthält, löst immer eine Ausnahme aus. Sie kann die Überprüfung nie überspringen, auch wenn Sie von voll vertrauenswürdigem Code erstellt und ausgeführt wird.  
  
 Die Ausnahme, die für nicht überprüfbaren Code ausgelöst wird, variiert in Abhängigkeit davon, wie die dynamische Methode aufgerufen wird. Wenn Sie eine dynamische Methode aufrufen, indem Sie einen Delegaten verwenden, der von der <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>-Methode zurückgegeben wird, wird eine <xref:System.Security.VerificationException> ausgelöst. Wenn Sie die dynamische Methode mithilfe der <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>-Methode aufrufen, wird ein <xref:System.Reflection.TargetInvocationException> mit einem inneren <xref:System.Security.VerificationException>ausgelöst.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine dynamische Methode erstellt, die zwei Parameter annimmt. Im Beispiel wird ein einfacher Funktions Text ausgegeben, der den ersten Parameter in der Konsole ausgibt. im Beispiel wird der zweite Parameter als Rückgabewert der-Methode verwendet. Im Beispiel wird die-Methode vervollständigt, indem ein Delegat erstellt wird, der Delegat mit unterschiedlichen Parametern aufgerufen und schließlich die dynamische Methode mithilfe der <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>-Methode aufgerufen wird.  
  
 [!code-cpp[Reflection.DynamicMethod.All#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.All#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.All#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Gewusst wie: Definieren und Ausführen von dynamischen Methoden</related>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Sicherheitsaspekte bei der Reflektionsausgabe</related>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">Exemplarische Vorgehensweise: Ausgeben von Code in Szenarien mit teilweiser Vertrauenswürdigkeit</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine dynamische Methode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der dynamischen Methode. Dies kann eine leere Zeichenfolge sein, sie darf aber nicht <see langword="null" /> sein.</param>
        <param name="returnType">Ein <see cref="T:System.Type" />-Objekt, das den Rückgabetyp der dynamischen Methode angibt, oder <see langword="null" />, wenn die Methode keinen Rückgabetyp hat.</param>
        <param name="parameterTypes">Ein Array von <see cref="T:System.Type" />-Objekten, die die Typen der Parameter der dynamischen Methode angeben, oder <see langword="null" />, wenn die Methode keine Parameter hat.</param>
        <summary>Initialisiert eine anonym gehostete dynamische Methode, wobei der Methodenname, der Rückgabetyp und die Parametertypen angegeben werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die dynamische Methode, die von diesem Konstruktor erstellt wird, ist einer anonymen Assembly anstatt einem vorhandenen Typ oder Modul zugeordnet. Die anonyme Assembly ist nur vorhanden, um eine Sandkasten Umgebung für dynamische Methoden bereitzustellen, d. h. um Sie von anderem Code zu isolieren. Diese Umgebung macht es sicher, dass die dynamische Methode von teilweise vertrauenswürdigem Code ausgegeben und ausgeführt werden kann.  
  
 Dieser Konstruktor gibt an, dass JIT-Sichtbarkeits Prüfungen (Just-in-Time) für die MSIL (Microsoft Intermediate Language) der dynamischen Methode erzwungen werden. Das heißt, der Code in der dynamischen Methode hat Zugriff auf öffentliche Methoden öffentlicher Klassen. Ausnahmen werden ausgelöst, wenn die Methode versucht, auf Typen oder Member zuzugreifen, die `private`, `protected`oder `internal` sind (`Friend` in Visual Basic). Verwenden Sie zum Erstellen einer dynamischen Methode, die eingeschränkte Fähigkeit zum Überspringen von JIT-Sichtbarkeits Prüfungen hat, den <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29>-Konstruktor.  
  
 Wenn eine anonym gehostete dynamische Methode erstellt wird, wird die aufzurufende Assembly einbezogen. Wenn die-Methode aufgerufen wird, werden die Berechtigungen der ausgebenden Assembly anstelle der Berechtigungen des eigentlichen Aufrufers verwendet. Folglich kann die dynamische Methode nicht auf einer höheren Berechtigungsebene ausgeführt werden, als die der Assembly, die Sie ausgegeben hat, auch wenn Sie an eine Assembly mit einer höheren Vertrauens Ebene weitergegeben und von dieser ausgeführt wird.  
  
 Dieser Konstruktor gibt die Methoden Attribute <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> und <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>sowie die Aufruf Konvention <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>an.  
  
> [!NOTE]
>  Dieser Konstruktor wurde in der [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher eingeführt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Element von <paramref name="parameterTypes" /> ist <see langword="null" /> oder <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> ist ein Typ, für den <see cref="P:System.Type.IsByRef" /> den Wert <see langword="true" /> zurückgibt.</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Gewusst wie: Definieren und Ausführen von dynamischen Methoden</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Sicherheitsaspekte bei der Reflektionsausgabe</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">Exemplarische Vorgehensweise: Ausgeben von Code in Szenarien mit teilweiser Vertrauenswürdigkeit</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, bool restrictedSkipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), restrictedSkipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, restrictedSkipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="restrictedSkipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der dynamischen Methode. Dies kann eine leere Zeichenfolge sein, sie darf aber nicht <see langword="null" /> sein.</param>
        <param name="returnType">Ein <see cref="T:System.Type" />-Objekt, das den Rückgabetyp der dynamischen Methode angibt, oder <see langword="null" />, wenn die Methode keinen Rückgabetyp hat.</param>
        <param name="parameterTypes">Ein Array von <see cref="T:System.Type" />-Objekten, die die Typen der Parameter der dynamischen Methode angeben, oder <see langword="null" />, wenn die Methode keine Parameter hat.</param>
        <param name="restrictedSkipVisibility"><see langword="true" />, wenn JIT-Sichtbarkeitsprüfungen für Typen und Member übersprungen werden sollen, auf die durch die MSIL der dynamischen Methode zugegriffen wird. Dafür gibt es folgende Einschränkung: Die Vertrauensebene der Assemblys, die diese Typen und Member enthalten, muss identisch sein mit oder kleiner sein als die Vertrauensebene der Aufrufliste, die die dynamische Methode ausgibt. Andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine anonym gehostete dynamische Methode. Dazu werden der Methodenname, der Rückgabetyp und die Parametertypen angegeben und wird angegeben, ob JIT-Sichtbarkeitsprüfungen (Just-In-Time) für Typen und Member übersprungen werden sollen, auf die von der MSIL (Microsoft Intermediate Language) der dynamischen Methode zugegriffen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die dynamische Methode, die von diesem Konstruktor erstellt wird, ist einer anonymen Assembly anstatt einem vorhandenen Typ oder Modul zugeordnet. Die anonyme Assembly ist nur vorhanden, um eine Sandkasten Umgebung für dynamische Methoden bereitzustellen, d. h. um Sie von anderem Code zu isolieren. Diese Umgebung macht es sicher, dass die dynamische Methode von teilweise vertrauenswürdigem Code ausgegeben und ausgeführt werden kann.  
  
 Anonym gehostete dynamische Methoden haben keinen automatischen Zugriff auf Typen oder Member, die `private`, `protected`oder `internal` (`Friend` in Visual Basic) sind. Dies unterscheidet sich von dynamischen Methoden, die einem vorhandenen Typ oder Modul zugeordnet sind, die Zugriff auf verborgene Member im zugeordneten Bereich haben.  
  
 Geben Sie `true` für `restrictedSkipVisibility` an, wenn die dynamische Methode auf Typen oder Member zugreifen muss, die `private`, `protected`oder `internal`sind. Dadurch wird der dynamischen Methode der Zugriff auf diese Member eingeschränkt. Das heißt, auf die Member kann nur zugegriffen werden, wenn die folgenden Bedingungen erfüllt sind:  
  
-   Die Zielmember gehören zu einer Assembly, die eine Vertrauens Ebene aufweist, die gleich oder niedriger ist als die-Methode, die die dynamische Methode ausgibt.  
  
-   Der-Rückruf Stapel, der die dynamische Methode ausgibt, wird <xref:System.Security.Permissions.ReflectionPermission> mit dem <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>-Flag erteilt. Dies gilt immer, wenn der Code mit voller Vertrauenswürdigkeit ausgeführt wird. Bei teilweise vertrauenswürdigem Code ist dies nur dann der Fall, wenn der Host die Berechtigung explizit erteilt.  
  
    > [!IMPORTANT]
    >  Wenn die Berechtigung nicht erteilt wurde, wird eine Sicherheits Ausnahme ausgelöst, wenn <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> aufgerufen wird oder wenn die dynamische Methode aufgerufen wird, nicht, wenn dieser Konstruktor aufgerufen wird. Zum Ausgeben der dynamischen Methode sind keine speziellen Berechtigungen erforderlich.  
  
 Beispielsweise kann eine dynamische Methode, die mit `restrictedSkipVisibility` auf `true` erstellt wird, auf einen privaten Member einer beliebigen Assembly in der aufrufsstapel zugreifen, wenn der aufrufsstapel eingeschränkten Element Zugriff gewährt wurde. Wenn die dynamische Methode mit teilweise vertrauenswürdigem Code in der aufrufsstapel erstellt wird, kann Sie nicht auf einen privaten Member eines Typs in einer [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] Assembly zugreifen, da solche Assemblys voll vertrauenswürdig sind.  
  
 Wenn `restrictedSkipVisibility` `false`ist, werden JIT-Sichtbarkeits Prüfungen erzwungen. Der Code in der dynamischen Methode hat Zugriff auf öffentliche Methoden öffentlicher Klassen, und Ausnahmen werden ausgelöst, wenn versucht wird, auf Typen oder Member zuzugreifen, die `private`, `protected`oder `internal`sind.  
  
 Wenn eine anonym gehostete dynamische Methode erstellt wird, wird die aufzurufende Assembly einbezogen. Wenn die-Methode aufgerufen wird, werden die Berechtigungen der ausgebenden Aufruf Stapel anstelle der Berechtigungen des eigentlichen Aufrufers verwendet. Folglich kann die dynamische Methode nicht auf einer höheren Berechtigungsebene ausgeführt werden, als die der Assembly, die Sie ausgegeben hat, auch wenn Sie an eine Assembly mit einer höheren Vertrauens Ebene weitergegeben und von dieser ausgeführt wird.  
  
 Dieser Konstruktor gibt die Methoden Attribute <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> und <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>sowie die Aufruf Konvention <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>an.  
  
> [!NOTE]
>  Dieser Konstruktor wurde in der [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher eingeführt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Element von <paramref name="parameterTypes" /> ist <see langword="null" /> oder <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> ist ein Typ, für den <see cref="P:System.Type.IsByRef" /> den Wert <see langword="true" /> zurückgibt.</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Gewusst wie: Definieren und Ausführen von dynamischen Methoden</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Sicherheitsaspekte bei der Reflektionsausgabe</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">Exemplarische Vorgehensweise: Ausgeben von Code in Szenarien mit teilweiser Vertrauenswürdigkeit</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der dynamischen Methode. Dies kann eine leere Zeichenfolge sein, sie darf aber nicht <see langword="null" /> sein.</param>
        <param name="returnType">Ein <see cref="T:System.Type" />-Objekt, das den Rückgabetyp der dynamischen Methode angibt, oder <see langword="null" />, wenn die Methode keinen Rückgabetyp hat.</param>
        <param name="parameterTypes">Ein Array von <see cref="T:System.Type" />-Objekten, die die Typen der Parameter der dynamischen Methode angeben, oder <see langword="null" />, wenn die Methode keine Parameter hat.</param>
        <param name="m">Ein <see cref="T:System.Reflection.Module" />, das das Modul darstellt, dem die dynamische Methode logisch zugeordnet ist.</param>
        <summary>Erstellt eine dynamische Methode, die sich zu einem Modul global verhält und den Methodennamen, den Rückgabetyp, die Parametertypen und das Modul angibt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor gibt Methoden Attribute <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> und <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, eine Aufruf Konvention <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>an und überspringt keine Just-in-time (JIT)-Sichtbarkeits Prüfungen.  
  
 Die mit diesem Konstruktor erstellte dynamische Methode hat Zugriff auf die Member Public und `internal` (`Friend` in Visual Basic) aller Typen, die in Modul `m`enthalten sind.  
  
> [!NOTE]
>  Aus Gründen der Abwärtskompatibilität fordert dieser Konstruktor <xref:System.Security.Permissions.SecurityPermission> mit dem <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>-Flag an, wenn die folgenden Bedingungen zutreffen: `m` ist ein anderes Modul als das Aufruf Modul, und die Anforderung für <xref:System.Security.Permissions.ReflectionPermission> mit dem <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>-Flag ist fehlgeschlagen. Wenn die Nachfrage nach <xref:System.Security.Permissions.SecurityPermission> erfolgreich ist, ist der Vorgang zulässig.  
  
> [!NOTE]
>  Beginnend mit dem [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] erfordert dieser Member nicht mehr <xref:System.Security.Permissions.ReflectionPermission> mit dem <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>-Flag. (Siehe [Sicherheitsprobleme bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Um diese Funktion verwenden zu können, sollte Ihre Anwendung auf [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgerichtet sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine dynamische Methode erstellt, die zwei Parameter annimmt. Im Beispiel wird ein einfacher Funktions Text ausgegeben, der den ersten Parameter in der Konsole ausgibt. im Beispiel wird der zweite Parameter als Rückgabewert der-Methode verwendet. Im Beispiel wird die-Methode vervollständigt, indem ein Delegat erstellt wird, der Delegat mit unterschiedlichen Parametern aufgerufen und schließlich die dynamische Methode mithilfe der <xref:System.Reflection.Emit.DynamicMethod.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29>-Methode aufgerufen wird.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Element von <paramref name="parameterTypes" /> ist <see langword="null" /> oder <see cref="T:System.Void" />.  
  
- oder - 
 <paramref name="m" /> ist ein Modul, das das anonyme Hosten für dynamische Methoden bereitstellt.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="m" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> ist ein Typ, für den <see cref="P:System.Type.IsByRef" /> den Wert <see langword="true" /> zurückgibt.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">, wenn die dynamische Methode einem anderen Modul als dem aufrufenden Modul zugeordnet werden soll. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /></permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Gewusst wie: Definieren und Ausführen von dynamischen Methoden</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Sicherheitsaspekte bei der Reflektionsausgabe</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der dynamischen Methode. Dies kann eine leere Zeichenfolge sein, sie darf aber nicht <see langword="null" /> sein.</param>
        <param name="returnType">Ein <see cref="T:System.Type" />-Objekt, das den Rückgabetyp der dynamischen Methode angibt, oder <see langword="null" />, wenn die Methode keinen Rückgabetyp hat.</param>
        <param name="parameterTypes">Ein Array von <see cref="T:System.Type" />-Objekten, die die Typen der Parameter der dynamischen Methode angeben, oder <see langword="null" />, wenn die Methode keine Parameter hat.</param>
        <param name="owner">Ein <see cref="T:System.Type" />, der der dynamischen Methode logisch zugeordnet ist. Die dynamische Methode hat Zugriff auf alle Member des Typs.</param>
        <summary>Erstellt eine dynamische Methode und gibt den Methodennamen, den Rückgabetyp, die Parametertypen und den Typ an, dem die dynamische Methode logisch zugeordnet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die dynamische Methode, die mit diesem Konstruktor erstellt wird, hat Zugriff auf alle Member des Typs `owner`sowie auf öffentliche und `internal` (`Friend` in Visual Basic) Membern aller anderen Typen im Modul, das `owner`enthält.  
  
 Dieser Konstruktor gibt Methoden Attribute <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> und <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>, eine Aufruf Konvention <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>an und überspringt keine Just-in-time (JIT)-Sichtbarkeits Prüfungen.  
  
> [!NOTE]
>  Aus Gründen der Abwärtskompatibilität fordert dieser Konstruktor <xref:System.Security.Permissions.SecurityPermission> mit dem <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>-Flag an, wenn die folgenden Bedingungen zutreffen: `owner` in einem anderen Modul als dem aufrufenden Modul, und die Anforderung für <xref:System.Security.Permissions.ReflectionPermission> mit dem <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Flag ist fehlgeschlagen. Wenn die Nachfrage nach <xref:System.Security.Permissions.SecurityPermission> erfolgreich ist, ist der Vorgang zulässig.  
  
> [!NOTE]
>  Beginnend mit dem [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] erfordert dieser Member nicht mehr <xref:System.Security.Permissions.ReflectionPermission> mit dem <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>-Flag. (Siehe [Sicherheitsprobleme bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Um diese Funktion verwenden zu können, sollte Ihre Anwendung auf [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgerichtet sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Reflection.Emit.DynamicMethod> erstellt, die logisch einem-Typ zugeordnet ist. Diese Zuordnung ermöglicht den Zugriff auf die privaten Member dieses Typs.  
  
 Das Codebeispiel definiert eine Klasse mit dem Namen `Example` mit einem privaten Feld, einer Klasse mit dem Namen `DerivedFromExample`, die von der ersten Klasse abgeleitet ist, einem Delegattyp mit dem Namen `UseLikeStatic`, der <xref:System.Int32> zurückgibt und Parameter vom Typ `Example` und <xref:System.Int32>und einen Delegattyp mit dem Namen `UseLikeInstance`, der <xref:System.Int32> zurückgibt und über einen Parameter vom Typ <xref:System.Int32>verfügt.  
  
 Der Beispielcode erstellt dann eine <xref:System.Reflection.Emit.DynamicMethod>, die das private-Feld einer Instanz von `Example` ändert und den vorherigen Wert zurückgibt.  
  
> [!NOTE]
>  Im Allgemeinen handelt es sich bei der Änderung der internen Felder von Klassen nicht um eine gute objektorientierte Programmier Übung.  
  
 Im Beispielcode wird eine Instanz von `Example` erstellt und dann zwei Delegaten erstellt. Der erste ist vom Typ `UseLikeStatic`, der die gleichen Parameter wie die dynamische Methode aufweist. Die zweite ist vom Typ `UseLikeInstance`, bei dem der erste Parameter (vom Typ `Example`) fehlt. Dieser Delegat wird mit der <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29>-Methoden Überladung erstellt. der zweite Parameter dieser Methoden Überladung ist eine Instanz von `Example`, in diesem Fall die soeben erstellte Instanz, die an den neu erstellten Delegaten gebunden ist. Wenn dieser Delegat aufgerufen wird, verhält sich die dynamische Methode für die gebundene Instanz von `Example`.  
  
> [!NOTE]
>  Dies ist ein Beispiel für die gelockerten Regeln für die Delegatbindung, die im [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]eingeführt wurde, sowie neue über Ladungen der <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType>-Methode. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Delegate>-Klasse.  
  
 Der `UseLikeStatic` Delegat wird aufgerufen und übergibt die Instanz von `Example`, die an den `UseLikeInstance` Delegaten gebunden ist. Anschließend wird der `UseLikeInstance` Delegat aufgerufen, sodass beide Delegaten für dieselbe Instanz von `Example`fungieren. Die Änderungen an den Werten des internen Felds werden nach jedem-Befehl angezeigt. Schließlich wird ein `UseLikeInstance` Delegat an eine Instanz von `DerivedFromExample`gebunden, und die Delegataufrufe werden wiederholt.  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Element von <paramref name="parameterTypes" /> ist <see langword="null" /> oder <see cref="T:System.Void" />.  
  
- oder - 
 <paramref name="owner" /> ist eine Schnittstelle, ein Array, ein offener generischer Typ oder ein Typparameter eines generischen Typs oder einer Methode.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="owner" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> ist <see langword="null" /> oder ein Typ, für den <see cref="P:System.Type.IsByRef" /> den Wert <see langword="true" /> zurückgibt.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">, wenn die dynamische Methode einem Typ in einem anderen Modul als dem aufrufenden Modul zugeordnet werden soll. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /></permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Gewusst wie: Definieren und Ausführen von dynamischen Methoden</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Sicherheitsaspekte bei der Reflektionsausgabe</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der dynamischen Methode. Dies kann eine leere Zeichenfolge sein, sie darf aber nicht <see langword="null" /> sein.</param>
        <param name="returnType">Ein <see cref="T:System.Type" />-Objekt, das den Rückgabetyp der dynamischen Methode angibt, oder <see langword="null" />, wenn die Methode keinen Rückgabetyp hat.</param>
        <param name="parameterTypes">Ein Array von <see cref="T:System.Type" />-Objekten, die die Typen der Parameter der dynamischen Methode angeben, oder <see langword="null" />, wenn die Methode keine Parameter hat.</param>
        <param name="m">Ein <see cref="T:System.Reflection.Module" />, das das Modul darstellt, dem die dynamische Methode logisch zugeordnet ist.</param>
        <param name="skipVisibility"><see langword="true" />, wenn JIT-Sichtbarkeitsprüfungen für Typen und Member übersprungen werden sollen, auf die die MSIL der dynamischen Methode zugreift.</param>
        <summary>Erstellt eine dynamische Methode, die sich zu einem Modul global verhält und den Methodennamen, Rückgabetyp, die Parametertypen, das Modul angibt. Zudem wird angegeben, ob JIT-Sichtbarkeitsprüfungen (Just-In-Time) für Typen und Member übersprungen werden sollen, auf die von der MSIL (Microsoft Intermediate Language) der dynamischen Methode zugegriffen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor gibt Methoden Attribute <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> und <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>sowie die Aufruf Konvention <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>an.  
  
 Die dynamische Methode, die mit diesem Konstruktor erstellt wurde, hat Zugriff auf die Member Public und `internal` (`Friend` in Visual Basic) aller Typen im enthaltenen Modul `m`. Das Überspringen der Sichtbarkeits Prüfungen des JIT-Compilers ermöglicht der dynamischen Methode auch den Zugriff auf private und geschützte Member aller anderen Typen. Dies ist beispielsweise hilfreich, wenn Sie Code zum Serialisieren von Objekten schreiben.  
  
> [!NOTE]
>  Aus Gründen der Abwärtskompatibilität fordert dieser Konstruktor <xref:System.Security.Permissions.SecurityPermission> mit dem <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>-Flag an, wenn die folgenden Bedingungen zutreffen: `m` ist ein anderes Modul als das Aufruf Modul, und die Anforderung für <xref:System.Security.Permissions.ReflectionPermission> mit dem <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>-Flag ist fehlgeschlagen. Wenn die Nachfrage nach <xref:System.Security.Permissions.SecurityPermission> erfolgreich ist, ist der Vorgang zulässig.  
  
> [!NOTE]
>  Beginnend mit dem [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] erfordert dieser Member nicht mehr <xref:System.Security.Permissions.ReflectionPermission> mit dem <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>-Flag. (Siehe [Sicherheitsprobleme bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Um diese Funktion verwenden zu können, sollte Ihre Anwendung auf [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgerichtet sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Element von <paramref name="parameterTypes" /> ist <see langword="null" /> oder <see cref="T:System.Void" />.  
  
- oder - 
 <paramref name="m" /> ist ein Modul, das das anonyme Hosten für dynamische Methoden bereitstellt.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="m" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> ist ein Typ, für den <see cref="P:System.Type.IsByRef" /> den Wert <see langword="true" /> zurückgibt.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">, wenn die dynamische Methode einem anderen Modul als dem aufrufenden Modul zugeordnet werden soll. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /></permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Gewusst wie: Definieren und Ausführen von dynamischen Methoden</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Sicherheitsaspekte bei der Reflektionsausgabe</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der dynamischen Methode. Dies kann eine leere Zeichenfolge sein, sie darf aber nicht <see langword="null" /> sein.</param>
        <param name="returnType">Ein <see cref="T:System.Type" />-Objekt, das den Rückgabetyp der dynamischen Methode angibt, oder <see langword="null" />, wenn die Methode keinen Rückgabetyp hat.</param>
        <param name="parameterTypes">Ein Array von <see cref="T:System.Type" />-Objekten, die die Typen der Parameter der dynamischen Methode angeben, oder <see langword="null" />, wenn die Methode keine Parameter hat.</param>
        <param name="owner">Ein <see cref="T:System.Type" />, der der dynamischen Methode logisch zugeordnet ist. Die dynamische Methode hat Zugriff auf alle Member des Typs.</param>
        <param name="skipVisibility"><see langword="true" />, wenn JIT-Sichtbarkeitsprüfungen für Typen und Member übersprungen werden sollen, auf die die MSIL der dynamischen Methode zugreift, andernfalls <see langword="false" />.</param>
        <summary>Erstellt eine dynamische Methode. Dabei werden der Methodenname, der Rückgabetyp, die Parametertypen und der Typ angegeben, der der dynamischen Methode logisch zugeordnet ist. Außerdem wird angegeben, ob JIT-Sichtbarkeitsprüfungen (Just-In-Time) für Typen und Member übersprungen werden sollen, auf die die MSIL (Microsoft Intermediate Language) der dynamischen Methode zugreift.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die dynamische Methode, die mit diesem Konstruktor erstellt wird, hat Zugriff auf alle Member des Typs `owner`sowie auf öffentliche und `internal` (`Friend` in Visual Basic) Membern aller anderen Typen im Modul, das `owner`enthält. Das Überspringen der Sichtbarkeits Prüfungen des JIT-Compilers ermöglicht der dynamischen Methode auch den Zugriff auf private und geschützte Member aller anderen Typen. Dies ist beispielsweise hilfreich, wenn Sie Code zum Serialisieren von Objekten schreiben.  
  
 Dieser Konstruktor gibt Methoden Attribute <xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType> und <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>sowie die Aufruf Konvention <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>an.  
  
> [!NOTE]
>  Aus Gründen der Abwärtskompatibilität fordert dieser Konstruktor <xref:System.Security.Permissions.SecurityPermission> mit dem <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>-Flag an, wenn die folgenden Bedingungen zutreffen: `owner` in einem anderen Modul als dem aufrufenden Modul, und die Anforderung für <xref:System.Security.Permissions.ReflectionPermission> mit dem <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Flag ist fehlgeschlagen. Wenn die Nachfrage nach <xref:System.Security.Permissions.SecurityPermission> erfolgreich ist, ist der Vorgang zulässig.  
  
> [!NOTE]
>  Beginnend mit dem [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] erfordert dieser Member nicht mehr <xref:System.Security.Permissions.ReflectionPermission> mit dem <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>-Flag. (Siehe [Sicherheitsprobleme bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Um diese Funktion verwenden zu können, sollte Ihre Anwendung auf [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgerichtet sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Element von <paramref name="parameterTypes" /> ist <see langword="null" /> oder <see cref="T:System.Void" />.  
  
- oder - 
 <paramref name="owner" /> ist eine Schnittstelle, ein Array, ein offener generischer Typ oder ein Typparameter eines generischen Typs oder einer Methode.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="owner" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> ist <see langword="null" /> oder ein Typ, für den <see cref="P:System.Type.IsByRef" /> den Wert <see langword="true" /> zurückgibt.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">, wenn die dynamische Methode einem Typ in einem anderen Modul als dem aufrufenden Modul zugeordnet werden soll. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /></permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Gewusst wie: Definieren und Ausführen von dynamischen Methoden</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Sicherheitsaspekte bei der Reflektionsausgabe</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der dynamischen Methode. Dies kann eine leere Zeichenfolge sein, sie darf aber nicht <see langword="null" /> sein.</param>
        <param name="attributes">Eine bitweise Kombination von <see cref="T:System.Reflection.MethodAttributes" />-Werten, die die Attribute der dynamischen Methode angibt. Die einzige zulässige Kombination ist <see cref="F:System.Reflection.MethodAttributes.Public" /> und <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">Die Aufrufkonvention für die dynamische Methode. Dieser Wert muss <see cref="F:System.Reflection.CallingConventions.Standard" /> sein.</param>
        <param name="returnType">Ein <see cref="T:System.Type" />-Objekt, das den Rückgabetyp der dynamischen Methode angibt, oder <see langword="null" />, wenn die Methode keinen Rückgabetyp hat.</param>
        <param name="parameterTypes">Ein Array von <see cref="T:System.Type" />-Objekten, die die Typen der Parameter der dynamischen Methode angeben, oder <see langword="null" />, wenn die Methode keine Parameter hat.</param>
        <param name="m">Ein <see cref="T:System.Reflection.Module" />, das das Modul darstellt, dem die dynamische Methode logisch zugeordnet ist.</param>
        <param name="skipVisibility"><see langword="true" />, wenn JIT-Sichtbarkeitsprüfungen für Typen und Member übersprungen werden sollen, auf die die MSIL der dynamischen Methode zugreift, andernfalls <see langword="false" />.</param>
        <summary>Erstellt eine dynamische Methode, die sich zu einem Modul global verhält und Methodennamen, Attribute, die Aufrufkonvention, den Rückgabetyp, die Parametertypen und das Modul angibt. Zudem wird angegeben, ob JIT-Sichtbarkeitsprüfungen (Just-In-Time) für Typen und Member übersprungen werden sollen, auf die von der MSIL (Microsoft Intermediate Language) der dynamischen Methode zugegriffen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die mit diesem Konstruktor erstellte dynamische Methode hat Zugriff auf die Member Public und `internal` (`Friend` in Visual Basic) aller öffentlichen und internen Typen, die in Modul `m`enthalten sind.  
  
 Das Überspringen der Sichtbarkeits Prüfungen des JIT-Compilers ermöglicht der dynamischen Methode den Zugriff auf private und geschützte Member aller anderen Typen im Modul und in allen anderen Assemblys. Dies ist beispielsweise hilfreich, wenn Sie Code zum Serialisieren von Objekten schreiben.  
  
> [!NOTE]
>  Aus Gründen der Abwärtskompatibilität fordert dieser Konstruktor <xref:System.Security.Permissions.SecurityPermission> mit dem <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>-Flag an, wenn die folgenden Bedingungen zutreffen: `m` ist ein anderes Modul als das Aufruf Modul, und die Anforderung für <xref:System.Security.Permissions.ReflectionPermission> mit dem <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>-Flag ist fehlgeschlagen. Wenn die Nachfrage nach <xref:System.Security.Permissions.SecurityPermission> erfolgreich ist, ist der Vorgang zulässig.  
  
> [!NOTE]
>  Beginnend mit dem [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] erfordert dieser Member nicht mehr <xref:System.Security.Permissions.ReflectionPermission> mit dem <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>-Flag. (Siehe [Sicherheitsprobleme bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Um diese Funktion verwenden zu können, sollte Ihre Anwendung auf [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgerichtet sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Element von <paramref name="parameterTypes" /> ist <see langword="null" /> oder <see cref="T:System.Void" />.  
  
- oder - 
 <paramref name="m" /> ist ein Modul, das das anonyme Hosten für dynamische Methoden bereitstellt.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="m" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="attributes" /> ist eine Kombination aus Flags außer <see cref="F:System.Reflection.MethodAttributes.Public" /> und <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
- oder - 
 <paramref name="callingConvention" /> ist nicht <see cref="F:System.Reflection.CallingConventions.Standard" />.  
  
- oder - 
 <paramref name="returnType" /> ist ein Typ, für den <see cref="P:System.Type.IsByRef" /> den Wert <see langword="true" /> zurückgibt.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">, wenn die dynamische Methode einem anderen Modul als dem aufrufenden Modul zugeordnet werden soll. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /></permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Gewusst wie: Definieren und Ausführen von dynamischen Methoden</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Sicherheitsaspekte bei der Reflektionsausgabe</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der dynamischen Methode. Dies kann eine leere Zeichenfolge sein, sie darf aber nicht <see langword="null" /> sein.</param>
        <param name="attributes">Eine bitweise Kombination von <see cref="T:System.Reflection.MethodAttributes" />-Werten, die die Attribute der dynamischen Methode angibt. Die einzige zulässige Kombination ist <see cref="F:System.Reflection.MethodAttributes.Public" /> und <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">Die Aufrufkonvention für die dynamische Methode. Dieser Wert muss <see cref="F:System.Reflection.CallingConventions.Standard" /> sein.</param>
        <param name="returnType">Ein <see cref="T:System.Type" />-Objekt, das den Rückgabetyp der dynamischen Methode angibt, oder <see langword="null" />, wenn die Methode keinen Rückgabetyp hat.</param>
        <param name="parameterTypes">Ein Array von <see cref="T:System.Type" />-Objekten, die die Typen der Parameter der dynamischen Methode angeben, oder <see langword="null" />, wenn die Methode keine Parameter hat.</param>
        <param name="owner">Ein <see cref="T:System.Type" />, der der dynamischen Methode logisch zugeordnet ist. Die dynamische Methode hat Zugriff auf alle Member des Typs.</param>
        <param name="skipVisibility"><see langword="true" />, wenn JIT-Sichtbarkeitsprüfungen für Typen und Member übersprungen werden sollen, auf die die MSIL der dynamischen Methode zugreift, andernfalls <see langword="false" />.</param>
        <summary>Erstellt eine dynamische Methode. Dabei werden der Methodenname, die Attribute, die Aufrufkonvention, der Rückgabetyp, die Parametertypen und der Typ angegeben, der der dynamischen Methode logisch zugeordnet ist. Außerdem wird angegeben, ob JIT-Sichtbarkeitsprüfungen (Just-In-Time) für Typen und Member übersprungen werden sollen, auf die die MSIL (Microsoft Intermediate Language) der dynamischen Methode zugreift.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die dynamische Methode ist global für das Modul, das den Typ `owner`enthält. Er verfügt über Zugriff auf alle Member des Typs `owner`.  
  
 Die dynamische Methode, die mit diesem Konstruktor erstellt wird, hat Zugriff auf alle Member des Typs `owner`sowie auf Public und `internal` (`Friend` in Visual Basic) Membern aller Typen, die im Modul enthalten sind, das `owner`enthält. Das Überspringen der Sichtbarkeits Prüfungen des JIT-Compilers ermöglicht der dynamischen Methode auch den Zugriff auf private und geschützte Member aller anderen Typen. Dies ist beispielsweise hilfreich, wenn Sie Code zum Serialisieren von Objekten schreiben.  
  
> [!NOTE]
>  Aus Gründen der Abwärtskompatibilität fordert dieser Konstruktor <xref:System.Security.Permissions.SecurityPermission> mit dem <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>-Flag an, wenn die folgenden Bedingungen zutreffen: `owner` in einem anderen Modul als dem aufrufenden Modul, und die Anforderung für <xref:System.Security.Permissions.ReflectionPermission> mit dem <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Flag ist fehlgeschlagen. Wenn die Nachfrage nach <xref:System.Security.Permissions.SecurityPermission> erfolgreich ist, ist der Vorgang zulässig.  
  
> [!NOTE]
>  Beginnend mit dem [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] erfordert dieser Member nicht mehr <xref:System.Security.Permissions.ReflectionPermission> mit dem <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>-Flag. (Siehe [Sicherheitsprobleme bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Um diese Funktion verwenden zu können, sollte Ihre Anwendung auf [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgerichtet sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Element von <paramref name="parameterTypes" /> ist <see langword="null" /> oder <see cref="T:System.Void" />.  
  
- oder - 
 <paramref name="owner" /> ist eine Schnittstelle, ein Array, ein offener generischer Typ oder ein Typparameter eines generischen Typs oder einer Methode.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="owner" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="attributes" /> ist eine Kombination aus Flags außer <see cref="F:System.Reflection.MethodAttributes.Public" /> und <see cref="F:System.Reflection.MethodAttributes.Static" />.  
  
- oder - 
 <paramref name="callingConvention" /> ist nicht <see cref="F:System.Reflection.CallingConventions.Standard" />.  
  
- oder - 
 <paramref name="returnType" /> ist ein Typ, für den <see cref="P:System.Type.IsByRef" /> den Wert <see langword="true" /> zurückgibt.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">, wenn die dynamische Methode einem Typ in einem anderen Modul als dem aufrufenden Modul zugeordnet werden soll. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /></permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Gewusst wie: Definieren und Ausführen von dynamischen Methoden</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Sicherheitsaspekte bei der Reflektionsausgabe</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.MethodAttributes" Usage="System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Attribute ab, die beim Erstellen der dynamischen Methode angegeben wurden.</summary>
        <value>Eine bitweise Kombination der <see cref="T:System.Reflection.MethodAttributes" />-Werte, die die Attribute für die Methode darstellen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Derzeit sind die Methoden Attribute für eine dynamische Methode immer <xref:System.Reflection.MethodAttributes.Public> und <xref:System.Reflection.MethodAttributes.Static>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die Methoden Attribute einer dynamischen Methode angezeigt. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Reflection.Emit.DynamicMethod>-Klasse bereitgestellt wird.  
  
 [!code-cpp[Reflection.DynamicMethod.All#21](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#21)]
 [!code-csharp[Reflection.DynamicMethod.All#21](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#21)]
 [!code-vb[Reflection.DynamicMethod.All#21](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberSignature Language="F#" Value="member this.CallingConvention : System.Reflection.CallingConventions" Usage="System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Aufrufkonvention ab, die beim Erstellen der dynamischen Methode angegeben wurde.</summary>
        <value>Einer der <see cref="T:System.Reflection.CallingConventions" />-Werte, der die Aufrufkonvention der Methode angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Derzeit ist die Aufruf Konvention für eine dynamische Methode immer <xref:System.Reflection.CallingConventions.Standard>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Aufruf Konvention einer dynamischen Methode angezeigt. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Reflection.Emit.DynamicMethod>-Klasse bereitgestellt wird.  
  
 [!code-cpp[Reflection.DynamicMethod.All#22](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#22)]
 [!code-csharp[Reflection.DynamicMethod.All#22](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#22)]
 [!code-vb[Reflection.DynamicMethod.All#22](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vervollständigt die dynamische Methode und erstellt einen Delegaten, mit dem die Methode ausgeführt werden kann.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type) As Delegate" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type -&gt; Delegate" Usage="dynamicMethod.CreateDelegate delegateType" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public Delegate CreateDelegate (Type delegateType);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Delegate CreateDelegate(class System.Type delegateType) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDelegate (delegateType As Type) As Delegate" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Delegate ^ CreateDelegate(Type ^ delegateType);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="F#" Value="member this.CreateDelegate : Type -&gt; Delegate" Usage="dynamicMethod.CreateDelegate delegateType" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="delegateType">Ein Delegattyp, dessen Signatur mit der Signatur der dynamischen Methode übereinstimmt.</param>
        <summary>Vervollständigt die dynamische Methode und erstellt einen Delegaten, mit dem die Methode ausgeführt werden kann.</summary>
        <returns>Ein Delegat des angegebenen Typs, mit dem die dynamische Methode ausgeführt werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>-Methode oder die <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>-Methode aufrufen, wird die dynamische Methode abgeschlossen. Jeder weitere Versuch, die dynamische Methode zu ändern, z. b. das Ändern von Parameter Definitionen oder das Ausgeben von MSIL (Microsoft Intermediate Language), wird ignoriert. Es wird keine Ausnahme ausgelöst.  
  
 Um einen Methoden Text für eine dynamische Methode zu erstellen, wenn Sie über einen eigenen MSIL-Generator verfügen, rufen Sie die <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A>-Methode auf, um ein <xref:System.Reflection.Emit.DynamicILInfo> Objekt zu erhalten. Wenn Sie nicht über einen eigenen MSIL-Generator verfügen, rufen Sie die <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A>-Methode auf, um ein <xref:System.Reflection.Emit.ILGenerator> Objekt zu erhalten, das zum Generieren des Methoden Texts verwendet werden kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine dynamische Methode erstellt, die zwei Parameter annimmt. Im Beispiel wird ein einfacher Funktions Text ausgegeben, der den ersten Parameter in der Konsole ausgibt. im Beispiel wird der zweite Parameter als Rückgabewert der-Methode verwendet. Im Beispiel wird die-Methode vervollständigt, indem ein Delegat erstellt wird, der Delegat mit unterschiedlichen Parametern aufgerufen und schließlich die dynamische Methode mithilfe der <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>-Methode aufgerufen wird.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die dynamische Methode verfügt über keinen Methodentext.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="delegateType" /> weist die falsche Anzahl von Parametern oder die falschen Parametertypen auf.</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Gewusst wie: Definieren und Ausführen von dynamischen Methoden</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType, object target);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType, object target) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type, target As Object) As Delegate" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType, System::Object ^ target);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type * obj -&gt; Delegate" Usage="dynamicMethod.CreateDelegate (delegateType, target)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public Delegate CreateDelegate (Type delegateType, object target);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Delegate CreateDelegate(class System.Type delegateType, object target) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDelegate (delegateType As Type, target As Object) As Delegate" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Delegate ^ CreateDelegate(Type ^ delegateType, System::Object ^ target);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="F#" Value="member this.CreateDelegate : Type * obj -&gt; Delegate" Usage="dynamicMethod.CreateDelegate (delegateType, target)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="delegateType">Ein Delegattyp, dessen Signatur mit der Signatur der dynamischen Methode übereinstimmt, ohne den ersten Parameter.</param>
        <param name="target">Ein Objekt, an das der Delegat gebunden ist. Muss denselben Typ wie der erste Parameter der dynamischen Methode aufweisen.</param>
        <summary>Vervollständigt die dynamische Methode und erstellt einen Delegaten, mit dem die Methode ausgeführt werden kann, wobei der Delegattyp und ein Objekt angegeben werden, das an den Delegaten gebunden ist.</summary>
        <returns>Ein Delegat des angegebenen Typs, mit dem die dynamische Methode mit dem angegebenen Zielobjekt ausgeführt werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methoden Überladung erstellt einen Delegaten, der an ein bestimmtes Objekt gebunden ist. Ein solcher Delegat wird als erstes Argument geschlossen. Obwohl die Methode statisch ist, verhält sie sich so, als ob es sich um eine Instanzmethode handelt. die Instanz ist `target`.  
  
 Diese Methoden Überladung erfordert, dass `target` denselben Typ wie der erste Parameter der dynamischen Methode aufweisen oder diesem Typ zugewiesen werden kann (z. b. eine abgeleitete Klasse).  Die Signatur von `delegateType` weist alle Parameter der dynamischen Methode auf, mit Ausnahme des ersten. Wenn die dynamische Methode z. b. die Parameter <xref:System.String>, <xref:System.Int32>und <xref:System.Byte>hat, verfügt `delegateType` über die Parameter <xref:System.Int32> und <xref:System.Byte>; `target` ist vom Typ <xref:System.String>.  
  
 Wenn Sie die <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>-Methode oder die <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>-Methode aufrufen, wird die dynamische Methode abgeschlossen. Jeder weitere Versuch, die dynamische Methode zu ändern, z. b. das Ändern von Parameter Definitionen oder das Ausgeben von MSIL (Microsoft Intermediate Language), wird ignoriert. Es wird keine Ausnahme ausgelöst.  
  
 Um einen Methoden Text für eine dynamische Methode zu erstellen, wenn Sie über einen eigenen MSIL-Generator verfügen, rufen Sie die <xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A>-Methode auf, um ein <xref:System.Reflection.Emit.DynamicILInfo> Objekt zu erhalten. Wenn Sie nicht über einen eigenen MSIL-Generator verfügen, rufen Sie die <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A>-Methode auf, um ein <xref:System.Reflection.Emit.ILGenerator> Objekt zu erhalten, das zum Generieren des Methoden Texts verwendet werden kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Delegat erstellt, der eine <xref:System.Reflection.Emit.DynamicMethod> an eine Instanz eines Typs bindet, sodass die-Methode bei jedem Aufruf auf dieselbe Instanz angewendet wird.  
  
 Das Codebeispiel definiert eine Klasse mit dem Namen `Example` mit einem privaten Feld, einer Klasse mit dem Namen `DerivedFromExample`, die von der ersten Klasse abgeleitet ist, einem Delegattyp mit dem Namen `UseLikeStatic`, der <xref:System.Int32> zurückgibt und Parameter vom Typ `Example` und <xref:System.Int32>und einen Delegattyp mit dem Namen `UseLikeInstance`, der <xref:System.Int32> zurückgibt und über einen Parameter vom Typ <xref:System.Int32>verfügt.  
  
 Der Beispielcode erstellt dann eine <xref:System.Reflection.Emit.DynamicMethod>, die das private-Feld einer Instanz von `Example` ändert und den vorherigen Wert zurückgibt.  
  
> [!NOTE]
>  Im Allgemeinen handelt es sich bei der Änderung der internen Felder von Klassen nicht um eine gute objektorientierte Programmier Übung.  
  
 Im Beispielcode wird eine Instanz von `Example` erstellt und dann zwei Delegaten erstellt. Der erste ist vom Typ `UseLikeStatic`, der die gleichen Parameter wie die dynamische Methode aufweist. Die zweite ist vom Typ `UseLikeInstance`, bei dem der erste Parameter (vom Typ `Example`) fehlt. Dieser Delegat wird mit der <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29>-Methoden Überladung erstellt. der zweite Parameter dieser Methoden Überladung ist eine Instanz von `Example`, in diesem Fall die soeben erstellte Instanz, die an den neu erstellten Delegaten gebunden ist. Wenn dieser Delegat aufgerufen wird, verhält sich die dynamische Methode für die gebundene Instanz von `Example`.  
  
> [!NOTE]
>  Dies ist ein Beispiel für die gelockerten Regeln für die Delegatbindung, die im [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]eingeführt wurde, sowie neue über Ladungen der <xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType>-Methode. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Delegate>-Klasse.  
  
 Der `UseLikeStatic` Delegat wird aufgerufen und übergibt die Instanz von `Example`, die an den `UseLikeInstance` Delegaten gebunden ist. Anschließend wird der `UseLikeInstance` Delegat aufgerufen, sodass beide Delegaten für dieselbe Instanz von `Example`fungieren. Die Änderungen an den Werten des internen Felds werden nach jedem-Befehl angezeigt. Schließlich wird ein `UseLikeInstance` Delegat an eine Instanz von `DerivedFromExample`gebunden, und die Delegataufrufe werden wiederholt.  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die dynamische Methode verfügt über keinen Methodentext.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> entspricht nicht demselben Typ wie der erste Parameter der dynamischen Methode und kann diesem Typ nicht zugewiesen werden.  
  
- oder - 
 <paramref name="delegateType" /> weist die falsche Anzahl von Parametern oder die falschen Parametertypen auf.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ ab, der die Methode deklariert und für dynamische Methoden immer <see langword="null" /> ist.</summary>
        <value>Immer <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt immer `null` für dynamische Methoden zurück. Auch wenn eine dynamische Methode logisch einem Typ zugeordnet ist, wird Sie nicht vom-Typ deklariert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der deklarierende Typ einer dynamischen Methode angezeigt. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Reflection.Emit.DynamicMethod>-Klasse bereitgestellt wird.  
  
 [!code-cpp[Reflection.DynamicMethod.All#23](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#23)]
 [!code-csharp[Reflection.DynamicMethod.All#23](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#23)]
 [!code-vb[Reflection.DynamicMethod.All#23](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, parameterName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ parameterName);" />
      <MemberSignature Language="F#" Value="member this.DefineParameter : int * System.Reflection.ParameterAttributes * string -&gt; System.Reflection.Emit.ParameterBuilder" Usage="dynamicMethod.DefineParameter (position, attributes, parameterName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="parameterName" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="position">Die Position des Parameters in der Parameterliste. Parameter werden beginnend mit der Zahl 1 (für den ersten Parameter) indiziert.</param>
        <param name="attributes">Eine bitweise Kombination von <see cref="T:System.Reflection.ParameterAttributes" />-Werten, die die Attribute des Parameters angibt.</param>
        <param name="parameterName">Der Name des Parameters. Der Name kann eine leere Zeichenfolge sein.</param>
        <summary>Definiert einen Parameter der dynamischen Methode.</summary>
        <returns>Gibt immer <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `position` 0 ist, verweist die <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A>-Methode auf den Rückgabewert. Das Festlegen von Parameterinformationen hat keine Auswirkung auf den Rückgabewert.  
  
 Wenn die dynamische Methode bereits durch Aufrufen der Methode <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> oder <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> abgeschlossen wurde, hat die <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A> Methode keine Auswirkung. Es werden keine Ausnahmen ausgelöst.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie Parameterinformationen für eine dynamische Methode definiert werden. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Reflection.Emit.DynamicMethod>-Klasse bereitgestellt wird.  
  
 [!code-cpp[Reflection.DynamicMethod.All#33](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#33)]
 [!code-csharp[Reflection.DynamicMethod.All#33](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#33)]
 [!code-vb[Reflection.DynamicMethod.All#33](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Methode hat keine Parameter.  
  
- oder - 
 <paramref name="position" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="position" /> ist größer als die Anzahl der Parameter der Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetBaseDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="dynamicMethod.GetBaseDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Basisimplementierung für die Methode zurück.</summary>
        <returns>Die Basisimplementierung für die Methode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt immer das aktuelle `DynamicMethod`-Objekt zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die auf die Methode angewendeten benutzerdefinierten Attribute zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="inherit"><see langword="true" />, wenn die Vererbungskette der Methode nach den benutzerdefinierten Attributen durchsucht werden soll, <see langword="false" />, wenn nur die aktuelle Methode überprüft werden soll.</param>
        <summary>Gibt alle für die Methode definierten benutzerdefinierten Attribute zurück.</summary>
        <returns>Ein Objektarray, das alle benutzerdefinierten Attribute der Methode darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei dynamischen Methoden hat das Angeben von `true` für `inherit` keine Auswirkung, da die Methode nicht in einem Typ deklariert wird.  
  
> [!NOTE]
>  Benutzerdefinierte Attribute werden derzeit nicht für dynamische Methoden unterstützt. Das einzige zurückgegebene Attribut ist <xref:System.Runtime.CompilerServices.MethodImplAttribute>. mit der <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A>-Methode können Sie die Methodenimplementierungsflags leichter erhalten.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="attributeType">Ein <see cref="T:System.Type" />, der den Typ des zurückzugebenden benutzerdefinierten Attributs darstellt.</param>
        <param name="inherit"><see langword="true" />, wenn die Vererbungskette der Methode nach den benutzerdefinierten Attributen durchsucht werden soll, <see langword="false" />, wenn nur die aktuelle Methode überprüft werden soll.</param>
        <summary>Gibt die benutzerdefinierten Attribute des angegebenen Typs zurück, die auf die Methode angewendet wurden.</summary>
        <returns>Ein Array von Objekten, die die Attribute der Methode darstellen und vom Typ <paramref name="attributeType" /> sind oder vom Typ <paramref name="attributeType" /> abgeleitet werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei dynamischen Methoden hat das Angeben von `true` für `inherit` keine Auswirkung, da die Methode nicht in einem Typ deklariert wird.  
  
> [!NOTE]
>  Benutzerdefinierte Attribute werden derzeit nicht für dynamische Methoden unterstützt. Das einzige zurückgegebene Attribut ist <xref:System.Runtime.CompilerServices.MethodImplAttribute>. mit der <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A>-Methode können Sie die Methodenimplementierungsflags leichter erhalten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="attributeType" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetDynamicILInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.DynamicILInfo GetDynamicILInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.DynamicILInfo GetDynamicILInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDynamicILInfo () As DynamicILInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::DynamicILInfo ^ GetDynamicILInfo();" />
      <MemberSignature Language="F#" Value="member this.GetDynamicILInfo : unit -&gt; System.Reflection.Emit.DynamicILInfo" Usage="dynamicMethod.GetDynamicILInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.DynamicILInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Reflection.Emit.DynamicILInfo" />-Objekt zurück, das zum Generieren von Methodentext aus Metadatentoken, Bereichen und MSIL-Streams (Microsoft Intermediate Language) verwendet werden kann.</summary>
        <returns>Ein <see cref="T:System.Reflection.Emit.DynamicILInfo" />-Objekt, das zum Generieren von Methodentext aus Metadatentoken, Bereichen und MSIL-Streams verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.Emit.DynamicILInfo>-Klasse wird zur Unterstützung der Generierung von nicht verwaltetem Code bereitgestellt.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Ausführen von nicht verwaltetem Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Reflection.Emit.DynamicILInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen MSIL-Generator zurück, mit dem ein Textkörper für die dynamische Methode ausgegeben werden kann.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : unit -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt für die Methode einen MSIL-Generator (Microsoft Intermediate Language) mit einer MSIL-Standardstreamgröße von 64 Byte zurück.</summary>
        <returns>Ein <see cref="T:System.Reflection.Emit.ILGenerator" />-Objekt für die Methode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nachdem eine dynamische Methode durch Aufrufen der Methode <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> oder <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> abgeschlossen wurde, wird jeder weitere Versuch, MSIL hinzuzufügen, ignoriert. Es werden keine Ausnahmen ausgelöst.  
  
> [!NOTE]
>  Es gibt Einschränkungen für nicht überprüfbaren Code in dynamischen Methoden, auch in einigen Szenarien mit voller Vertrauenswürdigkeit. Weitere Informationen finden Sie im Abschnitt „Überprüfung“ für <xref:System.Reflection.Emit.DynamicMethod>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine dynamische Methode erstellt, die zwei Parameter annimmt. Im Beispiel wird ein einfacher Funktions Text ausgegeben, der den ersten Parameter in der Konsole ausgibt. im Beispiel wird der zweite Parameter als Rückgabewert der-Methode verwendet. Im Beispiel wird die-Methode vervollständigt, indem ein Delegat erstellt wird, der Delegat mit unterschiedlichen Parametern aufgerufen und schließlich die dynamische Methode mithilfe der <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>-Methode aufgerufen wird.  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Gewusst wie: Definieren und Ausführen von dynamischen Methoden</related>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int streamSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 streamSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (streamSize As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int streamSize);" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : int -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator streamSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="streamSize">Die Größe des MSIL-Streams in Bytes.</param>
        <summary>Gibt für die Methode einen MSIL-Generator (Microsoft Intermediate Language) mit der angegebenen Größe der MSIL-Streams zurück.</summary>
        <returns>Ein <see cref="T:System.Reflection.Emit.ILGenerator" />-Objekt für die Methode mit der angegebenen Größe der MSIL-Streams.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nachdem eine dynamische Methode durch Aufrufen der Methode <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A> oder <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A> abgeschlossen wurde, wird jeder weitere Versuch, MSIL hinzuzufügen, ignoriert. Es werden keine Ausnahmen ausgelöst.  
  
> [!NOTE]
>  Es gibt Einschränkungen für nicht überprüfbaren Code in dynamischen Methoden, auch in einigen Szenarien mit voller Vertrauenswürdigkeit. Weitere Informationen finden Sie im Abschnitt „Überprüfung“ für <xref:System.Reflection.Emit.DynamicMethod>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird diese Methoden Überladung veranschaulicht. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Reflection.Emit.DynamicMethod>-Klasse bereitgestellt wird.  
  
 [!code-cpp[Reflection.DynamicMethod.All#2](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#2)]
 [!code-csharp[Reflection.DynamicMethod.All#2](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#2)]
 [!code-vb[Reflection.DynamicMethod.All#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">Gewusst wie: Definieren und Ausführen von dynamischen Methoden</related>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberSignature Language="F#" Value="override this.GetMethodImplementationFlags : unit -&gt; System.Reflection.MethodImplAttributes" Usage="dynamicMethod.GetMethodImplementationFlags " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Implementierungsflags für die Methode zurück.</summary>
        <returns>Eine bitweise Kombination von <see cref="T:System.Reflection.MethodImplAttributes" />-Werten, die die Implementierungsflags für die Methode darstellen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Derzeit werden Methoden Implementierungs Attribute für dynamische Methoden immer <xref:System.Reflection.MethodImplAttributes.IL> und <xref:System.Reflection.MethodImplAttributes.NoInlining>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberSignature Language="F#" Value="override this.GetParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="dynamicMethod.GetParameters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Parameter der dynamischen Methode zurück.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.ParameterInfo" />-Objekten, das die Parameter der dynamischen Methode darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die von dieser Methode zurückgegebenen <xref:System.Reflection.ParameterInfo> Objekte dienen nur zu Informationszwecken. Verwenden Sie die <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A>-Methode, um die Eigenschaften der Parameter festzulegen oder zu ändern.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die Parameter einer dynamischen Methode angezeigt. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Reflection.Emit.DynamicMethod>-Klasse bereitgestellt wird.  
  
 [!code-cpp[Reflection.DynamicMethod.All#34](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#34)]
 [!code-csharp[Reflection.DynamicMethod.All#34](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#34)]
 [!code-vb[Reflection.DynamicMethod.All#34](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#34)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InitLocals : bool with get, set" Usage="System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die lokalen Variablen in der Methode mit 0 (null) initialisiert werden, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn die lokalen Variablen in der Methode mit 0 (null) initialisiert werden, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft auf `true`festgelegt ist, enthält die ausgegebene MSIL (Microsoft Intermediate Language) die Initialisierung lokaler Variablen. Wenn Sie auf `false`festgelegt ist, werden lokale Variablen nicht initialisiert, und der generierte Code ist nicht überprüfbar.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A>-Eigenschaft einer dynamischen Methode angezeigt. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Reflection.Emit.DynamicMethod>-Klasse bereitgestellt wird.  
  
 [!code-cpp[Reflection.DynamicMethod.All#24](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#24)]
 [!code-csharp[Reflection.DynamicMethod.All#24](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#24)]
 [!code-vb[Reflection.DynamicMethod.All#24](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="override this.Invoke : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="dynamicMethod.Invoke (obj, invokeAttr, binder, parameters, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="parameters" Type="System.Object[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj">Dieser Parameter wird bei dynamischen Methoden ignoriert, da er statisch ist. Geben Sie <see langword="null" />an.</param>
        <param name="invokeAttr">Eine bitweise Kombination von <see cref="T:System.Reflection.BindingFlags" />-Werten.</param>
        <param name="binder">Ein <see cref="T:System.Reflection.Binder" />-Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see cref="T:System.Reflection.MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn <paramref name="binder" /> den Wert <see langword="null" /> aufweist, wird der Standardbinder verwendet. Weitere Informationen finden Sie unter <see cref="T:System.Reflection.Binder" />.</param>
        <param name="parameters">Eine Argumentliste. Diese ist ein Array von Argumenten, die hinsichtlich Anzahl, Reihenfolge und Typ mit den Parametern der aufzurufenden Methode identisch sind. Wenn keine Parameter vorhanden sind, muss dieser Parameter gleich <see langword="null" /> sein.</param>
        <param name="culture">Eine Instanz von <see cref="T:System.Globalization.CultureInfo" /> für die Steuerung der Umwandlung von Typen. Wenn dies <see langword="null" /> ist, wird die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet. Diese Informationen sind z.B. erforderlich, um ein <see cref="T:System.String" />, das 1000 darstellt, ordnungsgemäß in einen <see cref="T:System.Double" />-Wert zu konvertieren, da 1000 in verschiedenen Kulturen unterschiedlich dargestellt wird.</param>
        <summary>Ruft die dynamische Methode mithilfe des angegebenen Parameters und den Einschränkungen des angegebenen Binders mit den angegebenen Kulturinformationen auf.</summary>
        <returns>Ein <see cref="T:System.Object" />, das den Rückgabewert der aufgerufenen Methode enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zusätzlich zu den aufgeführten Ausnahmen sollte der aufrufende Code darauf vorbereitet sein, alle Ausnahmen abzufangen, die von der dynamischen Methode ausgelöst werden.  
  
 Das Ausführen einer dynamischen Methode mit einem Delegaten, der durch die <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>-Methode erstellt wurde, ist effizienter als die Ausführung mit der <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>-Methode.  
  
 Wenn Sie die <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>-Methode oder die <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>-Methode aufrufen, wird die dynamische Methode abgeschlossen. Jeder weitere Versuch, die dynamische Methode zu ändern, z. b. das Ändern von Parameter Definitionen oder das Ausgeben von MSIL (Microsoft Intermediate Language), wird ignoriert. Es wird keine Ausnahme ausgelöst.  
  
 Alle dynamischen Methoden sind statisch, sodass der `obj`-Parameter immer ignoriert wird. Um eine dynamische Methode wie eine Instanzmethode zu behandeln, verwenden Sie die <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29> Überladung, die eine Objektinstanz annimmt.  
  
 Wenn die dynamische Methode keine Parameter aufweist, sollte der Wert `parameters` `null`sein. Andernfalls sollten die Anzahl, der Typ und die Reihenfolge der Elemente im Parameter Array mit der Anzahl, dem Typ und der Reihenfolge der Parameter der dynamischen Methode identisch sein.  
  
> [!NOTE]
>  Diese Methoden Überladung wird von der <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29>-Methoden Überladung aufgerufen, die von der <xref:System.Reflection.MethodBase>-Klasse geerbt wird, sodass die vorangehenden Hinweise auf beide über Ladungen zutreffen.  
  
 Diese Methode fordert keine Berechtigungen direkt an, aber das Aufrufen der dynamischen Methode kann zu Sicherheitsanforderungen führen, abhängig von der Methode. Beispielsweise werden keine Anforderungen für anonym gehostete dynamische Methoden hergestellt, die mit dem `restrictedSkipVisibility`-Parameter erstellt werden, der auf `false`festgelegt ist. Wenn Sie dagegen eine Methode erstellen, bei der `restrictedSkipVisibility` auf `true` festgelegt ist, um auf einen ausgeblendeten Member einer Zielassembly zugreifen zu können, bewirkt die Methode eine Anforderung für die Berechtigungen der Zielassembly Plus <xref:System.Security.Permissions.ReflectionPermission> mit dem <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> Flag.  
  
> [!NOTE]
>  Vor der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]erforderte diese Methode <xref:System.Security.Permissions.ReflectionPermission> mit dem <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess>-Flag.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine dynamische Methode mit der exakten Bindung aufgerufen, die die Kultur US-Englisch verwendet. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Reflection.Emit.DynamicMethod>-Klasse bereitgestellt wird.  
  
 [!code-cpp[Reflection.DynamicMethod.All#4](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#4)]
 [!code-csharp[Reflection.DynamicMethod.All#4](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#4)]
 [!code-vb[Reflection.DynamicMethod.All#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die <see cref="F:System.Reflection.CallingConventions.VarArgs" />-Aufrufkonvention wird nicht unterstützt.</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">Die Anzahl der Elemente in <paramref name="parameters" /> stimmt nicht mit der Anzahl der Parameter in der dynamischen Methode überein.</exception>
        <exception cref="T:System.ArgumentException">Der Typ eines oder mehrerer Elemente von <paramref name="parameters" /> entspricht nicht dem Typ des entsprechenden Parameters der dynamischen Methode.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Die dynamische Methode ist einem Modul zugeordnet, nicht anonym gehostet und wurde mit <paramref name="skipVisibility" /> (festgelegt auf <see langword="false" />) erstellt, aber die dynamische Methode greift auf die Member zu, die nicht <see langword="public" /> oder <see langword="internal" /> sind (<see langword="Friend" /> in Visual Basic).  
  
- oder - 
Die dynamische Methode wird anonym gehostet und wurde mit <paramref name="skipVisibility" /> (festgelegt auf <see langword="false" />) erstellt, aber sie greift auf Member zu, die nicht <see langword="public" /> sind.  
  
- oder - 
Die dynamische Methode enthält nicht überprüfbaren Code. Weitere Informationen finden Sie im Abschnitt „Überprüfung“ für <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="dynamicMethod.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="attributeType">Ein <see cref="T:System.Type" />, der den Typ des benutzerdefinierten Attributs darstellt, nach dem gesucht werden soll.</param>
        <param name="inherit"><see langword="true" />, wenn die Vererbungskette der Methode nach den benutzerdefinierten Attributen durchsucht werden soll, <see langword="false" />, wenn nur die aktuelle Methode überprüft werden soll.</param>
        <summary>Gibt an, ob der Typ des angegebenen benutzerdefinierten Attributs definiert ist.</summary>
        <returns><see langword="true" />, wenn der Typ des angegebenen benutzerdefinierten Attributs definiert ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für dynamische Methoden hat das Angeben von `true` für `inherit` keine Auswirkungen. Dynamische Methoden haben keine Vererbungs Kette.  
  
> [!NOTE]
>  Benutzerdefinierte Attribute werden derzeit nicht für dynamische Methoden unterstützt.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die aktuelle dynamische Methode sicherheitsrelevant ist und daher wichtige Vorgänge ausführen darf.</summary>
        <value><see langword="true" />, wenn die aktuelle dynamische Methode sicherheitsrelevant ist. <see langword="false" />, wenn sie transparent ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Eigenschaften <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>und <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> melden die Transparenz Ebene der dynamischen Methode, wie vom Common Language Runtime (CLR) festgelegt. Die Kombinationen dieser Eigenschaften werden in der folgenden Tabelle gezeigt:  
  
|Sicherheitsstufe|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Kritisch|`true`|`false`|`false`|  
|Sicher kritisch|`true`|`true`|`false`|  
|Transparent|`false`|`false`|`true`|  
  
 Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.  
  
 Die Transparenz einer dynamischen Methode hängt von dem Modul ab, dem es zugeordnet ist. Wenn die dynamische Methode einem Typ und nicht einem Modul zugeordnet ist, hängt die Transparenz von dem Modul ab, das den Typ enthält. Dynamische Methoden haben keine Sicherheits Anmerkungen, sodass Ihnen die Standard Transparenz für das zugehörige Modul zugewiesen wird.  
  
-   Anonym gehostete dynamische Methoden sind immer transparent, da das vom System bereitgestellte Modul, das Sie enthält, transparent ist.  
  
-   Die Transparenz einer dynamischen Methode, die mit einer vertrauenswürdigen Assembly verknüpft ist (d. h. eine Assembly mit starkem Namen, die im globalen Assemblycache installiert ist), wird in der folgenden Tabelle beschrieben.  
  
    |Assemblyanmerkung|Transparenz der Ebene 1|Transparenz der Ebene 2|  
    |-------------------------|--------------------------|--------------------------|  
    |Vollständig transparent|Transparent|Transparent|  
    |Vollständig kritisch|Kritisch|Kritisch|  
    |Gemischte Transparenz|Transparent|Transparent|  
    |Sicherheits agnostisch|Sicherheitskritisch|Kritisch|  
  
     Wenn Sie z. b. eine dynamische Methode einem Typ zuordnen, der sich in der Datei "mscorlib. dll" befindet, die über eine gemischte Transparenz der Ebene 2 verfügt, ist die dynamische Methode transparent und kann keinen kritischen Code ausführen. Informationen zu Transparenzstufen finden Sie unter [Sicherheits transparenter Code, Ebene 1](~/docs/framework/misc/security-transparent-code-level-1.md) und [Sicherheits transparenter Code, Ebene 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Das Zuordnen einer dynamischen Methode zu einem Modul in einer vertrauenswürdigen Assembly mit einer vertrauenswürdigen Ebene 1, die Sicherheits agnostisch ist (z. b. System. dll), lässt keine Vertrauenswürdigkeit zu. Wenn der Berechtigungs Satz des Codes, der die dynamische Methode aufruft, den Berechtigungs Satz von System. dll (also voll vertrauenswürdig) nicht enthält, wird <xref:System.Security.SecurityException> ausgelöst, wenn die dynamische Methode aufgerufen wird.  
  
-   Die Transparenz einer dynamischen Methode, die einer teilweise vertrauenswürdigen Assembly zugeordnet ist, hängt davon ab, wie die Assembly geladen wird. Wenn die Assembly mit teilweiser Vertrauenswürdigkeit (z. b. in eine Sandbox-Anwendungsdomäne) geladen wird, ignoriert die Laufzeit die Sicherheits Anmerkungen der Assembly. Die Assembly und alle zugehörigen Typen und Member, einschließlich dynamischer Methoden, werden als transparent behandelt. Die Laufzeit achtet nur dann auf Sicherheits Anmerkungen, wenn die teilweise vertrauenswürdige Assembly mit voller Vertrauenswürdigkeit (z. b. in die Standard Anwendungsdomäne einer Desktop Anwendung) geladen wird. In diesem Fall weist die Runtime der dynamischen Methode die Standard Transparenz für Methoden entsprechend den Anmerkungen der Assembly zu.  
  
 Weitere Informationen zur Reflektionsausgabe und Transparenz finden Sie unter [Sicherheitsprobleme bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Informationen zur Transparenz finden Sie unter [Sicherheitsänderungen](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die dynamische Methode weist keinen Methodentext auf.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Sicherheitsaspekte bei der Reflektionsausgabe</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Sicherheitsüberlegungen für die Reflektion</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Sicherheitsänderungen in der .NET Framework Version 4,0</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">Sicherheits transparenter Code, Ebene 1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">Sicherheitstransparenter Code, Ebene 2</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die aktuelle dynamische Methode auf der aktuellen Vertrauensebene sicherheitsgeschützt ist, d. h. ob sie wichtige Vorgänge ausführen darf und ob von transparentem Code auf sie zugegriffen werden kann.</summary>
        <value><see langword="true" />, wenn die dynamische Methode auf der aktuellen Vertrauensebene sicherheitsgeschützt ist, <see langword="false" /> wenn sie sicherheitskritisch oder sicherheitstransparent ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Eigenschaften <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>und <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> melden die Transparenz Ebene der dynamischen Methode, wie vom Common Language Runtime (CLR) festgelegt. Die Kombinationen dieser Eigenschaften werden in der folgenden Tabelle gezeigt:  
  
|Sicherheitsstufe|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Kritisch|`true`|`false`|`false`|  
|Sicher kritisch|`true`|`true`|`false`|  
|Transparent|`false`|`false`|`true`|  
  
 Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.  
  
 Die Transparenz einer dynamischen Methode hängt von dem Modul ab, dem es zugeordnet ist. Wenn die dynamische Methode einem Typ und nicht einem Modul zugeordnet ist, hängt die Transparenz von dem Modul ab, das den Typ enthält. Dynamische Methoden haben keine Sicherheits Anmerkungen, sodass Ihnen die Standard Transparenz für das zugehörige Modul zugewiesen wird.  
  
-   Anonym gehostete dynamische Methoden sind immer transparent, da das vom System bereitgestellte Modul, das Sie enthält, transparent ist.  
  
-   Die Transparenz einer dynamischen Methode, die mit einer vertrauenswürdigen Assembly verknüpft ist (d. h. eine Assembly mit starkem Namen, die im globalen Assemblycache installiert ist), wird in der folgenden Tabelle beschrieben.  
  
    |Assemblyanmerkung|Transparenz der Ebene 1|Transparenz der Ebene 2|  
    |-------------------------|--------------------------|--------------------------|  
    |Vollständig transparent|Transparent|Transparent|  
    |Vollständig kritisch|Kritisch|Kritisch|  
    |Gemischte Transparenz|Transparent|Transparent|  
    |Sicherheits agnostisch|Sicherheitskritisch|Kritisch|  
  
     Wenn Sie z. b. eine dynamische Methode einem Typ zuordnen, der sich in der Datei "mscorlib. dll" befindet, die über eine gemischte Transparenz der Ebene 2 verfügt, ist die dynamische Methode transparent und kann keinen kritischen Code ausführen. Informationen zu Transparenzstufen finden Sie unter [Sicherheits transparenter Code, Ebene 1](~/docs/framework/misc/security-transparent-code-level-1.md) und [Sicherheits transparenter Code, Ebene 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Das Zuordnen einer dynamischen Methode zu einem Modul in einer vertrauenswürdigen Assembly mit einer vertrauenswürdigen Ebene 1, die Sicherheits agnostisch ist (z. b. System. dll), lässt keine Vertrauenswürdigkeit zu. Wenn der Berechtigungs Satz des Codes, der die dynamische Methode aufruft, den Berechtigungs Satz von System. dll (also voll vertrauenswürdig) nicht enthält, wird <xref:System.Security.SecurityException> ausgelöst, wenn die dynamische Methode aufgerufen wird.  
  
-   Die Transparenz einer dynamischen Methode, die einer teilweise vertrauenswürdigen Assembly zugeordnet ist, hängt davon ab, wie die Assembly geladen wird. Wenn die Assembly mit teilweiser Vertrauenswürdigkeit (z. b. in eine Sandbox-Anwendungsdomäne) geladen wird, ignoriert die Laufzeit die Sicherheits Anmerkungen der Assembly. Die Assembly und alle zugehörigen Typen und Member, einschließlich dynamischer Methoden, werden als transparent behandelt. Die Laufzeit achtet nur dann auf Sicherheits Anmerkungen, wenn die teilweise vertrauenswürdige Assembly mit voller Vertrauenswürdigkeit (z. b. in die Standard Anwendungsdomäne einer Desktop Anwendung) geladen wird. In diesem Fall weist die Runtime der dynamischen Methode die Standard Transparenz für Methoden entsprechend den Anmerkungen der Assembly zu.  
  
 Weitere Informationen zur Reflektionsausgabe und Transparenz finden Sie unter [Sicherheitsprobleme bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Informationen zur Transparenz finden Sie unter [Sicherheitsänderungen](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die dynamische Methode weist keinen Methodentext auf.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Sicherheitsaspekte bei der Reflektionsausgabe</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Sicherheitsüberlegungen für die Reflektion</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Sicherheitsänderungen in der .NET Framework Version 4,0</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">Sicherheits transparenter Code, Ebene 1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">Sicherheitstransparenter Code, Ebene 2</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die aktuelle dynamische Methode auf der aktuellen Vertrauensebene sicherheitstransparent ist und daher keine wichtigen Vorgänge ausführen kann.</summary>
        <value><see langword="true" />, wenn die dynamische Methode auf der aktuellen Vertrauensebene sicherheitstransparent ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Eigenschaften <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>und <xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A> melden die Transparenz Ebene der dynamischen Methode, wie vom Common Language Runtime (CLR) festgelegt. Die Kombinationen dieser Eigenschaften werden in der folgenden Tabelle gezeigt:  
  
|Sicherheitsstufe|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Kritisch|`true`|`false`|`false`|  
|Sicher kritisch|`true`|`true`|`false`|  
|Transparent|`false`|`false`|`true`|  
  
 Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.  
  
 Die Transparenz einer dynamischen Methode hängt von dem Modul ab, dem es zugeordnet ist. Wenn die dynamische Methode einem Typ und nicht einem Modul zugeordnet ist, hängt die Transparenz von dem Modul ab, das den Typ enthält. Dynamische Methoden haben keine Sicherheits Anmerkungen, sodass Ihnen die Standard Transparenz für das zugehörige Modul zugewiesen wird.  
  
-   Anonym gehostete dynamische Methoden sind immer transparent, da das vom System bereitgestellte Modul, das Sie enthält, transparent ist.  
  
-   Die Transparenz einer dynamischen Methode, die mit einer vertrauenswürdigen Assembly verknüpft ist (d. h. eine Assembly mit starkem Namen, die im globalen Assemblycache installiert ist), wird in der folgenden Tabelle beschrieben.  
  
    |Assemblyanmerkung|Transparenz der Ebene 1|Transparenz der Ebene 2|  
    |-------------------------|--------------------------|--------------------------|  
    |Vollständig transparent|Transparent|Transparent|  
    |Vollständig kritisch|Kritisch|Kritisch|  
    |Gemischte Transparenz|Transparent|Transparent|  
    |Sicherheits agnostisch|Sicherheitskritisch|Kritisch|  
  
     Wenn Sie z. b. eine dynamische Methode einem Typ zuordnen, der sich in der Datei "mscorlib. dll" befindet, die über eine gemischte Transparenz der Ebene 2 verfügt, ist die dynamische Methode transparent und kann keinen kritischen Code ausführen. Informationen zu Transparenzstufen finden Sie unter [Sicherheits transparenter Code, Ebene 1](~/docs/framework/misc/security-transparent-code-level-1.md) und [Sicherheits transparenter Code, Ebene 2](~/docs/framework/misc/security-transparent-code-level-2.md).  
  
    > [!NOTE]
    >  Das Zuordnen einer dynamischen Methode zu einem Modul in einer vertrauenswürdigen Assembly mit einer vertrauenswürdigen Ebene 1, die Sicherheits agnostisch ist (z. b. System. dll), lässt keine Vertrauenswürdigkeit zu. Wenn der Berechtigungs Satz des Codes, der die dynamische Methode aufruft, den Berechtigungs Satz von System. dll (also voll vertrauenswürdig) nicht enthält, wird <xref:System.Security.SecurityException> ausgelöst, wenn die dynamische Methode aufgerufen wird.  
  
-   Die Transparenz einer dynamischen Methode, die einer teilweise vertrauenswürdigen Assembly zugeordnet ist, hängt davon ab, wie die Assembly geladen wird. Wenn die Assembly mit teilweiser Vertrauenswürdigkeit (z. b. in eine Sandbox-Anwendungsdomäne) geladen wird, ignoriert die Laufzeit die Sicherheits Anmerkungen der Assembly. Die Assembly und alle zugehörigen Typen und Member, einschließlich dynamischer Methoden, werden als transparent behandelt. Die Laufzeit achtet nur dann auf Sicherheits Anmerkungen, wenn die teilweise vertrauenswürdige Assembly mit voller Vertrauenswürdigkeit (z. b. in die Standard Anwendungsdomäne einer Desktop Anwendung) geladen wird. In diesem Fall weist die Runtime der dynamischen Methode die Standard Transparenz für Methoden entsprechend den Anmerkungen der Assembly zu.  
  
 Weitere Informationen zur Reflektionsausgabe und Transparenz finden Sie unter [Sicherheitsprobleme bei der Reflektionsausgabe](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Informationen zur Transparenz finden Sie unter [Sicherheitsänderungen](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die dynamische Methode weist keinen Methodentext auf.</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">Sicherheitsaspekte bei der Reflektionsausgabe</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Sicherheitsüberlegungen für die Reflektion</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Sicherheitsänderungen in der .NET Framework Version 4,0</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">Sicherheits transparenter Code, Ebene 1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">Sicherheitstransparenter Code, Ebene 2</related>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodHandle : RuntimeMethodHandle" Usage="System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Für dynamische Methoden nicht unterstützt.</summary>
        <value>Für dynamische Methoden nicht unterstützt.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Für dynamische Methoden nicht zulässig.</exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodImplementationFlags : System.Reflection.MethodImplAttributes" Usage="System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.DynamicMethod.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Modul ab, dem die dynamische Methode logisch zugeordnet ist.</summary>
        <value>Das <see cref="T:System.Reflection.Module" />, dem die aktuelle dynamische Methode zugeordnet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn beim Erstellen der dynamischen Methode ein Modul angegeben wurde, gibt diese Eigenschaft dieses Modul zurück. Wenn ein Typ beim Erstellen der dynamischen Methode als Besitzer angegeben wurde, gibt diese Eigenschaft das Modul zurück, das diesen Typ enthält.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Reflection.Emit.DynamicMethod.Module%2A>-Eigenschaft einer dynamischen Methode angezeigt. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Reflection.Emit.DynamicMethod>-Klasse bereitgestellt wird.  
  
 [!code-cpp[Reflection.DynamicMethod.All#26](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#26)]
 [!code-csharp[Reflection.DynamicMethod.All#26](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#26)]
 [!code-vb[Reflection.DynamicMethod.All#26](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.DynamicMethod.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen der dynamischen Methode ab.</summary>
        <value>Der einfache Name der Methode.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Es ist nicht notwendig, dynamische Methoden zu benennen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Name einer dynamischen Methode angezeigt. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Reflection.Emit.DynamicMethod>-Klasse bereitgestellt wird.  
  
 [!code-cpp[Reflection.DynamicMethod.All#27](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#27)]
 [!code-csharp[Reflection.DynamicMethod.All#27](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#27)]
 [!code-vb[Reflection.DynamicMethod.All#27](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Klasse ab, die bei der Reflektion zum Abrufen der Methode verwendet wurde.</summary>
        <value>Immer <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt immer `null` für dynamische Methoden zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der reflektierte Typ einer dynamischen Methode angezeigt. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Reflection.Emit.DynamicMethod>-Klasse bereitgestellt wird.  
  
 [!code-cpp[Reflection.DynamicMethod.All#28](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#28)]
 [!code-csharp[Reflection.DynamicMethod.All#28](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#28)]
 [!code-vb[Reflection.DynamicMethod.All#28](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnParameter : System.Reflection.ParameterInfo" Usage="System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Rückgabeparameter der dynamischen Methode ab.</summary>
        <value>Immer <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt immer `null` für dynamische Methoden zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ des Rückgabewerts für die dynamische Methode ab.</summary>
        <value>Ein <see cref="T:System.Type" />, das den Typ des Rückgabewerts der aktuellen Methode darstellt. <see cref="T:System.Void" />, wenn die Methode keinen Rückgabetyp besitzt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `null` für den Rückgabetyp angegeben wurde, als die dynamische Methode erstellt wurde, gibt diese Eigenschaft <xref:System.Void?displayProperty=nameWithType>zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Rückgabetyp einer dynamischen Methode angezeigt. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Reflection.Emit.DynamicMethod>-Klasse bereitgestellt wird.  
  
 [!code-cpp[Reflection.DynamicMethod.All#30](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#30)]
 [!code-csharp[Reflection.DynamicMethod.All#30](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#30)]
 [!code-vb[Reflection.DynamicMethod.All#30](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnTypeCustomAttributes : System.Reflection.ICustomAttributeProvider" Usage="System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die benutzerdefinierten Attribute des Rückgabetyps für die dynamische Methode ab.</summary>
        <value>Ein <see cref="T:System.Reflection.ICustomAttributeProvider" />-Objekt, das die benutzerdefinierten Attribute des Rückgabetyps für die dynamische Methode darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Benutzerdefinierte Attribute werden für den Rückgabetyp einer dynamischen Methode nicht unterstützt, sodass das von der <xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A>-Methode zurückgegebene Array von benutzerdefinierten Attributen immer leer ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die benutzerdefinierten Attribute des Rückgabe Typs einer dynamischen Methode angezeigt werden. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Reflection.Emit.DynamicMethod>-Klasse bereitgestellt wird.  
  
 [!code-cpp[Reflection.DynamicMethod.All#31](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#31)]
 [!code-csharp[Reflection.DynamicMethod.All#31](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#31)]
 [!code-vb[Reflection.DynamicMethod.All#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#31)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dynamicMethod.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Signatur der Methode als Zeichenfolge zurück.</summary>
        <returns>Eine Zeichenfolge, die die Methodensignatur darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Signatur umfasst nur Typen und den Methodennamen, sofern vorhanden. Parameter Namen sind nicht eingeschlossen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Reflection.Emit.DynamicMethod.ToString%2A>-Methode einer dynamischen Methode angezeigt. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Reflection.Emit.DynamicMethod>-Klasse bereitgestellt wird.  
  
 [!code-cpp[Reflection.DynamicMethod.All#32](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#32)]
 [!code-csharp[Reflection.DynamicMethod.All#32](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#32)]
 [!code-vb[Reflection.DynamicMethod.All#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
