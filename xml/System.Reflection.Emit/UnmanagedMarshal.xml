<Type Name="UnmanagedMarshal" FullName="System.Reflection.Emit.UnmanagedMarshal">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="46fc4e13279b8ca823d2162a58c8f9ff13114e65" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30469744" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class UnmanagedMarshal" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit UnmanagedMarshal extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.UnmanagedMarshal" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class UnmanagedMarshal" />
  <TypeSignature Language="C++ CLI" Value="public ref class UnmanagedMarshal sealed" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Obsolete("An alternate API is available: Emit the MarshalAs custom attribute instead.")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt die Klasse dar, die das Marshallen eines Felds von verwaltetem zu nicht verwaltetem Code beschreibt. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Codebeispiel wird veranschaulicht, die problemumgehung für diesen Typ veraltet.  
  
 Marshalling versteht man das Packen und Entpackens Parameter Remoteprozeduraufrufe können daher auftreten. Während des Marshallens kann ein Feld Format konvertiert werden, wenn das Format des verwalteten Typs aus dem Format des entsprechenden nicht verwalteten Typs unterscheidet. Angenommen, Sie möchten möglicherweise Marshallen eine `String` Typ als nicht verwalteter BSTR. Bei einigen Konvertierungen Format werden automatisch von der Laufzeit behandelt. Um das Standardverhalten zu überschreiben, müssen Sie verwenden die `UnmanagedMarshal` Klasse, um die Konvertierung zu definieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, Austausch-Code für die veraltete <xref:System.Reflection.Emit.UnmanagedMarshal> Typ. Das Beispiel gibt eine Assembly mit einem Modul mit dem Namen `EmitMarshalAs.dll`, mit einem Typ mit dem Namen `Sample`. Der Typ verfügt über eine Methode namens `Test`, mit einem Parameter vom Typ <xref:System.String>. Das Codebeispiel bezieht sich die <xref:System.Runtime.InteropServices.MarshalAsAttribute> mit <xref:System.Runtime.InteropServices.UnmanagedType.BStr?displayProperty=nameWithType> an den Parameter.  
  
 Sie können die [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) , prüfen die ausgegebene Assembly und beobachten Sie, dass der Parameter markiert wird `marshal(bstr)`.  
  
 [!code-cpp[UnmanagedMarshalObsolete#1](~/samples/snippets/cpp/VS_Snippets_CLR/UnmanagedMarshalObsolete/cpp/source.cpp#1)]
 [!code-csharp[UnmanagedMarshalObsolete#1](~/samples/snippets/csharp/VS_Snippets_CLR/UnmanagedMarshalObsolete/cs/source.cs#1)]
 [!code-vb[UnmanagedMarshalObsolete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/UnmanagedMarshalObsolete/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Type" />
    <altmember cref="T:System.Runtime.InteropServices.UnmanagedType" />
    <altmember cref="T:System.Guid" />
  </Docs>
  <Members>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.UnmanagedType BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.InteropServices.UnmanagedType BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.UnmanagedMarshal.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseType As UnmanagedType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::InteropServices::UnmanagedType BaseType { System::Runtime::InteropServices::UnmanagedType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.UnmanagedType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen nicht verwalteten Basistyp ab. Diese Eigenschaft ist schreibgeschützt.</summary>
        <value>Ein <see langword="UnmanagedType" />-Objekt.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Bei dem nicht verwalteten Typ handelt es sich um kein <see langword="LPArray" /> oder <see langword="SafeArray" />.</exception>
        <altmember cref="T:System.Runtime.InteropServices.UnmanagedType" />
      </Docs>
    </Member>
    <Member MemberName="DefineByValArray">
      <MemberSignature Language="C#" Value="public static System.Reflection.Emit.UnmanagedMarshal DefineByValArray (int elemCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Emit.UnmanagedMarshal DefineByValArray(int32 elemCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.UnmanagedMarshal.DefineByValArray(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DefineByValArray (elemCount As Integer) As UnmanagedMarshal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Emit::UnmanagedMarshal ^ DefineByValArray(int elemCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.UnmanagedMarshal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elemCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elemCount">Die Anzahl der Elemente im Array fester Länge.</param>
        <summary>Gibt ein Array fester Länge (ByValArray) an, das zu nicht verwaltetem Code gemarshallt werden soll.</summary>
        <returns>Ein <see cref="T:System.Reflection.Emit.UnmanagedMarshal" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `DefineByValArray` Methode ist nicht mit einer einfachen native marshallen.  
  
 Nur nicht verwaltete Marshal-Konstrukte können mithilfe dieser statischen Konstruktoren vorgenommen werden.  
  
 Marshalling ein Array ist ein komplexer Prozess als Marshalling einen ganzzahligen Parameter an. Array-Elemente werden in einer bestimmten Reihenfolge kopiert, damit das Array von die anderen Seite genau rekonstruieren kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Argument ist kein einfacher systemeigener Typ.</exception>
        <altmember cref="T:System.Runtime.InteropServices.UnmanagedType" />
      </Docs>
    </Member>
    <Member MemberName="DefineByValTStr">
      <MemberSignature Language="C#" Value="public static System.Reflection.Emit.UnmanagedMarshal DefineByValTStr (int elemCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Emit.UnmanagedMarshal DefineByValTStr(int32 elemCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.UnmanagedMarshal.DefineByValTStr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DefineByValTStr (elemCount As Integer) As UnmanagedMarshal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Emit::UnmanagedMarshal ^ DefineByValTStr(int elemCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.UnmanagedMarshal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elemCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elemCount">Die Anzahl der Elemente im Puffer für ein feststehendes Array.</param>
        <summary>Gibt eine in einem Puffer für ein feststehendes Array enthaltene Zeichenfolge (ByValTStr) an, das zu nicht verwaltetem Code gemarshallt werden soll.</summary>
        <returns>Ein <see cref="T:System.Reflection.Emit.UnmanagedMarshal" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `DefineByValStr` Methode ist nicht mit einer einfachen native marshallen.  
  
 Nur nicht verwaltete Marshal-Konstrukte können mithilfe dieser statischen Konstruktoren vorgenommen werden.  
  
 Marshalling ein Array ist ein komplexer Prozess als Marshalling einen ganzzahligen Parameter an. Array-Elemente werden in einer bestimmten Reihenfolge kopiert, damit das Array von die anderen Seite genau rekonstruieren kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Argument ist kein einfacher systemeigener Typ.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Runtime.InteropServices.UnmanagedType" />
      </Docs>
    </Member>
    <Member MemberName="DefineLPArray">
      <MemberSignature Language="C#" Value="public static System.Reflection.Emit.UnmanagedMarshal DefineLPArray (System.Runtime.InteropServices.UnmanagedType elemType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Emit.UnmanagedMarshal DefineLPArray(valuetype System.Runtime.InteropServices.UnmanagedType elemType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.UnmanagedMarshal.DefineLPArray(System.Runtime.InteropServices.UnmanagedType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DefineLPArray (elemType As UnmanagedType) As UnmanagedMarshal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Emit::UnmanagedMarshal ^ DefineLPArray(System::Runtime::InteropServices::UnmanagedType elemType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.UnmanagedMarshal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elemType" Type="System.Runtime.InteropServices.UnmanagedType" />
      </Parameters>
      <Docs>
        <param name="elemType">Der nicht verwaltete Typ, zu dem das Array gemarshallt werden soll.</param>
        <summary>Gibt ein <see langword="LPArray" /> an, das zu nicht verwaltetem Code gemarshallt werden soll. Die Länge eines <see langword="LPArray" /> wird zur Laufzeit von der Größe des tatsächlich gemarshallten Arrays bestimmt.</summary>
        <returns>Ein <see cref="T:System.Reflection.Emit.UnmanagedMarshal" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `DefineLPArray` Methode ist nicht mit einer einfachen native marshallen.  
  
 Nur nicht verwaltete Marshal-Konstrukte können mithilfe dieser statischen Konstruktoren vorgenommen werden.  
  
 Marshalling ein Array ist ein komplexer Prozess als Marshalling einen ganzzahligen Parameter an. Array-Elemente werden in einer bestimmten Reihenfolge kopiert, damit das Array von die anderen Seite genau rekonstruieren kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Argument ist kein einfacher systemeigener Typ.</exception>
        <altmember cref="T:System.Runtime.InteropServices.UnmanagedType" />
      </Docs>
    </Member>
    <Member MemberName="DefineSafeArray">
      <MemberSignature Language="C#" Value="public static System.Reflection.Emit.UnmanagedMarshal DefineSafeArray (System.Runtime.InteropServices.UnmanagedType elemType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Emit.UnmanagedMarshal DefineSafeArray(valuetype System.Runtime.InteropServices.UnmanagedType elemType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.UnmanagedMarshal.DefineSafeArray(System.Runtime.InteropServices.UnmanagedType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DefineSafeArray (elemType As UnmanagedType) As UnmanagedMarshal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Emit::UnmanagedMarshal ^ DefineSafeArray(System::Runtime::InteropServices::UnmanagedType elemType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.UnmanagedMarshal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elemType" Type="System.Runtime.InteropServices.UnmanagedType" />
      </Parameters>
      <Docs>
        <param name="elemType">Der Basistyp oder der <see langword="UnmanagedType" /> der einzelnen Elemente des Arrays.</param>
        <summary>Gibt ein <see langword="SafeArray" /> an, das zu nicht verwaltetem Code gemarshallt werden soll.</summary>
        <returns>Ein <see cref="T:System.Reflection.Emit.UnmanagedMarshal" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `DefineSafeArray` Methode ist nicht mit einer einfachen native marshallen.  
  
 Nur nicht verwaltete Marshal-Konstrukte können mithilfe dieser statischen Konstruktoren vorgenommen werden.  
  
 Marshalling ein Array ist ein komplexer Prozess als Marshalling einen ganzzahligen Parameter an. Array-Elemente werden in einer bestimmten Reihenfolge kopiert, damit das Array von die anderen Seite genau rekonstruieren kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Argument ist kein einfacher systemeigener Typ.</exception>
        <altmember cref="T:System.Runtime.InteropServices.UnmanagedType" />
      </Docs>
    </Member>
    <Member MemberName="DefineUnmanagedMarshal">
      <MemberSignature Language="C#" Value="public static System.Reflection.Emit.UnmanagedMarshal DefineUnmanagedMarshal (System.Runtime.InteropServices.UnmanagedType unmanagedType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Emit.UnmanagedMarshal DefineUnmanagedMarshal(valuetype System.Runtime.InteropServices.UnmanagedType unmanagedType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.UnmanagedMarshal.DefineUnmanagedMarshal(System.Runtime.InteropServices.UnmanagedType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Emit::UnmanagedMarshal ^ DefineUnmanagedMarshal(System::Runtime::InteropServices::UnmanagedType unmanagedType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.UnmanagedMarshal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unmanagedType" Type="System.Runtime.InteropServices.UnmanagedType" />
      </Parameters>
      <Docs>
        <param name="unmanagedType">Der nicht verwaltete Typ, zu dem der Typ gemarshallt werden soll.</param>
        <summary>Gibt einen angegebenen Typ an, der zu nicht verwaltetem Code gemarshallt werden soll.</summary>
        <returns>Ein <see cref="T:System.Reflection.Emit.UnmanagedMarshal" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.InteropServices.UnmanagedType> übergeben an diese Methode muss ein einfacher systemeigener Typ sein. Dürfen keines der folgenden Werte verwendet werden: <xref:System.Runtime.InteropServices.UnmanagedType.ByValTStr?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.UnmanagedType.SafeArray?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.UnmanagedType.ByValArray?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.UnmanagedType.LPArray?displayProperty=nameWithType>, oder <xref:System.Runtime.InteropServices.UnmanagedType.CustomMarshaler?displayProperty=nameWithType>.  
  
 Nur nicht verwaltete Marshal-Konstrukte können mit dieser Methode vorgenommen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Argument ist kein einfacher systemeigener Typ.</exception>
        <altmember cref="T:System.Runtime.InteropServices.UnmanagedType" />
      </Docs>
    </Member>
    <Member MemberName="ElementCount">
      <MemberSignature Language="C#" Value="public int ElementCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ElementCount" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.UnmanagedMarshal.ElementCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ElementCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ElementCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Zahlenelement ab. Diese Eigenschaft ist schreibgeschützt.</summary>
        <value>Eine ganze Zahl, die die Elementanzahl angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es ist ein `ElementCount` nur dann, wenn eine `NativeTypeFixedArray`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Argument ist keine nicht verwaltete Elementanzahl.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetUnmanagedType">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.UnmanagedType GetUnmanagedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.InteropServices.UnmanagedType GetUnmanagedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.UnmanagedMarshal.GetUnmanagedType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GetUnmanagedType As UnmanagedType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::InteropServices::UnmanagedType GetUnmanagedType { System::Runtime::InteropServices::UnmanagedType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.UnmanagedType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt einen nicht verwalteten Typ an. Diese Eigenschaft ist schreibgeschützt.</summary>
        <value>Ein <see cref="T:System.Runtime.InteropServices.UnmanagedType" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `GetUnmanagedType` Eigenschaft ist eine Accessorfunktion für den systemeigenen Typ.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.UnmanagedType" />
      </Docs>
    </Member>
    <Member MemberName="IIDGuid">
      <MemberSignature Language="C#" Value="public Guid IIDGuid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid IIDGuid" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.UnmanagedMarshal.IIDGuid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IIDGuid As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid IIDGuid { Guid get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine GUID ab. Diese Eigenschaft ist schreibgeschützt.</summary>
        <value>Ein <see cref="T:System.Guid" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt immer "GUID.Empty" zurück. Diese Eigenschaft kann in einer zukünftigen Version entfernt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Argument ist kein benutzerdefinierter Marshaller.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
  </Members>
</Type>