<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ModuleBuilder.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5cd62ca0fc3883c3b58b0d81ab5d8f47e85cb31d6.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cd62ca0fc3883c3b58b0d81ab5d8f47e85cb31d6</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Defines and represents a module in a dynamic assembly.</source>
          <target state="translated">Definiert eine stellt ein Modul in einer dynamischen Assembly dar.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>To get an instance of <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Zum Abrufen einer Instanz des <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>, verwenden Sie die <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>The following code sample demonstrates the use of <ph id="ph1">`ModuleBuilder`</ph> to create a dynamic module.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung von <ph id="ph1">`ModuleBuilder`</ph> um ein dynamisches Modul zu erstellen.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Note that the ModuleBuilder is created by calling <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph> in <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph>, rather than through a constructor.</source>
          <target state="translated">Beachten Sie, dass der ModuleBuilder, durch den Aufruf erstellt wird <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph> in <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph>, anstatt über einen Konstruktor.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ModuleBuilder.Assembly">
          <source>Gets the dynamic assembly that defined this instance of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph>.</source>
          <target state="translated">Ruft die dynamische Assembly ab, die diese Instanz von <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph> definiert hat.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.Assembly">
          <source>The dynamic assembly that defined the current dynamic module.</source>
          <target state="translated">Die dynamische Assembly, die das aktuelle dynamische Modul definiert hat.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.Assembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> object that is returned is the <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> that defined this instance of <ph id="ph3">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> Objekt, das zurückgegeben wird, ist die <ph id="ph2">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> , die diese Instanz definiert <ph id="ph3">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
          <source>Completes the global function definitions and global data definitions for this dynamic module.</source>
          <target state="translated">Vervollständigt die globalen Funktions- und Datendefinitionen für dieses dynamische Modul.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
          <source>This method should be called when the user is done with defining all the global functions within this dynamic module.</source>
          <target state="translated">Diese Methode sollte aufgerufen werden, wenn der Benutzer die globalen Funktionen innerhalb dieses dynamische Modul definieren.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
          <source>After calling this function, no more new global functions or new global data are allowed.</source>
          <target state="translated">Nach dem Aufrufen dieser Funktion werden keine weiteren neuen globalen Funktionen oder neuen globalen Daten zulässig.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
          <source>The following sample illustrates the use of <ph id="ph1">`CreateGlobalFunctions`</ph> to create a static global method from a <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> implemented with <ph id="ph3">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A&gt;</ph>.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung von <ph id="ph1">`CreateGlobalFunctions`</ph> zum Erstellen einer globalen statischen Methode aus einer <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> mit implementiert <ph id="ph3">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions">
          <source>This method was called previously.</source>
          <target state="translated">Diese Methode wurde bereits aufgerufen.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>The URL for the document.</source>
          <target state="translated">Die URL für das Dokument.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>The GUID that identifies the document language.</source>
          <target state="translated">Die GUID, die die Dokumentsprache kennzeichnet.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>This can be <ph id="ph1">&lt;see cref="F:System.Guid.Empty" /&gt;</ph>.</source>
          <target state="translated">Dieser Wert kann <ph id="ph1">&lt;see cref="F:System.Guid.Empty" /&gt;</ph> sein.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>The GUID that identifies the document language vendor.</source>
          <target state="translated">Die GUID, die den Anbieter der Dokumentsprache kennzeichnet.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>This can be <ph id="ph1">&lt;see cref="F:System.Guid.Empty" /&gt;</ph>.</source>
          <target state="translated">Dieser Wert kann <ph id="ph1">&lt;see cref="F:System.Guid.Empty" /&gt;</ph> sein.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>The GUID that identifies the document type.</source>
          <target state="translated">Die GUID, die den Dokumenttyp kennzeichnet.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>This can be <ph id="ph1">&lt;see cref="F:System.Guid.Empty" /&gt;</ph>.</source>
          <target state="translated">Dieser Wert kann <ph id="ph1">&lt;see cref="F:System.Guid.Empty" /&gt;</ph> sein.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>Defines a document for source.</source>
          <target state="translated">Definiert ein Dokument als Quelle.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>The defined document.</source>
          <target state="translated">Das definierte Dokument.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>Earlier versions of the .NET Framework throw <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> instead of <ph id="ph2">&lt;xref:System.ArgumentNullException&gt;</ph> when <ph id="ph3">`url`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Frühere Versionen von .NET Framework lösen <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> anstelle von <ph id="ph2">&lt;xref:System.ArgumentNullException&gt;</ph> Wenn <ph id="ph3">`url`</ph> ist <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>The following code sample illustrates the use of <ph id="ph1">`DefineDocument`</ph> to attach an external symbol document (in this case, a raw IL file) to a dynamic module.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung von <ph id="ph1">`DefineDocument`</ph> ein dynamisches Modul ein externes Symbol-Dokument (in diesem Fall eine unformatierte IL-Datei) an.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source><ph id="ph1">&lt;paramref name="url" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="url" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>This is a change from earlier versions of the .NET Framework.</source>
          <target state="translated">Dies ist eine Änderung gegenüber früheren Versionen von .NET Framework.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)">
          <source>This method is called on a dynamic module that is not a debug module.</source>
          <target state="translated">Diese Methode wird für ein dynamisches Modul aufgerufen, das kein Debug-Modul ist.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The full path of the enumeration type.</source>
          <target state="translated">Der vollständige Pfad des Enumerationstyps.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The type attributes for the enumeration.</source>
          <target state="translated">Die Typattribute für die Enumeration.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The attributes are any bits defined by <ph id="ph1">&lt;see cref="F:System.Reflection.TypeAttributes.VisibilityMask" /&gt;</ph>.</source>
          <target state="translated">Die Attribute sind beliebige, durch <ph id="ph1">&lt;see cref="F:System.Reflection.TypeAttributes.VisibilityMask" /&gt;</ph> definierte Bits.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The underlying type for the enumeration.</source>
          <target state="translated">Der zugrunde liegende Typ für die Enumeration.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This must be a built-in integer type.</source>
          <target state="translated">Dabei muss es sich um einen integrierten ganzzahligen Typ handeln.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Defines an enumeration type that is a value type with a single non-static field called <ph id="ph1">&lt;paramref name="value__" /&gt;</ph> of the specified type.</source>
          <target state="translated">Definiert einen Enumerationstyp, der ein Werttyp mit dem einzelnen, nicht statischen Feld <ph id="ph1">&lt;paramref name="value__" /&gt;</ph> des angegebenen Typs ist.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The defined enumeration.</source>
          <target state="translated">Die definierte Enumeration.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The defined enum is a derived class of <ph id="ph1">&lt;xref:System.Enum&gt;</ph>.</source>
          <target state="translated">Die definierte Enumeration ist eine abgeleitete Klasse von <ph id="ph1">&lt;xref:System.Enum&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The <ph id="ph1">`value__`</ph> field has <ph id="ph2">&lt;xref:System.Reflection.FieldAttributes.Private&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.FieldAttributes.SpecialName&gt;</ph> attributes set.</source>
          <target state="translated">Die <ph id="ph1">`value__`</ph> Feld <ph id="ph2">&lt;xref:System.Reflection.FieldAttributes.Private&gt;</ph> und <ph id="ph3">&lt;xref:System.Reflection.FieldAttributes.SpecialName&gt;</ph> Attribute festgelegt.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>For more information about the built-in integer types that can be specified as the underlying types of enumerations, see <bpt id="p1">[</bpt>Class Library Overview<ept id="p1">](~/docs/standard/class-library-overview.md)</ept>.</source>
          <target state="translated">Weitere Informationen zu den integrierten ganzzahligen Typen, die als zugrunde liegende Typen von Enumerationen angegeben werden können, finden Sie unter <bpt id="p1">[</bpt>Class Library Overview<ept id="p1">](~/docs/standard/class-library-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>In the .NET Framework versions 1.0 and 1.1, it is necessary to define enumerations using <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> because <ph id="ph2">&lt;xref:System.Reflection.Emit.EnumBuilder&gt;</ph> emits enumerations whose elements are of type <ph id="ph3">&lt;xref:System.Int32&gt;</ph> instead of the enumeration type.</source>
          <target state="translated">In der .NET Framework-Versionen 1.0 und 1.1, ist es erforderlich, Enumerationen, die mit definieren <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> da <ph id="ph2">&lt;xref:System.Reflection.Emit.EnumBuilder&gt;</ph> ausgibt, deren Elemente vom Typ sind, Enumerationen <ph id="ph3">&lt;xref:System.Int32&gt;</ph> anstelle des Enumerationstyps.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>In the .NET Framework version 2.0, <ph id="ph1">&lt;xref:System.Reflection.Emit.EnumBuilder&gt;</ph> emits enumerations whose elements have the correct type.</source>
          <target state="translated">In .NET Framework, Version 2.0 <ph id="ph1">&lt;xref:System.Reflection.Emit.EnumBuilder&gt;</ph> ausgibt, Enumerationen, deren Elemente über den richtigen Typ.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The following example illustrates the use of <ph id="ph1">`DefineEnum`</ph> to implement an enumeration class in a dynamic module.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung von <ph id="ph1">`DefineEnum`</ph> eine Enumerationsklasse in einem dynamischen Modul implementiert.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The example defines an enumeration named <ph id="ph1">`Elevation`</ph> that has an underlying type of <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, and creates two elements: <ph id="ph3">`Low`</ph>, with a value of 0, and <ph id="ph4">`High`</ph>, with a value of 1.</source>
          <target state="translated">Im Beispiel definiert eine Enumeration, die mit dem Namen <ph id="ph1">`Elevation`</ph> , besitzt einen zugrunde liegenden Typ <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, und erstellt zwei Elemente: <ph id="ph3">`Low`</ph>, mit dem Wert 0 (null) und <ph id="ph4">`High`</ph>, mit dem Wert 1.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>After the type has been created, the assembly is saved with the name <ph id="ph1">`TempAssembly.dll`</ph>.</source>
          <target state="translated">Nachdem der Typ erstellt wurde, wird die Assembly gespeichert, mit dem Namen <ph id="ph1">`TempAssembly.dll`</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the contents of this assembly.</source>
          <target state="translated">Sie können die <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> untersuchen den Inhalt dieser Assembly.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Prior to the .NET Framework version 2.0, this code example does not produce a correct enumeration.</source>
          <target state="translated">Vor .NET Framework, Version 2.0 wird in diesem Codebeispiel wird eine ordnungsgemäße Enumeration kein erzeugt.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Attributes other than visibility attributes are provided.</source>
          <target state="translated">Außer Sichtbarkeitsattributen werden andere Attribute bereitgestellt.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>An enumeration with the given name exists in the parent assembly of this module.</source>
          <target state="translated">Eine Enumeration mit dem angegebenen Namen ist in der übergeordneten Assembly dieses Moduls vorhanden.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The visibility attributes do not match the scope of the enumeration.</source>
          <target state="translated">Die Sichtbarkeitsattribute entsprechen nicht dem Bereich der Enumeration.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>For example, <ph id="ph1">&lt;see cref="F:System.Reflection.TypeAttributes.NestedPublic" /&gt;</ph> is specified for <ph id="ph2">&lt;paramref name="visibility" /&gt;</ph>, but the enumeration is not a nested type.</source>
          <target state="translated">Beispielsweise ist <ph id="ph1">&lt;see cref="F:System.Reflection.TypeAttributes.NestedPublic" /&gt;</ph> für <ph id="ph2">&lt;paramref name="visibility" /&gt;</ph> angegeben, die Enumeration ist jedoch kein geschachtelter Typ.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Defines a global method.</source>
          <target state="translated">Definiert eine globale Methode.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The name of the method.</source>
          <target state="translated">Der Name der Methode.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The attributes of the method.</source>
          <target state="translated">Die Attribute der Methode.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>attributes<ept id="p1">&lt;/c&gt;</ept> must include <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>attributes<ept id="p1">&lt;/c&gt;</ept> muss <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph> enthalten.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The return type of the method.</source>
          <target state="translated">Der Rückgabetyp der Methode</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The types of the method's parameters.</source>
          <target state="translated">Die Typen der Parameter der Methode.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>Defines a global method with the specified name, attributes, return type, and parameter types.</source>
          <target state="translated">Definiert eine globale Methode mit den Angaben für Name, Attribute, Rückgabetyp und Parametertypen.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The defined global method.</source>
          <target state="translated">Die definierte globale Methode.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The global method that this method defines is not usable until you call <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph>.</source>
          <target state="translated">Die globale Methode, die diese Methode definiert wird, kann erst Sie rufen <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The following example illustrates the use of <ph id="ph1">`DefineGlobalMethod`</ph> to create a type-independent method tied to the current <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung von <ph id="ph1">`DefineGlobalMethod`</ph> zum Erstellen einer typunabhängig-Methode, die mit dem aktuellen gebunden <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>After building the global method, <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> must be called in order to complete it.</source>
          <target state="translated">Nach dem Erstellen der globalen Methode <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> muss aufgerufen werden, um sie abzuschließen.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The method is not static.</source>
          <target state="translated">Die Methode ist nicht statisch.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>That is, <ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> does not include <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated">Das heißt, <ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> enthält nicht <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist 0.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>An element in the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Element im <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Array ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> has been previously called.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> wurde bereits zuvor aufgerufen.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The name of the method.</source>
          <target state="translated">Der Name der Methode.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The attributes of the method.</source>
          <target state="translated">Die Attribute der Methode.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>attributes<ept id="p1">&lt;/c&gt;</ept> must include <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>attributes<ept id="p1">&lt;/c&gt;</ept> muss <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph> enthalten.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The calling convention for the method.</source>
          <target state="translated">Die Aufrufkonvention für die Methode.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The return type of the method.</source>
          <target state="translated">Der Rückgabetyp der Methode</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The types of the method's parameters.</source>
          <target state="translated">Die Typen der Parameter der Methode.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>Defines a global method with the specified name, attributes, calling convention, return type, and parameter types.</source>
          <target state="translated">Definiert eine globale Methode mit den Angaben für Name, Attribute, Aufrufkonvention, Rückgabetyp und Parametertypen.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The defined global method.</source>
          <target state="translated">Die definierte globale Methode.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>You cannot use the global method that this method defines until you call <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph>.</source>
          <target state="translated">Sie können keine globale Methode, die diese Methode definiert wird, bis Sie rufen <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The following code sample illustrates the use of <ph id="ph1">`DefineGlobalMethod`</ph> to create a type-independent method tied to the current <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung von <ph id="ph1">`DefineGlobalMethod`</ph> zum Erstellen einer typunabhängig-Methode, die mit dem aktuellen gebunden <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>After building the global method, <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> must be called in order to complete it.</source>
          <target state="translated">Nach dem Erstellen der globalen Methode <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> muss aufgerufen werden, um sie abzuschließen.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The method is not static.</source>
          <target state="translated">Die Methode ist nicht statisch.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>That is, <ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> does not include <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated">Das heißt, <ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> enthält nicht <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>An element in the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Element im <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Array ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> has been previously called.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> wurde bereits zuvor aufgerufen.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The name of the method.</source>
          <target state="translated">Der Name der Methode.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded null characters.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Zeichen enthalten.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The attributes of the method.</source>
          <target state="translated">Die Attribute der Methode.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><bpt id="p1">&lt;c&gt;</bpt>attributes<ept id="p1">&lt;/c&gt;</ept> must include <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>attributes<ept id="p1">&lt;/c&gt;</ept> muss <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph> enthalten.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The calling convention for the method.</source>
          <target state="translated">Die Aufrufkonvention für die Methode.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The return type of the method.</source>
          <target state="translated">Der Rückgabetyp der Methode</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the required custom modifiers for the return type, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Runtime.CompilerServices.IsBoxed" /&gt;</ph>.</source>
          <target state="translated">Ein Array von Typen, die die erforderlichen benutzerdefinierten Modifizierer für den Rückgabetyp darstellen, z. B. <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> oder <ph id="ph2">&lt;see cref="T:System.Runtime.CompilerServices.IsBoxed" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Wenn der Rückgabetyp keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the optional custom modifiers for the return type, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Runtime.CompilerServices.IsBoxed" /&gt;</ph>.</source>
          <target state="translated">Ein Array von Typen, die die optionalen benutzerdefinierten Modifizierer für den Rückgabetyp darstellen, z. B. <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> oder <ph id="ph2">&lt;see cref="T:System.Runtime.CompilerServices.IsBoxed" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Wenn der Rückgabetyp keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The types of the method's parameters.</source>
          <target state="translated">Die Typen der Parameter der Methode.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Ein Array mit Arrays von Typen.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter of the global method.</source>
          <target state="translated">Jedes Array von Typen stellt die erforderlichen benutzerdefinierten Modifizierer für den entsprechenden Parameter der globalen Methode dar.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular argument has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Wenn ein bestimmtes Argument über keine erforderlichen benutzerdefinierten Modifizierer verfügt, geben Sie anstelle eines Arrays von Typen <ph id="ph1">&lt;see langword="null" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the global method has no arguments, or if none of the arguments have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Wenn die globale Methode über keine Argumente oder keines der Argumente über erforderliche benutzerdefinierte Modifizierer verfügt, geben Sie anstelle eines Arrays von Arrays <ph id="ph1">&lt;see langword="null" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Ein Array mit Arrays von Typen.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter.</source>
          <target state="translated">Jedes Array von Typen stellt die optionalen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular argument has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Wenn ein bestimmtes Argument über keine optionalen benutzerdefinierten Modifizierer verfügt, geben Sie anstelle eines Arrays von Typen <ph id="ph1">&lt;see langword="null" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the global method has no arguments, or if none of the arguments have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Wenn die globale Methode über keine Argumente oder keines der Argumente über optionale benutzerdefinierte Modifizierer verfügt, geben Sie anstelle eines Arrays von Arrays <ph id="ph1">&lt;see langword="null" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Defines a global method with the specified name, attributes, calling convention, return type, custom modifiers for the return type, parameter types, and custom modifiers for the parameter types.</source>
          <target state="translated">Definiert eine globale Methode mit den Angaben für Name, Attribute, Aufrufkonvention, Rückgabetyp, benutzerdefinierte Modifizierer für den Rückgabetyp, Parametertypen und benutzerdefinierte Modifizierer für die Parametertypen.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The defined global method.</source>
          <target state="translated">Die definierte globale Methode.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>This overload is provided for designers of managed compilers.</source>
          <target state="translated">Diese Überladung wird für Designer von verwalteten Compilern bereitgestellt.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>You cannot use the global method that this method defines until you call <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph>.</source>
          <target state="translated">Sie können keine globale Methode, die diese Methode definiert wird, bis Sie rufen <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The method is not static.</source>
          <target state="translated">Die Methode ist nicht statisch.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>That is, <ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> does not include <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</source>
          <target state="translated">Das heißt, <ph id="ph1">&lt;paramref name="attributes" /&gt;</ph> enthält nicht <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An element in the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Element im <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Array ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> method has been previously called.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph>-Methode wurde zuvor aufgerufen.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The name used to refer to the data.</source>
          <target state="translated">Der Name, der zum Verweisen auf die Daten verwendet wird.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The binary large object (BLOB) of data.</source>
          <target state="translated">Das BLOB (Binary Large Object) der Daten.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The attributes for the field.</source>
          <target state="translated">Die Attribute für das Feld.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The default is <ph id="ph1">&lt;see langword="Static" /&gt;</ph>.</source>
          <target state="translated">Der Standardwert ist <ph id="ph1">&lt;see langword="Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>Defines an initialized data field in the .sdata section of the portable executable (PE) file.</source>
          <target state="translated">Definiert ein initialisiertes Datenfeld im .sdata-Abschnitt der übertragbaren ausführbaren Datei (Portable Executable, PE).</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>A field to reference the data.</source>
          <target state="translated">Ein Feld zum Verweisen auf die Daten.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.Static&gt;</ph> is automatically included in <ph id="ph2">`attributes`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.Static&gt;</ph> automatisch <ph id="ph2">`attributes`</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The data defined by this method is not created until the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> method is called.</source>
          <target state="translated">Die von dieser Methode definierten Daten werden erst erstellt, wenn die <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> -Methode aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A&gt;</ph> method to define an initialized data field in the <ph id="ph2">`.sdata`</ph> section of the portable executable (PE) file.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A&gt;</ph> Methode, um eine initialisierte Datenfeld im Definieren der <ph id="ph2">`.sdata`</ph> -Abschnitts der Datei (portable Executable)-Datei.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The size of <ph id="ph1">&lt;paramref name="data" /&gt;</ph> is less than or equal to zero or greater than or equal to 0x3f0000.</source>
          <target state="translated">Die Größe von <ph id="ph1">&lt;paramref name="data" /&gt;</ph> ist kleiner oder gleich 0 bzw. größer oder gleich 0x3f0000.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="data" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="data" /&gt;</ph> ist <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> has been previously called.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> wurde bereits zuvor aufgerufen.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>The case-sensitive name for the resource.</source>
          <target state="translated">Der Name der Ressource unter Berücksichtigung der Groß- und Kleinschreibung.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>A stream that contains the bytes for the resource.</source>
          <target state="translated">Ein Stream, der die Bytes für die Ressource enthält.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>An enumeration value that specifies whether the resource is public or private.</source>
          <target state="translated">Ein Enumerationswert, der angibt, ob die Ressource öffentlich oder privat ist.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>Defines a binary large object (BLOB) that represents a manifest resource to be embedded in the dynamic assembly.</source>
          <target state="translated">Definiert ein BLOB (Binary Large Object), das eine Manifestressource darstellt, die in die dynamische Assembly eingebettet werden soll.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>Resources that are recorded in the assembly manifest can be managed resources or manifest resource BLOBs, and each of these can be included in the assembly either by linking or by embedding.</source>
          <target state="translated">Ressourcen, die im Assemblymanifest aufgezeichnet werden, werden die verwalteten Ressourcen oder Manifestressourcen-BLOBs können, und jedes dieser kann in der Assembly enthalten sein, indem Sie eine Verknüpfung oder durch das Einbetten von.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>All four scenarios are supported for dynamic assemblies.</source>
          <target state="translated">Für dynamische Assemblys werden alle vier Szenarien unterstützt.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>This method allows you to embed a manifest resource BLOB into a dynamic assembly.</source>
          <target state="translated">Diese Methode ermöglicht Ihnen, eine Manifestressource BLOB mit einer dynamischen Assembly einzubetten.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>To embed a managed resource into the manifest module of a dynamic assembly or into a satellite module, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineResource%2A?displayProperty=nameWithType&gt;</ph> method to get a resource writer, and use the <ph id="ph2">&lt;xref:System.Resources.ResourceWriter.AddResource%2A?displayProperty=nameWithType&gt;</ph> method to add the resource.</source>
          <target state="translated">Zum Einbetten einer verwalteten Ressource in das Manifestmodul einer dynamischen Assembly oder in einer Satellitenmodul verwenden die <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineResource%2A?displayProperty=nameWithType&gt;</ph> Methode zum Abrufen einer Ressourcenwriters und zum Verwenden der <ph id="ph2">&lt;xref:System.Resources.ResourceWriter.AddResource%2A?displayProperty=nameWithType&gt;</ph> Methode, um die Ressource hinzuzufügen.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>To link a managed resource into a dynamic assembly, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A?displayProperty=nameWithType&gt;</ph> method to get a resource writer, and use the <ph id="ph2">&lt;xref:System.Resources.ResourceWriter.AddResource%2A?displayProperty=nameWithType&gt;</ph> method to add the linked resource.</source>
          <target state="translated">Um eine verwaltete Ressource in eine dynamische Assembly zu verknüpfen, verwenden die <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A?displayProperty=nameWithType&gt;</ph> Methode zum Abrufen einer Ressourcenwriters und zum Verwenden der <ph id="ph2">&lt;xref:System.Resources.ResourceWriter.AddResource%2A?displayProperty=nameWithType&gt;</ph> Methode, um die verknüpfte Ressource hinzuzufügen.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>To link a manifest resource BLOB into a dynamic assembly, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A?displayProperty=nameWithType&gt;</ph> method to add the linked resource.</source>
          <target state="translated">Um einer Manifestressource BLOB mit einer dynamischen Assembly zu verknüpfen, verwenden die <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A?displayProperty=nameWithType&gt;</ph> Methode, um die verknüpfte Ressource hinzuzufügen.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>In addition, a single Win32 resource can be attached to an assembly by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A?displayProperty=nameWithType&gt;</ph> method or the <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Darüber hinaus kann eine einzelne Win32-Ressource an eine Assembly angefügt werden, mithilfe der <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A?displayProperty=nameWithType&gt;</ph> Methode oder die <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>This resource does not appear in the assembly manifest.</source>
          <target state="translated">Diese Ressource wird im Assemblymanifest nicht angezeigt.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>The following example generates and saves a dynamic assembly named <ph id="ph1">`EmittedManifestResourceAssembly.exe`</ph>, which contains an embedded unmanaged resource.</source>
          <target state="translated">Im folgende Beispiel wird generiert und speichert eine dynamische Assembly mit dem Namen <ph id="ph1">`EmittedManifestResourceAssembly.exe`</ph>, die ein eingebettetes enthält nicht verwaltete Ressource.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>The example creates the assembly, which consists of one module, and opens a memory stream to contain the unmanaged resource.</source>
          <target state="translated">Das Beispiel erstellt die Assembly, die aus einem Modul besteht, und öffnet einen arbeitsspeicherdatenstrom, die nicht verwaltete Ressource enthalten.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>The code then calls the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> method to define the resource.</source>
          <target state="translated">Der Code ruft dann die <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> Methode, um die Ressource zu definieren.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>You can use any kind of stream for your resource; for example, you can read the unmanaged binary data from a file.</source>
          <target state="translated">Sie können eine beliebige Art von Datenstrom für die Ressource verwenden. Beispielsweise können Sie die nicht verwalteten Binärdaten aus einer Datei lesen.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>The example defines a type in the dynamic module with a <ph id="ph1">`Main`</ph> method, and generates MSIL for the method body.</source>
          <target state="translated">Im Beispiel wird einen Typ definiert, in das dynamische Modul mit einer <ph id="ph1">`Main`</ph> -Methode, und die MSIL für den Methodentext generiert.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>After the body for the <ph id="ph1">`Main`</ph> method has been generated and the type has been created, the code example writes five bytes to the stream associated with the manifest resource.</source>
          <target state="translated">Nach dem Text für die <ph id="ph1">`Main`</ph> Methode generiert wurde, und der Typ erstellt wurde, schreibt das Codebeispiel 5 Bytes in den Stream, der die Manifestressource zugeordnet.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>When the assembly is saved, the resource is appended to it.</source>
          <target state="translated">Wenn die Assembly gespeichert wird, wird die Ressource an sie angefügt.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>After running the example, you can run the emitted assembly.</source>
          <target state="translated">Nach dem Ausführen des Beispiels können Sie die ausgegebene Assembly ausführen.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>The code in the emitted assembly's <ph id="ph1">`Main`</ph> method reads the embedded manifest resource and prints the byte values to the console.</source>
          <target state="translated">Der Code in der ausgegebenen Assembly <ph id="ph1">`Main`</ph> Methode liest die eingebettete Manifestressource und gibt die Bytewerte in die Konsole.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to view the information in the assembly manifest.</source>
          <target state="translated">Sie können die <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> die Informationen im Assemblymanifest anzeigen.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is a zero-length string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist eine Zeichenfolge mit der Länge 0 (null).</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)">
          <source>The dynamic assembly that contains the current module is transient; that is, no file name was specified when <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)" /&gt;</ph> was called.</source>
          <target state="translated">Die dynamische Assembly, die das aktuelle Modul enthält, ist flüchtig. Das heißt, dass beim Aufruf von <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)" /&gt;</ph> kein Dateiname angegeben wurde.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Definiert eine <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>-Methode.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Der Name der <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>-Methode.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the DLL in which the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method is defined.</source>
          <target state="translated">Der Name der DLL, in der die <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>-Methode definiert ist.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The attributes of the method.</source>
          <target state="translated">Die Attribute der Methode.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's calling convention.</source>
          <target state="translated">Die Aufrufkonvention der Methode.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's return type.</source>
          <target state="translated">Der Rückgabetyp der Methode.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The types of the method's parameters.</source>
          <target state="translated">Die Typen der Parameter der Methode.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The native calling convention.</source>
          <target state="translated">Die systemeigene Aufrufkonvention.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's native character set.</source>
          <target state="translated">Der systemeigene Zeichensatz der Methode.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method with the specified name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> flags.</source>
          <target state="translated">Definiert eine <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>-Methode mit den Angaben für den Namen, den Namen der DLL, in der die Methode definiert ist, für die Attribute der Methode, die Aufrufkonvention der Methode, den Rückgabetyp der Methode, die Parametertypen der Methode und die <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph>-Flags.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The defined <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Die definierte <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>-Methode.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Some DLL import attributes (see the description of System.Runtime.InteropServices.DllImportAttribute) cannot be specified as arguments to this method.</source>
          <target state="translated">Einige DLL-Importattribute können nicht (siehe die Beschreibung des System.Runtime.InteropServices.DllImportAttribute) als Argumente für diese Methode angegeben werden.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Such attributes should be set by emitting a custom attribute for the method.</source>
          <target state="translated">Solche Attribute sollte festgelegt werden, durch das ein benutzerdefiniertes Attribut für die Methode ausgeben.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For example, the DLL import attribute <ph id="ph1">`PreserveSig`</ph> is set by emitting a custom attribute.</source>
          <target state="translated">Z. B. import die DLL-Attribut <ph id="ph1">`PreserveSig`</ph> wird durch das Ausgeben eines benutzerdefinierten Attributs festgelegt.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The following example illustrates the use of the <ph id="ph1">`DefinePInvokeMethod`</ph> method to create a <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> for an external unmanaged method, <ph id="ph3">`MessageBoxA`</ph>, in the Win32 API.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung von der <ph id="ph1">`DefinePInvokeMethod`</ph> Methode zum Erstellen einer <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> für externe nicht verwaltete Methode <ph id="ph3">`MessageBoxA`</ph>, in der Win32-API.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example displays a message box with <bpt id="p1">**</bpt>Retry<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Cancel<ept id="p2">**</ept> buttons, and displays the return value from the message box.</source>
          <target state="translated">Das Beispiel zeigt ein Meldungsfeld mit <bpt id="p1">**</bpt>wiederholen<ept id="p1">**</ept> und <bpt id="p2">**</bpt>"Abbrechen"<ept id="p2">**</ept> Schaltflächen und der Rückgabewert aus dem Meldungsfeld angezeigt.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>To get a non-zero return value, you must add <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> to the method implementation flags after you create the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, by using the <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Um einen Rückgabewert ungleich 0 (null) zu erhalten, müssen Sie hinzufügen <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> die Methodenimplementierungsflags nach der Erstellung der <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, mithilfe der <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is not static or if the containing type is an interface.</source>
          <target state="translated">Die Methode ist nicht statisch, wenn der enthaltende Typ eine Schnittstelle ist.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is abstract.</source>
          <target state="translated">Die Methode ist abstrakt.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method was previously defined.</source>
          <target state="translated">Die Methode wurde bereits definiert.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> ist <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The containing type has been previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph></source>
          <target state="translated">Der enthaltende Typ wurde bereits mit <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Der Name der <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>-Methode.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the DLL in which the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method is defined.</source>
          <target state="translated">Der Name der DLL, in der die <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>-Methode definiert ist.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the entry point in the DLL.</source>
          <target state="translated">Der Name des Einstiegspunkts in die DLL.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The attributes of the method.</source>
          <target state="translated">Die Attribute der Methode.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's calling convention.</source>
          <target state="translated">Die Aufrufkonvention der Methode.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's return type.</source>
          <target state="translated">Der Rückgabetyp der Methode.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The types of the method's parameters.</source>
          <target state="translated">Die Typen der Parameter der Methode.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The native calling convention.</source>
          <target state="translated">Die systemeigene Aufrufkonvention.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's native character set.</source>
          <target state="translated">Der systemeigene Zeichensatz der Methode.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method with the specified name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> flags.</source>
          <target state="translated">Definiert eine <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>-Methode mit den Angaben für den Namen, den Namen der DLL, in der die Methode definiert ist, für die Attribute der Methode, die Aufrufkonvention der Methode, den Rückgabetyp der Methode, die Parametertypen der Methode und die <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph>-Flags.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The defined <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Die definierte <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>-Methode.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Some DLL import attributes (see the description of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) cannot be specified as arguments to this method.</source>
          <target state="translated">Einige DLL-Importattribute (siehe die Beschreibung der <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) kann nicht als Argumente für diese Methode angegeben werden.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Such attributes should be set by emitting a custom attribute for the method.</source>
          <target state="translated">Solche Attribute sollte festgelegt werden, durch das ein benutzerdefiniertes Attribut für die Methode ausgeben.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For example, the DLL import attribute <ph id="ph1">`PreserveSig`</ph> is set by emitting a custom attribute.</source>
          <target state="translated">Z. B. import die DLL-Attribut <ph id="ph1">`PreserveSig`</ph> wird durch das Ausgeben eines benutzerdefinierten Attributs festgelegt.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The following example illustrates the use of the <ph id="ph1">`DefinePInvokeMethod`</ph> method to create a <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> for an external unmanaged method, <ph id="ph3">`MessageBoxA`</ph>, in the Win32 API.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung von der <ph id="ph1">`DefinePInvokeMethod`</ph> Methode zum Erstellen einer <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> für externe nicht verwaltete Methode <ph id="ph3">`MessageBoxA`</ph>, in der Win32-API.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example displays a message box with <bpt id="p1">**</bpt>Retry<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Cancel<ept id="p2">**</ept> buttons, and displays the return value from the message box.</source>
          <target state="translated">Das Beispiel zeigt ein Meldungsfeld mit <bpt id="p1">**</bpt>wiederholen<ept id="p1">**</ept> und <bpt id="p2">**</bpt>"Abbrechen"<ept id="p2">**</ept> Schaltflächen und der Rückgabewert aus dem Meldungsfeld angezeigt.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>To get a non-zero return value, you must add <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> to the method implementation flags after you create the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, by using the <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Um einen Rückgabewert ungleich 0 (null) zu erhalten, müssen Sie hinzufügen <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> die Methodenimplementierungsflags nach der Erstellung der <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, mithilfe der <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>This example uses a different overload of the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A&gt;</ph> method, but the technique is the same.</source>
          <target state="translated">Dieses Beispiel verwendet eine andere Überladung von der <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A&gt;</ph> -Methode, aber das Verfahren ist identisch.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is not static or if the containing type is an interface or if the method is abstract of if the method was previously defined.</source>
          <target state="translated">Die Methode ist nicht statisch, der enthaltende Typ ist eine Schnittstelle, die Methode ist abstrakt, oder die Methode wurde bereits definiert.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> ist <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The containing type has been previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph></source>
          <target state="translated">Der enthaltende Typ wurde bereits mit <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Defines a managed embedded resource to be stored in this module.</source>
          <target state="translated">Definiert eine verwaltete eingebettete Ressource, die in diesem Modul gespeichert werden soll.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>The name of the resource.</source>
          <target state="translated">Der Name der Ressource.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>The description of the resource.</source>
          <target state="translated">Die Beschreibung der Ressource.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>Defines the named managed embedded resource to be stored in this module.</source>
          <target state="translated">Definiert die benannte verwaltete eingebettete Ressource, die in diesem Modul gespeichert werden soll.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>A resource writer for the defined resource.</source>
          <target state="translated">Ein Ressourcenwriter für die definierte Ressource.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>The caller must not call the <ph id="ph1">`ResourceWriter.Generate()`</ph> and <ph id="ph2">`ResourceWriter.Close()`</ph> methods, because these methods are called by <ph id="ph3">`ModuleBuilder.Save`</ph> when the dynamic assembly is written to disk.</source>
          <target state="translated">Der Aufrufer muss nicht aufrufen, die <ph id="ph1">`ResourceWriter.Generate()`</ph> und <ph id="ph2">`ResourceWriter.Close()`</ph> Methoden, da diese Methoden, indem aufgerufen werden <ph id="ph3">`ModuleBuilder.Save`</ph> beim Schreiben von der dynamischen Assembly auf den Datenträger.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>Use this method to embed a managed resource.</source>
          <target state="translated">Verwenden Sie diese Methode, um eine verwaltete Ressource einbetten.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>To embed a manifest resource blob, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> method.</source>
          <target state="translated">Um ein Blob Manifestressource einzubetten, verwenden die <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>For a summary of embedding and linking managed resources and manifest resource blobs, see the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> method.</source>
          <target state="translated">Eine Übersicht über das Einbetten von und Verknüpfen von verwalteten Ressourcen und Manifestressourcen-Blobs finden Sie unter der <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>The following example illustrates the use of <ph id="ph1">`DefineResource`</ph> to add an external resource to the current <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung von <ph id="ph1">`DefineResource`</ph> hinzuzufügende eine externe Ressource mit dem aktuellen <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>Length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist NULL.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>This module is transient.</source>
          <target state="translated">Dieses Modul ist flüchtig.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)">
          <source>The containing assembly is not persistable.</source>
          <target state="translated">Die enthaltende Assembly kann nicht beibehalten werden.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The name of the resource.</source>
          <target state="translated">Der Name der Ressource.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The description of the resource.</source>
          <target state="translated">Die Beschreibung der Ressource.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The resource attributes.</source>
          <target state="translated">Die Ressourcenattribute.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>Defines the named managed embedded resource with the given attributes that is to be stored in this module.</source>
          <target state="translated">Definiert die benannte verwaltete eingebettete Ressource, die in diesem Modul gespeichert werden soll, mit den angegebenen Attributen.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>A resource writer for the defined resource.</source>
          <target state="translated">Ein Ressourcenwriter für die definierte Ressource.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The caller must not call the <ph id="ph1">`ResourceWriter.Generate()`</ph> and <ph id="ph2">`ResourceWriter.Close()`</ph> methods, because these methods are called by <ph id="ph3">`ModuleBuilder.Save`</ph> when the dynamic assembly is written to disk.</source>
          <target state="translated">Der Aufrufer muss nicht aufrufen, die <ph id="ph1">`ResourceWriter.Generate()`</ph> und <ph id="ph2">`ResourceWriter.Close()`</ph> Methoden, da diese Methoden, indem aufgerufen werden <ph id="ph3">`ModuleBuilder.Save`</ph> beim Schreiben von der dynamischen Assembly auf den Datenträger.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>Use this method to embed a managed resource.</source>
          <target state="translated">Verwenden Sie diese Methode, um eine verwaltete Ressource einbetten.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>To embed a manifest resource blob, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> method.</source>
          <target state="translated">Um ein Blob Manifestressource einzubetten, verwenden die <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>For a summary of embedding and linking managed resources and manifest resource blobs, see the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> method.</source>
          <target state="translated">Eine Übersicht über das Einbetten von und Verknüpfen von verwalteten Ressourcen und Manifestressourcen-Blobs finden Sie unter der <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The following example illustrates the use of DefineResource to add an external resource to the current <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung von DefineResource zum Hinzufügen einer externen Ressource mit dem aktuellen <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>Length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist NULL.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>This module is transient.</source>
          <target state="translated">Dieses Modul ist flüchtig.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)">
          <source>The containing assembly is not persistable.</source>
          <target state="translated">Die enthaltende Assembly kann nicht beibehalten werden.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Constructs a <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>.</source>
          <target state="translated">Erstellt ein Objekt vom Typ <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>To define a value type, define a type that derives from <ph id="ph1">&lt;see cref="T:System.ValueType" /&gt;</ph>.</source>
          <target state="translated">Zum Definieren eines Werttyps definieren Sie einen Typ, der von <ph id="ph1">&lt;see cref="T:System.ValueType" /&gt;</ph> abgeleitet ist.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>The full path of the type, including the namespace.</source>
          <target state="translated">Der vollständige Pfad des Typs, einschließlich des Namespaces.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>Constructs a <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> for a private type with the specified name in this module.</source>
          <target state="translated">Erstellt einen <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> für einen privaten Typ mit dem angegebenen Namen in diesem Modul.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>A private type with the specified name.</source>
          <target state="translated">Ein privater Typ mit dem angegebenen Namen.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>Type names must be unique within an assembly.</source>
          <target state="translated">Typnamen müssen innerhalb einer Assembly eindeutig sein.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>You cannot have two types with the same name in two different modules of an assembly.</source>
          <target state="translated">Sie können nicht in zwei verschiedenen Modulen einer Assembly zwei Typen mit dem gleichen Namen haben.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in the current dynamic module using <ph id="ph2">`CreateType`</ph>, builds and completes the type, and saves the assembly.</source>
          <target state="translated">Das folgende Beispiel erstellt eine <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in der aktuellen dynamisches Modul mit <ph id="ph2">`CreateType`</ph>, builds und schließt den Typ und speichert die Assembly.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>A type with the given name exists in the parent assembly of this module.</source>
          <target state="translated">Ein Typ mit dem angegebenen Namen ist in der übergeordneten Assembly dieses Moduls vorhanden.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source>Nested type attributes are set on a type that is not nested.</source>
          <target state="translated">Geschachtelte Typattribute werden für einen Typ festgelegt, der nicht geschachtelt ist.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>The full path of the type.</source>
          <target state="translated">Der vollständige Pfad des Typs.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>The attributes of the defined type.</source>
          <target state="translated">Die Attribute des definierten Typs.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>Constructs a <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> given the type name and the type attributes.</source>
          <target state="translated">Erstellt einen <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> anhand der Angaben für den Typnamen und die Typattribute.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>A <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> created with all of the requested attributes.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>, der mit allen angeforderten Attributen erstellt wurde.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>Type names must be unique within an assembly.</source>
          <target state="translated">Typnamen müssen innerhalb einer Assembly eindeutig sein.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>You cannot have two types with the same name in two different modules of an assembly.</source>
          <target state="translated">Sie können nicht in zwei verschiedenen Modulen einer Assembly zwei Typen mit dem gleichen Namen haben.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in the current dynamic module using <ph id="ph2">`CreateType`</ph>, builds and completes the type, and saves the assembly.</source>
          <target state="translated">Das folgende Beispiel erstellt eine <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in der aktuellen dynamisches Modul mit <ph id="ph2">`CreateType`</ph>, builds und schließt den Typ und speichert die Assembly.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>A type with the given name exists in the parent assembly of this module.</source>
          <target state="translated">Ein Typ mit dem angegebenen Namen ist in der übergeordneten Assembly dieses Moduls vorhanden.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source>Nested type attributes are set on a type that is not nested.</source>
          <target state="translated">Geschachtelte Typattribute werden für einen Typ festgelegt, der nicht geschachtelt ist.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The full path of the type.</source>
          <target state="translated">Der vollständige Pfad des Typs.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The attribute to be associated with the type.</source>
          <target state="translated">Das Attribut, das diesem Typ zugeordnet werden soll.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The type that the defined type extends.</source>
          <target state="translated">Der vom definierten Typ erweiterte Typ.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Constructs a <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> given type name, its attributes, and the type that the defined type extends.</source>
          <target state="translated">Erstellt einen <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> anhand der Angaben für den Typnamen, die Attribute und den vom definierten Typ erweiterten Typ.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>A <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> created with all of the requested attributes.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>, der mit allen angeforderten Attributen erstellt wurde.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Type names must be unique within an assembly.</source>
          <target state="translated">Typnamen müssen innerhalb einer Assembly eindeutig sein.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>You cannot have two types with the same name in two different modules of an assembly.</source>
          <target state="translated">Sie können nicht in zwei verschiedenen Modulen einer Assembly zwei Typen mit dem gleichen Namen haben.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in the current dynamic module using <ph id="ph2">`CreateType`</ph>, builds and completes the type, and saves the assembly.</source>
          <target state="translated">Das folgende Beispiel erstellt eine <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in der aktuellen dynamisches Modul mit <ph id="ph2">`CreateType`</ph>, builds und schließt den Typ und speichert die Assembly.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>A type with the given name exists in the parent assembly of this module.</source>
          <target state="translated">Ein Typ mit dem angegebenen Namen ist in der übergeordneten Assembly dieses Moduls vorhanden.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Nested type attributes are set on a type that is not nested.</source>
          <target state="translated">Geschachtelte Typattribute werden für einen Typ festgelegt, der nicht geschachtelt ist.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The full path of the type.</source>
          <target state="translated">Der vollständige Pfad des Typs.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The attributes of the defined type.</source>
          <target state="translated">Die Attribute des definierten Typs.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The type that the defined type extends.</source>
          <target state="translated">Der vom definierten Typ erweiterte Typ.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The total size of the type.</source>
          <target state="translated">Die Gesamtgröße des Typs.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>Constructs a <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> given the type name, the attributes, the type that the defined type extends, and the total size of the type.</source>
          <target state="translated">Erstellt einen <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> anhand der Angaben für den Typnamen, die Attribute, den vom definierten Typ erweiterten Typ und die Gesamtgröße des Typs.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>A <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> object.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>Type names must be unique within an assembly.</source>
          <target state="translated">Typnamen müssen innerhalb einer Assembly eindeutig sein.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>It is forbidden to have two types with the same name in two different modules of an assembly.</source>
          <target state="translated">Es ist nicht zulässig, zwei Typen mit demselben Namen in zwei verschiedenen Modulen einer Assembly aufweisen.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in the current dynamic module using <ph id="ph2">`CreateType`</ph>, builds and completes the type, and saves the assembly.</source>
          <target state="translated">Das folgende Beispiel erstellt eine <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in der aktuellen dynamisches Modul mit <ph id="ph2">`CreateType`</ph>, builds und schließt den Typ und speichert die Assembly.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>A type with the given name exists in the parent assembly of this module.</source>
          <target state="translated">Ein Typ mit dem angegebenen Namen ist in der übergeordneten Assembly dieses Moduls vorhanden.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>Nested type attributes are set on a type that is not nested.</source>
          <target state="translated">Geschachtelte Typattribute werden für einen Typ festgelegt, der nicht geschachtelt ist.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The full path of the type.</source>
          <target state="translated">Der vollständige Pfad des Typs.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The attributes of the defined type.</source>
          <target state="translated">Die Attribute des definierten Typs.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The type that the defined type extends.</source>
          <target state="translated">Der vom definierten Typ erweiterte Typ.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The packing size of the type.</source>
          <target state="translated">Die Komprimierungsgröße des Typs.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>Constructs a <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> given the type name, the attributes, the type that the defined type extends, and the packing size of the type.</source>
          <target state="translated">Erstellt einen <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> anhand der Angaben für den Typnamen, die Attribute, den vom definierten Typ erweiterten Typ und die Komprimierungsgröße des Typs.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>A <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> object.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>Type names must be unique within an assembly.</source>
          <target state="translated">Typnamen müssen innerhalb einer Assembly eindeutig sein.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>You cannot have two types with the same name in two different modules of an assembly.</source>
          <target state="translated">Sie können nicht in zwei verschiedenen Modulen einer Assembly zwei Typen mit dem gleichen Namen haben.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in the current dynamic module using <ph id="ph2">`CreateType`</ph>, builds and completes the type, and saves the assembly.</source>
          <target state="translated">Das folgende Beispiel erstellt eine <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in der aktuellen dynamisches Modul mit <ph id="ph2">`CreateType`</ph>, builds und schließt den Typ und speichert die Assembly.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>A type with the given name exists in the parent assembly of this module.</source>
          <target state="translated">Ein Typ mit dem angegebenen Namen ist in der übergeordneten Assembly dieses Moduls vorhanden.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>Nested type attributes are set on a type that is not nested.</source>
          <target state="translated">Geschachtelte Typattribute werden für einen Typ festgelegt, der nicht geschachtelt ist.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The full path of the type.</source>
          <target state="translated">Der vollständige Pfad des Typs.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The attributes to be associated with the type.</source>
          <target state="translated">Die Attribute, die diesem Typ zugeordnet werden sollen.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The type that the defined type extends.</source>
          <target state="translated">Der vom definierten Typ erweiterte Typ.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The list of interfaces that the type implements.</source>
          <target state="translated">Die Liste der vom Typ implementierten Schnittstellen.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>Constructs a <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> given the type name, attributes, the type that the defined type extends, and the interfaces that the defined type implements.</source>
          <target state="translated">Erstellt einen <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> anhand der Angaben für den Typnamen, die Attribute, den vom definierten Typ erweiterten Typ und den vom definierten Typ implementierten Schnittstellen.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>A <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> created with all of the requested attributes.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>, der mit allen angeforderten Attributen erstellt wurde.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>Type names must be unique within an assembly.</source>
          <target state="translated">Typnamen müssen innerhalb einer Assembly eindeutig sein.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>You cannot have two types with the same name in two different modules of an assembly.</source>
          <target state="translated">Sie können nicht in zwei verschiedenen Modulen einer Assembly zwei Typen mit dem gleichen Namen haben.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in the current dynamic module using <ph id="ph2">`CreateType`</ph>, builds and completes the type, and saves the assembly.</source>
          <target state="translated">Das folgende Beispiel erstellt eine <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in der aktuellen dynamisches Modul mit <ph id="ph2">`CreateType`</ph>, builds und schließt den Typ und speichert die Assembly.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>A type with the given name exists in the parent assembly of this module.</source>
          <target state="translated">Ein Typ mit dem angegebenen Namen ist in der übergeordneten Assembly dieses Moduls vorhanden.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>Nested type attributes are set on a type that is not nested.</source>
          <target state="translated">Geschachtelte Typattribute werden für einen Typ festgelegt, der nicht geschachtelt ist.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The full path of the type.</source>
          <target state="translated">Der vollständige Pfad des Typs.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The attributes of the defined type.</source>
          <target state="translated">Die Attribute des definierten Typs.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The type that the defined type extends.</source>
          <target state="translated">Der vom definierten Typ erweiterte Typ.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The packing size of the type.</source>
          <target state="translated">Die Komprimierungsgröße des Typs.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The total size of the type.</source>
          <target state="translated">Die Gesamtgröße des Typs.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>Constructs a <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> given the type name, attributes, the type that the defined type extends, the packing size of the defined type, and the total size of the defined type.</source>
          <target state="translated">Erstellt einen <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> anhand der Angaben für den Typnamen, die Attribute, den vom definierten Typ erweiterten Typ, die Komprimierungsgröße des definierten Typs und die Gesamtgröße des definierten Typs.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>A <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> created with all of the requested attributes.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>, der mit allen angeforderten Attributen erstellt wurde.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>Type names must be unique within an assembly.</source>
          <target state="translated">Typnamen müssen innerhalb einer Assembly eindeutig sein.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>You cannot have two types with the same name in two different modules of an assembly.</source>
          <target state="translated">Sie können nicht in zwei verschiedenen Modulen einer Assembly zwei Typen mit dem gleichen Namen haben.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in the current dynamic module using <ph id="ph2">`CreateType`</ph>, builds and completes the type, and saves the assembly.</source>
          <target state="translated">Das folgende Beispiel erstellt eine <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> in der aktuellen dynamisches Modul mit <ph id="ph2">`CreateType`</ph>, builds und schließt den Typ und speichert die Assembly.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>A type with the given name exists in the parent assembly of this module.</source>
          <target state="translated">Ein Typ mit dem angegebenen Namen ist in der übergeordneten Assembly dieses Moduls vorhanden.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>Nested type attributes are set on a type that is not nested.</source>
          <target state="translated">Geschachtelte Typattribute werden für einen Typ festgelegt, der nicht geschachtelt ist.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The name used to refer to the data.</source>
          <target state="translated">Der Name, der zum Verweisen auf die Daten verwendet wird.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The size of the data field.</source>
          <target state="translated">Die Größe des Datenfelds.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The attributes for the field.</source>
          <target state="translated">Die Attribute für das Feld.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>Defines an uninitialized data field in the .sdata section of the portable executable (PE) file.</source>
          <target state="translated">Definiert ein nicht initialisiertes Datenfeld im .sdata-Abschnitt der übertragbaren ausführbaren Datei (Portable Executable, PE).</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>A field to reference the data.</source>
          <target state="translated">Ein Feld zum Verweisen auf die Daten.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.Static&gt;</ph> is automatically included in <ph id="ph2">`attributes`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.FieldAttributes.Static&gt;</ph> automatisch <ph id="ph2">`attributes`</ph>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The data defined by this method is not created until the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> method is called.</source>
          <target state="translated">Die von dieser Methode definierten Daten werden erst erstellt, wenn die <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> -Methode aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than or equal to zero, or greater than or equal to 0x003f0000.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist kleiner gleich 0 oder größer gleich 0x003f0000.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> has been previously called.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /&gt;</ph> wurde bereits zuvor aufgerufen.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Defines an unmanaged resource in this module.</source>
          <target state="translated">Definiert eine nicht verwaltete Ressource in diesem Modul.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>The binary large object (BLOB) must have the right format for a Win32 resource.</source>
          <target state="translated">Das Binary Large Object (BLOB) muss das korrekte Format für eine Win32-Ressource aufweisen.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>An opaque BLOB that represents an unmanaged resource</source>
          <target state="translated">Ein nicht transparentes BLOB, das eine nicht verwaltete Ressource darstellt.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>Defines an unmanaged embedded resource given an opaque binary large object (BLOB) of bytes.</source>
          <target state="translated">Definiert eine nicht verwaltete eingebettete Ressource anhand eines angegebenen, nicht transparenten BLOBs (Binary Large Object) von Bytes.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>An assembly can be associated with only one unmanaged resource.</source>
          <target state="translated">Eine Assembly kann nur eine nicht verwaltete Ressource zugeordnet werden.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>This means that calling <ph id="ph1">`DefineVersionInfoResource`</ph> or <ph id="ph2">`DefineUnmanagedResource`</ph> after either one of the methods was called previously throws <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Dies bedeutet, dass der Aufruf <ph id="ph1">`DefineVersionInfoResource`</ph> oder <ph id="ph2">`DefineUnmanagedResource`</ph> nach entweder eine der Methoden aufgerufen wurde zuvor löst <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>Multiple unmanaged resources need to be merged with a tool such as the Microsoft ResMerge utility (not supplied with the common language runtime).</source>
          <target state="translated">Mehrere nicht verwaltete Ressourcen müssen mit einem Tool wie dem Microsoft ResMerge-Hilfsprogramm (nicht im Lieferumfang der common Language Runtime) zusammengeführt werden sollen.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])">
          <source>An unmanaged resource has already been defined in the module's assembly.</source>
          <target state="translated">Es wurde bereits eine nicht verwaltete Ressource in der Assembly des Moduls definiert.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="resource" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resource" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>The name of the unmanaged resource file.</source>
          <target state="translated">Der Name der nicht verwalteten Ressourcendatei.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>Defines an unmanaged resource given the name of Win32 resource file.</source>
          <target state="translated">Definiert eine nicht verwaltete Ressource anhand des angegebenen Namens der Win32-Ressourcendatei.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>An assembly can be associated with only one unmanaged resource.</source>
          <target state="translated">Eine Assembly kann nur eine nicht verwaltete Ressource zugeordnet werden.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>This means that calling <ph id="ph1">`DefineVersionInfoResource`</ph> or <ph id="ph2">`DefineUnmanagedResource`</ph> after either one of the methods was called previously throws <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Dies bedeutet, dass der Aufruf <ph id="ph1">`DefineVersionInfoResource`</ph> oder <ph id="ph2">`DefineUnmanagedResource`</ph> nach entweder eine der Methoden aufgerufen wurde zuvor löst <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>Multiple unmanaged resources need to be merged with a tool such as the Microsoft ResMerge utility (not supplied with the common language runtime).</source>
          <target state="translated">Mehrere nicht verwaltete Ressourcen müssen mit einem Tool wie dem Microsoft ResMerge-Hilfsprogramm (nicht im Lieferumfang der common Language Runtime) zusammengeführt werden sollen.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>An unmanaged resource has already been defined in the module's assembly.</source>
          <target state="translated">Es wurde bereits eine nicht verwaltete Ressource in der Assembly des Moduls definiert.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> is the empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> ist die leere Zeichenfolge ("").</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)">
          <source><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> is a directory.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceFileName" /&gt;</ph> ist ein Verzeichnis.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.Equals(System.Object)">
          <source>An object to compare with this instance, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, das mit dieser Instanz verglichen werden soll, oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.Equals(System.Object)">
          <source>Returns a value that indicates whether this instance is equal to the specified object.</source>
          <target state="translated">Gibt einen Wert zurück, der angibt, ob diese Instanz gleich dem angegebenen Objekt ist.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> equals the type and value of this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> dem Typ und dem Wert dieser Instanz entspricht, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName">
          <source>Gets a <ph id="ph1">&lt;see langword="String" /&gt;</ph> representing the fully qualified name and path to this module.</source>
          <target state="translated">Ruft einen <ph id="ph1">&lt;see langword="String" /&gt;</ph> ab, der den vollqualifizierten Namen und den Pfad zu diesem Modul darstellt.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName">
          <source>The fully qualified module name.</source>
          <target state="translated">Der vollqualifizierte Modulname.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName">
          <source>To get the name without the path, use <ph id="ph1">`Name`</ph>.</source>
          <target state="translated">Verwenden Sie zum Abrufen der Namen ohne die Pfadangabe <ph id="ph1">`Name`</ph>.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName">
          <source>The case of a module name is platform dependent.</source>
          <target state="translated">Die Groß-/Kleinschreibung einen Modulnamen ist plattformabhängig.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName">
          <source>Accesses information in the path.</source>
          <target state="translated">Greift auf die Informationen im Pfad.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>An array class.</source>
          <target state="translated">Eine Arrayklasse.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The name of a method on the array class.</source>
          <target state="translated">Der Name einer Methode für eine Arrayklasse.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The method's calling convention.</source>
          <target state="translated">Die Aufrufkonvention der Methode.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The return type of the method.</source>
          <target state="translated">Der Rückgabetyp der Methode</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The types of the method's parameters.</source>
          <target state="translated">Die Typen der Parameter der Methode.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>Returns the named method on an array class.</source>
          <target state="translated">Gibt die benannte Methode für eine Arrayklasse zurück.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The named method on an array class.</source>
          <target state="translated">Die benannte Methode für eine Arrayklasse.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">`GetArrayMethod`</ph> is useful when you have an array of a type whose definition has not been completed and you want to access methods defined on <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`GetArrayMethod`</ph> ist nützlich, wenn Sie ein Array eines Typs, dessen Definition wurde nicht abgeschlossen, haben und Sie definierte Methoden zugreifen möchten <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>For example, you might define a type and want to define a method that takes an array of the type as a parameter.</source>
          <target state="translated">Sie können z. B. einen Typ definieren und definieren Sie eine Methode, die ein Array des Typs als Parameter verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>In order to access the elements of the array, you will need to call methods of the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class.</source>
          <target state="translated">Um die Elemente des Arrays zugreifen zu können, müssen Sie Methoden von Aufrufen der <ph id="ph1">&lt;xref:System.Array&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The following example demonstrates how to use <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A&gt;</ph> to obtain the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> corresponding to a method that returns an array value.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A&gt;</ph> zum Abrufen der <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> für eine Methode, einen Arraywert zurückgibt.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="arrayClass" /&gt;</ph> is not an array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayClass" /&gt;</ph> ist kein Array.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="arrayClass" /&gt;</ph> or <ph id="ph2">&lt;paramref name="methodName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayClass" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="methodName" /&gt;</ph> ist <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The object for the array.</source>
          <target state="translated">Das Objekt für das Array.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>A string that contains the name of the method.</source>
          <target state="translated">Eine Zeichenfolge, die den Namen der Methode enthält.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The calling convention for the method.</source>
          <target state="translated">Die Aufrufkonvention für die Methode.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The return type of the method.</source>
          <target state="translated">Der Rückgabetyp der Methode</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The types of the parameters of the method.</source>
          <target state="translated">Die Typen der Parameter der Methode.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>Returns the token for the named method on an array class.</source>
          <target state="translated">Gibt das Token für die benannte Methode einer Arrayklasse zurück.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The token for the named method on an array class.</source>
          <target state="translated">Das Token für die benannte Methode einer Arrayklasse.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>This method is similar to <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A&gt;</ph>, except that it returns the token of the array method instead of the method itself.</source>
          <target state="translated">Diese Methode ist vergleichbar mit <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A&gt;</ph>, mit dem Unterschied, dass das Token der Arraymethode, statt die Methode selbst zurückgegeben.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The following example demonstrates how to use <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A&gt;</ph> to obtain the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodToken&gt;</ph> corresponding to a method that returns an array value.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A&gt;</ph> zum Abrufen der <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodToken&gt;</ph> für eine Methode, einen Arraywert zurückgibt.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="arrayClass" /&gt;</ph> is not an array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayClass" /&gt;</ph> ist kein Array.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="methodName" /&gt;</ph> is zero.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="methodName" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="arrayClass" /&gt;</ph> or <ph id="ph2">&lt;paramref name="methodName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayClass" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="methodName" /&gt;</ph> ist <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Returns the token used to identify the specified constructor within this module.</source>
          <target state="translated">Gibt das Token zurück, mit dem der angegebene Konstruktor innerhalb dieses Moduls bezeichnet wird.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo)">
          <source>The constructor to get a token for.</source>
          <target state="translated">Der Konstruktor, für den ein Token abgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo)">
          <source>Returns the token used to identify the specified constructor within this module.</source>
          <target state="translated">Gibt das Token zurück, mit dem der angegebene Konstruktor innerhalb dieses Moduls bezeichnet wird.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo)">
          <source>The token used to identify the specified constructor within this module.</source>
          <target state="translated">Das Token, mit dem der angegebene Konstruktor innerhalb dieses Moduls bezeichnet wird.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo)">
          <source><ph id="ph1">&lt;paramref name="con" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="con" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source>The constructor to get a token for.</source>
          <target state="translated">Der Konstruktor, für den ein Token abgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source>A collection of the types of the optional parameters to the constructor.</source>
          <target state="translated">Eine Sammlung der Typen der optionalen Parameter für den Konstruktor.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source>Returns the token used to identify the constructor that has the specified attributes and parameter types within this module.</source>
          <target state="translated">Gibt das Token zurück, das verwendet wird, um den Konstruktor zu identifizieren, der über die angegebenen Attribute und Parametertypen innerhalb dieses Moduls verfügt.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source>The token used to identify the specified constructor within this module.</source>
          <target state="translated">Das Token, mit dem der angegebene Konstruktor innerhalb dieses Moduls bezeichnet wird.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source><ph id="ph1">&lt;paramref name="constructor" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="constructor" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Returns the custom attributes that are applied to the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph>.</source>
          <target state="translated">Gibt die benutzerdefinierten Attribute zurück, die auf den aktuellen <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph> angewendet werden.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Boolean)">
          <source>This argument is ignored for objects of this type.</source>
          <target state="translated">Dieses Argument wird für Objekte dieses Typs ignoriert.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Boolean)">
          <source>Returns all the custom attributes that have been applied to the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph>.</source>
          <target state="translated">Gibt alle benutzerdefinierten Attribute zurück, die auf den aktuellen <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph> angewendet wurden.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Boolean)">
          <source>An array that contains the custom attributes; the array is empty if there are no attributes.</source>
          <target state="translated">Ein Array, das die benutzerdefinierten Attribute enthält. Das Array ist leer, wenn keine Attribute vorhanden sind.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The base type from which attributes derive.</source>
          <target state="translated">Der Basistyp, von dem Attribute abgeleitet werden.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This argument is ignored for objects of this type.</source>
          <target state="translated">Dieses Argument wird für Objekte dieses Typs ignoriert.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Returns all the custom attributes that have been applied to the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph>, and that derive from a specified attribute type.</source>
          <target state="translated">Gibt alle benutzerdefinierten Attribute zurück, die auf den aktuellen <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph> angewendet wurden und die von einem angegebenen Attributtyp abgeleitet sind.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>An array that contains the custom attributes that are derived, at any level, from <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph>; the array is empty if there are no such attributes.</source>
          <target state="translated">Ein Array, das die benutzerdefinierten Attribute enthält, die auf beliebiger Ebene von <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> abgeleitet sind. Das Array ist leer, wenn keine solchen Attribute vorhanden sind.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object supplied by the runtime.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> ist kein von der Laufzeit angegebenes <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>For example, <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is a <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> ist beispielsweise ein <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData">
          <source>Returns information about the attributes that have been applied to the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph>, expressed as <ph id="ph2">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> objects.</source>
          <target state="translated">Gibt Informationen zu den Attributen zurück, die auf den aktuellen <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph> angewendet wurden. Diese sind als <ph id="ph2">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph>-Objekte ausgedrückt.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData">
          <source>A generic list of <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph> objects representing data about the attributes that have been applied to the current module.</source>
          <target state="translated">Eine generische Liste von <ph id="ph1">&lt;see cref="T:System.Reflection.CustomAttributeData" /&gt;</ph>-Objekten, die Daten zu den Attributen darstellen, die auf das aktuelle Modul angewendet wurden.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData">
          <source>Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context.</source>
          <target state="translated">Verwenden Sie diese Methode, um die benutzerdefinierten Attribute des Codes in den ReflectionOnly Kontext, in Fällen zu untersuchen, in dem die benutzerdefinierten Attribute selbst im Code definiert werden, die in den reflektionsbezogenen Kontext geladen wird.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData">
          <source>Methods like <ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> cannot be used in such cases, because they create instances of the attributes.</source>
          <target state="translated">Methoden wie <ph id="ph1">&lt;xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType&gt;</ph> kann nicht in solchen Fällen verwendet werden, da sie Instanzen der Attribute erstellen.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData">
          <source>Code in the reflection-only context cannot be executed.</source>
          <target state="translated">Code in den ReflectionOnly Kontext kann nicht ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData">
          <source>For more information and for example code, see the <ph id="ph1">&lt;xref:System.Reflection.CustomAttributeData&gt;</ph> class.</source>
          <target state="translated">Weitere Informationen und Beispielcode, finden Sie unter der <ph id="ph1">&lt;xref:System.Reflection.CustomAttributeData&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The field name.</source>
          <target state="translated">Der Feldname.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A combination of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> bit flags used to control the search.</source>
          <target state="translated">Eine Kombination der <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>-Bitflags zum Steuern der Suche.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Returns a module-level field, defined in the .sdata region of the portable executable (PE) file, that has the specified name and binding attributes.</source>
          <target state="translated">Gibt ein Feld auf Modulebene zurück, das im .sdata-Bereich der PE-Datei (Portable Executable) definiert ist und über den angegebenen Namen und die angegebenen Bindungsattribute verfügt.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A field that has the specified name and binding attributes, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the field does not exist.</source>
          <target state="translated">Ein Feld mit dem angegebenen Namen und den angegebenen Bindungsattributen, oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn das Feld nicht vorhanden ist.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>When you emit dynamic assemblies, fields in the .sdata region of the portable executable (PE) file are defined by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData%2A&gt;</ph> methods.</source>
          <target state="translated">Wenn Sie dynamische Assemblys ausgeben, werden Felder im ".sdata" Bereich der PE (portable Executable)-Datei definiert, mit der <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData%2A&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Module-level fields cannot be retrieved until after the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> method has been called for the module.</source>
          <target state="translated">Modulebene Felder können nicht abgerufen werden, erst nach der <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> Methode für das Modul aufgerufen wurde.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="name" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>A combination of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> bit flags used to control the search.</source>
          <target state="translated">Eine Kombination der <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>-Bitflags zum Steuern der Suche.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>Returns all fields defined in the .sdata region of the portable executable (PE) file that match the specified binding flags.</source>
          <target state="translated">Gibt alle im .sdata-Bereich der PE-Datei (Portable Executable) definierten Felder zurück, die den angegebenen Bindungsflags entsprechen.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>An array of fields that match the specified flags; the array is empty if no such fields exist.</source>
          <target state="translated">Ein Array von Feldern, die den angegebenen Flags entsprechen. Das Array ist leer, wenn keine solchen Felder vorhanden sind.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>When you emit dynamic assemblies, fields in the .sdata region of the portable executable (PE) file are defined by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData%2A&gt;</ph> methods.</source>
          <target state="translated">Wenn Sie dynamische Assemblys ausgeben, werden Felder im ".sdata" Bereich der PE (portable Executable)-Datei definiert, mit der <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData%2A&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>Module-level fields cannot be retrieved until after the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> method has been called for the module.</source>
          <target state="translated">Modulebene Felder können nicht abgerufen werden, erst nach der <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> Methode für das Modul aufgerufen wurde.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;paramref name="name" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="name" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetFieldToken(System.Reflection.FieldInfo)">
          <source>The field to get a token for.</source>
          <target state="translated">Das Feld, für das ein Token abgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetFieldToken(System.Reflection.FieldInfo)">
          <source>Returns the token used to identify the specified field within this module.</source>
          <target state="translated">Gibt das Token zurück, mit dem das angegebene Feld innerhalb dieses Moduls identifiziert wird.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetFieldToken(System.Reflection.FieldInfo)">
          <source>The token used to identify the specified field within this module.</source>
          <target state="translated">Das Token, mit dem das angegebene Feld innerhalb dieses Moduls identifiziert wird.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetFieldToken(System.Reflection.FieldInfo)">
          <source><ph id="ph1">&lt;paramref name="field" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="field" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">Gibt den Hashcode für diese Instanz zurück.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The method name.</source>
          <target state="translated">Der Methodenname.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A combination of <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> bit flags used to control the search.</source>
          <target state="translated">Eine Kombination von <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>-Bitflags zum Steuern der Suche.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that implements <ph id="ph1">&lt;see langword="Binder" /&gt;</ph>, containing properties related to this method.</source>
          <target state="translated">Ein Objekt, das <ph id="ph1">&lt;see langword="Binder" /&gt;</ph> implementiert, das auf diese Methode bezogene Eigenschaften enthält.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The calling convention for the method.</source>
          <target state="translated">Die Aufrufkonvention für die Methode.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The parameter types of the method.</source>
          <target state="translated">Die Parametertypen der Methode.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</source>
          <target state="translated">Ein Array von Parametermodifizierern, das zur Bindung mit Parametersignaturen verwendet wird, in denen die Typen geändert wurden.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Returns the module-level method that matches the specified criteria.</source>
          <target state="translated">Gibt eine Methode auf Modulebene zurück, die den angegebenen Kriterien entspricht.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A method that is defined at the module level, and matches the specified criteria; or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if such a method does not exist.</source>
          <target state="translated">Eine Methode, die auf Modulebene definiert ist und den angegebenen Kriterien entspricht, oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn keine solche Methode vorhanden ist.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>This method provides the implementation for all overloads of the inherited <ph id="ph1">&lt;xref:System.Reflection.Module.GetMethod%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Diese Methode stellt die Implementierung für alle Überladungen der vererbten <ph id="ph1">&lt;xref:System.Reflection.Module.GetMethod%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Use the inherited <ph id="ph1">&lt;xref:System.Reflection.Module.GetMethod%2A?displayProperty=nameWithType&gt;</ph> method to get methods that have been declared at the module level.</source>
          <target state="translated">Verwenden Sie die geerbte <ph id="ph1">&lt;xref:System.Reflection.Module.GetMethod%2A?displayProperty=nameWithType&gt;</ph> Methode zum Abrufen von Methoden, die deklariert wurden auf Modulebene.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Module-level methods are defined in emitted code by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A&gt;</ph> method.</source>
          <target state="translated">Auf Modulebene Methoden im ausgegebenen Code definiert werden, mithilfe der <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Module-level methods cannot be retrieved until after the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> method has been called for the module.</source>
          <target state="translated">Auf Modulebene Methoden können nicht abgerufen werden, erst nach der <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> Methode für das Modul aufgerufen wurde.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="types" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>, or an element of <ph id="ph5">&lt;paramref name="types" /&gt;</ph> is <ph id="ph6">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph4">&lt;see langword="null" /&gt;</ph>, oder ein Element von <ph id="ph5">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph6">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>A combination of <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> bit flags used to control the search.</source>
          <target state="translated">Eine Kombination von <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>-Bitflags zum Steuern der Suche.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>Returns all the methods that have been defined at the module level for the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph>, and that match the specified binding flags.</source>
          <target state="translated">Gibt alle Methoden zurück, die auf Modulebene für den aktuellen <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ModuleBuilder" /&gt;</ph> definiert wurden und den angegebenen Bindungsflags entsprechen.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>An array that contains all the module-level methods that match <ph id="ph1">&lt;paramref name="bindingFlags" /&gt;</ph>.</source>
          <target state="translated">Ein Array, das alle Methoden auf Modulebene enthält, die <ph id="ph1">&lt;paramref name="bindingFlags" /&gt;</ph> entsprechen.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>Module-level methods are defined in emitted code by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A&gt;</ph> method.</source>
          <target state="translated">Auf Modulebene Methoden im ausgegebenen Code definiert werden, mithilfe der <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>Module-level methods cannot be retrieved until after the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> method has been called for the module.</source>
          <target state="translated">Auf Modulebene Methoden können nicht abgerufen werden, erst nach der <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A&gt;</ph> Methode für das Modul aufgerufen wurde.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Returns the token used to identify the specified method within this module.</source>
          <target state="translated">Gibt das Token zurück, mit dem die angegebene Methode innerhalb dieses Moduls bezeichnet wird.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo)">
          <source>The method to get a token for.</source>
          <target state="translated">Die Methode, für die ein Token abgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo)">
          <source>Returns the token used to identify the specified method within this module.</source>
          <target state="translated">Gibt das Token zurück, mit dem die angegebene Methode innerhalb dieses Moduls bezeichnet wird.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo)">
          <source>The token used to identify the specified method within this module.</source>
          <target state="translated">Das Token, mit dem die angegebene Methode innerhalb dieses Moduls bezeichnet wird.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo)">
          <source>The declaring type for the method is not in this module.</source>
          <target state="translated">Der deklarierende Typ für die Methode befindet sich nicht in diesem Modul.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source>The method to get a token for.</source>
          <target state="translated">Die Methode, für die ein Token abgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source>A collection of the types of the optional parameters to the method.</source>
          <target state="translated">Eine Sammlung der Typen der optionalen Parameter für die Methode.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source>Returns the token used to identify the method that has the specified attributes and parameter types within this module.</source>
          <target state="translated">Gibt das Token zurück, das verwendet wird, um die Methode zu identifizieren, die über die angegebenen Attribute und Parametertypen innerhalb dieses Moduls verfügt.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source>The token used to identify the specified method within this module.</source>
          <target state="translated">Das Token, mit dem die angegebene Methode innerhalb dieses Moduls bezeichnet wird.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Type})">
          <source>The declaring type for the method is not in this module.</source>
          <target state="translated">Der deklarierende Typ für die Methode befindet sich nicht in diesem Modul.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
          <source>When this method returns, a combination of the <ph id="ph1">&lt;see cref="T:System.Reflection.PortableExecutableKinds" /&gt;</ph> values indicating the nature of the code in the module.</source>
          <target state="translated">Diese Methode gibt eine Kombination der <ph id="ph1">&lt;see cref="T:System.Reflection.PortableExecutableKinds" /&gt;</ph>-Werte zurück, die die Merkmale des Codes im Modul angeben.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
          <source>When this method returns, one of the <ph id="ph1">&lt;see cref="T:System.Reflection.ImageFileMachine" /&gt;</ph> values indicating the platform targeted by the module.</source>
          <target state="translated">Diese Methode gibt einen der <ph id="ph1">&lt;see cref="T:System.Reflection.ImageFileMachine" /&gt;</ph>-Werte zurück, die die Plattform angeben, die das Ziel des Moduls darstellt.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
          <source>Gets a pair of values indicating the nature of the code in a module and the platform targeted by the module.</source>
          <target state="translated">Ruft ein Paar von Werten ab, die die Merkmale des Codes in einem Modul und die Plattform angeben, die das Ziel dieses Moduls darstellt.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)">
          <source>For dynamic modules, <ph id="ph1">`peKind`</ph> is always <ph id="ph2">&lt;xref:System.Reflection.PortableExecutableKinds.NotAPortableExecutableImage?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">`machine`</ph> is always 0 (zero).</source>
          <target state="translated">Bei dynamischen Modulen ist <ph id="ph1">`peKind`</ph> ist immer <ph id="ph2">&lt;xref:System.Reflection.PortableExecutableKinds.NotAPortableExecutableImage?displayProperty=nameWithType&gt;</ph> und <ph id="ph3">`machine`</ph> ist immer 0 (null).</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Defines a signature token.</source>
          <target state="translated">Definiert ein Signaturtoken.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Reflection.Emit.SignatureHelper)">
          <source>The signature.</source>
          <target state="translated">Die Signatur.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Reflection.Emit.SignatureHelper)">
          <source>Defines a token for the signature that is defined by the specified <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.SignatureHelper" /&gt;</ph>.</source>
          <target state="translated">Definiert ein Token für die Signatur, die vom angegebenen <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.SignatureHelper" /&gt;</ph> definiert wird.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Reflection.Emit.SignatureHelper)">
          <source>A token for the defined signature.</source>
          <target state="translated">Ein Token für die definierte Signatur.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Reflection.Emit.SignatureHelper)">
          <source>This method defines a metadata token for the signature described by <ph id="ph1">`sigHelper`</ph>.</source>
          <target state="translated">Diese Methode definiert ein Metadatentoken für die Signatur von beschriebenen <ph id="ph1">`sigHelper`</ph>.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Reflection.Emit.SignatureHelper)">
          <source><ph id="ph1">&lt;paramref name="sigHelper" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sigHelper" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Byte[],System.Int32)">
          <source>The signature binary large object (BLOB).</source>
          <target state="translated">Das Signatur-BLOB (Binary Large Object).</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Byte[],System.Int32)">
          <source>The length of the signature BLOB.</source>
          <target state="translated">Die Länge des Signatur-BLOBs.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Byte[],System.Int32)">
          <source>Defines a token for the signature that has the specified character array and signature length.</source>
          <target state="translated">Definiert ein Token für die Signatur mit dem angegebenen Zeichenarray und der angegebenen Signaturlänge.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Byte[],System.Int32)">
          <source>A token for the specified signature.</source>
          <target state="translated">Ein Token für die angegebene Signatur.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sigBytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sigBytes" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignerCertificate">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" /&gt;</ph> object corresponding to the certificate included in the Authenticode signature of the assembly which this module belongs to.</source>
          <target state="translated">Gibt ein <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" /&gt;</ph>-Objekt zurück, das dem in der Authenticode-Signatur enthaltenen Zertifikat der Assembly entspricht, zu der dieses Modul gehört.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignerCertificate">
          <source>If the assembly has not been Authenticode signed, <ph id="ph1">&lt;see langword="null" /&gt;</ph> is returned.</source>
          <target state="translated">Wenn die Assembly nicht mit Authenticode signiert wurde, wird <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurückgegeben.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSignerCertificate">
          <source>A certificate, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the assembly to which this module belongs has not been Authenticode signed.</source>
          <target state="translated">Ein Zertifikat oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn die Assembly, zu der dieses Modul gehört, nicht mit Authenticode signiert wurde.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetStringConstant(System.String)">
          <source>The string to add to the module's constant pool.</source>
          <target state="translated">Die dem Konstantenpool des Moduls hinzuzufügende Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetStringConstant(System.String)">
          <source>Returns the token of the given string in the module’s constant pool.</source>
          <target state="translated">Gibt das Token der angegebenen Zeichenfolge im Konstantenpool des Moduls zurück.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetStringConstant(System.String)">
          <source>The token of the string in the constant pool.</source>
          <target state="translated">Das Token der Zeichenfolge im Konstantenpool.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetStringConstant(System.String)">
          <source>If <ph id="ph1">`str`</ph> has already been defined, the existing token will be returned.</source>
          <target state="translated">Wenn <ph id="ph1">`str`</ph> wurde bereits definiert ist, wird das vorhandene Token zurückgegeben.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetStringConstant(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="str" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSymWriter">
          <source>Returns the symbol writer associated with this dynamic module.</source>
          <target state="translated">Gibt den Symbolwriter zurück, der diesem dynamischen Modul zugeordnet ist.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetSymWriter">
          <source>The symbol writer associated with this dynamic module.</source>
          <target state="translated">Der Symbolwriter, der diesem dynamischen Modul zugeordnet ist.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetSymWriter">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetSymWriter">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Gets the named type defined in the module.</source>
          <target state="translated">Ruft den im Modul definierten benannten Typ ab.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>The name of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> to get.</source>
          <target state="translated">Der Name des abzurufenden <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>Gets the named type defined in the module.</source>
          <target state="translated">Ruft den im Modul definierten benannten Typ ab.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>The requested type, if the type is defined in this module; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der angeforderte Typ, wenn der Typ in diesem Modul definiert wurde, andernfalls <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>Do not use this method to generate array types, pointer types, or byref types.</source>
          <target state="translated">Verwenden Sie diese Methode nicht um Arraytypen, Zeigertypen oder Byref-Typen zu generieren.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType&gt;</ph> methods instead.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType&gt;</ph>, und <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType&gt;</ph> Methoden stattdessen.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>Length of <ph id="ph1">&lt;paramref name="className" /&gt;</ph> is zero or is greater than 1023.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="className" /&gt;</ph> ist 0 (null) oder größer als 1023.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>The requested <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is non-public and the caller does not have <ph id="ph2">&lt;see cref="T:System.Security.Permissions.ReflectionPermission" /&gt;</ph> to reflect non-public objects outside the current assembly.</source>
          <target state="translated">Der angeforderte <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> ist nicht öffentlich, und der Aufrufer besitzt keine <ph id="ph2">&lt;see cref="T:System.Security.Permissions.ReflectionPermission" /&gt;</ph> zum Reflektieren nicht öffentlicher Objekte außerhalb der aktuellen Assembly.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)">
          <source>An error is encountered while loading the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Beim Laden von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> ist ein Fehler aufgetreten.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>The name of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> to get.</source>
          <target state="translated">Der Name des abzurufenden <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="true" /&gt;</ph>, the search is case-insensitive.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;see langword="true" /&gt;</ph>, wird bei der Suche die Groß- und Kleinschreibung nicht berücksichtigt.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the search is case-sensitive.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;see langword="false" /&gt;</ph>, wird bei der Suche die Groß- und Kleinschreibung berücksichtigt.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>Gets the named type defined in the module, optionally ignoring the case of the type name.</source>
          <target state="translated">Ruft den im Modul definierten benannten Typ ab, wobei optional die Groß- und Kleinschreibung des Typnamens nicht berücksichtigt wird.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>The requested type, if the type is defined in this module; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der angeforderte Typ, wenn der Typ in diesem Modul definiert wurde, andernfalls <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>Do not use this method to generate array types, pointer types, or byref types.</source>
          <target state="translated">Verwenden Sie diese Methode nicht um Arraytypen, Zeigertypen oder Byref-Typen zu generieren.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType&gt;</ph> methods instead.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType&gt;</ph>, und <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType&gt;</ph> Methoden stattdessen.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>Length of <ph id="ph1">&lt;paramref name="className" /&gt;</ph> is zero or is greater than 1023.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="className" /&gt;</ph> ist 0 (null) oder größer als 1023.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>The requested <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is non-public and the caller does not have <ph id="ph2">&lt;see cref="T:System.Security.Permissions.ReflectionPermission" /&gt;</ph> to reflect non-public objects outside the current assembly.</source>
          <target state="translated">Der angeforderte <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> ist nicht öffentlich, und der Aufrufer besitzt keine <ph id="ph2">&lt;see cref="T:System.Security.Permissions.ReflectionPermission" /&gt;</ph> zum Reflektieren nicht öffentlicher Objekte außerhalb der aktuellen Assembly.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The name of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> to get.</source>
          <target state="translated">Der Name des abzurufenden <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type cannot be found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden werden kann, <ph id="ph2">&lt;see langword="false" /&gt;</ph>, damit <ph id="ph3">&lt;see langword="null" /&gt;</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="true" /&gt;</ph>, the search is case-insensitive.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;see langword="true" /&gt;</ph>, wird bei der Suche die Groß- und Kleinschreibung nicht berücksichtigt.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the search is case-sensitive.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;see langword="false" /&gt;</ph>, wird bei der Suche die Groß- und Kleinschreibung berücksichtigt.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Gets the named type defined in the module, optionally ignoring the case of the type name.</source>
          <target state="translated">Ruft den im Modul definierten benannten Typ ab, wobei optional die Groß- und Kleinschreibung des Typnamens nicht berücksichtigt wird.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Optionally throws an exception if the type is not found.</source>
          <target state="translated">Löst optional eine Ausnahme aus, wenn der Typ nicht gefunden wird.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The specified type, if the type is declared in this module; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der angegebene Typ, wenn der Typ in diesem Modul deklariert wurde, andernfalls <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`throwOnError`</ph> parameter only affects what happens when the type is not found.</source>
          <target state="translated">Die <ph id="ph1">`throwOnError`</ph> Parameter wirkt sich nur auf was geschieht, wenn der Typ nicht gefunden wird.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>It does not affect any other exceptions that might be thrown.</source>
          <target state="translated">Dies beeinflusst keine andere Ausnahmen, die möglicherweise ausgelöst werden.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In particular, if the type is found but cannot be loaded, <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> can be thrown even if <ph id="ph2">`throwOnError`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Insbesondere, wenn der Typ gefunden wird, kann nicht geladen werden kann <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> kann ausgelöst werden, selbst wenn <ph id="ph2">`throwOnError`</ph> ist <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Do not use this method to generate array types, pointer types, or byref types.</source>
          <target state="translated">Verwenden Sie diese Methode nicht um Arraytypen, Zeigertypen oder Byref-Typen zu generieren.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType&gt;</ph> methods instead.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType&gt;</ph>, und <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType&gt;</ph> Methoden stattdessen.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Length of <ph id="ph1">&lt;paramref name="className" /&gt;</ph> is zero or is greater than 1023.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="className" /&gt;</ph> ist 0 (null) oder größer als 1023.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="className" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="className" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The requested <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is non-public and the caller does not have <ph id="ph2">&lt;see cref="T:System.Security.Permissions.ReflectionPermission" /&gt;</ph> to reflect non-public objects outside the current assembly.</source>
          <target state="translated">Der angeforderte <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> ist nicht öffentlich, und der Aufrufer besitzt keine <ph id="ph2">&lt;see cref="T:System.Security.Permissions.ReflectionPermission" /&gt;</ph> zum Reflektieren nicht öffentlicher Objekte außerhalb der aktuellen Assembly.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the specified type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und der angegebene Typ wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>Returns all the classes defined within this module.</source>
          <target state="translated">Gibt alle in diesem Modul definierten Klassen zurück.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>An array that contains the types defined within the module that is reflected by this instance.</source>
          <target state="translated">Ein Array, das die Typen enthält, die in dem durch diese Instanz reflektierten Modul definiert sind.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source><ph id="ph1">`ReflectionTypeLoadException`</ph> is a special class load exception.</source>
          <target state="translated"><ph id="ph1">`ReflectionTypeLoadException`</ph> ist eine besondere Klasse Load-Ausnahme.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>The <ph id="ph1">`ReflectionTypeLoadException.Types`</ph> property contains the array of classes that were defined in the module and loaded.</source>
          <target state="translated">Die <ph id="ph1">`ReflectionTypeLoadException.Types`</ph> -Eigenschaft enthält das Array von Klassen, die im Modul definiert und geladen wurden.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>This array can contain some null values.</source>
          <target state="translated">Dieses Array kann einige null-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>The <ph id="ph1">`ReflectionTypeLoadException.LoaderExceptions`</ph> property is an array of exceptions that represent the exceptions that were thrown by the class loader.</source>
          <target state="translated">Die <ph id="ph1">`ReflectionTypeLoadException.LoaderExceptions`</ph> Eigenschaft ist ein Array von Ausnahmen, die Ausnahmen darstellen, die vom Klassenladeprogramm ausgelöst wurden.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>The holes in the class array line up with the exceptions.</source>
          <target state="translated">Richten Sie die Lücken in der Klasse Array mit den Ausnahmen.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>For example, if the class initializers of one of the classes throws an exception while it is being loaded, a <ph id="ph1">`TargetInvocationException`</ph> is stored in the corresponding element of the <ph id="ph2">`LoaderExceptions`</ph> array.</source>
          <target state="translated">Z. B. wenn eine der Klassen der Klasseninitialisierer löst eine Ausnahme während der es wird geladen, eine <ph id="ph1">`TargetInvocationException`</ph> befindet sich in dem entsprechenden Element des der <ph id="ph2">`LoaderExceptions`</ph> Array.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>One or more classes in a module could not be loaded.</source>
          <target state="translated">Mindestens eine Klasse in einem Modul konnte nicht geladen werden.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypes">
          <source>The caller does not have the required permission.</source>
          <target state="translated">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Returns a type token.</source>
          <target state="translated">Gibt ein Typtoken zurück.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source>The name of the class, including the namespace.</source>
          <target state="translated">Der Name der Klasse, einschließlich Namespace.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source>Returns the token used to identify the type with the specified name.</source>
          <target state="translated">Gibt das Token zurück, das zur Bezeichnung des Typs mit dem angegebenen Namen verwendet wird.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source>The token used to identify the type with the specified name within this module.</source>
          <target state="translated">Das Token, mit dem der Typ mit dem angegebenen Namen in diesem Modul bezeichnet wird.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source>This method is useful for clients of the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodRental&gt;</ph> class who want to directly modify the body of a method.</source>
          <target state="translated">Diese Methode eignet sich für Clients die <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodRental&gt;</ph> Klasse, die auf den Text einer Methode nicht direkt ändern möchten.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is the empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist die leere Zeichenfolge ("").</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> represents a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> stellt einen <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph>-Typ dar.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source>The type specified by <ph id="ph1">&lt;paramref name="name" /&gt;</ph> could not be found.</source>
          <target state="translated">Der durch <ph id="ph1">&lt;paramref name="name" /&gt;</ph> angegebene Typ konnte nicht gefunden werden.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)">
          <source>This is a non-transient module that references a transient module.</source>
          <target state="translated">Dies ist ein dauerhaftes Modul, das auf ein flüchtiges Modul verweist.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source>The type object that represents the class type.</source>
          <target state="translated">Das Typobjekt, das den Klassentyp darstellt.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source>Returns the token used to identify the specified type within this module.</source>
          <target state="translated">Gibt das Token zurück, mit dem der angegebene Typ in diesem Modul bezeichnet wird.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source>The token used to identify the given type within this module.</source>
          <target state="translated">Das Token, mit dem der angegebene Typ in diesem Modul bezeichnet wird.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source>Tokens are used in Microsoft intermediate language (MSIL) instructions to identify objects.</source>
          <target state="translated">Token werden in Microsoft intermediate Language (MSIL)-Anweisungen verwendet, um Objekte zu identifizieren.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source>Tokens are relative to the module in which they are contained.</source>
          <target state="translated">Token sind relativ zu dem Modul, in dem sie enthalten sind.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source>For example, the token value for <ph id="ph1">`String`</ph> is likely to be different from module to module.</source>
          <target state="translated">Z. B. den Tokenwert für <ph id="ph1">`String`</ph> ist es wahrscheinlich, dass von einem Modul zu unterscheiden.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source>When <ph id="ph1">`GetTypeToken`</ph> is invoked, a reference is added to the module.</source>
          <target state="translated">Wenn <ph id="ph1">`GetTypeToken`</ph> wird aufgerufen, wird ein Verweis auf das Modul hinzugefügt.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source>The reference becomes a permanent part of the module; multiple calls with the same argument have no additional effect.</source>
          <target state="translated">Der Verweis wird einem dauerhaften Bestandteil des Moduls. mehrere Aufrufe mit dem gleichen Argument haben keine weitere Auswirkung.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist ein <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph>-Typ.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)">
          <source>This is a non-transient module that references a transient module.</source>
          <target state="translated">Dies ist ein dauerhaftes Modul, das auf ein flüchtiges Modul verweist.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
          <source>The type of custom attribute to test for.</source>
          <target state="translated">Der Typ des benutzerdefinierten Attributs, auf das getestet werden soll.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
          <source>This argument is ignored for objects of this type.</source>
          <target state="translated">Dieses Argument wird für Objekte dieses Typs ignoriert.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Returns a value that indicates whether the specified attribute type has been applied to this module.</source>
          <target state="translated">Gibt einen Wert zurück, der angibt, ob der angegebene Attributtyp auf dieses Modul angewendet wurde.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if one or more instances of <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph> have been applied to this module; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn eine oder mehrere Instanzen von <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph> auf dieses Modul angewendet werden, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object supplied by the runtime.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> ist kein von der Laufzeit angegebenes <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)">
          <source>For example, <ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is a <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> ist beispielsweise ein <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsResource">
          <source>Gets a value indicating whether the object is a resource.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob das Objekt eine Ressource ist.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsResource">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the object is a resource; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn das Objekt eine Ressource ist, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsTransient">
          <source>Returns a value that indicates whether this dynamic module is transient.</source>
          <target state="translated">Gibt einen Wert zurück, der angibt, ob dieses dynamische Modul flüchtig ist.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.IsTransient">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this dynamic module is transient; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn dieses dynamische Modul flüchtig ist, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion">
          <source>Gets the metadata stream version.</source>
          <target state="translated">Ruft die Metadatenstreamversion ab.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion">
          <source>A 32-bit integer representing the metadata stream version.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl, die die Metadatenstreamversion darstellt.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion">
          <source>The high-order two bytes represent the major version number, and the low-order two bytes represent the minor version number.</source>
          <target state="translated">Die beiden höherwertigen Bytes stellen die Hauptversionsnummer dar und die beiden niederwertigen Bytes die Nebenversionsnummer.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion">
          <source>For more information on the metadata header, see "Partition II: Metadata Definition and Semantics" in the Common Language Infrastructure (CLI) documentation.</source>
          <target state="translated">Weitere Informationen zu den Metadatenheader finden Sie unter "Partition II: Metadata Definition and Semantics" in der Dokumentation für die Common Language Infrastructure (CLI).</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. finden Sie unter <bpt id="p1">[</bpt>ECMA c# and Common Language Infrastructure-Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> der ECMA-Website.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ModuleBuilder.MetadataToken">
          <source>Gets a token that identifies the current dynamic module in metadata.</source>
          <target state="translated">Ruft ein Token ab, das das aktuelle dynamische Modul in den Metadaten angibt.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.MetadataToken">
          <source>An integer token that identifies the current module in metadata.</source>
          <target state="translated">Ein Ganzzahltoken, das das aktuelle Modul in den Metadaten angibt.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.MetadataToken">
          <source>The tokens obtained using this property can be passed to the unmanaged Reflection API.</source>
          <target state="translated">Das Token mit dieser Eigenschaft können auf der nicht verwalteten Reflektions-API übergeben werden.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.MetadataToken">
          <source>For more information, see <bpt id="p1">[</bpt>Unmanaged Reflection API<ept id="p1">](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>nicht verwalteten Reflektions-API<ept id="p1">](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)</ept>.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.MetadataToken">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.MetadataToken">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. finden Sie unter <bpt id="p1">[</bpt>ECMA c# and Common Language Infrastructure-Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> der ECMA-Website.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId">
          <source>Gets a universally unique identifier (UUID) that can be used to distinguish between two versions of a module.</source>
          <target state="translated">Ruft einen universellen eindeutigen Bezeichner (Universally Unique Identifier, UUID) ab, der zur Unterscheidung zwischen zwei Versionen eines Moduls verwendet werden kann.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId">
          <source>A <ph id="ph1">&lt;see cref="T:System.Guid" /&gt;</ph> that can be used to distinguish between two versions of a module.</source>
          <target state="translated">Eine <ph id="ph1">&lt;see cref="T:System.Guid" /&gt;</ph>, die zur Unterscheidung zwischen zwei Versionen eines Moduls verwendet werden kann.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId">
          <source>In unmanaged metadata, the GUID returned by the <ph id="ph1">&lt;xref:System.Reflection.Module.ModuleVersionId%2A&gt;</ph> property is referred to as the <ph id="ph2">`mvid`</ph>, and is stored in the GUID heap.</source>
          <target state="translated">In nicht verwalteten Metadaten, die GUID zurückgegeben, indem Sie die <ph id="ph1">&lt;xref:System.Reflection.Module.ModuleVersionId%2A&gt;</ph> Eigenschaft wird als bezeichnet den <ph id="ph2">`mvid`</ph>, und im GUID-Heap gespeichert wird.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId">
          <source>More information about metadata can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Weitere Informationen zu Metadaten kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. finden Sie unter <bpt id="p1">[</bpt>ECMA c# and Common Language Infrastructure-Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> der ECMA-Website.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ModuleBuilder.Name">
          <source>A string that indicates that this is an in-memory module.</source>
          <target state="translated">Eine Zeichenfolge, die angibt, dass es sich um ein speicherinternes Modul handelt.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.Name">
          <source>Text that indicates that this is an in-memory module.</source>
          <target state="translated">Text, der angibt, dass es sich um ein speicherinternes Modul handelt.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.Name">
          <source>The name of a dynamic module cannot be obtained until the module has been saved and reloaded from disk.</source>
          <target state="translated">Der Name der ein dynamisches Modul konnte nicht ermittelt werden, bis das Modul gespeichert und vom Datenträger neu geladen wurde.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a field in the module.</source>
          <target state="translated">Ein Metadatentoken, das ein Feld im Modul angibt.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, die die generischen Typargumente des Typs darstellen, in dessen Gültigkeitsbereich sich das Token befindet, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn dieser Typ nicht generisch ist.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, die die generischen Typargumente der Methode darstellen, in deren Gültigkeitsbereich sich das Token befindet, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn diese Methode nicht generisch ist.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Returns the field identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Gibt das vom angegebenen Metadatentoken angegebene Feld im von den angegebenen generischen Typparametern definierten Kontext zurück.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> object representing the field that is identified by the specified metadata token.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>-Objekt, das das durch das angegebene Metadatentoken angegebene Feld darstellt.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> -Methode des Typs, in dem <ph id="ph2">`metadataToken`</ph> befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> Methode für die Methode, in denen <ph id="ph2">`metadataToken`</ph> befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">Es ist immer sicher, diese Argumente bereitzustellen, auch wenn sie nicht benötigt werden.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. finden Sie unter <bpt id="p1">[</bpt>ECMA c# and Common Language Infrastructure-Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> der ECMA-Website.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Code, der demonstriert das Auflösen von token mithilfe des generische Kontexts (d. h. die generischen Typparameter der generischen Typs und/oder der generischen Methode, die in der das Token eingebettet ist) finden Sie unter der <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a field in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Bereich des aktuellen Moduls kein Token für ein Feld.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifies a field whose parent <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> has a signature containing element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> gibt ein Feld an, dessen übergeordnete <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> eine Signatur mit Elementtyp <ph id="ph3">&lt;see langword="var" /&gt;</ph> (Typparameter eines generischen Typs) oder <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (Typparameter einer generischen Methode) aufweist, und die erforderlichen Argumente des generischen Typs wurden nicht für <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> und/oder <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph> angegeben.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Bereich des aktuellen Moduls kein gültiges Token.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a type or member in the module.</source>
          <target state="translated">Ein Metadatentoken, das einen Typ oder Member im Modul angibt.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, die die generischen Typargumente des Typs darstellen, in dessen Gültigkeitsbereich sich das Token befindet, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn dieser Typ nicht generisch ist.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, die die generischen Typargumente der Methode darstellen, in deren Gültigkeitsbereich sich das Token befindet, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn diese Methode nicht generisch ist.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Returns the type or member identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Gibt den vom angegebenen Metadatentoken angegebenen Typ oder Member im von den angegebenen generischen Typparametern definierten Kontext zurück.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> object representing the type or member that is identified by the specified metadata token.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>-Objekt, das den Typ oder Member darstellt, der vom angegebenen Metadatentoken angegeben wird.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> -Methode des Typs, in dem <ph id="ph2">`metadataToken`</ph> befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> Methode für die Methode, in denen <ph id="ph2">`metadataToken`</ph> befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">Es ist immer sicher, diese Argumente bereitzustellen, auch wenn sie nicht benötigt werden.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. finden Sie unter <bpt id="p1">[</bpt>ECMA c# and Common Language Infrastructure-Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> der ECMA-Website.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Code, der demonstriert das Auflösen von token mithilfe des generische Kontexts (d. h. die generischen Typparameter der generischen Typs und/oder der generischen Methode, die in der das Token eingebettet ist) finden Sie unter der <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a type or member in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Gültigkeitsbereich des aktuellen Moduls kein Token für einen Typ oder Member.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> or <ph id="ph3">&lt;see langword="TypeSpec" /&gt;</ph> whose signature contains element type <ph id="ph4">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph5">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph6">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph7">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist eine <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> oder eine <ph id="ph3">&lt;see langword="TypeSpec" /&gt;</ph>, deren Signatur Elementtyp <ph id="ph4">&lt;see langword="var" /&gt;</ph> (Typparameter eines generischen Typs) oder <ph id="ph5">&lt;see langword="mvar" /&gt;</ph> (Typparameter einer generischen Methode) enthält, und die erforderlichen Argumente des generischen Typs wurden nicht für <ph id="ph6">&lt;paramref name="genericTypeArguments" /&gt;</ph> und/oder <ph id="ph7">&lt;paramref name="genericMethodArguments" /&gt;</ph> angegeben.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> identifies a property or event.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> gibt eine Eigenschaft oder ein Ereignis an.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Bereich des aktuellen Moduls kein gültiges Token.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a method or constructor in the module.</source>
          <target state="translated">Ein Metadatentoken, das eine Methode oder einen Konstruktor im Modul identifiziert.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, die die generischen Typargumente des Typs darstellen, in dessen Gültigkeitsbereich sich das Token befindet, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn dieser Typ nicht generisch ist.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, die die generischen Typargumente der Methode darstellen, in deren Gültigkeitsbereich sich das Token befindet, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn diese Methode nicht generisch ist.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Returns the method or constructor identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Gibt die vom angegebenen Metadatentoken angegebene Methode oder den vom angegebenen Metadatentoken angegebenen Konstruktor im von den angegebenen generischen Typparametern definierten Kontext zurück.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object representing the method that is identified by the specified metadata token.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph>-Objekt, das die Methode darstellt, die durch das angegebene Metadatentoken angegeben wird.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> -Methode des Typs, in dem <ph id="ph2">`metadataToken`</ph> befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericMethodArguments`</ph>.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> Methode für die Methode, in denen <ph id="ph2">`metadataToken`</ph> befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für <ph id="ph3">`genericMethodArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">Es ist immer sicher, diese Argumente bereitzustellen, auch wenn sie nicht benötigt werden.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. finden Sie unter <bpt id="p1">[</bpt>ECMA c# and Common Language Infrastructure-Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> der ECMA-Website.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Code, der demonstriert das Auflösen von token mithilfe des generische Kontexts (d. h. die generischen Typparameter der generischen Typs und/oder der generischen Methode, die in der das Token eingebettet ist) finden Sie unter der <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a method or constructor in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Bereich des aktuellen Moduls kein Token für eine Methode oder einen Konstruktor.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph> whose signature contains element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist eine <ph id="ph2">&lt;see langword="MethodSpec" /&gt;</ph>, deren Signatur Elementtyp <ph id="ph3">&lt;see langword="var" /&gt;</ph> (Typparameter eines generischen Typs) oder <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (Typparameter einer generischen Methode) enthält, und die erforderlichen Argumente des generischen Typs wurden für <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> und/oder <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph> nicht angegeben.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Bereich des aktuellen Moduls kein gültiges Token.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
          <source>A metadata token that identifies a signature in the module.</source>
          <target state="translated">Ein Metadatentoken, das eine Signatur im Modul angibt.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
          <source>Returns the signature blob identified by a metadata token.</source>
          <target state="translated">Gibt das von einem Metadatentoken angegebene Signatur-BLOB zurück.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
          <source>An array of bytes representing the signature blob.</source>
          <target state="translated">Ein Bytearray, das den Signatur-BLOB darstellt.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
          <source>Information about metadata tokens and signatures can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informationen zum Metadatentoken und Signaturen kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. finden Sie unter <bpt id="p1">[</bpt>ECMA c# and Common Language Infrastructure-Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> der ECMA-Website.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid <ph id="ph2">&lt;see langword="MemberRef" /&gt;</ph>, <ph id="ph3">&lt;see langword="MethodDef" /&gt;</ph>, <ph id="ph4">&lt;see langword="TypeSpec" /&gt;</ph>, signature, or <ph id="ph5">&lt;see langword="FieldDef" /&gt;</ph> token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist keine gültige <ph id="ph2">&lt;see langword="MemberRef" /&gt;</ph>, <ph id="ph3">&lt;see langword="MethodDef" /&gt;</ph>, <ph id="ph4">&lt;see langword="TypeSpec" /&gt;</ph> oder Signatur bzw. kein gültiges <ph id="ph5">&lt;see langword="FieldDef" /&gt;</ph>-Token im Bereich des aktuellen Moduls.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Bereich des aktuellen Moduls kein gültiges Token.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
          <source>A metadata token that identifies a string in the string heap of the module.</source>
          <target state="translated">Ein Metadatentoken, das eine Zeichenfolge im Zeichenfolgenheap des Moduls angibt.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
          <source>Returns the string identified by the specified metadata token.</source>
          <target state="translated">Gibt die vom angegebenen Metadatentoken angegebene Zeichenfolge zurück.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing a string value from the metadata string heap.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, der einen Zeichenfolgenwert aus dem Metadaten-Zeichenfolgenheap enthält.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. finden Sie unter <bpt id="p1">[</bpt>ECMA c# and Common Language Infrastructure-Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> der ECMA-Website.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a string in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Gültigkeitsbereich des aktuellen Moduls kein Token für eine Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Bereich des aktuellen Moduls kein gültiges Token.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>A metadata token that identifies a type in the module.</source>
          <target state="translated">Ein Metadatentoken, das einen Typ im Modul identifiziert.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the type where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that type is not generic.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, die die generischen Typargumente des Typs darstellen, in dessen Gültigkeitsbereich sich das Token befindet, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn dieser Typ nicht generisch ist.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the generic type arguments of the method where the token is in scope, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if that method is not generic.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, die die generischen Typargumente der Methode darstellen, in deren Gültigkeitsbereich sich das Token befindet, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn diese Methode nicht generisch ist.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Returns the type identified by the specified metadata token, in the context defined by the specified generic type parameters.</source>
          <target state="translated">Gibt den vom angegebenen Metadatentoken angegebenen Typ im von den angegebenen generischen Typparametern definierten Kontext zurück.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the type that is identified by the specified metadata token.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt, das den Typ darstellt, der durch das angegebene Metadatentoken angegeben wird.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the type where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> -Methode des Typs, in dem <ph id="ph2">`metadataToken`</ph> befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method on the method where <ph id="ph2">`metadataToken`</ph> is in scope to obtain an array of generic type arguments for <ph id="ph3">`genericTypeArguments`</ph>.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> Methode für die Methode, in denen <ph id="ph2">`metadataToken`</ph> befindet sich im Bereich zum Abrufen eines Arrays von generischen Typargumenten für <ph id="ph3">`genericTypeArguments`</ph>.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>It is always safe to provide these arguments, even when they are not needed.</source>
          <target state="translated">Es ist immer sicher, diese Argumente bereitzustellen, auch wenn sie nicht benötigt werden.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Informationen zum Metadatentoken kann in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics" gefunden werden.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the ECMA Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. finden Sie unter <bpt id="p1">[</bpt>ECMA c# and Common Language Infrastructure-Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> der ECMA-Website.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Code, der demonstriert das Auflösen von token mithilfe des generische Kontexts (d. h. die generischen Typparameter der generischen Typs und/oder der generischen Methode, die in der das Token eingebettet ist) finden Sie unter der <ph id="ph1">&lt;xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a token for a type in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Bereich des aktuellen Moduls kein Token für einen Typ.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is a <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph> whose signature contains element type <ph id="ph3">&lt;see langword="var" /&gt;</ph> (a type parameter of a generic type) or <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> and <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist eine <ph id="ph2">&lt;see langword="TypeSpec" /&gt;</ph>, deren Signatur Elementtyp <ph id="ph3">&lt;see langword="var" /&gt;</ph> (Typparameter eines generischen Typs) oder <ph id="ph4">&lt;see langword="mvar" /&gt;</ph> (Typparameter einer generischen Methode) enthält, und die erforderlichen Argumente des generischen Typs wurden für <ph id="ph5">&lt;paramref name="genericTypeArguments" /&gt;</ph> und/oder <ph id="ph6">&lt;paramref name="genericMethodArguments" /&gt;</ph> nicht angegeben.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])">
          <source><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> is not a valid token in the scope of the current module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="metadataToken" /&gt;</ph> ist im Bereich des aktuellen Moduls kein gültiges Token.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.ModuleBuilder.ScopeName">
          <source>Gets a string that represents the name of the dynamic module.</source>
          <target state="translated">Ruft eine Zeichenfolge ab, die den Namen des dynamischen Moduls darstellt.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.ModuleBuilder.ScopeName">
          <source>The name of the dynamic module.</source>
          <target state="translated">Der Name des dynamischen Moduls.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.ModuleBuilder">
          <source>Applies a custom attribute to this module.</source>
          <target state="translated">Wendet ein benutzerdefiniertes Attribut auf dieses Modul an.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>An instance of a helper class that specifies the custom attribute to apply.</source>
          <target state="translated">Eine Instanz einer Hilfsklasse, die das anzuwendende benutzerdefinierte Attribut angibt.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>Applies a custom attribute to this module by using a custom attribute builder.</source>
          <target state="translated">Wendet ein benutzerdefiniertes Attribut auf dieses Modul an, indem ein Generator für benutzerdefinierte Attribute verwendet wird.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source><ph id="ph1">&lt;paramref name="customBuilder" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="customBuilder" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The constructor for the custom attribute.</source>
          <target state="translated">Der Konstruktor für das benutzerdefinierte Attribut.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>A byte BLOB representing the attribute.</source>
          <target state="translated">Ein Byte-BLOB, das das Attribut darstellt.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>Applies a custom attribute to this module by using a specified binary large object (BLOB) that represents the attribute.</source>
          <target state="translated">Wendet ein benutzerdefiniertes Attribut auf dieses Modul an, indem ein angegebenes BLOB (Binary Large Object) verwendet wird, das das Attribut darstellt.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>For more information about how to format <ph id="ph1">`binaryAttribute`</ph>, see the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Weitere Informationen zum Formatieren <ph id="ph1">`binaryAttribute`</ph>, finden Sie in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics".</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. Sie finden sie unter <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> auf der Ecma International-Website.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="con" /&gt;</ph> or <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="con" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph> ist <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>The name of the custom attribute</source>
          <target state="translated">Der Name des benutzerdefinierten Attributs.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>An opaque binary large object (BLOB) of bytes that represents the value of the custom attribute.</source>
          <target state="translated">Ein nicht transparentes BLOB (Binary Large Object) von Bytes, das den Wert des benutzerdefinierten Attributs darstellt.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>This method does nothing.</source>
          <target state="translated">Diese Methode hat keine Funktion.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>This method does nothing.</source>
          <target state="translated">Diese Methode hat keine Funktion.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetSymCustomAttribute(System.String,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="url" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="url" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source>The user entry point.</source>
          <target state="translated">Der Einstiegspunkt für Benutzer.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source>Sets the user entry point.</source>
          <target state="translated">Legt den Einstiegspunkt für Benutzer fest.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source>The compiler might generate a startup stub before calling user main.</source>
          <target state="translated">Der Compiler möglicherweise einen Startstub vor dem Aufrufen der wichtigsten Benutzer generieren.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source>The startup stub will be the entry point.</source>
          <target state="translated">Die Startstub wird der Einstiegspunkt sein.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source>While the user main will be the user entry point so that debugger will not step into the compiler entry point.</source>
          <target state="translated">Während der Benutzer, die wichtigsten, damit der Debugger den Einstiegspunkt der Compiler nicht schrittweise wird benutzerdefinierter Einstiegspunkt kann.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="entryPoint" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="entryPoint" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source>This method is called on a dynamic module that is not a debug module.</source>
          <target state="translated">Diese Methode wird für ein dynamisches Modul aufgerufen, das kein Debug-Modul ist.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="entryPoint" /&gt;</ph> is not contained in this dynamic module.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="entryPoint" /&gt;</ph> ist nicht in diesem dynamischen Modul enthalten.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Für zukünftige Verwendung reserviert.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Muss IID_NULL sein.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Das übergebene Array von zuzuordnenden Namen.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Die Anzahl der zuzuordnenden Namen.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">Der Gebietsschemakontext, in dem die Namen interpretiert werden sollen.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">Das vom Aufrufer zugewiesene Array, das die IDs entsprechend den Namen empfängt.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" /&gt;</ph>.</source>
          <target state="translated">Eine Beschreibung dieses Elements finden Sie unter <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Weitere Informationen zu <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, finden Sie in der MSDN Library.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._ModuleBuilder&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.Runtime.InteropServices._ModuleBuilder&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The method is called late-bound using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface.</source>
          <target state="translated">Die Methode wird unter Verwendung der <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept>-Schnittstelle in COM mit spät gebundenem Zugriff aufgerufen.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">Die zurückzugebenden Typinformationen.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">Der Gebietsschemabezeichner für die Typinformationen.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>A pointer to the requested type information object.</source>
          <target state="translated">Ein Zeiger auf das angeforderte Objekt mit den Typinformationen.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" /&gt;</ph>.</source>
          <target state="translated">Eine Beschreibung dieses Elements finden Sie unter <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Weitere Informationen zu <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, finden Sie in der MSDN Library.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._ModuleBuilder&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.Runtime.InteropServices._ModuleBuilder&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The method is called late-bound using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface.</source>
          <target state="translated">Die Methode wird unter Verwendung der <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept>-Schnittstelle in COM mit spät gebundenem Zugriff aufgerufen.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>The location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Der Speicherort, der die Anzahl der Schnittstellen mit Typinformationen empfängt, die vom Objekt bereitgestellt werden.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount(System.UInt32@)" /&gt;</ph>.</source>
          <target state="translated">Eine Beschreibung dieses Elements finden Sie unter <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount(System.UInt32@)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Weitere Informationen zu <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, finden Sie in der MSDN Library.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._ModuleBuilder&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.Runtime.InteropServices._ModuleBuilder&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>The method is called late-bound using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface.</source>
          <target state="translated">Die Methode wird unter Verwendung der <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept>-Schnittstelle in COM mit spät gebundenem Zugriff aufgerufen.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The member ID.</source>
          <target state="translated">Die Member-ID.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Für zukünftige Verwendung reserviert.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Muss IID_NULL sein.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">Der Gebietsschemakontext, in dem Argumente interpretiert werden sollen.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Flags, die den Kontext des Aufrufs beschreiben.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Ein Zeiger auf eine Struktur, die ein Array von Argumenten und ein Array von Argument-DISPIDs für benannte Argumente sowie Zähler für die Anzahl der Elemente in jedem Array enthält.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Ein Verweis auf den Speicherort, an dem das Ergebnis gespeichert werden soll.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Ein Zeiger auf eine Struktur mit Ausnahmeinformationen.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">Der Index des ersten Arguments mit einem Fehler.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._ModuleBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" /&gt;</ph>.</source>
          <target state="translated">Eine Beschreibung dieses Elements finden Sie unter <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._ModuleBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Weitere Informationen zu <ph id="ph1">`IDispatch::Invoke`</ph>, finden Sie in der MSDN Library.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._ModuleBuilder&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.Reflection.Emit.ModuleBuilder&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.Runtime.InteropServices._ModuleBuilder&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The method is called late-bound using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface.</source>
          <target state="translated">Die Methode wird unter Verwendung der <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept>-Schnittstelle in COM mit spät gebundenem Zugriff aufgerufen.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>