<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="76cf31c35ad94a83719988c90e476ffdd459c191" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75169332" /></Metadata><TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="3bd02-101">Stellt Felddarstellungen der MSIL (Microsoft Intermediate Language)-Anweisungen für die Ausgabe durch die <see cref="T:System.Reflection.Emit.ILGenerator" />-Klassenmember bereit, beispielsweise <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />.</span><span class="sxs-lookup"><span data-stu-id="3bd02-101">Provides field representations of the Microsoft Intermediate Language (MSIL) instructions for emission by the <see cref="T:System.Reflection.Emit.ILGenerator" /> class members (such as <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />).</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-102">Eine ausführliche Beschreibung der Member-Opcodes finden Sie in der Common Language Infrastructure (CLI)-Dokumentation, insbesondere "Partition III: CIL Instruction Set" und "Partition II: Metadata Definition and Semantics".</span><span class="sxs-lookup"><span data-stu-id="3bd02-102">For a detailed description of the member opcodes, see the Common Language Infrastructure (CLI) documentation, especially "Partition III: CIL Instruction Set" and "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="3bd02-103">Die Dokumentation ist online verfügbar. Sie finden sie unter [ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)](https://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))](https://go.microsoft.com/fwlink/?LinkID=65552) auf der Ecma International-Website.</span><span class="sxs-lookup"><span data-stu-id="3bd02-103">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3bd02-104">Das folgende Beispiel veranschaulicht die Erstellung einer dynamischen Methode mithilfe von <xref:System.Reflection.Emit.ILGenerator>, um `OpCodes` in einem <xref:System.Reflection.Emit.MethodBuilder>auszugeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-104">The following example demonstrates the construction of a dynamic method using <xref:System.Reflection.Emit.ILGenerator> to emit `OpCodes` into a <xref:System.Reflection.Emit.MethodBuilder>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-105">Addiert zwei Werte und legt das Ergebnis auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-105">Adds two values and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-106">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-106">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-107">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-107">Format</span></span>|<span data-ttu-id="3bd02-108">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-108">Assembly Format</span></span>|<span data-ttu-id="3bd02-109">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-109">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-110">58</span><span class="sxs-lookup"><span data-stu-id="3bd02-110">58</span></span>|<span data-ttu-id="3bd02-111">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-111">add</span></span>|<span data-ttu-id="3bd02-112">Fügt zwei numerische Werte hinzu und gibt einen neuen numerischen Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="3bd02-112">Adds two numeric values, returning a new numeric value.</span></span>|  
  
 <span data-ttu-id="3bd02-113">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-113">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-114">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-114">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-115">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-115">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-116">`value2` und `value1` werden aus dem Stapel entfernt. `value1` wird `value2`hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-116">`value2` and `value1` are popped from the stack; `value1` is added to `value2`.</span></span>  
  
4.  <span data-ttu-id="3bd02-117">Das Ergebnis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-117">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-118">Ein Überlauf für ganzzahlige Vorgänge wird nicht erkannt (für eine ordnungsgemäße Überlauf Behandlung finden Sie unter <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).</span><span class="sxs-lookup"><span data-stu-id="3bd02-118">Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).</span></span>  
  
 <span data-ttu-id="3bd02-119">Ganzzahlige Addition umbrochen und nicht als ganze Zahl.</span><span class="sxs-lookup"><span data-stu-id="3bd02-119">Integer addition wraps, rather than saturates.</span></span> <span data-ttu-id="3bd02-120">Beispiel: bei 8-Bit-Ganzzahlen, bei denen `value1` auf 255 und `value2` auf 1 festgelegt ist, ist das umschließende Ergebnis 0 (null) und nicht 256.</span><span class="sxs-lookup"><span data-stu-id="3bd02-120">For example, assuming 8-bit integers where `value1` is set to 255 and `value2` is set to 1, the wrapped result is 0 rather than 256.</span></span>  
  
 <span data-ttu-id="3bd02-121">Gleit Komma Überlauf gibt `+inf` (`PositiveInfinity`) oder `-inf` (`NegativeInfinity`) zurück.</span><span class="sxs-lookup"><span data-stu-id="3bd02-121">Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`).</span></span>  
  
 <span data-ttu-id="3bd02-122">Die zulässigen Operanden Typen und deren zugehöriger Ergebnis Datentyp sind in der folgenden Tabelle aufgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-122">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="3bd02-123">Wenn es keinen Eintrag für eine bestimmte Typkombination gibt (z. b. `int32` und `float`; `int32` und `int64`), handelt es sich um eine ungültige MSIL (Microsoft Intermediate Language) und generiert einen Fehler.</span><span class="sxs-lookup"><span data-stu-id="3bd02-123">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) and generates an error.</span></span>  
  
|<span data-ttu-id="3bd02-124">Operand</span><span class="sxs-lookup"><span data-stu-id="3bd02-124">operand</span></span>|<span data-ttu-id="3bd02-125">value1-Typ</span><span class="sxs-lookup"><span data-stu-id="3bd02-125">value1 type</span></span>|<span data-ttu-id="3bd02-126">Value2-Typ</span><span class="sxs-lookup"><span data-stu-id="3bd02-126">value2 type</span></span>|<span data-ttu-id="3bd02-127">Ergebnistyp</span><span class="sxs-lookup"><span data-stu-id="3bd02-127">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="3bd02-128">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-128">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="3bd02-129">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-129">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="3bd02-130">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-130">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="3bd02-131">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-131">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="3bd02-132">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-132">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="3bd02-133">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-133">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="3bd02-134">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-134">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="3bd02-135">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-135">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="3bd02-136">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-136">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="3bd02-137">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-137">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="3bd02-138">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-138">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="3bd02-139">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-139">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="3bd02-140">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-140">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="3bd02-141">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-141">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="3bd02-142">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `add` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-142">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-143">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-143">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-144">Addiert zwei ganze Zahlen, führt eine Überlaufprüfung durch und legt das Ergebnis auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-144">Adds two integers, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-145">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-145">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-146">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-146">Format</span></span>|<span data-ttu-id="3bd02-147">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-147">Assembly Format</span></span>|<span data-ttu-id="3bd02-148">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-148">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-149">D6</span><span class="sxs-lookup"><span data-stu-id="3bd02-149">D6</span></span>|<span data-ttu-id="3bd02-150">add.ovf</span><span class="sxs-lookup"><span data-stu-id="3bd02-150">add.ovf</span></span>|<span data-ttu-id="3bd02-151">Fügt mit einer Überlauf Überprüfung zwei ganzzahlige Werte mit Vorzeichen hinzu.</span><span class="sxs-lookup"><span data-stu-id="3bd02-151">Adds two signed integer values with an overflow check.</span></span>|  
  
 <span data-ttu-id="3bd02-152">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-152">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-153">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-153">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-154">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-154">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-155">`value2` und `value1` werden aus dem Stapel entfernt. `value1` wird `value2` mit einer Überprüfung auf Überlauf hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-155">`value2` and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="3bd02-156">Das Ergebnis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-156">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-157"><xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-157"><xref:System.OverflowException> is thrown if the result is not represented in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-158">Sie können diesen Vorgang für ganze Zahlen mit Vorzeichen ausführen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-158">You can perform this operation on signed integers.</span></span> <span data-ttu-id="3bd02-159">Verwenden Sie für Gleit Komma Werte <xref:System.Reflection.Emit.OpCodes.Add>.</span><span class="sxs-lookup"><span data-stu-id="3bd02-159">For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.</span></span>  
  
 <span data-ttu-id="3bd02-160">Die zulässigen Operanden Typen und deren zugehöriger Ergebnis Datentyp sind in der folgenden Tabelle aufgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-160">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="3bd02-161">Wenn kein Eintrag für eine bestimmte Typkombination (z. b. `int32` und `float`; `int32` und `int64`) vorhanden ist, handelt es sich um eine ungültige MSIL-Anweisung (Microsoft Intermediate Language), und es wird ein Fehler generiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-161">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</span></span>  
  
|<span data-ttu-id="3bd02-162">Operand</span><span class="sxs-lookup"><span data-stu-id="3bd02-162">operand</span></span>|<span data-ttu-id="3bd02-163">value1-Typ</span><span class="sxs-lookup"><span data-stu-id="3bd02-163">value1 type</span></span>|<span data-ttu-id="3bd02-164">Value2-Typ</span><span class="sxs-lookup"><span data-stu-id="3bd02-164">value2 type</span></span>|<span data-ttu-id="3bd02-165">Ergebnistyp</span><span class="sxs-lookup"><span data-stu-id="3bd02-165">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="3bd02-166">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-166">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="3bd02-167">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-167">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="3bd02-168">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-168">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="3bd02-169">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-169">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="3bd02-170">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-170">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="3bd02-171">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-171">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="3bd02-172">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-172">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="3bd02-173">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-173">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="3bd02-174">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-174">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="3bd02-175">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-175">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="3bd02-176">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-176">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="3bd02-177">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-177">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="3bd02-178">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-178">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="3bd02-179">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-179">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="3bd02-180">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `add.ovf` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-180">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-181">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-181">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-182">Addiert zwei Ganzzahlwerte ohne Vorzeichen, führt eine Überlaufprüfung durch und legt das Ergebnis auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-182">Adds two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-183">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-183">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-184">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-184">Format</span></span>|<span data-ttu-id="3bd02-185">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-185">Assembly Format</span></span>|<span data-ttu-id="3bd02-186">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-186">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-187">D7</span><span class="sxs-lookup"><span data-stu-id="3bd02-187">D7</span></span>|<span data-ttu-id="3bd02-188">add.ovf.un</span><span class="sxs-lookup"><span data-stu-id="3bd02-188">add.ovf.un</span></span>|<span data-ttu-id="3bd02-189">Fügt zwei ganzzahlige Werte ohne Vorzeichen mit einer Überlauf Überprüfung hinzu.</span><span class="sxs-lookup"><span data-stu-id="3bd02-189">Adds two unsigned integer values with an overflow check.</span></span>|  
  
 <span data-ttu-id="3bd02-190">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-190">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-191">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-191">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-192">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-192">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-193">`value2` und `value1` werden aus dem Stapel entfernt. `value1` wird `value2` mit einer Überprüfung auf Überlauf hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-193">`value2` and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="3bd02-194">Das Ergebnis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-194">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-195"><xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-195"><xref:System.OverflowException> is thrown if the result is not represented in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-196">Sie können diesen Vorgang für ganze Zahlen mit Vorzeichen ausführen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-196">You can perform this operation on signed integers.</span></span> <span data-ttu-id="3bd02-197">Verwenden Sie für Gleit Komma Werte <xref:System.Reflection.Emit.OpCodes.Add>.</span><span class="sxs-lookup"><span data-stu-id="3bd02-197">For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.</span></span>  
  
 <span data-ttu-id="3bd02-198">Die zulässigen Operanden Typen und deren zugehöriger Ergebnis Datentyp sind in der folgenden Tabelle aufgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-198">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="3bd02-199">Wenn kein Eintrag für eine bestimmte Typkombination (z. b. `int32` und `float`; `int32` und `int64`) vorhanden ist, handelt es sich um eine ungültige MSIL-Anweisung (Microsoft Intermediate Language), und es wird ein Fehler generiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-199">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</span></span>  
  
|<span data-ttu-id="3bd02-200">Operand</span><span class="sxs-lookup"><span data-stu-id="3bd02-200">operand</span></span>|<span data-ttu-id="3bd02-201">value1-Typ</span><span class="sxs-lookup"><span data-stu-id="3bd02-201">value1 type</span></span>|<span data-ttu-id="3bd02-202">Value2-Typ</span><span class="sxs-lookup"><span data-stu-id="3bd02-202">value2 type</span></span>|<span data-ttu-id="3bd02-203">Ergebnistyp</span><span class="sxs-lookup"><span data-stu-id="3bd02-203">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="3bd02-204">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-204">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="3bd02-205">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-205">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="3bd02-206">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-206">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="3bd02-207">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-207">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="3bd02-208">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-208">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="3bd02-209">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-209">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="3bd02-210">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-210">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="3bd02-211">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-211">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="3bd02-212">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-212">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="3bd02-213">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-213">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="3bd02-214">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-214">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="3bd02-215">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-215">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="3bd02-216">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-216">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="3bd02-217">add</span><span class="sxs-lookup"><span data-stu-id="3bd02-217">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="3bd02-218">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `add.ovf.un` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-218">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-219">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-219">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-220">Berechnet das bitweise AND für zwei Werte und legt das Ergebnis auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-220">Computes the bitwise AND of two values and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-221">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-221">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-222">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-222">Format</span></span>|<span data-ttu-id="3bd02-223">Anweisung</span><span class="sxs-lookup"><span data-stu-id="3bd02-223">Instruction</span></span>|<span data-ttu-id="3bd02-224">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-224">Description</span></span>|  
|------------|-----------------|-----------------|  
|<span data-ttu-id="3bd02-225">5F</span><span class="sxs-lookup"><span data-stu-id="3bd02-225">5F</span></span>|<span data-ttu-id="3bd02-226">und</span><span class="sxs-lookup"><span data-stu-id="3bd02-226">and</span></span>|<span data-ttu-id="3bd02-227">Bestimmt das bitweise and von zwei ganzzahligen Werten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-227">Determines the bitwise AND of two integer values.</span></span>|  
  
 <span data-ttu-id="3bd02-228">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-228">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-229">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-229">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-230">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-230">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-231">`value1` und `value2` werden aus dem Stapel entfernt. das bitweise and der beiden Werte wird berechnet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-231">`value1` and `value2` are popped from the stack; the bitwise AND of the two values is computed.</span></span>  
  
4.  <span data-ttu-id="3bd02-232">Das Ergebnis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-232">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-233">Die `and`-Anweisung berechnet das bitweise and der obersten beiden Werte im Stapel und verlässt das Ergebnis auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-233">The `and` instruction computes the bitwise AND of the top two values on the stack and leaves the result on the stack.</span></span>  
  
 <span data-ttu-id="3bd02-234">`And` ist ein ganzzahliger spezifischer Vorgang.</span><span class="sxs-lookup"><span data-stu-id="3bd02-234">`And` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="3bd02-235">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `and` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-235">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `and` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-236">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-236">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-237">Gibt einen nicht verwalteten Zeiger auf die Argumentliste der aktuellen Methode zurück.</span><span class="sxs-lookup"><span data-stu-id="3bd02-237">Returns an unmanaged pointer to the argument list of the current method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-238">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-238">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-239">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-239">Format</span></span>|<span data-ttu-id="3bd02-240">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-240">Assembly Format</span></span>|<span data-ttu-id="3bd02-241">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-241">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-242">FE 00</span><span class="sxs-lookup"><span data-stu-id="3bd02-242">FE 00</span></span>|<span data-ttu-id="3bd02-243">Arglist</span><span class="sxs-lookup"><span data-stu-id="3bd02-243">arglist</span></span>|<span data-ttu-id="3bd02-244">Gibt ein Argumentlisten Handle für die aktuelle Methode zurück.</span><span class="sxs-lookup"><span data-stu-id="3bd02-244">Returns an argument list handle for the current method.</span></span>|  
  
 <span data-ttu-id="3bd02-245">Von diesem Vorgang werden keine Bewertungs Stapel Verhalten ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-245">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="3bd02-246">Die `arglist`-Anweisung gibt ein undurchsichtiges handle (ein nicht verwalteter Zeiger vom Typ `native int`) zurück, der die Argumentliste der aktuellen Methode darstellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-246">The `arglist` instruction returns an opaque handle (an unmanaged pointer, of type `native int`) that represents the argument list of the current method.</span></span> <span data-ttu-id="3bd02-247">Dieses Handle ist nur während der Lebensdauer der aktuellen Methode gültig.</span><span class="sxs-lookup"><span data-stu-id="3bd02-247">This handle is valid only during the lifetime of the current method.</span></span> <span data-ttu-id="3bd02-248">Sie können das Handle jedoch an andere Methoden übergeben, solange sich die aktuelle Methode im Steuerungs Thread befindet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-248">You can, however, pass the handle to other methods as long as the current method is on the thread of control.</span></span> <span data-ttu-id="3bd02-249">Sie können die `arglist`-Anweisung nur innerhalb einer Methode ausführen, die eine Variable Anzahl von Argumenten annimmt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-249">You can only execute the `arglist` instruction within a method that takes a variable number of arguments.</span></span>  
  
 <span data-ttu-id="3bd02-250">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `arglist` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-250">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `arglist` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-251">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-251">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-252">Überträgt die Steuerung an eine Zielanweisung, wenn zwei Werte übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-252">Transfers control to a target instruction if two values are equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-253">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-253">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-254">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-254">Format</span></span>|<span data-ttu-id="3bd02-255">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-255">Assembly Format</span></span>|<span data-ttu-id="3bd02-256">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-256">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-257">3B-< `int32` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-257">3B < `int32` ></span></span>|<span data-ttu-id="3bd02-258">beq-`target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-258">beq `target`</span></span>|<span data-ttu-id="3bd02-259">Verzweigt die Ziel Anweisung bei Offset `target`, wenn die beiden Werte gleich sind.</span><span class="sxs-lookup"><span data-stu-id="3bd02-259">Branch to the target instruction at offset `target` if the two values are equal.</span></span>|  
  
 <span data-ttu-id="3bd02-260">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-260">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-261">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-261">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-262">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-262">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-263">`value2` und `value1` werden aus dem Stapel entfernt. Wenn `value1` gleich `value2`ist, wird der Verzweigungs Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-263">`value2` and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="3bd02-264">Die `beq` Anweisung überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value1` gleich `value2`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-264">The `beq` instruction transfers control to the specified target instruction if `value1` is equal to `value2`.</span></span> <span data-ttu-id="3bd02-265">Der Effekt ist derselbe wie das Ausführen einer `ceq` Anweisung, gefolgt von einer `brtrue` Verzweigung zur spezifischen Ziel Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-265">The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="3bd02-266">Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-266">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-267">Die zulässigen Operanden Typen werden im folgenden dargestellt:</span><span class="sxs-lookup"><span data-stu-id="3bd02-267">The acceptable operand types are encapsulated below:</span></span>  
  
 <span data-ttu-id="3bd02-268">Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-268">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="3bd02-269">Steuerelement Übertragungen in und aus `try`-, `catch`-, `filter`-und `finally`-Blöcken können nicht von dieser Anweisung ausgeführt werden (solche Übertragungen sind stark eingeschränkt und müssen stattdessen die <xref:System.Reflection.Emit.OpCodes.Leave>-Anweisung verwenden).</span><span class="sxs-lookup"><span data-stu-id="3bd02-269">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead).</span></span>  
  
 <span data-ttu-id="3bd02-270">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `beq` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-270">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-271">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-271">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-272">Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn zwei Werte übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-272">Transfers control to a target instruction (short form) if two values are equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-273">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-273">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-274">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-274">Format</span></span>|<span data-ttu-id="3bd02-275">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-275">Assembly Format</span></span>|<span data-ttu-id="3bd02-276">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-276">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-277">2E < `int8` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-277">2E < `int8` ></span></span>|<span data-ttu-id="3bd02-278">beq. s `target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-278">beq.s `target`</span></span>|<span data-ttu-id="3bd02-279">Verzweigung zur Ziel Anweisung bei Offset `target` wenn gleich, Kurzform</span><span class="sxs-lookup"><span data-stu-id="3bd02-279">Branch to the target instruction at offset `target` if equal, short form</span></span>|  
  
 <span data-ttu-id="3bd02-280">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-280">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-281">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-281">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-282">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-282">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-283">`value2` und `value1` werden aus dem Stapel entfernt. Wenn `value1` gleich `value2`ist, wird der Verzweigungs Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-283">`value2` and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="3bd02-284">Die `beq.s` Anweisung überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value1` gleich `value2`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-284">The `beq.s` instruction transfers control to the specified target instruction if `value1` is equal to `value2`.</span></span> <span data-ttu-id="3bd02-285">Der Effekt ist derselbe wie das Ausführen einer `ceq` Anweisung, gefolgt von einer `brtrue` Verzweigung zur spezifischen Ziel Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-285">The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="3bd02-286">Die Ziel Anweisung wird als 1-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-286">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-287">Die zulässigen Operanden Typen werden im folgenden dargestellt:</span><span class="sxs-lookup"><span data-stu-id="3bd02-287">The acceptable operand types are encapsulated below:</span></span>  
  
 <span data-ttu-id="3bd02-288">Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-288">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="3bd02-289">Steuerelement Übertragungen in und aus `try`-, `catch`-, `filter`-und `finally`-Blöcken können nicht von dieser Anweisung ausgeführt werden (solche Übertragungen sind stark eingeschränkt und müssen stattdessen die <xref:System.Reflection.Emit.OpCodes.Leave>-Anweisung verwenden).</span><span class="sxs-lookup"><span data-stu-id="3bd02-289">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead).</span></span>  
  
 <span data-ttu-id="3bd02-290">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `beq.s` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-290">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq.s` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-291">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-291">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-292">Überträgt die Steuerung an eine Zielanweisung, wenn der erste Wert größer oder gleich dem zweiten Wert ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-292">Transfers control to a target instruction if the first value is greater than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-293">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-293">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-294">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-294">Format</span></span>|<span data-ttu-id="3bd02-295">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-295">Assembly Format</span></span>|<span data-ttu-id="3bd02-296">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-296">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-297">3C-`<int32>`</span><span class="sxs-lookup"><span data-stu-id="3bd02-297">3C `<int32>`</span></span>|<span data-ttu-id="3bd02-298">BGE-`target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-298">bge `target`</span></span>|<span data-ttu-id="3bd02-299">Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert größer oder gleich dem zweiten Wert ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-299">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value.</span></span>|  
  
 <span data-ttu-id="3bd02-300">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-300">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-301">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-301">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-302">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-302">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-303">`value2` und `value1` werden aus dem Stapel entfernt. Wenn `value1` größer oder gleich `value2`ist, wird der Verzweigungs Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-303">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="3bd02-304">Die `bge` Anweisung überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value1` größer oder gleich `value2`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-304">The `bge` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`.</span></span> <span data-ttu-id="3bd02-305">Der Effekt ist identisch mit der Ausführung einer `clt.un` Anweisung, gefolgt von einer `brfalse` Verzweigung zur spezifischen Ziel Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-305">The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="3bd02-306">Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-306">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-307">Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-307">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="3bd02-308">Steuerelement Übertragungen in und aus `try`-, `catch`-, `filter`-und `finally`-Blöcken können von dieser Anweisung nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-308">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-309">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `bge` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-309">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-310">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-310">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-311">Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn der erste Wert größer oder gleich dem zweiten Wert ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-311">Transfers control to a target instruction (short form) if the first value is greater than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-312">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-312">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-313">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-313">Format</span></span>|<span data-ttu-id="3bd02-314">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-314">Assembly Format</span></span>|<span data-ttu-id="3bd02-315">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-315">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-316">2F-`<int8>`</span><span class="sxs-lookup"><span data-stu-id="3bd02-316">2F `<int8>`</span></span>|<span data-ttu-id="3bd02-317">BGE. s-`target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-317">bge.s `target`</span></span>|<span data-ttu-id="3bd02-318">Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert größer oder gleich dem zweiten Wert (Kurzform) ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-318">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value, short form.</span></span>|  
  
 <span data-ttu-id="3bd02-319">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-319">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-320">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-320">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-321">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-321">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-322">`value2` und `value1` werden aus dem Stapel entfernt. Wenn `value1` größer oder gleich `value2`ist, wird der Verzweigungs Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-322">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="3bd02-323">Die `bge.s` Anweisung überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value1` größer oder gleich `value2`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-323">The `bge.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`.</span></span> <span data-ttu-id="3bd02-324">Der Effekt ist identisch mit der Ausführung einer `clt.un` Anweisung, gefolgt von einer `brfalse` Verzweigung zur spezifischen Ziel Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-324">The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="3bd02-325">Die Ziel Anweisung wird als 1-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-325">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-326">Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-326">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="3bd02-327">Steuerelement Übertragungen in und aus `try`-, `catch`-, `filter`-und `finally`-Blöcken können von dieser Anweisung nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-327">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-328">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `bge.s` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-328">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.s` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-329">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-329">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-330">Überträgt die Steuerung an eine Zielanweisung, wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert größer als der zweite Wert ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-330">Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-331">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-331">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-332">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-332">Format</span></span>|<span data-ttu-id="3bd02-333">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-333">Assembly Format</span></span>|<span data-ttu-id="3bd02-334">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-334">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-335">41 `<int32>`</span><span class="sxs-lookup"><span data-stu-id="3bd02-335">41 `<int32>`</span></span>|<span data-ttu-id="3bd02-336">BGE. UN-`target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-336">bge.un `target`</span></span>|<span data-ttu-id="3bd02-337">Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert größer oder gleich dem zweiten Wert (ohne Vorzeichen) ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-337">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="3bd02-338">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-338">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-339">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-339">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-340">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-340">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-341">`value2` und `value1` werden aus dem Stapel entfernt. Wenn `value1` größer oder gleich `value2`ist, wird der Verzweigungs Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-341">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="3bd02-342">Mit der `bge.un`-Anweisung wird die Steuerung an die angegebene Ziel Anweisung übertragen, wenn `value1` größer oder gleich `value2`ist, wenn Sie mit einer Ganzzahl ohne Vorzeichen oder ungeordnete Gleit Komma Werte verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-342">The `bge.un` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="3bd02-343">Der Effekt ist identisch mit der Ausführung einer `clt` Anweisung, gefolgt von einer `brfalse` Verzweigung zur spezifischen Ziel Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-343">The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="3bd02-344">Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-344">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-345">Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-345">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="3bd02-346">Steuerelement Übertragungen in und aus `try`-, `catch`-, `filter`-und `finally`-Blöcken können von dieser Anweisung nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-346">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-347">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `bge.un` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-347">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-348">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-348">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-349">Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert größer als der zweite Wert ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-349">Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-350">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-350">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-351">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-351">Format</span></span>|<span data-ttu-id="3bd02-352">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-352">Assembly Format</span></span>|<span data-ttu-id="3bd02-353">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-353">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-354">34 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-354">34 < `int8` ></span></span>|<span data-ttu-id="3bd02-355">BGE. un. s `target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-355">bge.un.s `target`</span></span>|<span data-ttu-id="3bd02-356">Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert größer oder gleich dem zweiten Wert (ohne Vorzeichen), Kurzform ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-356">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="3bd02-357">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-357">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-358">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-358">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-359">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-359">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-360">`value2` und `value1` werden aus dem Stapel entfernt. Wenn `value1` größer oder gleich `value2`ist, wird der Verzweigungs Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-360">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="3bd02-361">Mit der `bge.un.s`-Anweisung wird die Steuerung an die angegebene Ziel Anweisung übertragen, wenn `value1` größer oder gleich `value2`ist, wenn Sie mit einer Ganzzahl ohne Vorzeichen oder ungeordnete Gleit Komma Werte verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-361">The `bge.un.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="3bd02-362">Der Effekt ist identisch mit der Ausführung einer `clt` Anweisung, gefolgt von einer `brfalse` Verzweigung zur spezifischen Ziel Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-362">The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="3bd02-363">Die Ziel Anweisung wird als 1-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-363">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-364">Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-364">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="3bd02-365">Steuerelement Übertragungen in und aus `try`-, `catch`-, `filter`-und `finally`-Blöcken können von dieser Anweisung nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-365">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-366">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `bge.un.s` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-366">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-367">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-367">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-368">Überträgt die Steuerung an eine Zielanweisung, wenn der erste Wert größer als der zweite Wert ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-368">Transfers control to a target instruction if the first value is greater than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-369">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-369">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-370">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-370">Format</span></span>|<span data-ttu-id="3bd02-371">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-371">Assembly Format</span></span>|<span data-ttu-id="3bd02-372">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-372">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-373">3D-< `int32` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-373">3D < `int32` ></span></span>|<span data-ttu-id="3bd02-374">BGT-`target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-374">bgt `target`</span></span>|<span data-ttu-id="3bd02-375">Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert größer als der zweite Wert ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-375">Branch to the target instruction at the specified offset if the first value is greater than the second value.</span></span>|  
  
 <span data-ttu-id="3bd02-376">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-376">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-377">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-377">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-378">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-378">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-379">`value2` und `value1` werden aus dem Stapel entfernt. Wenn `value1` größer als `value2`ist, wird der Verzweigungs Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-379">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="3bd02-380">Die `bgt` Anweisung überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value1` größer als `value2`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-380">The `bgt` instruction transfers control to the specified target instruction if `value1` is greater than `value2`.</span></span> <span data-ttu-id="3bd02-381">Der Effekt ist identisch mit der Ausführung einer `cgt` Anweisung, gefolgt von einer `brtrue` Verzweigung zur spezifischen Ziel Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-381">The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="3bd02-382">Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-382">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-383">Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-383">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="3bd02-384">Steuerelement Übertragungen in und aus `try`-, `catch`-, `filter`-und `finally`-Blöcken können von dieser Anweisung nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-384">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-385">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `bgt` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-385">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-386">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-386">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-387">Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn der erste Wert größer als der zweite Wert ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-387">Transfers control to a target instruction (short form) if the first value is greater than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-388">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-388">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-389">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-389">Format</span></span>|<span data-ttu-id="3bd02-390">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-390">Assembly Format</span></span>|<span data-ttu-id="3bd02-391">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-391">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-392">30 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-392">30 < `int8` ></span></span>|<span data-ttu-id="3bd02-393">BGT. s `target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-393">bgt.s `target`</span></span>|<span data-ttu-id="3bd02-394">Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert größer als der zweite Wert (Kurzform) ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-394">Branch to the target instruction at the specified offset if the first value is greater than the second value, short form.</span></span>|  
  
 <span data-ttu-id="3bd02-395">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-395">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-396">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-396">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-397">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-397">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-398">`value2` und `value1` werden aus dem Stapel entfernt. Wenn `value1` größer als `value2`ist, wird der Verzweigungs Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-398">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="3bd02-399">Die `bgt.s` Anweisung überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value1` größer als `value2`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-399">The `bgt.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`.</span></span> <span data-ttu-id="3bd02-400">Der Effekt ist identisch mit der Ausführung einer `cgt` Anweisung, gefolgt von einer `brtrue` Verzweigung zur spezifischen Ziel Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-400">The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="3bd02-401">Die Ziel Anweisung wird als 1-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-401">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-402">Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-402">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="3bd02-403">Steuerelement Übertragungen in und aus `try`-, `catch`-, `filter`-und `finally`-Blöcken können von dieser Anweisung nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-403">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-404">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `bgt.s` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-404">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.s` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-405">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-405">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-406">Überträgt die Steuerung an eine Zielanweisung, wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert größer als der zweite Wert ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-406">Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-407">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-407">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-408">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-408">Format</span></span>|<span data-ttu-id="3bd02-409">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-409">Assembly Format</span></span>|<span data-ttu-id="3bd02-410">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-410">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-411">42 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-411">42 < `int32` ></span></span>|<span data-ttu-id="3bd02-412">BGT. UN-`target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-412">bgt.un `target`</span></span>|<span data-ttu-id="3bd02-413">Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert größer als der zweite Wert (ohne Vorzeichen) ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-413">Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="3bd02-414">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-414">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-415">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-415">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-416">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-416">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-417">`value2` und `value1` werden aus dem Stapel entfernt. Wenn `value1` größer als `value2`ist, wird der Verzweigungs Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-417">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="3bd02-418">Mit der `bgt.un`-Anweisung wird die Steuerung an die angegebene Ziel Anweisung übertragen, wenn `value1` größer als `value2`ist, wenn eine ganze Zahl ohne Vorzeichen oder ungeordnete Gleit Komma Werte verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-418">The `bgt.un` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="3bd02-419">Der Effekt ist identisch mit der Ausführung einer `cgt.un` Anweisung, gefolgt von einer `brtrue` Verzweigung zur spezifischen Ziel Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-419">The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="3bd02-420">Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-420">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-421">Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-421">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="3bd02-422">Steuerelement Übertragungen in und aus `try`-, `catch`-, `filter`-und `finally`-Blöcken können von dieser Anweisung nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-422">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-423">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `bgt.un` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-423">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-424">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-424">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-425">Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert größer als der zweite Wert ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-425">Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-426">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-426">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-427">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-427">Format</span></span>|<span data-ttu-id="3bd02-428">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-428">Assembly Format</span></span>|<span data-ttu-id="3bd02-429">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-429">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-430">35 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-430">35 < `int8` ></span></span>|<span data-ttu-id="3bd02-431">BGT. UN-`target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-431">bgt.un.s `target`</span></span>|<span data-ttu-id="3bd02-432">Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert größer als der zweite Wert (ohne Vorzeichen), Kurzform ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-432">Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="3bd02-433">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-433">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-434">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-434">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-435">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-435">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-436">`value2` und `value1` werden aus dem Stapel entfernt. Wenn `value1` größer als `value2`ist, wird der Verzweigungs Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-436">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="3bd02-437">Mit der `bgt.un.s`-Anweisung wird die Steuerung an die angegebene Ziel Anweisung übertragen, wenn `value1` größer als `value2`ist, wenn eine ganze Zahl ohne Vorzeichen oder ungeordnete Gleit Komma Werte verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-437">The `bgt.un.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="3bd02-438">Der Effekt ist identisch mit der Ausführung einer `cgt.un` Anweisung, gefolgt von einer `brtrue` Verzweigung zur spezifischen Ziel Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-438">The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="3bd02-439">Die Ziel Anweisung wird als 1-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-439">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-440">Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-440">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="3bd02-441">Steuerelement Übertragungen in und aus `try`-, `catch`-, `filter`-und `finally`-Blöcken können von dieser Anweisung nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-441">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-442">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `bgt.un.s` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-442">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-443">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-443">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-444">Überträgt die Steuerung an eine Zielanweisung, wenn der erste Wert kleiner oder gleich dem zweiten Wert ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-444">Transfers control to a target instruction if the first value is less than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-445">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-445">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-446">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-446">Format</span></span>|<span data-ttu-id="3bd02-447">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-447">Assembly Format</span></span>|<span data-ttu-id="3bd02-448">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-448">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-449">3e-`<int32>`</span><span class="sxs-lookup"><span data-stu-id="3bd02-449">3E `<int32>`</span></span>|<span data-ttu-id="3bd02-450">BLE-`target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-450">ble `target`</span></span>|<span data-ttu-id="3bd02-451">Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert kleiner oder gleich dem zweiten Wert ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-451">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value.</span></span>|  
  
 <span data-ttu-id="3bd02-452">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-452">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-453">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-453">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-454">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-454">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-455">`value2` und `value1` werden aus dem Stapel entfernt. Wenn `value1` kleiner oder gleich `value2`ist, wird der Verzweigungs Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-455">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="3bd02-456">Die `ble` Anweisung überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value1` kleiner oder gleich `value2`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-456">The `ble` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="3bd02-457">Der Effekt ist identisch mit der Durchführung einer `cgt` Anweisung (`cgt.un` für Gleit Komma Zahlen), gefolgt von einer `brfalse` Verzweigung zur spezifischen Ziel Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-457">The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="3bd02-458">Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-458">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-459">Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-459">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="3bd02-460">Steuerelement Übertragungen in und aus `try`-, `catch`-, `filter`-und `finally`-Blöcken können von dieser Anweisung nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-460">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-461">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ble` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-461">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-462">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-462">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-463">Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn der erste Wert kleiner oder gleich dem zweiten Wert ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-463">Transfers control to a target instruction (short form) if the first value is less than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-464">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-464">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-465">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-465">Format</span></span>|<span data-ttu-id="3bd02-466">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-466">Assembly Format</span></span>|<span data-ttu-id="3bd02-467">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-467">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-468">31 `<int8>`</span><span class="sxs-lookup"><span data-stu-id="3bd02-468">31 `<int8>`</span></span>|<span data-ttu-id="3bd02-469">BLE. s-`target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-469">ble.s `target`</span></span>|<span data-ttu-id="3bd02-470">Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert kleiner oder gleich dem zweiten Wert ist, Kurzform.</span><span class="sxs-lookup"><span data-stu-id="3bd02-470">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value, short form.</span></span>|  
  
 <span data-ttu-id="3bd02-471">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-471">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-472">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-472">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-473">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-473">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-474">`value2` und `value1` werden aus dem Stapel entfernt. Wenn `value1` kleiner oder gleich `value2`ist, wird der Verzweigungs Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-474">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="3bd02-475">Die `ble.s` Anweisung überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value1` kleiner oder gleich `value2`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-475">The `ble.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="3bd02-476">Der Effekt ist identisch mit der Durchführung einer `cgt` Anweisung (`cgt.un` für Gleit Komma Zahl), gefolgt von einer`brfalse` Verzweigung zur spezifischen Ziel Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-476">The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) instruction followed by a`brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="3bd02-477">Die Ziel Anweisung wird als 1-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-477">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-478">Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-478">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="3bd02-479">Steuerelement Übertragungen in und aus `try`-, `catch`-, `filter`-und `finally`-Blöcken können von dieser Anweisung nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-479">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-480">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ble.s` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-480">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.s` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-481">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-481">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-482">Überträgt die Steuerung an eine Zielanweisung, wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert kleiner oder gleich dem zweiten Wert ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-482">Transfers control to a target instruction if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-483">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-483">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-484">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-484">Format</span></span>|<span data-ttu-id="3bd02-485">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-485">Assembly Format</span></span>|<span data-ttu-id="3bd02-486">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-486">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-487">43 `<int32>`</span><span class="sxs-lookup"><span data-stu-id="3bd02-487">43 `<int32>`</span></span>|<span data-ttu-id="3bd02-488">BLE. UN-`target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-488">ble.un `target`</span></span>|<span data-ttu-id="3bd02-489">Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert kleiner oder gleich dem zweiten Wert (ohne Vorzeichen) ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-489">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="3bd02-490">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-490">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-491">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-491">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-492">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-492">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-493">`value2` und `value1` werden aus dem Stapel entfernt. Wenn `value1` kleiner oder gleich `value2`ist, wird der Verzweigungs Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-493">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="3bd02-494">Die `ble.un` Anweisung überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value1` kleiner oder gleich `value2`ist, wenn Sie mit einer Ganzzahl ohne Vorzeichen oder ungeordnete Gleit Komma Werte verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-494">The `ble.un` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="3bd02-495">Der Effekt ist identisch mit der Durchführung einer `cgt.un` Anweisung (`cgt` für Gleit Komma Zahlen), gefolgt von einer `brfalse` Verzweigung zur spezifischen Ziel Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-495">The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="3bd02-496">Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-496">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-497">Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-497">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="3bd02-498">Steuerelement Übertragungen in und aus `try`-, `catch`-, `filter`-und `finally`-Blöcken können von dieser Anweisung nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-498">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-499">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ble.un` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-499">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-500">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-500">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-501">Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert kleiner oder gleich dem zweiten Wert ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-501">Transfers control to a target instruction (short form) if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-502">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-502">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-503">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-503">Format</span></span>|<span data-ttu-id="3bd02-504">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-504">Assembly Format</span></span>|<span data-ttu-id="3bd02-505">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-505">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-506">36 `<int8>`</span><span class="sxs-lookup"><span data-stu-id="3bd02-506">36 `<int8>`</span></span>|<span data-ttu-id="3bd02-507">BLE. un. s `target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-507">ble.un.s `target`</span></span>|<span data-ttu-id="3bd02-508">Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert kleiner oder gleich dem zweiten Wert (nicht signierte Werte), Kurzform ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-508">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="3bd02-509">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-509">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-510">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-510">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-511">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-511">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-512">`value2` und `value1` werden aus dem Stapel entfernt. Wenn `value1` kleiner oder gleich `value2`ist, wird der Verzweigungs Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-512">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="3bd02-513">Die `ble.un.s` Anweisung überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value1` kleiner oder gleich `value2`ist, wenn Sie mit einer Ganzzahl ohne Vorzeichen oder ungeordnete Gleit Komma Werte verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-513">The `ble.un.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="3bd02-514">Der Effekt ist identisch mit der Durchführung einer `cgt.un` Anweisung (`cgt` für Gleit Komma Zahlen), gefolgt von einer `brfalse` Verzweigung zur spezifischen Ziel Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-514">The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="3bd02-515">Die Ziel Anweisung wird als 1-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-515">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-516">Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-516">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="3bd02-517">Steuerelement Übertragungen in und aus `try`-, `catch`-, `filter`-und `finally`-Blöcken können von dieser Anweisung nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-517">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-518">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ble.un.s` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-518">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-519">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-519">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-520">Überträgt die Steuerung an eine Zielanweisung, wenn der erste Wert kleiner als der zweite Wert ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-520">Transfers control to a target instruction if the first value is less than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-521">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-521">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-522">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-522">Format</span></span>|<span data-ttu-id="3bd02-523">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-523">Assembly Format</span></span>|<span data-ttu-id="3bd02-524">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-524">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-525">3F-< `int32` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-525">3F < `int32` ></span></span>|<span data-ttu-id="3bd02-526">BLT-`target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-526">blt `target`</span></span>|<span data-ttu-id="3bd02-527">Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert kleiner als der zweite Wert ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-527">Branch to the target instruction at the specified offset if the first value is less than the second value.</span></span>|  
  
 <span data-ttu-id="3bd02-528">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-528">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-529">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-529">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-530">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-530">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-531">`value2` und `value1` werden aus dem Stapel entfernt. Wenn `value1` kleiner als `value2`ist, wird der Verzweigungs Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-531">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="3bd02-532">Die `blt` Anweisung überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value1` kleiner oder gleich `value2`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-532">The `blt` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="3bd02-533">Der Effekt ist identisch mit der Ausführung einer `clt` Anweisung, gefolgt von einer `brtrue` Verzweigung zur spezifischen Ziel Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-533">The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="3bd02-534">Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-534">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-535">Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-535">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="3bd02-536">Steuerelement Übertragungen in und aus `try`-, `catch`-, `filter`-und `finally`-Blöcken können von dieser Anweisung nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-536">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-537">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `blt` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-537">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-538">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-538">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-539">Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn der erste Wert kleiner als der zweite Wert ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-539">Transfers control to a target instruction (short form) if the first value is less than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-540">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-540">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-541">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-541">Format</span></span>|<span data-ttu-id="3bd02-542">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-542">Assembly Format</span></span>|<span data-ttu-id="3bd02-543">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-543">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-544">32 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-544">32 < `int8` ></span></span>|<span data-ttu-id="3bd02-545">BLT. s `target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-545">blt.s `target`</span></span>|<span data-ttu-id="3bd02-546">Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert kleiner als der zweite Wert (Kurzform) ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-546">Branch to the target instruction at the specified offset if the first value is less than the second value, short form.</span></span>|  
  
 <span data-ttu-id="3bd02-547">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-547">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-548">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-548">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-549">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-549">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-550">`value2` und `value1` werden aus dem Stapel entfernt. Wenn `value1` kleiner als `value2`ist, wird der Verzweigungs Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-550">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="3bd02-551">Die `blt.s` Anweisung überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value1` kleiner als `value2`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-551">The `blt.s` instruction transfers control to the specified target instruction if `value1` is less than `value2`.</span></span> <span data-ttu-id="3bd02-552">Der Effekt ist identisch mit der Ausführung einer `clt` Anweisung, gefolgt von einer `brtrue` Verzweigung zur spezifischen Ziel Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-552">The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="3bd02-553">Die Ziel Anweisung wird als 1-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-553">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-554">Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-554">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="3bd02-555">Steuerelement Übertragungen in und aus `try`-, `catch`-, `filter`-und `finally`-Blöcken können von dieser Anweisung nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-555">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-556">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `blt.s` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-556">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.s` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-557">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-557">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-558">Überträgt die Steuerung an eine Zielanweisung, wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert kleiner als der zweite Wert ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-558">Transfers control to a target instruction if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-559">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-559">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-560">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-560">Format</span></span>|<span data-ttu-id="3bd02-561">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-561">Assembly Format</span></span>|<span data-ttu-id="3bd02-562">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-562">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-563">44 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-563">44 < `int32` ></span></span>|<span data-ttu-id="3bd02-564">BLT. UN-`target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-564">blt.un `target`</span></span>|<span data-ttu-id="3bd02-565">Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert kleiner als der zweite Wert (ohne Vorzeichen) ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-565">Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="3bd02-566">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-566">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-567">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-567">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-568">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-568">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-569">`value2` und `value1` werden aus dem Stapel entfernt. Wenn `value1` kleiner als `value2`ist, wird der Verzweigungs Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-569">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="3bd02-570">Mit der `blt.un`-Anweisung wird die Steuerung an die angegebene Ziel Anweisung übertragen, wenn `value1` kleiner als `value2`ist, wenn eine ganze Zahl ohne Vorzeichen oder ungeordnete Gleit Komma Werte verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-570">The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="3bd02-571">Der Effekt ist identisch mit der Ausführung einer `clt.un` Anweisung, gefolgt von einer `brtrue` Verzweigung zur spezifischen Ziel Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-571">The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="3bd02-572">Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-572">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-573">Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-573">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="3bd02-574">Steuerelement Übertragungen in und aus `try`-, `catch`-, `filter`-und `finally`-Blöcken können von dieser Anweisung nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-574">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-575">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `blt.un` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-575">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-576">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-576">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-577">Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert kleiner als der zweite Wert ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-577">Transfers control to a target instruction (short form) if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-578">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-578">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-579">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-579">Format</span></span>|<span data-ttu-id="3bd02-580">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-580">Assembly Format</span></span>|<span data-ttu-id="3bd02-581">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-581">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-582">37 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-582">37 < `int8` ></span></span>|<span data-ttu-id="3bd02-583">BLT. un. s `target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-583">blt.un.s `target`</span></span>|<span data-ttu-id="3bd02-584">Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert kleiner als der zweite Wert (ohne Vorzeichen), Kurzform ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-584">Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="3bd02-585">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-585">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-586">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-586">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-587">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-587">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-588">`value2` und `value1` werden aus dem Stapel entfernt. Wenn `value1` kleiner als `value2`ist, wird der Verzweigungs Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-588">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="3bd02-589">Mit der `blt.un`-Anweisung wird die Steuerung an die angegebene Ziel Anweisung übertragen, wenn `value1` kleiner als `value2`ist, wenn eine ganze Zahl ohne Vorzeichen oder ungeordnete Gleit Komma Werte verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-589">The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="3bd02-590">Der Effekt ist identisch mit der Ausführung einer `clt.un` Anweisung, gefolgt von einer `brtrue` Verzweigung zur spezifischen Ziel Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-590">The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="3bd02-591">Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-591">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-592">Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-592">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="3bd02-593">Steuerelement Übertragungen in und aus `try`-, `catch`-, `filter`-und `finally`-Blöcken können von dieser Anweisung nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-593">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-594">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `blt.un.s` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-594">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-595">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-595">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-596">Überträgt die Steuerung an eine Zielanweisung, wenn zwei Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte ungleich sind.</span><span class="sxs-lookup"><span data-stu-id="3bd02-596">Transfers control to a target instruction when two unsigned integer values or unordered float values are not equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-597">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-597">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-598">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-598">Format</span></span>|<span data-ttu-id="3bd02-599">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-599">Assembly Format</span></span>|<span data-ttu-id="3bd02-600">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-600">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-601">40 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-601">40 < `int32` ></span></span>|<span data-ttu-id="3bd02-602">BNE. UN-`target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-602">bne.un `target`</span></span>|<span data-ttu-id="3bd02-603">Verzweigt die Ziel Anweisung am angegebenen Offset, wenn zwei ganzzahlige Werte ohne Vorzeichen nicht gleich sind (Werte ohne Vorzeichen).</span><span class="sxs-lookup"><span data-stu-id="3bd02-603">Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values).</span></span>|  
  
 <span data-ttu-id="3bd02-604">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-604">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-605">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-605">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-606">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-606">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-607">`value2` und `value1` werden aus dem Stapel entfernt. Wenn `value1` nicht gleich `value2`ist, wird der Verzweigungs Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-607">`value2` and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="3bd02-608">Mit der `bne.un`-Anweisung wird die Steuerung an die angegebene Ziel Anweisung übertragen, wenn `value1` nicht gleich `value2`ist, wenn eine ganze Zahl ohne Vorzeichen oder ungeordnete Gleit Komma Werte verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-608">The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="3bd02-609">Der Effekt ist identisch mit der Ausführung einer `ceq` Anweisung, gefolgt von einer `brfalse` Verzweigung zur spezifischen Ziel Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-609">The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="3bd02-610">Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-610">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-611">Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-611">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="3bd02-612">Steuerelement Übertragungen in und aus `try`-, `catch`-, `filter`-und `finally`-Blöcken können von dieser Anweisung nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-612">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-613">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `bne.un` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-613">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-614">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-614">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-615">Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn zwei Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte ungleich sind.</span><span class="sxs-lookup"><span data-stu-id="3bd02-615">Transfers control to a target instruction (short form) when two unsigned integer values or unordered float values are not equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-616">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-616">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-617">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-617">Format</span></span>|<span data-ttu-id="3bd02-618">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-618">Assembly Format</span></span>|<span data-ttu-id="3bd02-619">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-619">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-620">33 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-620">33 < `int8` ></span></span>|<span data-ttu-id="3bd02-621">BNE. un. s `target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-621">bne.un.s `target`</span></span>|<span data-ttu-id="3bd02-622">Verzweigt die Ziel Anweisung am angegebenen Offset, wenn zwei ganzzahlige Werte ohne Vorzeichen nicht gleich sind (unsignierte Werte), Kurzform.</span><span class="sxs-lookup"><span data-stu-id="3bd02-622">Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="3bd02-623">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-623">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-624">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-624">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-625">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-625">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-626">`value2` und `value1` werden aus dem Stapel entfernt. Wenn `value1` nicht gleich `value2`ist, wird der Verzweigungs Vorgang ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-626">`value2` and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="3bd02-627">Mit der `bne.un`-Anweisung wird die Steuerung an die angegebene Ziel Anweisung übertragen, wenn `value1` nicht gleich `value2`ist, wenn eine ganze Zahl ohne Vorzeichen oder ungeordnete Gleit Komma Werte verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-627">The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="3bd02-628">Der Effekt ist identisch mit der Ausführung einer `ceq` Anweisung, gefolgt von einer `brfalse` Verzweigung zur spezifischen Ziel Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-628">The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="3bd02-629">Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-629">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-630">Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-630">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="3bd02-631">Steuerelement Übertragungen in und aus `try`-, `catch`-, `filter`-und `finally`-Blöcken können von dieser Anweisung nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-631">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-632">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `bne.un.s` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-632">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-633">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-633">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-634">Konvertiert einen Werttyp in einen Objektverweis (Typ <see langword="O" />).</span><span class="sxs-lookup"><span data-stu-id="3bd02-634">Converts a value type to an object reference (type <see langword="O" />).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-635">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-635">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-636">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-636">Format</span></span>|<span data-ttu-id="3bd02-637">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-637">Assembly Format</span></span>|<span data-ttu-id="3bd02-638">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-638">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-639">8c < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-639">8C < `T` ></span></span>|<span data-ttu-id="3bd02-640">Box-`valTypeToken`</span><span class="sxs-lookup"><span data-stu-id="3bd02-640">box `valTypeToken`</span></span>|<span data-ttu-id="3bd02-641">Konvertiert einen Werttyp (des in `valTypeToken`angegebenen Typs) in einen echten Objekt Verweis.</span><span class="sxs-lookup"><span data-stu-id="3bd02-641">Convert a value type (of the type specified in `valTypeToken`) to a true object reference.</span></span>|  
  
 <span data-ttu-id="3bd02-642">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-642">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-643">Ein Werttyp wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-643">A value type is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-644">Der Werttyp wird aus dem Stapel ausgeblendet. der `box` Vorgang wird ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-644">The value type is popped from the stack; the `box` operation is performed.</span></span>  
  
3.  <span data-ttu-id="3bd02-645">Ein Objekt Verweis auf den resultierenden "Boxed"-Werttyp wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-645">An object reference to the resulting "boxed" value type is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-646">Ein Werttyp verfügt über zwei separate Darstellungen innerhalb der Common Language Infrastructure (CLI):</span><span class="sxs-lookup"><span data-stu-id="3bd02-646">A value type has two separate representations within the Common Language Infrastructure (CLI):</span></span>  
  
-   <span data-ttu-id="3bd02-647">Ein RAW-Formular, das verwendet wird, wenn ein Werttyp in ein anderes Objekt oder auf dem Stapel eingebettet ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-647">A 'raw' form used when a value type is embedded within another object or on the stack.</span></span>  
  
-   <span data-ttu-id="3bd02-648">Ein geschachteltes Formular, in dem die Daten im Werttyp in ein Objekt umwickelt (geschachtelt) werden, damit es als unabhängige Entität vorhanden sein kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-648">A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</span></span>  
  
 <span data-ttu-id="3bd02-649">Die `box` Anweisung konvertiert den "RAW"-Werttyp (Unboxing) in einen Objekt Verweis (Typ `O`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-649">The `box` instruction converts the 'raw' (unboxed) value type into an object reference (type `O`).</span></span> <span data-ttu-id="3bd02-650">Dies wird erreicht, indem ein neues-Objekt erstellt und die Daten aus dem Werttyp in das neu zugewiesene-Objekt kopiert werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-650">This is accomplished by creating a new object and copying the data from the value type into the newly allocated object.</span></span> <span data-ttu-id="3bd02-651">`valTypeToken` ist ein Metadatentoken, das den Typ des Werttyps auf dem Stapel angibt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-651">`valTypeToken` is a metadata token indicating the type of the value type on the stack.</span></span>  
  
 <span data-ttu-id="3bd02-652"><xref:System.OutOfMemoryException> wird ausgelöst, wenn nicht genügend Arbeitsspeicher vorhanden ist, um die Anforderung zu erfüllen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-652"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="3bd02-653"><xref:System.TypeLoadException> wird ausgelöst, wenn die Klasse nicht gefunden werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-653"><xref:System.TypeLoadException> is thrown if the class cannot be found.</span></span> <span data-ttu-id="3bd02-654">Dies wird in der Regel erkannt, wenn MSIL (Microsoft Intermediate Language) in nativen Code konvertiert wird, anstatt zur Laufzeit.</span><span class="sxs-lookup"><span data-stu-id="3bd02-654">This is typically detected when Microsoft Intermediate Language (MSIL) is converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="3bd02-655">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `box` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-655">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `box` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-656">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="3bd02-656">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-657">Überträgt die Steuerung bedingungslos an eine Zielanweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-657">Unconditionally transfers control to a target instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-658">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-658">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-659">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-659">Format</span></span>|<span data-ttu-id="3bd02-660">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-660">Assembly Format</span></span>|<span data-ttu-id="3bd02-661">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-661">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-662">38 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-662">38 < `int32` ></span></span>|<span data-ttu-id="3bd02-663">BR-`target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-663">br `target`</span></span>|<span data-ttu-id="3bd02-664">Verzweigt am angegebenen Offset in eine Ziel Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-664">Branches to a target instruction at the specified offset.</span></span>|  
  
 <span data-ttu-id="3bd02-665">Von diesem Vorgang werden keine Bewertungs Stapel Verhalten ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-665">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="3bd02-666">Die `br` Anweisung überträgt die Steuerung bedingungslos an eine Ziel Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-666">The `br` instruction unconditionally transfers control to a target instruction.</span></span> <span data-ttu-id="3bd02-667">Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-667">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-668">Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-668">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="3bd02-669">Steuerelement Übertragungen in und aus `try`-, `catch`-, `filter`-und `finally`-Blöcken können von dieser Anweisung nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-669">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-670">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `br` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-670">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-671">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-671">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-672">Überträgt die Steuerung bedingungslos an eine Zielanweisung (Kurzform).</span><span class="sxs-lookup"><span data-stu-id="3bd02-672">Unconditionally transfers control to a target instruction (short form).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-673">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-673">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-674">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-674">Format</span></span>|<span data-ttu-id="3bd02-675">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-675">Assembly Format</span></span>|<span data-ttu-id="3bd02-676">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-676">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-677">2B < `int8` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-677">2B < `int8` ></span></span>|<span data-ttu-id="3bd02-678">Br. s `target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-678">br.s `target`</span></span>|<span data-ttu-id="3bd02-679">Verzweigt in eine Ziel Anweisung am angegebenen Offset, Kurzform.</span><span class="sxs-lookup"><span data-stu-id="3bd02-679">Branches to a target instruction at the specified offset, short form.</span></span>|  
  
 <span data-ttu-id="3bd02-680">Von diesem Vorgang werden keine Bewertungs Stapel Verhalten ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-680">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="3bd02-681">Die `br.s` Anweisung überträgt die Steuerung bedingungslos an eine Ziel Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-681">The `br.s` instruction unconditionally transfers control to a target instruction.</span></span> <span data-ttu-id="3bd02-682">Die Ziel Anweisung wird als 1-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-682">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-683">Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-683">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="3bd02-684">Steuerelement Übertragungen in und aus `try`-, `catch`-, `filter`-und `finally`-Blöcken können von dieser Anweisung nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-684">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-685">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `br.s` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-685">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br.s` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-686">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-686">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-687">Signalisiert CLI (Common Language Infrastructure), den Debugger darüber zu informieren, dass ein Haltepunkt erreicht wurde.</span><span class="sxs-lookup"><span data-stu-id="3bd02-687">Signals the Common Language Infrastructure (CLI) to inform the debugger that a break point has been tripped.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-688">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-688">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-689">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-689">Format</span></span>|<span data-ttu-id="3bd02-690">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-690">Assembly Format</span></span>|<span data-ttu-id="3bd02-691">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-691">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-692">01</span><span class="sxs-lookup"><span data-stu-id="3bd02-692">01</span></span>|<span data-ttu-id="3bd02-693">break</span><span class="sxs-lookup"><span data-stu-id="3bd02-693">break</span></span>|<span data-ttu-id="3bd02-694">informieren Sie einen Debugger, dass ein Haltepunkt erreicht wurde.</span><span class="sxs-lookup"><span data-stu-id="3bd02-694">inform a debugger that a breakpoint has been reached.</span></span>|  
  
 <span data-ttu-id="3bd02-695">Von diesem Vorgang werden keine Bewertungs Stapel Verhalten ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-695">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="3bd02-696">Die `break` Anweisung dient der Debugunterstützung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-696">The `break` instruction is for debugging support.</span></span> <span data-ttu-id="3bd02-697">Es signalisiert der CLI, den Debugger darüber zu informieren, dass ein Haltepunkt erreicht wurde.</span><span class="sxs-lookup"><span data-stu-id="3bd02-697">It signals the CLI to inform the debugger that a break point has been tripped.</span></span> <span data-ttu-id="3bd02-698">Er wirkt sich nicht auf den Interpreterzustand aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-698">It has no other effect on the interpreter state.</span></span>  
  
 <span data-ttu-id="3bd02-699">Die `break` Anweisung verfügt über die kleinste mögliche Anweisungs Größe, die das Patchen von Code mit einem Breakpoint ermöglicht und den umgebenden Code minimal stört.</span><span class="sxs-lookup"><span data-stu-id="3bd02-699">The `break` instruction has the smallest possible instruction size enabling code patching with a break point and generating minimal disturbance to the surrounding code.</span></span>  
  
 <span data-ttu-id="3bd02-700">Die `break` Anweisung kann zu einem Debugger Trap machen, keine Aktion durchführen oder eine Sicherheits Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-700">The `break` instruction can trap to a debugger, do nothing, or raise a security exception.</span></span> <span data-ttu-id="3bd02-701">Das genaue Verhalten ist von der Implementierung definiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-701">The exact behavior is implementation-defined.</span></span>  
  
 <span data-ttu-id="3bd02-702">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `break` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-702">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `break` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-703">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-703">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-704">Überträgt die Steuerung an eine Zielanweisung, wenn <paramref name="value" /> entweder <see langword="false" />, ein NULL-Verweis (<see langword="Nothing" /> in Visual Basic) oder 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-704">Transfers control to a target instruction if <paramref name="value" /> is <see langword="false" />, a null reference (<see langword="Nothing" /> in Visual Basic), or zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-705">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-705">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-706">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-706">Format</span></span>|<span data-ttu-id="3bd02-707">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-707">Assembly Format</span></span>|<span data-ttu-id="3bd02-708">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-708">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-709">39 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-709">39 < `int32` ></span></span>|<span data-ttu-id="3bd02-710">brfalse-`target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-710">brfalse `target`</span></span><br /><br /> <span data-ttu-id="3bd02-711">brnull-`target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-711">brnull `target`</span></span><br /><br /> <span data-ttu-id="3bd02-712">brzero-`target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-712">brzero `target`</span></span>|<span data-ttu-id="3bd02-713">Verzweigt beim angegebenen Offset in eine Ziel Anweisung, wenn `false`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-713">Branches to a target instruction at the specified offset if `false`.</span></span>|  
  
 <span data-ttu-id="3bd02-714">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-714">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-715">`value` wird von einem vorherigen Vorgang auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-715">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="3bd02-716">`value` aus dem Stapel entfernt wird. Wenn `value` `false`ist, verzweigen Sie in `target`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-716">`value` is popped from the stack; if `value` is `false`, branch to `target`.</span></span>  
  
 <span data-ttu-id="3bd02-717">Die `brfalse` Anweisung (und ihre Aliase `brnull` und `brzero`) überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value` (vom Typ `int32`, `int64`, Objekt Verweis `O`, verwalteter Zeiger `&`, vorübergehender Zeiger `*`, `native int`) 0 (null) (`false`) ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-717">The `brfalse` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`).</span></span> <span data-ttu-id="3bd02-718">Wenn `value` nicht 0 (`true`) ist, wird die Ausführung bei der nächsten Anweisung fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-718">If `value` is non-zero (`true`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="3bd02-719">Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-719">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-720">Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-720">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="3bd02-721">Steuerelement Übertragungen in und aus `try`-, `catch`-, `filter`-und `finally`-Blöcken können von dieser Anweisung nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-721">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-722">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `brfalse` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-722">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-723">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-723">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-724">Überträgt die Steuerung an eine Zielanweisung, wenn <paramref name="value" /> entweder <see langword="false" />, ein NULL-Verweis oder 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-724">Transfers control to a target instruction if <paramref name="value" /> is <see langword="false" />, a null reference, or zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-725">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-725">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-726">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-726">Format</span></span>|<span data-ttu-id="3bd02-727">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-727">Assembly Format</span></span>|<span data-ttu-id="3bd02-728">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-728">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-729">2C-<`int8` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-729">2C <`int8` ></span></span>|<span data-ttu-id="3bd02-730">brfalse. s `target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-730">brfalse.s `target`</span></span><br /><br /> <span data-ttu-id="3bd02-731">brnull. s `target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-731">brnull.s `target`</span></span><br /><br /> <span data-ttu-id="3bd02-732">brzero. s `target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-732">brzero.s `target`</span></span>|<span data-ttu-id="3bd02-733">Verzweigt sich am angegebenen Offset zu einer Ziel Anweisung, wenn `false`, Kurzform.</span><span class="sxs-lookup"><span data-stu-id="3bd02-733">Branches to a target instruction at the specified offset if `false`, short form.</span></span>|  
  
 <span data-ttu-id="3bd02-734">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-734">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-735">`value` wird von einem vorherigen Vorgang auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-735">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="3bd02-736">`value` aus dem Stapel entfernt wird. Wenn `value` `false`ist, verzweigen Sie in `target`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-736">`value` is popped from the stack; if `value` is `false`, branch to `target`.</span></span>  
  
 <span data-ttu-id="3bd02-737">Die `brfalse.s` Anweisung (und ihre Aliase `brnull` und `brzero`) überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value` (vom Typ `int32`, `int64`, Objekt Verweis `O`, verwalteter Zeiger `&`, vorübergehender Zeiger `*`, `native int`) 0 (null) (`false`) ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-737">The `brfalse.s` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`).</span></span> <span data-ttu-id="3bd02-738">Wenn `value` nicht 0 (`true`) ist, wird die Ausführung bei der nächsten Anweisung fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-738">If `value` is non-zero (`true`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="3bd02-739">Die Ziel Anweisung wird als 1-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-739">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-740">Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-740">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="3bd02-741">Steuerelement Übertragungen in und aus `try`-, `catch`-, `filter`-und `finally`-Blöcken können von dieser Anweisung nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-741">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-742">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `brfalse.s` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-742">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse.s` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-743">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-743">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-744">Überträgt die Steuerung an eine Zielanweisung, wenn <paramref name="value" /> entweder <see langword="true" />, nicht NULL oder ungleich 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-744">Transfers control to a target instruction if <paramref name="value" /> is <see langword="true" />, not null, or non-zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-745">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-745">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-746">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-746">Format</span></span>|<span data-ttu-id="3bd02-747">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-747">Assembly Format</span></span>|<span data-ttu-id="3bd02-748">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-748">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-749">3a-< `int32` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-749">3A < `int32` ></span></span>|<span data-ttu-id="3bd02-750">brtrue-`target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-750">brtrue `target`</span></span><br /><br /> <span data-ttu-id="3bd02-751">brinst-`target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-751">brinst `target`</span></span>|<span data-ttu-id="3bd02-752">Verzweigt in eine Ziel Anweisung am angegebenen Offset, wenn nicht 0 (null) (`true`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-752">Branch to a target instruction at the specified offset if non-zero (`true`).</span></span>|  
  
 <span data-ttu-id="3bd02-753">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-753">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-754">`value` wird von einem vorherigen Vorgang auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-754">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="3bd02-755">`value` aus dem Stapel entfernt wird. Wenn `value` `true`ist, verzweigen Sie in `target`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-755">`value` is popped from the stack; if `value` is `true`, branch to `target`.</span></span>  
  
 <span data-ttu-id="3bd02-756">Die `brtrue` Anweisung überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value` (Type `native int`) ungleich 0 (null) (`true`) ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-756">The `brtrue` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`).</span></span> <span data-ttu-id="3bd02-757">Wenn `value` NULL (`false`) ist, wird die Ausführung bei der nächsten Anweisung fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-757">If `value` is zero (`false`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="3bd02-758">Wenn `value` ein Objekt Verweis (Typ `O`) ist, übermittelt `brinst` (ein Alias für `brtrue`) die Steuerung, wenn Sie eine Instanz eines Objekts darstellt (z. b., wenn es sich nicht um den NULL-Objekt Verweis handelt; Weitere Informationen finden Sie unter <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span><span class="sxs-lookup"><span data-stu-id="3bd02-758">If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span></span>  
  
 <span data-ttu-id="3bd02-759">Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-759">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-760">Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-760">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="3bd02-761">Steuerelement Übertragungen in und aus `try`-, `catch`-, `filter`-und `finally`-Blöcken können von dieser Anweisung nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-761">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-762">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `brtrue` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-762">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-763">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-763">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-764">Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn <paramref name="value" /> entweder <see langword="true" />, nicht NULL oder ungleich 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-764">Transfers control to a target instruction (short form) if <paramref name="value" /> is <see langword="true" />, not null, or non-zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-765">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-765">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-766">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-766">Format</span></span>|<span data-ttu-id="3bd02-767">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-767">Assembly Format</span></span>|<span data-ttu-id="3bd02-768">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-768">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-769">2D-< `int8` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-769">2D < `int8` ></span></span>|<span data-ttu-id="3bd02-770">brtrue. s `target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-770">brtrue.s `target`</span></span><br /><br /> <span data-ttu-id="3bd02-771">brinst. s `target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-771">brinst.s `target`</span></span>|<span data-ttu-id="3bd02-772">Verzweigt beim angegebenen Offset in eine Ziel Anweisung, wenn Sie nicht NULL (`true`), Kurzform ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-772">Branch to a target instruction at the specified offset if non-zero (`true`), short form.</span></span>|  
  
 <span data-ttu-id="3bd02-773">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-773">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-774">`value` wird von einem vorherigen Vorgang auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-774">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="3bd02-775">`value` aus dem Stapel entfernt wird. Wenn `value` `true`ist, verzweigen Sie in `target`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-775">`value` is popped from the stack; if `value` is `true`, branch to `target`.</span></span>  
  
 <span data-ttu-id="3bd02-776">Die `brtrue.s` Anweisung überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value` (Type `native int`) ungleich 0 (null) (`true`) ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-776">The `brtrue.s` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`).</span></span> <span data-ttu-id="3bd02-777">Wenn `value` NULL (`false`) ist, wird die Ausführung bei der nächsten Anweisung fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-777">If `value` is zero (`false`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="3bd02-778">Wenn `value` ein Objekt Verweis (Typ `O`) ist, übermittelt `brinst` (ein Alias für `brtrue`) die Steuerung, wenn Sie eine Instanz eines Objekts darstellt (z. b., wenn es sich nicht um den NULL-Objekt Verweis handelt; Weitere Informationen finden Sie unter <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span><span class="sxs-lookup"><span data-stu-id="3bd02-778">If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span></span>  
  
 <span data-ttu-id="3bd02-779">Die Ziel Anweisung wird als 1-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-779">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-780">Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-780">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="3bd02-781">Steuerelement Übertragungen in und aus `try`-, `catch`-, `filter`-und `finally`-Blöcken können von dieser Anweisung nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-781">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-782">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `brtrue.s` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-782">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue.s` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-783">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-783">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-784">Ruft die Methode auf, die der übergebene Methodendeskriptor angibt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-784">Calls the method indicated by the passed method descriptor.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-785">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-785">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-786">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-786">Format</span></span>|<span data-ttu-id="3bd02-787">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-787">Assembly Format</span></span>|<span data-ttu-id="3bd02-788">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-788">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-789">28 < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-789">28 < `T` ></span></span>|<span data-ttu-id="3bd02-790">`methodDesc` anrufen</span><span class="sxs-lookup"><span data-stu-id="3bd02-790">call `methodDesc`</span></span>|<span data-ttu-id="3bd02-791">Ruft die Methode auf, die von `methodDesc`beschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-791">Call the method described by `methodDesc`.</span></span>|  
  
 <span data-ttu-id="3bd02-792">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-792">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-793">Methodenargumente, die über `argN` `arg1` werden, werden auf dem Stapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-793">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-794">Methodenargumente, die durch `argN` `arg1` werden, werden aus dem Stapel entfernt. der Methodenaufrufe wird mit diesen Argumenten ausgeführt, und das Steuerelement wird an die Methode übertragen, auf die vom Methoden Deskriptor verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-794">Method arguments `arg1` through `argN` are popped from the stack; the method call is performed with these arguments and control is transferred to the method referred to by the method descriptor.</span></span> <span data-ttu-id="3bd02-795">Nach Abschluss des Vorgangs wird ein Rückgabewert von der aufgerufenen Methode generiert und an den Aufrufer gesendet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-795">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
3.  <span data-ttu-id="3bd02-796">Der Rückgabewert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-796">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-797">Die `call`-Anweisung ruft die Methode auf, die durch den mit der-Anweisung bestandenen Methoden Deskriptor angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-797">The `call` instruction calls the method indicated by the method descriptor passed with the instruction.</span></span> <span data-ttu-id="3bd02-798">Der Methoden Deskriptor ist ein Metadatentoken, das die aufzurufende Methode angibt, sowie die Anzahl, den Typ und die Reihenfolge der Argumente, die auf dem Stapel abgelegt wurden und die an diese Methode und die zu verwendende Aufruf Konvention übermittelt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-798">The method descriptor is a metadata token that indicates the method to call and the number, type, and order of the arguments that have been placed on the stack to be passed to that method as well as the calling convention to be used.</span></span> <span data-ttu-id="3bd02-799">Der `call`-Anweisung kann eine `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>)-Präfix Anweisung vorangestellt werden, um anzugeben, dass der aktuelle Methoden Zustand vor dem übertragen der Steuerung freigegeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="3bd02-799">The `call` instruction can be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix instruction to specify that the current method state should be released before transferring control.</span></span> <span data-ttu-id="3bd02-800">Wenn der-Befehl die Steuerung an eine Methode mit höherer Vertrauenswürdigkeit überträgt, als die Ursprungs Methode, wird der Stapel Rahmen nicht freigegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-800">If the call transfers control to a method of higher trust than the origin method, the stack frame is not released.</span></span> <span data-ttu-id="3bd02-801">Stattdessen wird die Ausführung automatisch fortgesetzt, als wäre die `tail` nicht angegeben worden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-801">Instead, the execution continues silently as if the `tail` had not been supplied.</span></span> <span data-ttu-id="3bd02-802">Das Metadatentoken enthält ausreichende Informationen, um zu bestimmen, ob es sich um eine statische Methode, eine Instanzmethode, eine virtuelle Methode oder eine globale Funktion handelt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-802">The metadata token carries sufficient information to determine whether the call is to a static method, an instance method, a virtual method, or a global function.</span></span> <span data-ttu-id="3bd02-803">In all diesen Fällen wird die Zieladresse vollständig vom Methoden Deskriptor bestimmt (vergleichen Sie dies mit der <xref:System.Reflection.Emit.OpCodes.Callvirt> Anweisung zum Aufrufen von virtuellen Methoden, wobei die Zieladresse auch vom Lauf Zeittyp des instanzverweises abhängt, der vor dem <xref:System.Reflection.Emit.OpCodes.Callvirt>gepusht wurde).</span><span class="sxs-lookup"><span data-stu-id="3bd02-803">In all of these cases the destination address is determined entirely from the method descriptor (contrast this with the <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction for calling virtual methods, where the destination address also depends upon the runtime type of the instance reference pushed before the <xref:System.Reflection.Emit.OpCodes.Callvirt>).</span></span>  
  
 <span data-ttu-id="3bd02-804">Die Argumente werden in der Reihenfolge von links nach rechts auf dem Stapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-804">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="3bd02-805">Das heißt, das erste Argument wird berechnet und auf dem Stapel abgelegt, dann das zweite Argument, dann das dritte, bis alle erforderlichen Argumente in absteigender Reihenfolge auf dem Stapel liegen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-805">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="3bd02-806">Es gibt drei wichtige Sonderfälle:</span><span class="sxs-lookup"><span data-stu-id="3bd02-806">There are three important special cases:</span></span>  
  
 1. <span data-ttu-id="3bd02-807">Aufrufe einer Instanz-(oder virtuellen) Methode müssen diesen Instanzverweis vor allen Benutzer sichtbaren Argumenten übersetzen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-807">Calls to an instance (or virtual) method must push that instance reference before any of the user-visible arguments.</span></span> <span data-ttu-id="3bd02-808">Der Instanzverweis darf kein NULL-Verweis sein.</span><span class="sxs-lookup"><span data-stu-id="3bd02-808">The instance reference must not be a null reference.</span></span> <span data-ttu-id="3bd02-809">Die in den Metadaten getragene Signatur enthält keinen Eintrag in der Parameterliste für den `this` Zeiger. Stattdessen wird ein Bit verwendet, um anzugeben, ob die Methode das Übergeben des `this` Zeigers erfordert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-809">The signature carried in the metadata does not contain an entry in the parameter list for the `this` pointer; instead, it uses a bit to indicate whether the method requires passing the `this` pointer.</span></span>  
  
 2. <span data-ttu-id="3bd02-810">Es ist zulässig, eine virtuelle Methode mithilfe von `call` (anstatt `callvirt`) aufzurufen. Dies gibt an, dass die Methode mithilfe der Klasse aufgelöst werden soll, die von der-Methode angegeben wird, anstatt wie von dem aufgerufenen Objekt dynamisch angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-810">It is valid to call a virtual method using `call` (rather than `callvirt`); this indicates that the method is to be resolved using the class specified by method rather than as specified dynamically from the object being invoked.</span></span>  
  
 3. <span data-ttu-id="3bd02-811">Beachten Sie, dass die `Invoke`-Methode eines Delegaten entweder mit der `call`-oder `callvirt`-Anweisung aufgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-811">Note that a delegate's `Invoke` method can be called with either the `call` or `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="3bd02-812"><xref:System.Security.SecurityException> kann ausgelöst werden, wenn die Systemsicherheit dem Aufrufer nicht den Zugriff auf die aufgerufene Methode gewährt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-812"><xref:System.Security.SecurityException> may be thrown if system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="3bd02-813">Die Sicherheitsüberprüfung kann auftreten, wenn die MSIL-Anweisungen (Microsoft Intermediate Language) nicht zur Laufzeit, sondern in systemeigenen Code konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-813">The security check may occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3bd02-814">Wenn Sie Methoden von System. Object für Werttypen aufrufen, empfiehlt es sich, das `constrained`-Präfix mit der `callvirt` Anweisung zu verwenden, anstatt eine `call` Anweisung auszuwerten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-814">When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction instead of emitting a `call` instruction.</span></span> <span data-ttu-id="3bd02-815">Dadurch entfällt die Notwendigkeit, eine andere Il auszugeben, je nachdem, ob der Werttyp die Methode überschreibt, sodass ein mögliches Versions Problem vermieden wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-815">This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</span></span> <span data-ttu-id="3bd02-816">Verwenden Sie beim Aufrufen von Schnittstellen Methoden für Werttypen ggf. das `constrained` Präfix, da die Werttyp Methode, die die Schnittstellen Methode implementiert, mithilfe eines `MethodImpl`geändert werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-816">Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="3bd02-817">Diese Probleme werden im <xref:System.Reflection.Emit.OpCodes.Constrained> Opcode ausführlicher beschrieben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-817">These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span></span>  
  
 <span data-ttu-id="3bd02-818">Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladungen können den `call` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-818">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `call` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-819">ILGenerator. ausgeben (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="3bd02-819">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="3bd02-820">ILGenerator. EmitCall(OpCode, MethodInfo, Typ [])</span><span class="sxs-lookup"><span data-stu-id="3bd02-820">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3bd02-821">Die <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A>-Methode wird für `varargs` Aufrufe bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-821">The <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> method is provided for `varargs` calls.</span></span> <span data-ttu-id="3bd02-822">Verwenden Sie die <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methode für normale Aufrufe.</span><span class="sxs-lookup"><span data-stu-id="3bd02-822">Use the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method for normal calls.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-823">Ruft die angegebene Methode auf dem Auswertungsstapel (als Zeiger auf einen Einstiegspunkt) mit Argumenten auf, die durch eine Aufrufkonvention beschrieben sind.</span><span class="sxs-lookup"><span data-stu-id="3bd02-823">Calls the method indicated on the evaluation stack (as a pointer to an entry point) with arguments described by a calling convention.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-824">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-824">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-825">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-825">Format</span></span>|<span data-ttu-id="3bd02-826">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-826">Assembly Format</span></span>|<span data-ttu-id="3bd02-827">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-827">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-828">29 < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-828">29 < `T` ></span></span>|<span data-ttu-id="3bd02-829">Calli-`callSiteDescr`</span><span class="sxs-lookup"><span data-stu-id="3bd02-829">calli `callSiteDescr`</span></span>|<span data-ttu-id="3bd02-830">Ruft die Methode auf, auf die mit den von der Aufruf Konvention beschriebenen Argumenten verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-830">Calls the method pointed to with arguments described by the calling convention.</span></span>|  
  
 <span data-ttu-id="3bd02-831">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-831">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-832">Methodenargumente, die über `argN` `arg1` werden, werden auf dem Stapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-832">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-833">Der Methoden Eingabe Zeiger wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-833">The method entry pointer is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-834">Methodenargumente `arg1` über `argN` und der Methoden Eingabe Zeiger aus dem Stapel. der Aufrufe der-Methode wird ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-834">Method arguments `arg1` through `argN` and the method entry pointer are popped from the stack; the call to the method is performed.</span></span> <span data-ttu-id="3bd02-835">Nach Abschluss des Vorgangs wird ein Rückgabewert von der aufgerufenen Methode generiert und an den Aufrufer gesendet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-835">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
4.  <span data-ttu-id="3bd02-836">Der Rückgabewert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-836">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-837">Die `calli`-Anweisung ruft den Methoden Eintrags Zeiger mit den Argumenten auf, die durch `argN``arg1` werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-837">The `calli` instruction calls the method entry pointer with the arguments `arg1` through `argN`.</span></span> <span data-ttu-id="3bd02-838">Die Typen dieser Argumente werden von der spezifischen Aufruf Konvention (`callSiteDesc`) beschrieben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-838">The types of these arguments are described by the specific calling convention (`callSiteDesc`).</span></span> <span data-ttu-id="3bd02-839">Der `calli` Anweisung kann unmittelbar ein `tail` Präfix (<xref:System.Reflection.Emit.OpCodes.Tailcall>) vorangestellt werden, um anzugeben, dass der aktuelle Methoden Zustand vor dem übertragen der Steuerung freigegeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="3bd02-839">The `calli` instruction may be immediately preceded by a `tail` prefix (<xref:System.Reflection.Emit.OpCodes.Tailcall>) to specify that the current method state should be released before transferring control.</span></span> <span data-ttu-id="3bd02-840">Wenn der-Befehl die Steuerung an eine Methode mit höherer Vertrauenswürdigkeit überträgt, als die Ursprungs Methode, wird der Stapel Rahmen nicht freigegeben. Stattdessen wird die Ausführung im Hintergrund fortgesetzt, als wäre die `tail` nicht angegeben worden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-840">If the call would transfer control to a method of higher trust than the origin method the stack frame will not be released; instead, the execution will continue silently as if the `tail` had not been supplied.</span></span>  
  
 <span data-ttu-id="3bd02-841">Es wird davon ausgegangen, dass es sich um einen bestimmten Zeiger auf systemeigenen Code (des Ziel Computers) handelt, der mit den durch die Aufruf Konvention beschriebenen Argumenten (ein Metadatentoken für eine eigenständige Signatur) rechtmäßig aufgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-841">The method entry pointer is assumed to be a specific pointer to native code (of the target machine) that can be legitimately called with the arguments described by the calling convention (a metadata token for a stand-alone signature).</span></span> <span data-ttu-id="3bd02-842">Ein solcher Zeiger kann mit den <xref:System.Reflection.Emit.OpCodes.Ldftn>-oder <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> Anweisungen erstellt oder aus nativem Code übermittelt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-842">Such a pointer can be created using the <xref:System.Reflection.Emit.OpCodes.Ldftn> or <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> instructions, or passed in from native code.</span></span>  
  
 <span data-ttu-id="3bd02-843">Die Aufruf Konvention wird nicht dynamisch überprüft, sodass Code, der eine `calli` Anweisung verwendet, nicht ordnungsgemäß funktioniert, wenn das Ziel nicht die angegebene Aufruf Konvention tatsächlich verwendet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-843">The calling convention is not checked dynamically, so code that uses a `calli` instruction does not work correctly if the destination does not actually use the specified calling convention.</span></span>  
  
 <span data-ttu-id="3bd02-844">Die Argumente werden in der Reihenfolge von links nach rechts auf dem Stapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-844">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="3bd02-845">Das heißt, das erste Argument wird berechnet und auf dem Stapel abgelegt, dann das zweite Argument, dann das dritte, bis alle erforderlichen Argumente in absteigender Reihenfolge auf dem Stapel liegen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-845">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="3bd02-846">Die Argument Erstellungs Code Sequenz für eine Instanz oder eine virtuelle Methode muss diesen Instanzverweis (der kein NULL-Verweis sein darf) vor einem der Benutzer sichtbaren Argumente per Push übersetzen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-846">The argument-building code sequence for an instance or virtual method must push that instance reference (which must not be a null reference) before any of the user-visible arguments.</span></span>  
  
 <span data-ttu-id="3bd02-847"><xref:System.Security.SecurityException> kann ausgelöst werden, wenn die Systemsicherheit dem Aufrufer nicht den Zugriff auf die aufgerufene Methode gewährt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-847"><xref:System.Security.SecurityException> may be thrown if the system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="3bd02-848">Die Sicherheitsüberprüfung kann auftreten, wenn die MSIL-Anweisungen (Microsoft Intermediate Language) in nativen Code anstatt zur Laufzeit konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-848">The security check can occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="3bd02-849">Die folgenden <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> Methoden können verwendet werden, um eine `calli` Anweisung auf dem Stapel auszuführen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-849">The following <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> methods can be used to perform a `calli` instruction on the stack.</span></span> <span data-ttu-id="3bd02-850">Beachten Sie, dass `calli` über die folgenden Methoden aufgerufen werden sollte, anstatt die <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Klasse zu verwenden, um die Anweisung direkt auf dem Stapel zu platzieren.</span><span class="sxs-lookup"><span data-stu-id="3bd02-850">Note that `calli` should be called through the below methods rather than using the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> class to place the instruction directly on the stack.</span></span>  
  
-   <span data-ttu-id="3bd02-851">ILGenerator.EmitCalli(Opcode, CallingConventions, Type, Type[], Type[]) for calls using a managed calling convention.</span><span class="sxs-lookup"><span data-stu-id="3bd02-851">ILGenerator.EmitCalli(Opcode, CallingConventions, Type, Type[], Type[]) for calls using a managed calling convention.</span></span>  
  
-   <span data-ttu-id="3bd02-852">ILGenerator.EmitCalli(Opcode, CallingConvention, Type, Type[]) for calls using an unmanaged calling convention.</span><span class="sxs-lookup"><span data-stu-id="3bd02-852">ILGenerator.EmitCalli(Opcode, CallingConvention, Type, Type[]) for calls using an unmanaged calling convention.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-853">Ruft eine spät gebundene Methode für ein Objekt auf und legt den Rückgabewert auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-853">Calls a late-bound method on an object, pushing the return value onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-854">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-854">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-855">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-855">Format</span></span>|<span data-ttu-id="3bd02-856">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-856">Assembly Format</span></span>|<span data-ttu-id="3bd02-857">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-857">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-858">6f < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-858">6F < `T` ></span></span>|<span data-ttu-id="3bd02-859">"callvirt"-`method`</span><span class="sxs-lookup"><span data-stu-id="3bd02-859">callvirt `method`</span></span>|<span data-ttu-id="3bd02-860">Ruft eine bestimmte Methode auf, die `obj`zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-860">Calls a specific method associated with `obj`.</span></span>|  
  
 <span data-ttu-id="3bd02-861">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-861">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-862">Ein Objekt Verweis `obj` auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-862">An object reference `obj` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-863">Methodenargumente, die über `argN` `arg1` werden, werden auf dem Stapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-863">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-864">Methodenargumente `arg1` über `argN` und der Objekt Verweis `obj` aus dem Stapel entfernt werden. der Methodenaufrufe wird mit diesen Argumenten ausgeführt, und die Steuerung wird an die-Methode in `obj` übertragen, auf die durch das Methoden Metadaten-Token verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-864">Method arguments `arg1` through `argN` and the object reference `obj` are popped from the stack; the method call is performed with these arguments and control is transferred to the method in `obj` referred to by the method metadata token.</span></span> <span data-ttu-id="3bd02-865">Nach Abschluss des Vorgangs wird ein Rückgabewert von der aufgerufenen Methode generiert und an den Aufrufer gesendet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-865">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
4.  <span data-ttu-id="3bd02-866">Der Rückgabewert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-866">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-867">Die `callvirt`-Anweisung ruft eine spät gebundene Methode für ein Objekt auf.</span><span class="sxs-lookup"><span data-stu-id="3bd02-867">The `callvirt` instruction calls a late-bound method on an object.</span></span> <span data-ttu-id="3bd02-868">Das heißt, die Methode wird auf der Grundlage des Lauf Zeit Typs von `obj` und nicht mit der im Methoden Zeiger sichtbaren Kompilierzeit Klasse ausgewählt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-868">That is, the method is chosen based on the runtime type of `obj` rather than the compile-time class visible in the method pointer.</span></span> <span data-ttu-id="3bd02-869">`Callvirt` können verwendet werden, um sowohl virtuelle als auch Instanzmethoden aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-869">`Callvirt` can be used to call both virtual and instance methods.</span></span> <span data-ttu-id="3bd02-870">Der `callvirt`-Anweisung wird möglicherweise direkt ein Präfix `tail` vorangestellt (<xref:System.Reflection.Emit.OpCodes.Tailcall>), um anzugeben, dass der aktuelle Stapel Rahmen vor dem übertragen der Steuerung freigegeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="3bd02-870">The `callvirt` instruction may be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix to specify that the current stack frame should be released before transferring control.</span></span> <span data-ttu-id="3bd02-871">Wenn der-Befehl die Steuerung an eine Methode mit höherer Vertrauenswürdigkeit überträgt, als die ursprüngliche Methode, wird der Stapel Rahmen nicht freigegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-871">If the call would transfer control to a method of higher trust than the original method the stack frame will not be released.</span></span>  
  
 <span data-ttu-id="3bd02-872">Das Metadatentoken der Methode stellt den Namen, die Klasse und die Signatur der aufzurufenden Methode bereit.</span><span class="sxs-lookup"><span data-stu-id="3bd02-872">The method metadata token provides the name, class and signature of the method to call.</span></span> <span data-ttu-id="3bd02-873">Die Klasse, die `obj` zugeordnet ist, ist die Klasse, von der Sie eine-Instanz ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-873">The class associated with `obj` is the class of which it is an instance.</span></span> <span data-ttu-id="3bd02-874">Wenn die Klasse eine nicht statische Methode definiert, die mit dem festgelegten Methodennamen und der Signatur übereinstimmt, wird diese Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-874">If the class defines a non-static method that matches the indicated method name and signature, this method is called.</span></span> <span data-ttu-id="3bd02-875">Andernfalls werden alle Klassen in der Basisklassen Kette dieser Klasse in der richtigen Reihenfolge geprüft.</span><span class="sxs-lookup"><span data-stu-id="3bd02-875">Otherwise all classes in the base class chain of this class are checked in order.</span></span> <span data-ttu-id="3bd02-876">Wenn keine Methode gefunden wird, ist dies ein Fehler.</span><span class="sxs-lookup"><span data-stu-id="3bd02-876">It is an error if no method is found.</span></span>  
  
 <span data-ttu-id="3bd02-877">`Callvirt` springt das-Objekt und die zugehörigen Argumente aus dem Auswertungs Stapel, bevor die-Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-877">`Callvirt` pops the object and the associated arguments off the evaluation stack before calling the method.</span></span> <span data-ttu-id="3bd02-878">Wenn die Methode über einen Rückgabewert verfügt, wird Sie nach Abschluss der Methode auf dem Stapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-878">If the method has a return value, it is pushed on the stack upon method completion.</span></span> <span data-ttu-id="3bd02-879">Auf der aufgerufenen Seite wird auf den `obj`-Parameter als Argument 0 zugegriffen, `arg1` als Argument 1 usw.</span><span class="sxs-lookup"><span data-stu-id="3bd02-879">On the callee side, the `obj` parameter is accessed as argument 0, `arg1` as argument 1, and so on.</span></span>  
  
 <span data-ttu-id="3bd02-880">Die Argumente werden in der Reihenfolge von links nach rechts auf dem Stapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-880">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="3bd02-881">Das heißt, das erste Argument wird berechnet und auf dem Stapel abgelegt, dann das zweite Argument, dann das dritte, bis alle erforderlichen Argumente in absteigender Reihenfolge auf dem Stapel liegen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-881">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="3bd02-882">Der instanzverweisverweis `obj` (immer erforderlich für `callvirt`) muss vor allen Benutzer sichtbaren Argumenten gepusht werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-882">The instance reference `obj` (always required for `callvirt`) must be pushed before any of the user-visible arguments.</span></span> <span data-ttu-id="3bd02-883">Die Signatur (die im Metadatentoken enthalten ist) muss keinen Eintrag in der Parameterliste für den this-Zeiger enthalten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-883">The signature (carried in the metadata token) need not contain an entry in the parameter list for the this pointer.</span></span>  
  
 <span data-ttu-id="3bd02-884">Beachten Sie, dass eine virtuelle Methode auch mit der <xref:System.Reflection.Emit.OpCodes.Call>-Anweisung aufgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-884">Note that a virtual method can also be called using the <xref:System.Reflection.Emit.OpCodes.Call> instruction.</span></span>  
  
 <span data-ttu-id="3bd02-885"><xref:System.MissingMethodException> wird ausgelöst, wenn eine nicht statische Methode mit dem Namen und der Signatur in der Klasse, die `obj` oder einer der zugehörigen Basisklassen zugeordnet ist, nicht gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="3bd02-885"><xref:System.MissingMethodException> is thrown if a non-static method with the indicated name and signature could not be found in the class associated with `obj` or any of its base classes.</span></span> <span data-ttu-id="3bd02-886">Dies wird in der Regel erkannt, wenn MSIL-Anweisungen (Microsoft Intermediate Language) in systemeigenen Code konvertiert werden, anstatt zur Laufzeit.</span><span class="sxs-lookup"><span data-stu-id="3bd02-886">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="3bd02-887"><xref:System.NullReferenceException> wird ausgelöst, wenn obj null ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-887"><xref:System.NullReferenceException> is thrown if obj is null.</span></span>  
  
 <span data-ttu-id="3bd02-888"><xref:System.Security.SecurityException> wird ausgelöst, wenn die Systemsicherheit dem Aufrufer nicht den Zugriff auf die aufgerufene Methode gewährt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-888"><xref:System.Security.SecurityException> is thrown if system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="3bd02-889">Die Sicherheitsüberprüfung kann auftreten, wenn die cil anstelle der Laufzeit in nativen Code konvertiert wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-889">The security check may occur when the CIL is converted to native code rather than at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3bd02-890">Wenn Sie Methoden von System. Object für Werttypen aufrufen, empfiehlt es sich, das `constrained`-Präfix mit der `callvirt` Anweisung zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-890">When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction.</span></span> <span data-ttu-id="3bd02-891">Dadurch entfällt die Notwendigkeit, eine andere Il auszugeben, je nachdem, ob der Werttyp die Methode überschreibt, sodass ein mögliches Versions Problem vermieden wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-891">This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</span></span> <span data-ttu-id="3bd02-892">Verwenden Sie beim Aufrufen von Schnittstellen Methoden für Werttypen ggf. das `constrained` Präfix, da die Werttyp Methode, die die Schnittstellen Methode implementiert, mithilfe eines `MethodImpl`geändert werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-892">Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="3bd02-893">Diese Probleme werden im <xref:System.Reflection.Emit.OpCodes.Constrained> Opcode ausführlicher beschrieben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-893">These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span></span>  
  
 <span data-ttu-id="3bd02-894">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `callvirt` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-894">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `callvirt` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-895">ILGenerator. ausgeben (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="3bd02-895">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="3bd02-896">ILGenerator. EmitCall(OpCode, MethodInfo, Typ [])</span><span class="sxs-lookup"><span data-stu-id="3bd02-896">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-897">Wandelt ein als Verweis übergebenes Objekt in die angegebene Klasse um.</span><span class="sxs-lookup"><span data-stu-id="3bd02-897">Attempts to cast an object passed by reference to the specified class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-898">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-898">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-899">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-899">Format</span></span>|<span data-ttu-id="3bd02-900">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-900">Assembly Format</span></span>|<span data-ttu-id="3bd02-901">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-901">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-902">74 < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-902">74 < `T` ></span></span>|<span data-ttu-id="3bd02-903">castclass-`class`</span><span class="sxs-lookup"><span data-stu-id="3bd02-903">castclass `class`</span></span>|<span data-ttu-id="3bd02-904">Wandelt ein Objekt in ein neues Objekt vom Typ `class`um.</span><span class="sxs-lookup"><span data-stu-id="3bd02-904">Casts an object to a new object of type `class`.</span></span>|  
  
 <span data-ttu-id="3bd02-905">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-905">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-906">Ein Objekt Verweis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-906">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-907">Der Objekt Verweis wird aus dem Stapel entfernt. das Objekt, auf das verwiesen wird, wird in den angegebenen `class`umgewandelt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-907">The object reference is popped from the stack; the referenced object is cast as the specified `class`.</span></span>  
  
3.  <span data-ttu-id="3bd02-908">Bei erfolgreicher Ausführung wird ein neuer Objekt Verweis auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-908">If successful, a new object reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-909">Die `castclass`-Anweisung versucht, den Objekt Verweis (Typ `O`) oberhalb des Stapels in eine angegebene Klasse umzuwandeln.</span><span class="sxs-lookup"><span data-stu-id="3bd02-909">The `castclass` instruction attempts to cast the object reference (type `O`) atop the stack to a specified class.</span></span> <span data-ttu-id="3bd02-910">Die neue Klasse wird durch ein Metadatentoken angegeben, das die gewünschte Klasse angibt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-910">The new class is specified by a metadata token indicating the desired class.</span></span> <span data-ttu-id="3bd02-911">Wenn die Klasse des Objekts am Anfang des Stapels die neue Klasse nicht implementiert (vorausgesetzt, die neue Klasse ist eine Schnittstelle) und keine abgeleitete Klasse der neuen Klasse ist, wird ein <xref:System.InvalidCastException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-911">If the class of the object on the top of the stack does not implement the new class (assuming the new class is an interface) and is not a derived class of the new class then an <xref:System.InvalidCastException> is thrown.</span></span> <span data-ttu-id="3bd02-912">Wenn der Objekt Verweis ein NULL-Verweis ist, ist `castclass` erfolgreich und gibt das neue-Objekt als NULL-Verweis zurück.</span><span class="sxs-lookup"><span data-stu-id="3bd02-912">If the object reference is a null reference, `castclass` succeeds and returns the new object as a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-913"><xref:System.InvalidCastException> wird ausgelöst, wenn obj nicht in Class umgewandelt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-913"><xref:System.InvalidCastException> is thrown if obj cannot be cast to class.</span></span>  
  
 <span data-ttu-id="3bd02-914"><xref:System.TypeLoadException> wird ausgelöst, wenn die Klasse nicht gefunden werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-914"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="3bd02-915">Dies wird in der Regel erkannt, wenn eine MSIL-Anweisung (Microsoft Intermediate Language) in nativen Code anstatt zur Laufzeit konvertiert wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-915">This is typically detected when a Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="3bd02-916">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `castclass` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-916">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `castclass` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-917">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="3bd02-917">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-918">Vergleicht zwei Werte.</span><span class="sxs-lookup"><span data-stu-id="3bd02-918">Compares two values.</span></span> <span data-ttu-id="3bd02-919">Wenn sie gleich sind, wird der Ganzzahlwert 1 <see langword="(int32" />) auf dem Auswertungsstapel abgelegt, andernfalls wird 0 (<see langword="int32" />) auf dem Auswertungsstapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-919">If they are equal, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-920">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-920">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-921">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-921">Format</span></span>|<span data-ttu-id="3bd02-922">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-922">Assembly Format</span></span>|<span data-ttu-id="3bd02-923">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-923">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-924">FE 01</span><span class="sxs-lookup"><span data-stu-id="3bd02-924">FE 01</span></span>|<span data-ttu-id="3bd02-925">ceq</span><span class="sxs-lookup"><span data-stu-id="3bd02-925">ceq</span></span>|<span data-ttu-id="3bd02-926">Überträgt 1, wenn `value1` `value2`ist. Andernfalls wird 0 gedrückt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-926">Pushes 1 if `value1` equals `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="3bd02-927">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-927">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-928">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-928">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-929">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-929">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-930">`value2` und `value1` werden aus dem Stapel entfernt. `value1` wird mit `value2`verglichen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-930">`value2` and `value1` are popped from the stack; `value1` is compared to `value2`.</span></span>  
  
4.  <span data-ttu-id="3bd02-931">Wenn `value1` gleich `value2`ist, wird 1 auf den Stapel verschoben. Andernfalls wird 0 auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-931">If `value1` is equal to `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-932">Die `ceq`-Anweisung vergleicht `value1` und `value2`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-932">The `ceq` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="3bd02-933">Wenn `value1` gleich `value2`ist, wird 1 (vom Typ `int32`) auf dem Stapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-933">If `value1` is equal to `value2`, then 1 (of type `int32`) is pushed on the stack.</span></span> <span data-ttu-id="3bd02-934">Andernfalls wird "0" (vom Typ "`int32`") auf dem Stapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-934">Otherwise 0 (of type `int32`) is pushed on the stack.</span></span>  
  
 <span data-ttu-id="3bd02-935">Für Gleit Komma Zahlen gibt `ceq` 0 zurück, wenn die Zahlen nicht geordnet sind (entweder oder beide sind NaN).</span><span class="sxs-lookup"><span data-stu-id="3bd02-935">For floating-point number, `ceq` will return 0 if the numbers are unordered (either or both are NaN).</span></span> <span data-ttu-id="3bd02-936">Die unendlichen Werte sind gleich.</span><span class="sxs-lookup"><span data-stu-id="3bd02-936">The infinite values are equal to themselves.</span></span>  
  
 <span data-ttu-id="3bd02-937">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ceq` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-937">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ceq` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-938">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-938">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-939">Vergleicht zwei Werte.</span><span class="sxs-lookup"><span data-stu-id="3bd02-939">Compares two values.</span></span> <span data-ttu-id="3bd02-940">Wenn der erste Wert größer als der zweite Wert ist, wird der Ganzzahlwert 1 <see langword="(int32" />) auf dem Auswertungsstapel abgelegt, andernfalls wird 0 (<see langword="int32" />) auf dem Auswertungsstapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-940">If the first value is greater than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-941">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-941">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-942">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-942">Format</span></span>|<span data-ttu-id="3bd02-943">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-943">Assembly Format</span></span>|<span data-ttu-id="3bd02-944">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-944">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-945">FE 02</span><span class="sxs-lookup"><span data-stu-id="3bd02-945">FE 02</span></span>|<span data-ttu-id="3bd02-946">CGT</span><span class="sxs-lookup"><span data-stu-id="3bd02-946">cgt</span></span>|<span data-ttu-id="3bd02-947">Überträgt 1, wenn `value1` größer als `value2`ist. Andernfalls wird 0 gedrückt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-947">Pushes 1 if `value1` is greater than `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="3bd02-948">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-948">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-949">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-949">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-950">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-950">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-951">`value2` und `value1` werden aus dem Stapel entfernt. `cgt` testet, ob `value1` größer als `value2`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-951">`value2` and `value1` are popped from the stack; `cgt` tests if `value1` is greater than `value2`.</span></span>  
  
4.  <span data-ttu-id="3bd02-952">Wenn `value1` größer als `value2`ist, wird 1 auf den Stapel verschoben. Andernfalls wird 0 auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-952">If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-953">Die `cgt`-Anweisung vergleicht `value1` und `value2`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-953">The `cgt` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="3bd02-954">Wenn `value1` streng größer als `value2`ist, wird der `int32` Wert 1 auf dem Stapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-954">If `value1` is strictly greater than `value2`, then an `int32` value of 1 is pushed on the stack.</span></span> <span data-ttu-id="3bd02-955">Andernfalls wird der `int32` Wert 0 auf dem Stapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-955">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
-   <span data-ttu-id="3bd02-956">Für Gleit Komma Zahlen gibt `cgt` 0 zurück, wenn die Zahlen nicht geordnet sind (d. h., wenn eines oder beide der Argumente Nan sind).</span><span class="sxs-lookup"><span data-stu-id="3bd02-956">For floating-point numbers, `cgt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</span></span>  
  
 <span data-ttu-id="3bd02-957">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `cgt` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-957">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-958">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-958">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-959">Vergleicht zwei Werte ohne Vorzeichen oder zwei ungeordnete Werte.</span><span class="sxs-lookup"><span data-stu-id="3bd02-959">Compares two unsigned or unordered values.</span></span> <span data-ttu-id="3bd02-960">Wenn der erste Wert größer als der zweite Wert ist, wird der Ganzzahlwert 1 <see langword="(int32" />) auf dem Auswertungsstapel abgelegt, andernfalls wird 0 (<see langword="int32" />) auf dem Auswertungsstapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-960">If the first value is greater than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-961">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-961">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-962">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-962">Format</span></span>|<span data-ttu-id="3bd02-963">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-963">Assembly Format</span></span>|<span data-ttu-id="3bd02-964">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-964">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-965">FE 03</span><span class="sxs-lookup"><span data-stu-id="3bd02-965">FE 03</span></span>|<span data-ttu-id="3bd02-966">CGT. UN</span><span class="sxs-lookup"><span data-stu-id="3bd02-966">cgt.un</span></span>|<span data-ttu-id="3bd02-967">Überträgt 1, wenn `value1` größer als `value2`ist. Andernfalls wird 0 (nicht signierte Werte) gedrückt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-967">Pushes 1 if `value1` is greater than `value2`; else pushes 0 (unsigned values).</span></span>|  
  
 <span data-ttu-id="3bd02-968">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-968">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-969">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-969">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-970">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-970">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-971">`value2` und `value1` werden aus dem Stapel entfernt. `cgt.un` testet, ob `value1` größer als `value2`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-971">`value2` and `value1` are popped from the stack; `cgt.un` tests if `value1` is greater than `value2`.</span></span>  
  
4.  <span data-ttu-id="3bd02-972">Wenn `value1` größer als `value2`ist, wird 1 auf den Stapel verschoben. Andernfalls wird 0 auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-972">If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-973">Wenn eine der folgenden `true` ist, wird ein `int32` Wert 1 auf dem Stapel abgelegt:</span><span class="sxs-lookup"><span data-stu-id="3bd02-973">An `int32` value of 1 is pushed on the stack if any of the following is `true` :</span></span>  
  
 <span data-ttu-id="3bd02-974">Für Gleit Komma Zahlen ist `value1` in Bezug auf `value2`nicht geordnet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-974">For floating-point numbers, `value1` is not ordered with respect to `value2`.</span></span>  
  
 <span data-ttu-id="3bd02-975">Bei ganzzahligen Werten ist `value1` streng größer als `value2`, wenn Sie als nicht signierte Zahlen betrachtet werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-975">For integer values, `value1` is strictly greater than `value2` when considered as unsigned numbers.</span></span>  
  
 <span data-ttu-id="3bd02-976">Andernfalls wird ein `int32` Wert von 0 auf dem Stapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-976">Otherwise an `int32` value of 0 is pushed on the stack.</span></span>  
  
 <span data-ttu-id="3bd02-977">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `cgt.un` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-977">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt.un` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-978">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-978">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-979">Löst <see cref="T:System.ArithmeticException" /> aus, wenn der Wert keine endliche Zahl ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-979">Throws <see cref="T:System.ArithmeticException" /> if value is not a finite number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-980">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-980">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-981">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-981">Format</span></span>|<span data-ttu-id="3bd02-982">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-982">Assembly Format</span></span>|<span data-ttu-id="3bd02-983">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-983">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-984">C3</span><span class="sxs-lookup"><span data-stu-id="3bd02-984">C3</span></span>|<span data-ttu-id="3bd02-985">ckfinite</span><span class="sxs-lookup"><span data-stu-id="3bd02-985">ckfinite</span></span>|<span data-ttu-id="3bd02-986">Throw <xref:System.ArithmeticException>, wenn der Wert keine endliche Zahl ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-986">throw <xref:System.ArithmeticException> if value is not a finite number.</span></span>|  
  
 <span data-ttu-id="3bd02-987">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-987">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-988">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-988">`value` is pushed onto the stack.</span></span> 
  
2.  <span data-ttu-id="3bd02-989">`value` wird aus dem Stapel entfernt, und die `ckfinite` Anweisung wird darauf ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-989">`value` is popped from the stack and the `ckfinite` instruction is performed on it.</span></span>  
  
3.  <span data-ttu-id="3bd02-990">`value` wird zurück auf den Stapel verschoben, wenn keine Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-990">`value` is pushed back onto the stack if no exception is thrown.</span></span>  
  
 <span data-ttu-id="3bd02-991">Der `ckfinite instruction` löst <xref:System.ArithmeticException> aus, wenn `value` (eine Gleit Komma Zahl) entweder der Wert "not a Number" (NaN) oder ein `+-` unendlich Wert ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-991">The `ckfinite instruction` throws <xref:System.ArithmeticException> if `value` (a floating-point number) is either a "not a number" value (NaN) or a `+-` infinity value.</span></span> <span data-ttu-id="3bd02-992">`Ckfinite` verlässt den Wert auf dem Stapel, wenn keine Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-992">`Ckfinite` leaves the value on the stack if no exception is thrown.</span></span> <span data-ttu-id="3bd02-993">Die Ausführung ist nicht angegeben, wenn `value` keine Gleit Komma Zahl ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-993">Execution is unspecified if `value` is not a floating-point number.</span></span>  
  
 <span data-ttu-id="3bd02-994"><xref:System.ArithmeticException> wird ausgelöst, wenn `value` keine "normale" Zahl ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-994"><xref:System.ArithmeticException> is thrown if `value` is not a 'normal' number.</span></span>  
  
 <span data-ttu-id="3bd02-995">Beachten Sie, dass eine besondere Ausnahme oder eine abgeleitete Klasse von <xref:System.ArithmeticException> besser geeignet sein kann, wobei der falsche Wert an den Ausnahmehandler übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-995">Note that a special exception or a derived class of <xref:System.ArithmeticException> may be more appropriate, passing the incorrect value to the exception handler.</span></span>  
  
 <span data-ttu-id="3bd02-996">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ckfinite` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-996">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ckfinite` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-997">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-997">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-998">Vergleicht zwei Werte.</span><span class="sxs-lookup"><span data-stu-id="3bd02-998">Compares two values.</span></span> <span data-ttu-id="3bd02-999">Wenn der erste Wert kleiner als der zweite Wert ist, wird der Ganzzahlwert 1 <see langword="(int32" />) auf dem Auswertungsstapel abgelegt, andernfalls wird 0 (<see langword="int32" />) auf dem Auswertungsstapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-999">If the first value is less than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1000">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1000">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1001">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1001">Format</span></span>|<span data-ttu-id="3bd02-1002">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1002">Assembly Format</span></span>|<span data-ttu-id="3bd02-1003">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1003">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1004">FE 04</span><span class="sxs-lookup"><span data-stu-id="3bd02-1004">FE 04</span></span>|<span data-ttu-id="3bd02-1005">CLT</span><span class="sxs-lookup"><span data-stu-id="3bd02-1005">clt</span></span>|<span data-ttu-id="3bd02-1006">Überträgt 1, wenn `value1` kleiner als `value2`ist. Andernfalls wird 0 gedrückt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1006">Pushes 1 if `value1` is less than `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="3bd02-1007">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1007">The stack transitional behavior, in sequential order, is:</span></span> 

1.  <span data-ttu-id="3bd02-1008">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1008">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1009">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1009">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-1010">`value2` und `value1` werden aus dem Stapel entfernt. `clt` testet, ob `value1` kleiner als `value2`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1010">`value2` and `value1` are popped from the stack; `clt` tests if `value1` is less than `value2`.</span></span>  
  
4.  <span data-ttu-id="3bd02-1011">Wenn `value1` kleiner als `value2`ist, wird 1 auf den Stapel verschoben. Andernfalls wird 0 auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1011">If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1012">Die `clt`-Anweisung vergleicht `value1` und `value2`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1012">The `clt` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="3bd02-1013">Wenn `value1` streng kleiner als `value2`ist, wird der `int32` Wert 1 auf dem Stapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1013">If `value1` is strictly less than `value2`, then an `int32` value of 1 is pushed on the stack.</span></span> <span data-ttu-id="3bd02-1014">Andernfalls wird der `int32` Wert 0 auf dem Stapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1014">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
-   <span data-ttu-id="3bd02-1015">Für Gleit Komma Zahlen gibt `clt` 0 zurück, wenn die Zahlen nicht geordnet sind (d. h., wenn eines oder beide der Argumente Nan sind).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1015">For floating-point numbers, `clt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</span></span>  
  
 <span data-ttu-id="3bd02-1016">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `clt` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1016">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1017">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1017">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1018">Vergleicht die Werte ohne Vorzeichen oder die ungeordneten Werte <paramref name="value1" /> und <paramref name="value2" />.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1018">Compares the unsigned or unordered values <paramref name="value1" /> and <paramref name="value2" />.</span></span> <span data-ttu-id="3bd02-1019">Wenn <paramref name="value1" /> kleiner als <paramref name="value2" /> ist, wird der Ganzzahlwert 1 <see langword="(int32" />) auf dem Auswertungsstapel abgelegt, andernfalls wird 0 (<see langword="int32" />) auf dem Auswertungsstapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1019">If <paramref name="value1" /> is less than <paramref name="value2" />, then the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1020">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1020">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1021">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1021">Format</span></span>|<span data-ttu-id="3bd02-1022">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1022">Assembly Format</span></span>|<span data-ttu-id="3bd02-1023">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1023">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1024">FE 05</span><span class="sxs-lookup"><span data-stu-id="3bd02-1024">FE 05</span></span>|<span data-ttu-id="3bd02-1025">CLT. UN</span><span class="sxs-lookup"><span data-stu-id="3bd02-1025">clt.un</span></span>|<span data-ttu-id="3bd02-1026">Überträgt 1, wenn `value1` kleiner als `value2`ist. Andernfalls wird 0 (nicht signierte Werte) gedrückt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1026">Pushes 1 if `value1` is less than `value2`; else pushes 0 (unsigned values).</span></span>|  
  
 <span data-ttu-id="3bd02-1027">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1027">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1028">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1028">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1029">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1029">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-1030">`value2` und `value1` werden aus dem Stapel entfernt. `clt.un` testet, ob `value1` kleiner als `value2`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1030">`value2` and `value1` are popped from the stack; `clt.un` tests if `value1` is less than `value2`.</span></span>  
  
4.  <span data-ttu-id="3bd02-1031">Wenn `value1` kleiner als `value2`ist, wird 1 auf den Stapel verschoben. Andernfalls wird 0 auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1031">If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1032">Die `clt.un`-Anweisung vergleicht `value1` und `value2`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1032">The `clt.un` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="3bd02-1033">Der `int32` Wert 1 wird auf dem Stapel abgelegt, wenn Folgendes zutrifft:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1033">An `int32` value of 1 is pushed on the stack if any of the following is true:</span></span>  
  
-   <span data-ttu-id="3bd02-1034">`value1` ist streng kleiner als `value2` (wie für `clt`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1034">`value1` is strictly less than `value2` (as for `clt`).</span></span>  
  
-   <span data-ttu-id="3bd02-1035">Für Gleit Komma Zahlen ist `value1` in Bezug auf `value2`nicht geordnet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1035">For floating-point numbers, `value1` is not ordered with respect to `value2`.</span></span>  
  
-   <span data-ttu-id="3bd02-1036">Bei ganzzahligen Werten ist `value1` streng kleiner als `value2`, wenn Sie als nicht signierte Zahlen betrachtet werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1036">For integer values, `value1` is strictly less than `value2` when considered as unsigned numbers.</span></span>  
  
 <span data-ttu-id="3bd02-1037">Andernfalls wird der `int32` Wert 0 auf dem Stapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1037">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1038">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `clt.un` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1038">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt.un` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1039">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1039">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1040">Schränkt den Typ ein, für den eine virtuelle Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1040">Constrains the type on which a virtual method call is made.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1041">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1041">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1042">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1042">Format</span></span>|<span data-ttu-id="3bd02-1043">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1043">Assembly Format</span></span>|<span data-ttu-id="3bd02-1044">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1044">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1045">FE 16 < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-1045">FE 16 < `T` ></span></span>|<span data-ttu-id="3bd02-1046">schwierige.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1046">constrained.</span></span> `thisType`|<span data-ttu-id="3bd02-1047">Ruft eine virtuelle Methode für einen Typ auf, der für den Typ "`T`" eingeschränkt ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1047">Call a virtual method on a type constrained to be type `T`.</span></span>|  
  
 <span data-ttu-id="3bd02-1048">Das `constrained` Präfix ist nur in einer `callvirt` Anweisung zulässig.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1048">The `constrained` prefix is permitted only on a `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="3bd02-1049">An diesem Punkt muss der Status des MSIL-Stapels lauten:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1049">The state of the MSIL stack at this point must be as follows:</span></span>  
  
1.  <span data-ttu-id="3bd02-1050">Ein verwalteter Zeiger, `ptr`, wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1050">A managed pointer, `ptr`, is pushed onto the stack.</span></span> <span data-ttu-id="3bd02-1051">Der Typ `ptr` muss ein verwalteter Zeiger (`&`) sein, um `thisType`werden zu können.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1051">The type of `ptr` must be a managed pointer (`&`) to `thisType`.</span></span> <span data-ttu-id="3bd02-1052">Beachten Sie, dass sich dies von der Fall einer unfixen `callvirt` Anweisung unterscheidet, die einen Verweis auf `thisType`erwartet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1052">Note that this is different from the case of an unprefixed `callvirt` instruction, which expects a reference of `thisType`.</span></span>  
  
2.  <span data-ttu-id="3bd02-1053">Methodenargumente, die über `argN` `arg1` werden, werden auf den Stapel verschoben, ebenso wie bei einer `callvirt` Anweisung mit einem unvorhersehenden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1053">Method arguments `arg1` through `argN` are pushed onto the stack, just as with an unprefixed `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="3bd02-1054">Mit dem `constrained`-Präfix können `callvirt` Anweisungen auf einheitliche Weise erstellt werden, unabhängig davon, ob `thisType` ein Werttyp oder ein Verweistyp ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1054">The `constrained` prefix is designed to allow `callvirt` instructions to be made in a uniform way independent of whether `thisType` is a value type or a reference type.</span></span>  
  
 <span data-ttu-id="3bd02-1055">Wenn eine `callvirt` `method` Anweisung `constrained` `thisType`vorangestellt wurde, wird die Anweisung wie folgt ausgeführt:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1055">When a `callvirt` `method` instruction has been prefixed by `constrained` `thisType`, the instruction is executed as follows:</span></span>  
  
-   <span data-ttu-id="3bd02-1056">Wenn `thisType` ein Verweistyp ist (im Gegensatz zu einem Werttyp), wird `ptr` dereferenziert und als this-Zeiger an die `callvirt` der `method`weitergegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1056">If `thisType` is a reference type (as opposed to a value type) then `ptr` is dereferenced and passed as the 'this' pointer to the `callvirt` of `method`.</span></span>  
  
-   <span data-ttu-id="3bd02-1057">Wenn `thisType` ein Werttyp ist und `thisType` `method` implementiert, wird `ptr` unverändert als this-Zeiger an eine `call` `method` Anweisung weitergegeben, für die Implementierung von `method` `thisType`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1057">If `thisType` is a value type and `thisType` implements `method` then `ptr` is passed unmodified as the 'this' pointer to a `call` `method` instruction, for the implementation of `method` by `thisType`.</span></span>  
  
-   <span data-ttu-id="3bd02-1058">Wenn `thisType` ein Werttyp ist und `thisType` nicht `method` implementiert, wird `ptr` dereferenziert, gekapselt und als this-Zeiger an die `callvirt` `method` Anweisung weitergegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1058">If `thisType` is a value type and `thisType` does not implement `method` then `ptr` is dereferenced, boxed, and passed as the 'this' pointer to the `callvirt` `method` instruction.</span></span>  
  
 <span data-ttu-id="3bd02-1059">Der letzte Fall kann nur auftreten, wenn `method` auf <xref:System.Object>, <xref:System.ValueType>oder <xref:System.Enum> definiert wurde und von `thisType`nicht überschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1059">This last case can occur only when `method` was defined on <xref:System.Object>, <xref:System.ValueType>, or <xref:System.Enum> and not overridden by `thisType`.</span></span> <span data-ttu-id="3bd02-1060">In diesem Fall bewirkt das Boxing, dass eine Kopie des ursprünglichen Objekts erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1060">In this case, the boxing causes a copy of the original object to be made.</span></span> <span data-ttu-id="3bd02-1061">Da jedoch keine der Methoden <xref:System.Object>, <xref:System.ValueType>und <xref:System.Enum> den Status des Objekts ändern, kann dieser Fakt nicht erkannt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1061">However, because none of the methods of <xref:System.Object>, <xref:System.ValueType>, and <xref:System.Enum> modify the state of the object, this fact cannot be detected.</span></span>  
  
 <span data-ttu-id="3bd02-1062">Das `constrained` Präfix unterstützt Il-Generatoren, die generischen Code erstellen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1062">The `constrained` prefix supports IL generators that create generic code.</span></span> <span data-ttu-id="3bd02-1063">Normalerweise ist die `callvirt` Anweisung für Werttypen ungültig.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1063">Normally the `callvirt` instruction is not valid on value types.</span></span> <span data-ttu-id="3bd02-1064">Stattdessen ist es erforderlich, dass Il-Compiler die oben beschriebene "This"-Transformation zum Zeitpunkt der Kompilierung ausführen, abhängig vom Typ der `ptr` und der aufgerufenen Methode.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1064">Instead it is required that IL compilers effectively perform the 'this' transformation outlined above at compile time, depending on the type of `ptr` and the method being called.</span></span> <span data-ttu-id="3bd02-1065">Wenn `ptr` jedoch ein generischer Typ ist, der zur Kompilierzeit nicht bekannt ist, ist es nicht möglich, diese Transformation zur Kompilierzeit vorzunehmen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1065">However, when `ptr` is a generic type that is unknown at compile time, it is not possible to make this transformation at compile time.</span></span>  
  
 <span data-ttu-id="3bd02-1066">Der `constrained` Opcode ermöglicht es Il-Compilern, eine virtuelle Funktion auf einheitliche Weise aufzurufen, unabhängig davon, ob `ptr` ein Werttyp oder ein Verweistyp ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1066">The `constrained` opcode allows IL compilers to make a call to a virtual function in a uniform way independent of whether `ptr` is a value type or a reference type.</span></span> <span data-ttu-id="3bd02-1067">Obwohl es für den Fall vorgesehen ist, dass `thisType` eine generische Typvariable ist, kann das `constrained` Präfix auch für nicht generische Typen verwendet werden und die Komplexität beim Erstellen virtueller Aufrufe in Sprachen verringern, die den Unterschied zwischen Werttypen und Verweis Typen ausblenden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1067">Although it is intended for the case where `thisType` is a generic type variable, the `constrained` prefix also works for nongeneric types and can reduce the complexity of generating virtual calls in languages that hide the distinction between value types and reference types.</span></span>  
  
 <span data-ttu-id="3bd02-1068">Die Verwendung des `constrained` Präfixes vermeidet auch mögliche Versions Probleme mit Werttypen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1068">Using the `constrained` prefix also avoids potential versioning problems with value types.</span></span> <span data-ttu-id="3bd02-1069">Wenn das `constrained` Präfix nicht verwendet wird, muss eine andere Il ausgegeben werden, abhängig davon, ob ein Werttyp eine Methode von System. Object überschreibt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1069">If the `constrained` prefix is not used, different IL must be emitted depending on whether or not a value type overrides a method of System.Object.</span></span> <span data-ttu-id="3bd02-1070">Wenn ein Werttyp `V` z. b. die Object. destring ()-Methode überschreibt, wird eine `call` `V.ToString()`-Anweisung ausgegeben. Wenn dies nicht der Fall ist, werden eine `box` Anweisung und eine `callvirt` `Object.ToString()`-Anweisung ausgegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1070">For example, if a value type `V` overrides the Object.ToString() method, a `call` `V.ToString()` instruction is emitted; if it does not, a `box` instruction and a `callvirt` `Object.ToString()` instruction are emitted.</span></span> <span data-ttu-id="3bd02-1071">Im ersten Fall kann ein Versions Problem auftreten, wenn die außer Kraft Setzung später entfernt wird, und im letzteren Fall, wenn eine außer Kraft Setzung später hinzugefügt wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1071">A versioning problem can arise in the former case if the override is later removed, and in the latter case if an override is later added.</span></span>  
  
 <span data-ttu-id="3bd02-1072">Das `constrained` Präfix kann auch für den Aufruf von Schnittstellen Methoden für Werttypen verwendet werden, da die Werttyp Methode, die die Schnittstellen Methode implementiert, mithilfe eines `MethodImpl`geändert werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1072">The `constrained` prefix can also be used for invocation of interface methods on value types, because the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="3bd02-1073">Wenn das `constrained`-Präfix nicht verwendet wird, wird der Compiler gezwungen, auszuwählen, an welche Methode des Werttyps zur Kompilierzeit gebunden werden soll.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1073">If the `constrained` prefix is not used, the compiler is forced to choose which of the value type's methods to bind to at compile time.</span></span> <span data-ttu-id="3bd02-1074">Durch die Verwendung des Präfix `constrained` kann die MSIL eine Bindung an die Methode herstellen, die die Schnittstellen Methode zur Laufzeit implementiert, und nicht zur Kompilierzeit.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1074">Using the `constrained` prefix allows the MSIL to bind to the method that implements the interface method at run time, rather than at compile time.</span></span>  
  
 <span data-ttu-id="3bd02-1075">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `constrained` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1075">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `constrained` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1076">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1076">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1077">Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="native int" />.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1077">Converts the value on top of the evaluation stack to <see langword="native int" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1078">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1078">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1079">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1079">Format</span></span>|<span data-ttu-id="3bd02-1080">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1080">Assembly Format</span></span>|<span data-ttu-id="3bd02-1081">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1081">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1082">D3</span><span class="sxs-lookup"><span data-stu-id="3bd02-1082">D3</span></span>|<span data-ttu-id="3bd02-1083">. i</span><span class="sxs-lookup"><span data-stu-id="3bd02-1083">conv.i</span></span>|<span data-ttu-id="3bd02-1084">In `native int`konvertieren, `native int` auf Stapel schieben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1084">Convert to `native int`, pushing `native int` on stack.</span></span>|  
  
 <span data-ttu-id="3bd02-1085">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1085">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1086">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1086">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1087">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1087">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="3bd02-1088">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1088">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1089">Der `conv.i` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und belassen den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1089">The `conv.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1090">Ganzzahlige Werte von weniger als 4 Bytes werden auf `int32` erweitert, wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn, `conv.i` oder `conv.u` wird verwendet. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1090">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="3bd02-1091">Gleit Komma Werte werden in den `F`-Typ konvertiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1091">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="3bd02-1092">Durch die Konvertierung von Gleit Komma Zahlen in ganzzahlige Werte wird die Zahl in Richtung NULL abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1092">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="3bd02-1093">Bei der Umstellung von einer `float64` in eine `float32`kann die Genauigkeit verloren gehen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1093">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="3bd02-1094">Wenn `value` zu groß für eine `float32 (F)`ist, wird positiv unendlich (wenn `value` positiv ist) oder minus unendlich (wenn `value` negativ ist) zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1094">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="3bd02-1095">Wenn beim Umrechnen eines ganzzahligen Typs in einen anderen ein Überlauf auftritt, werden die hohen Bestell Bits abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1095">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="3bd02-1096">Wenn das Ergebnis kleiner als ein `int32`ist, wird der Wert mit Vorzeichen erweitert, um den Slot auszufüllen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1096">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="3bd02-1097">Wenn beim Umrechnen eines Gleit Komma Typs in eine ganze Zahl ein Überlauf auftritt, wird der zurückgegebene Wert nicht angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1097">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="3bd02-1098">Wenn dieses Feld verwendet wird, werden keine Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1098">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="3bd02-1099">Entsprechende Anweisungen, die eine Ausnahme auslösen, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann, finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1099">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="3bd02-1100">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.i` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1100">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1101">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1101">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1102">Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="int8" /> und erweitert ihn dann zu <see langword="int32" /> (durch Auffüllen).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1102">Converts the value on top of the evaluation stack to <see langword="int8" />, then extends (pads) it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1103">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1103">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1104">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1104">Format</span></span>|<span data-ttu-id="3bd02-1105">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1105">Assembly Format</span></span>|<span data-ttu-id="3bd02-1106">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1106">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1107">67</span><span class="sxs-lookup"><span data-stu-id="3bd02-1107">67</span></span>|<span data-ttu-id="3bd02-1108">"vs. I1"</span><span class="sxs-lookup"><span data-stu-id="3bd02-1108">conv.i1</span></span>|<span data-ttu-id="3bd02-1109">In `int8`konvertieren, `int32` auf Stapel schieben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1109">Convert to `int8`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="3bd02-1110">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1110">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1111">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1111">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1112">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1112">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="3bd02-1113">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1113">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1114">Der `conv.i1` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und belassen den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1114">The `conv.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1115">Ganzzahlige Werte von weniger als 4 Bytes werden auf `int32` erweitert, wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn, `conv.i` oder `conv.u` wird verwendet. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1115">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="3bd02-1116">Gleit Komma Werte werden in den `F`-Typ konvertiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1116">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="3bd02-1117">Durch die Konvertierung von Gleit Komma Zahlen in ganzzahlige Werte wird die Zahl in Richtung NULL abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1117">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="3bd02-1118">Bei der Umstellung von einer `float64` in eine `float32`kann die Genauigkeit verloren gehen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1118">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="3bd02-1119">Wenn `value` zu groß für eine `float32 (F)`ist, wird positiv unendlich (wenn `value` positiv ist) oder minus unendlich (wenn `value` negativ ist) zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1119">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="3bd02-1120">Wenn beim Umrechnen eines ganzzahligen Typs in einen anderen ein Überlauf auftritt, werden die hohen Bestell Bits abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1120">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="3bd02-1121">Wenn das Ergebnis kleiner als ein `int32`ist, wird der Wert mit Vorzeichen erweitert, um den Slot auszufüllen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1121">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="3bd02-1122">Wenn beim Umrechnen eines Gleit Komma Typs in eine ganze Zahl ein Überlauf auftritt, wird der zurückgegebene Wert nicht angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1122">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="3bd02-1123">Wenn dieses Feld verwendet wird, werden keine Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1123">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="3bd02-1124">Entsprechende Anweisungen, die eine Ausnahme auslösen, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann, finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1124">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="3bd02-1125">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.i1` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1125">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i1` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1126">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1126">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1127">Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="int16" /> und erweitert ihn dann zu <see langword="int32" /> (durch Auffüllen).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1127">Converts the value on top of the evaluation stack to <see langword="int16" />, then extends (pads) it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1128">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1128">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1129">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1129">Format</span></span>|<span data-ttu-id="3bd02-1130">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1130">Assembly Format</span></span>|<span data-ttu-id="3bd02-1131">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1131">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1132">68</span><span class="sxs-lookup"><span data-stu-id="3bd02-1132">68</span></span>|<span data-ttu-id="3bd02-1133">"vs. I2"</span><span class="sxs-lookup"><span data-stu-id="3bd02-1133">conv.i2</span></span>|<span data-ttu-id="3bd02-1134">In `int16`konvertieren, `int32` auf Stapel schieben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1134">Convert to `int16`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="3bd02-1135">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1135">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1136">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1136">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1137">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1137">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="3bd02-1138">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1138">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1139">Der `conv.i2` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und belassen den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1139">The `conv.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1140">Ganzzahlige Werte von weniger als 4 Bytes werden auf `int32` erweitert, wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn, `conv.i` oder `conv.u` wird verwendet. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1140">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="3bd02-1141">Gleit Komma Werte werden in den `F`-Typ konvertiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1141">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="3bd02-1142">Durch die Konvertierung von Gleit Komma Zahlen in ganzzahlige Werte wird die Zahl in Richtung NULL abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1142">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="3bd02-1143">Bei der Umstellung von einer `float64` in eine `float32`kann die Genauigkeit verloren gehen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1143">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="3bd02-1144">Wenn `value` zu groß für eine `float32 (F)`ist, wird positiv unendlich (wenn `value` positiv ist) oder minus unendlich (wenn `value` negativ ist) zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1144">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="3bd02-1145">Wenn beim Umrechnen eines ganzzahligen Typs in einen anderen ein Überlauf auftritt, werden die hohen Bestell Bits abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1145">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="3bd02-1146">Wenn das Ergebnis kleiner als ein `int32`ist, wird der Wert mit Vorzeichen erweitert, um den Slot auszufüllen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1146">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="3bd02-1147">Wenn beim Umrechnen eines Gleit Komma Typs in eine ganze Zahl ein Überlauf auftritt, wird der zurückgegebene Wert nicht angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1147">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="3bd02-1148">Wenn dieses Feld verwendet wird, werden keine Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1148">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="3bd02-1149">Entsprechende Anweisungen, die eine Ausnahme auslösen, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann, finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1149">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="3bd02-1150">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.i2` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1150">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i2` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1151">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1151">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1152">Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1152">Converts the value on top of the evaluation stack to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1153">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1153">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1154">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1154">Format</span></span>|<span data-ttu-id="3bd02-1155">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1155">Assembly Format</span></span>|<span data-ttu-id="3bd02-1156">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1156">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1157">69</span><span class="sxs-lookup"><span data-stu-id="3bd02-1157">69</span></span>|<span data-ttu-id="3bd02-1158">I4</span><span class="sxs-lookup"><span data-stu-id="3bd02-1158">conv.i4</span></span>|<span data-ttu-id="3bd02-1159">In `int32`konvertieren, `int32` auf Stapel schieben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1159">Convert to `int32`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="3bd02-1160">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1160">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1161">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1161">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1162">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1162">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="3bd02-1163">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1163">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1164">Der `conv.i4` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und belassen den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1164">The `conv.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1165">Ganzzahlige Werte von weniger als 4 Bytes werden auf `int32` erweitert, wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn, `conv.i` oder `conv.u` wird verwendet. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1165">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="3bd02-1166">Gleit Komma Werte werden in den `F`-Typ konvertiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1166">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="3bd02-1167">Durch die Konvertierung von Gleit Komma Zahlen in ganzzahlige Werte wird die Zahl in Richtung NULL abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1167">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="3bd02-1168">Bei der Umstellung von einer `float64` in eine `float32`kann die Genauigkeit verloren gehen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1168">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="3bd02-1169">Wenn `value` zu groß für eine `float32 (F)`ist, wird positiv unendlich (wenn `value` positiv ist) oder minus unendlich (wenn `value` negativ ist) zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1169">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="3bd02-1170">Wenn beim Umrechnen eines ganzzahligen Typs in einen anderen ein Überlauf auftritt, werden die hohen Bestell Bits abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1170">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="3bd02-1171">Wenn das Ergebnis kleiner als ein `int32`ist, wird der Wert mit Vorzeichen erweitert, um den Slot auszufüllen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1171">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="3bd02-1172">Wenn beim Umrechnen eines Gleit Komma Typs in eine ganze Zahl ein Überlauf auftritt, wird der zurückgegebene Wert nicht angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1172">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="3bd02-1173">Wenn dieses Feld verwendet wird, werden keine Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1173">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="3bd02-1174">Entsprechende Anweisungen, die eine Ausnahme auslösen, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann, finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1174">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="3bd02-1175">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.i4` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1175">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i4` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1176">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1176">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1177">Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="int64" />.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1177">Converts the value on top of the evaluation stack to <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1178">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1178">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1179">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1179">Format</span></span>|<span data-ttu-id="3bd02-1180">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1180">Assembly Format</span></span>|<span data-ttu-id="3bd02-1181">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1181">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1182">6a</span><span class="sxs-lookup"><span data-stu-id="3bd02-1182">6A</span></span>|<span data-ttu-id="3bd02-1183">conv.i8</span><span class="sxs-lookup"><span data-stu-id="3bd02-1183">conv.i8</span></span>|<span data-ttu-id="3bd02-1184">In `int64`konvertieren, `int64` auf Stapel schieben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1184">Convert to `int64`, pushing `int64` on stack.</span></span>|  
  
 <span data-ttu-id="3bd02-1185">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1185">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1186">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1186">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1187">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1187">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="3bd02-1188">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1188">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1189">Der `conv.i8` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und belassen den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1189">The `conv.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1190">Ganzzahlige Werte von weniger als 4 Bytes werden auf `int32` erweitert, wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn, `conv.i` oder `conv.u` wird verwendet. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1190">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="3bd02-1191">Gleit Komma Werte werden in den `F`-Typ konvertiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1191">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="3bd02-1192">Durch die Konvertierung von Gleit Komma Zahlen in ganzzahlige Werte wird die Zahl in Richtung NULL abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1192">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="3bd02-1193">Bei der Umstellung von einer `float64` in eine `float32`kann die Genauigkeit verloren gehen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1193">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="3bd02-1194">Wenn `value` zu groß für eine `float32 (F)`ist, wird positiv unendlich (wenn `value` positiv ist) oder minus unendlich (wenn `value` negativ ist) zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1194">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="3bd02-1195">Wenn beim Umrechnen eines ganzzahligen Typs in einen anderen ein Überlauf auftritt, werden die hohen Bestell Bits abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1195">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="3bd02-1196">Wenn das Ergebnis kleiner als ein `int32`ist, wird der Wert mit Vorzeichen erweitert, um den Slot auszufüllen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1196">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="3bd02-1197">Wenn beim Umrechnen eines Gleit Komma Typs in eine ganze Zahl ein Überlauf auftritt, wird der zurückgegebene Wert nicht angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1197">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="3bd02-1198">Wenn dieses Feld verwendet wird, werden keine Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1198">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="3bd02-1199">Entsprechende Anweisungen, die eine Ausnahme auslösen, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann, finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1199">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="3bd02-1200">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.i8` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1200">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i8` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1201">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1201">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1202">Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="native int" /> mit Vorzeichen und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1202">Converts the signed value on top of the evaluation stack to signed <see langword="native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1203">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1203">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1204">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1204">Format</span></span>|<span data-ttu-id="3bd02-1205">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1205">Assembly Format</span></span>|<span data-ttu-id="3bd02-1206">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1206">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1207">D4</span><span class="sxs-lookup"><span data-stu-id="3bd02-1207">D4</span></span>|<span data-ttu-id="3bd02-1208">conv.ovf.i</span><span class="sxs-lookup"><span data-stu-id="3bd02-1208">conv.ovf.i</span></span>|<span data-ttu-id="3bd02-1209">Konvertieren Sie in eine `native int` (auf dem Stapel als `native int`), und lösen Sie bei einem Überlauf eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1209">Convert to a `native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="3bd02-1210">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1210">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1211">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1211">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1212">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1212">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="3bd02-1213">Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1213">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="3bd02-1214">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1214">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1215">Der `conv.ovf.i` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1215">The `conv.ovf.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1216">Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1216">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="3bd02-1217">Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1217">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="3bd02-1218">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` erweitert werden, wenn Sie auf den Auswertungs Stapel geladen werden (sofern `conv.ovf.i` oder `conv.ovf.u` nicht verwendet werden. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1218">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="3bd02-1219"><xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1219"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-1220">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.ovf.i` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1220">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1221">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1221">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1222">Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="native int" /> mit Vorzeichen und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1222">Converts the unsigned value on top of the evaluation stack to signed <see langword="native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1223">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1223">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1224">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1224">Format</span></span>|<span data-ttu-id="3bd02-1225">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1225">Assembly Format</span></span>|<span data-ttu-id="3bd02-1226">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1226">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1227">8a</span><span class="sxs-lookup"><span data-stu-id="3bd02-1227">8A</span></span>|<span data-ttu-id="3bd02-1228">conv.ovf.i.un</span><span class="sxs-lookup"><span data-stu-id="3bd02-1228">conv.ovf.i.un</span></span>|<span data-ttu-id="3bd02-1229">Konvertiert einen Wert ohne Vorzeichen in einen `native int` (auf dem Stapel als `native int`) und löst bei einem Überlauf eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1229">Converts an unsigned value to a `native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="3bd02-1230">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1230">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1231">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1231">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1232">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1232">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="3bd02-1233">Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1233">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="3bd02-1234">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1234">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1235">Der `conv.ovf.i.un` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1235">The `conv.ovf.i.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1236">Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1236">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="3bd02-1237">Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1237">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="3bd02-1238">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` erweitert werden, wenn Sie auf den Auswertungs Stapel geladen werden (sofern `conv.ovf.i` oder `conv.ovf.u` nicht verwendet werden. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1238">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="3bd02-1239"><xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1239"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-1240">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.ovf.i.un` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1240">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i.un` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1241">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1241">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1242">Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int8" /> mit Vorzeichen und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1242">Converts the signed value on top of the evaluation stack to signed <see langword="int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1243">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1243">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1244">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1244">Format</span></span>|<span data-ttu-id="3bd02-1245">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1245">Assembly Format</span></span>|<span data-ttu-id="3bd02-1246">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1246">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1247">B3</span><span class="sxs-lookup"><span data-stu-id="3bd02-1247">B3</span></span>|<span data-ttu-id="3bd02-1248">conv.ovf.i1</span><span class="sxs-lookup"><span data-stu-id="3bd02-1248">conv.ovf.i1</span></span>|<span data-ttu-id="3bd02-1249">Konvertieren Sie in eine `int8` (auf dem Stapel als `int32`), und lösen Sie bei einem Überlauf eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1249">Convert to an `int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="3bd02-1250">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1250">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1251">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1251">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1252">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1252">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="3bd02-1253">Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1253">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="3bd02-1254">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1254">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1255">Der `conv.ovf.i1` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1255">The `conv.ovf.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1256">Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1256">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="3bd02-1257">Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1257">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="3bd02-1258">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` erweitert werden, wenn Sie auf den Auswertungs Stapel geladen werden (sofern `conv.ovf.i` oder `conv.ovf.u` nicht verwendet werden. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1258">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="3bd02-1259"><xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1259"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-1260">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.ovf.i1` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1260">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1261">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1261">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1262">Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int8" /> mit Vorzeichen und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1262">Converts the unsigned value on top of the evaluation stack to signed <see langword="int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1263">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1263">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1264">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1264">Format</span></span>|<span data-ttu-id="3bd02-1265">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1265">Assembly Format</span></span>|<span data-ttu-id="3bd02-1266">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1266">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1267">82</span><span class="sxs-lookup"><span data-stu-id="3bd02-1267">82</span></span>|<span data-ttu-id="3bd02-1268">conv.ovf.i1.un</span><span class="sxs-lookup"><span data-stu-id="3bd02-1268">conv.ovf.i1.un</span></span>|<span data-ttu-id="3bd02-1269">Konvertiert einen Wert ohne Vorzeichen in einen `int8` (auf dem Stapel als `int32`) und löst bei einem Überlauf eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1269">Converts an unsigned value to an `int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="3bd02-1270">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1270">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1271">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1271">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1272">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1272">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="3bd02-1273">Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1273">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="3bd02-1274">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1274">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1275">Der `conv.ovf.i1.un` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1275">The `conv.ovf.i1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1276">Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1276">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="3bd02-1277">Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1277">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="3bd02-1278">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` erweitert werden, wenn Sie auf den Auswertungs Stapel geladen werden (sofern `conv.ovf.i` oder `conv.ovf.u` nicht verwendet werden. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1278">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="3bd02-1279"><xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1279"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-1280">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.ovf.i1.un` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1280">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1.un` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1281">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1281">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1282">Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int16" /> mit Vorzeichen und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1282">Converts the signed value on top of the evaluation stack to signed <see langword="int16" /> and extending it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1283">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1283">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1284">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1284">Format</span></span>|<span data-ttu-id="3bd02-1285">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1285">Assembly Format</span></span>|<span data-ttu-id="3bd02-1286">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1286">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1287">B5</span><span class="sxs-lookup"><span data-stu-id="3bd02-1287">B5</span></span>|<span data-ttu-id="3bd02-1288">conv.ovf.i2</span><span class="sxs-lookup"><span data-stu-id="3bd02-1288">conv.ovf.i2</span></span>|<span data-ttu-id="3bd02-1289">Konvertieren Sie in eine `int16` (auf dem Stapel als `int32`), und lösen Sie bei einem Überlauf eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1289">Convert to an `int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="3bd02-1290">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1290">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1291">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1291">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1292">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1292">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="3bd02-1293">Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1293">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="3bd02-1294">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1294">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1295">Der `conv.ovf.i2` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1295">The `conv.ovf.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1296">Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1296">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="3bd02-1297">Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1297">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="3bd02-1298">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` erweitert werden, wenn Sie auf den Auswertungs Stapel geladen werden (sofern `conv.ovf.i` oder `conv.ovf.u` nicht verwendet werden. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1298">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="3bd02-1299"><xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1299"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-1300">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.ovf.i2` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1300">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1301">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1301">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1302">Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int16" /> mit Vorzeichen und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1302">Converts the unsigned value on top of the evaluation stack to signed <see langword="int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1303">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1303">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1304">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1304">Format</span></span>|<span data-ttu-id="3bd02-1305">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1305">Assembly Format</span></span>|<span data-ttu-id="3bd02-1306">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1306">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1307">83</span><span class="sxs-lookup"><span data-stu-id="3bd02-1307">83</span></span>|<span data-ttu-id="3bd02-1308">conv.ovf.i2.un</span><span class="sxs-lookup"><span data-stu-id="3bd02-1308">conv.ovf.i2.un</span></span>|<span data-ttu-id="3bd02-1309">Konvertiert einen Wert ohne Vorzeichen in einen `int16` (auf dem Stapel als `int32`) und löst bei einem Überlauf eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1309">Converts an unsigned value to an `int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="3bd02-1310">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1310">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1311">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1311">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1312">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1312">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="3bd02-1313">Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1313">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="3bd02-1314">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1314">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1315">Der `conv.ovf.i2.un` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1315">The `conv.ovf.i2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1316">Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1316">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="3bd02-1317">Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1317">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="3bd02-1318">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` erweitert werden, wenn Sie auf den Auswertungs Stapel geladen werden (sofern `conv.ovf.i` oder `conv.ovf.u` nicht verwendet werden. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1318">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="3bd02-1319"><xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1319"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-1320">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.ovf.i2.un` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1320">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2.un` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1321">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1321">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1322">Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int32" /> mit Vorzeichen und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1322">Converts the signed value on top of the evaluation stack to signed <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1323">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1323">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1324">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1324">Format</span></span>|<span data-ttu-id="3bd02-1325">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1325">Assembly Format</span></span>|<span data-ttu-id="3bd02-1326">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1326">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1327">B7</span><span class="sxs-lookup"><span data-stu-id="3bd02-1327">B7</span></span>|<span data-ttu-id="3bd02-1328">conv.ovf.i4</span><span class="sxs-lookup"><span data-stu-id="3bd02-1328">conv.ovf.i4</span></span>|<span data-ttu-id="3bd02-1329">Konvertieren Sie in eine `int32` (auf dem Stapel als `int32`), und lösen Sie bei einem Überlauf eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1329">Convert to an `int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="3bd02-1330">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1330">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1331">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1331">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1332">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1332">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="3bd02-1333">Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1333">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="3bd02-1334">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1334">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1335">Der `conv.ovf.i4` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1335">The `conv.ovf.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1336">Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1336">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="3bd02-1337">Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1337">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="3bd02-1338">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` erweitert werden, wenn Sie auf den Auswertungs Stapel geladen werden (sofern `conv.ovf.i` oder `conv.ovf.u` nicht verwendet werden. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1338">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="3bd02-1339"><xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1339"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-1340">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.ovf.i4` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1340">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1341">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1341">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1342">Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int32" /> mit Vorzeichen und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1342">Converts the unsigned value on top of the evaluation stack to signed <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1343">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1343">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1344">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1344">Format</span></span>|<span data-ttu-id="3bd02-1345">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1345">Assembly Format</span></span>|<span data-ttu-id="3bd02-1346">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1346">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1347">84</span><span class="sxs-lookup"><span data-stu-id="3bd02-1347">84</span></span>|<span data-ttu-id="3bd02-1348">conv.ovf.i4.un</span><span class="sxs-lookup"><span data-stu-id="3bd02-1348">conv.ovf.i4.un</span></span>|<span data-ttu-id="3bd02-1349">Konvertiert einen Wert ohne Vorzeichen in einen `int32` (auf dem Stapel als `int32`) und löst bei einem Überlauf eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1349">Converts an unsigned value to an `int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="3bd02-1350">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1350">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1351">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1351">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1352">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1352">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="3bd02-1353">Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1353">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="3bd02-1354">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1354">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1355">Der `conv.ovf.i4.un` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1355">The `conv.ovf.i4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1356">Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1356">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="3bd02-1357">Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1357">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="3bd02-1358">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` erweitert werden, wenn Sie auf den Auswertungs Stapel geladen werden (sofern `conv.ovf.i` oder `conv.ovf.u` nicht verwendet werden. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1358">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="3bd02-1359"><xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1359"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-1360">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.ovf.i4.un` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1360">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4.un` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1361">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1361">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1362">Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int64" /> mit Vorzeichen und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1362">Converts the signed value on top of the evaluation stack to signed <see langword="int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1363">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1363">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1364">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1364">Format</span></span>|<span data-ttu-id="3bd02-1365">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1365">Assembly Format</span></span>|<span data-ttu-id="3bd02-1366">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1366">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1367">B9</span><span class="sxs-lookup"><span data-stu-id="3bd02-1367">B9</span></span>|<span data-ttu-id="3bd02-1368">conv.ovf.i8</span><span class="sxs-lookup"><span data-stu-id="3bd02-1368">conv.ovf.i8</span></span>|<span data-ttu-id="3bd02-1369">Konvertieren Sie in eine `int64` (auf dem Stapel als `int64`), und lösen Sie bei einem Überlauf eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1369">Convert to an `int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="3bd02-1370">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1370">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1371">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1371">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1372">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1372">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="3bd02-1373">Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1373">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="3bd02-1374">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1374">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1375">Der `conv.ovf.i8` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1375">The `conv.ovf.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1376">Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1376">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="3bd02-1377">Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1377">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="3bd02-1378">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` erweitert werden, wenn Sie auf den Auswertungs Stapel geladen werden (sofern `conv.ovf.i` oder `conv.ovf.u` nicht verwendet werden. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1378">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="3bd02-1379"><xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1379"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-1380">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.ovf.i8` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1380">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1381">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1381">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1382">Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int64" /> mit Vorzeichen und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1382">Converts the unsigned value on top of the evaluation stack to signed <see langword="int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1383">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1383">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1384">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1384">Format</span></span>|<span data-ttu-id="3bd02-1385">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1385">Assembly Format</span></span>|<span data-ttu-id="3bd02-1386">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1386">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1387">85</span><span class="sxs-lookup"><span data-stu-id="3bd02-1387">85</span></span>|<span data-ttu-id="3bd02-1388">conv.ovf.i8.un</span><span class="sxs-lookup"><span data-stu-id="3bd02-1388">conv.ovf.i8.un</span></span>|<span data-ttu-id="3bd02-1389">Konvertiert einen Wert ohne Vorzeichen in einen `int64` (auf dem Stapel als `int64`) und löst bei einem Überlauf eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1389">Converts an unsigned value to an `int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="3bd02-1390">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1390">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1391">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1391">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1392">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1392">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="3bd02-1393">Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1393">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="3bd02-1394">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1394">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1395">Der `conv.ovf.i8.un` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1395">The `conv.ovf.i8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1396">Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1396">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="3bd02-1397">Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1397">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="3bd02-1398">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` erweitert werden, wenn Sie auf den Auswertungs Stapel geladen werden (sofern `conv.ovf.i` oder `conv.ovf.u` nicht verwendet werden. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1398">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="3bd02-1399"><xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1399"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-1400">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.ovf.i8.un` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1400">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8.un` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1401">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1401">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1402">Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned native int" /> und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1402">Converts the signed value on top of the evaluation stack to <see langword="unsigned native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1403">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1403">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1404">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1404">Format</span></span>|<span data-ttu-id="3bd02-1405">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1405">Assembly Format</span></span>|<span data-ttu-id="3bd02-1406">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1406">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1407">D5</span><span class="sxs-lookup"><span data-stu-id="3bd02-1407">D5</span></span>|<span data-ttu-id="3bd02-1408">conv.ovf.u</span><span class="sxs-lookup"><span data-stu-id="3bd02-1408">conv.ovf.u</span></span>|<span data-ttu-id="3bd02-1409">Konvertieren Sie in eine `unsigned native int` (auf dem Stapel als `native int`), und lösen Sie bei einem Überlauf eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1409">Convert to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="3bd02-1410">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1410">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1411">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1411">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1412">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1412">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="3bd02-1413">Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1413">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="3bd02-1414">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1414">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1415">Der `conv.ovf.u` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1415">The `conv.ovf.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1416">Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1416">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="3bd02-1417">Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1417">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="3bd02-1418">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` erweitert werden, wenn Sie auf den Auswertungs Stapel geladen werden (sofern `conv.ovf.i` oder `conv.ovf.u` nicht verwendet werden. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1418">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="3bd02-1419"><xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1419"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-1420">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.ovf.u` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1420">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1421">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1421">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1422">Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned native int" /> und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1422">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1423">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1423">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1424">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1424">Format</span></span>|<span data-ttu-id="3bd02-1425">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1425">Assembly Format</span></span>|<span data-ttu-id="3bd02-1426">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1426">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1427">8B</span><span class="sxs-lookup"><span data-stu-id="3bd02-1427">8B</span></span>|<span data-ttu-id="3bd02-1428">conv.ovf.u.un</span><span class="sxs-lookup"><span data-stu-id="3bd02-1428">conv.ovf.u.un</span></span>|<span data-ttu-id="3bd02-1429">Konvertiert den nicht signierten Wert in einen `unsigned native int` (auf dem Stapel als `native int`) und löst bei einem Überlauf eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1429">Converts un unsigned value to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="3bd02-1430">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1430">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1431">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1431">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1432">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1432">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="3bd02-1433">Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1433">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="3bd02-1434">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1434">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1435">Der `conv.ovf.u.un` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1435">The `conv.ovf.u.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1436">Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1436">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="3bd02-1437">Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1437">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="3bd02-1438">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` erweitert werden, wenn Sie auf den Auswertungs Stapel geladen werden (sofern `conv.ovf.i` oder `conv.ovf.u` nicht verwendet werden. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1438">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="3bd02-1439"><xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1439"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-1440">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.uvf.u.un` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1440">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.uvf.u.un` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1441">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1441">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1442">Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int8" /> und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1442">Converts the signed value on top of the evaluation stack to <see langword="unsigned int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1443">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1443">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1444">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1444">Format</span></span>|<span data-ttu-id="3bd02-1445">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1445">Assembly Format</span></span>|<span data-ttu-id="3bd02-1446">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1446">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1447">B4</span><span class="sxs-lookup"><span data-stu-id="3bd02-1447">B4</span></span>|<span data-ttu-id="3bd02-1448">conv.ovf.u1</span><span class="sxs-lookup"><span data-stu-id="3bd02-1448">conv.ovf.u1</span></span>|<span data-ttu-id="3bd02-1449">Konvertieren Sie in eine `unsigned int8` (auf dem Stapel als `int32`), und lösen Sie bei einem Überlauf eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1449">Convert to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="3bd02-1450">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1450">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1451">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1451">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1452">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1452">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="3bd02-1453">Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1453">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="3bd02-1454">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1454">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1455">Der `conv.ovf.u1` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1455">The `conv.ovf.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1456">Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1456">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="3bd02-1457">Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1457">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="3bd02-1458">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` erweitert werden, wenn Sie auf den Auswertungs Stapel geladen werden (sofern `conv.ovf.i` oder `conv.ovf.u` nicht verwendet werden. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1458">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="3bd02-1459"><xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1459"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-1460">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.ovf.u1` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1460">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1461">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1461">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1462">Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int8" /> und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1462">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1463">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1463">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1464">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1464">Format</span></span>|<span data-ttu-id="3bd02-1465">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1465">Assembly Format</span></span>|<span data-ttu-id="3bd02-1466">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1466">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1467">86</span><span class="sxs-lookup"><span data-stu-id="3bd02-1467">86</span></span>|<span data-ttu-id="3bd02-1468">conv.ovf.u1.un</span><span class="sxs-lookup"><span data-stu-id="3bd02-1468">conv.ovf.u1.un</span></span>|<span data-ttu-id="3bd02-1469">Konvertiert einen Wert ohne Vorzeichen in einen `unsigned int8` (auf dem Stapel als `int32`) und löst bei einem Überlauf eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1469">Converts an unsigned value to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="3bd02-1470">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1470">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1471">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1471">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1472">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1472">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="3bd02-1473">Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1473">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="3bd02-1474">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1474">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1475">Der `conv.ovf.u1.un` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1475">The `conv.ovf.u1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1476">Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1476">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="3bd02-1477">Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1477">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="3bd02-1478">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` erweitert werden, wenn Sie auf den Auswertungs Stapel geladen werden (sofern `conv.ovf.i` oder `conv.ovf.u` nicht verwendet werden. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1478">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="3bd02-1479"><xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1479"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-1480">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.ovf.u1.un` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1480">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1.un` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1481">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1481">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1482">Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int16" /> und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1482">Converts the signed value on top of the evaluation stack to <see langword="unsigned int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1483">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1483">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1484">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1484">Format</span></span>|<span data-ttu-id="3bd02-1485">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1485">Assembly Format</span></span>|<span data-ttu-id="3bd02-1486">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1486">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1487">B6</span><span class="sxs-lookup"><span data-stu-id="3bd02-1487">B6</span></span>|<span data-ttu-id="3bd02-1488">conv.ovf.u2</span><span class="sxs-lookup"><span data-stu-id="3bd02-1488">conv.ovf.u2</span></span>|<span data-ttu-id="3bd02-1489">Konvertieren Sie in eine `unsigned int16` (auf dem Stapel als `int32`), und lösen Sie bei einem Überlauf eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1489">Convert to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="3bd02-1490">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1490">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1491">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1491">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1492">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1492">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="3bd02-1493">Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1493">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="3bd02-1494">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1494">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1495">Der `conv.ovf.u2` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1495">The `conv.ovf.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1496">Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1496">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="3bd02-1497">Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1497">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="3bd02-1498">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` erweitert werden, wenn Sie auf den Auswertungs Stapel geladen werden (sofern `conv.ovf.i` oder `conv.ovf.u` nicht verwendet werden. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1498">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="3bd02-1499"><xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1499"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-1500">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.ovf.u2` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1500">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1501">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1501">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1502">Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int16" /> und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1502">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1503">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1503">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1504">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1504">Format</span></span>|<span data-ttu-id="3bd02-1505">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1505">Assembly Format</span></span>|<span data-ttu-id="3bd02-1506">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1506">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1507">87</span><span class="sxs-lookup"><span data-stu-id="3bd02-1507">87</span></span>|<span data-ttu-id="3bd02-1508">conv.ovf.u2.un</span><span class="sxs-lookup"><span data-stu-id="3bd02-1508">conv.ovf.u2.un</span></span>|<span data-ttu-id="3bd02-1509">Konvertiert einen Wert ohne Vorzeichen in einen `unsigned int16` (auf dem Stapel als `int32`) und löst bei einem Überlauf eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1509">Converts an unsigned value to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="3bd02-1510">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1510">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1511">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1511">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1512">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1512">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="3bd02-1513">Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1513">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="3bd02-1514">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1514">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1515">Der `conv.ovf.u2.un` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1515">The `conv.ovf.u2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1516">Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1516">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="3bd02-1517">Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1517">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="3bd02-1518">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` erweitert werden, wenn Sie auf den Auswertungs Stapel geladen werden (sofern `conv.ovf.i` oder `conv.ovf.u` nicht verwendet werden. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1518">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="3bd02-1519"><xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1519"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-1520">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.ovf.u2.un` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1520">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2.un` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1521">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1521">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1522">Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int32" /> und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1522">Converts the signed value on top of the evaluation stack to <see langword="unsigned int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1523">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1523">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1524">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1524">Format</span></span>|<span data-ttu-id="3bd02-1525">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1525">Assembly Format</span></span>|<span data-ttu-id="3bd02-1526">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1526">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1527">B8</span><span class="sxs-lookup"><span data-stu-id="3bd02-1527">B8</span></span>|<span data-ttu-id="3bd02-1528">conv.ovf.u4</span><span class="sxs-lookup"><span data-stu-id="3bd02-1528">conv.ovf.u4</span></span>|<span data-ttu-id="3bd02-1529">Konvertieren Sie in eine `unsigned int32` (auf dem Stapel als `int32`), und lösen Sie bei einem Überlauf eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1529">Convert to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="3bd02-1530">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1530">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1531">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1531">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1532">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1532">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="3bd02-1533">Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1533">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="3bd02-1534">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1534">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1535">Der `conv.ovf.u4` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1535">The `conv.ovf.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1536">Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1536">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="3bd02-1537">Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1537">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="3bd02-1538">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` erweitert werden, wenn Sie auf den Auswertungs Stapel geladen werden (sofern `conv.ovf.i` oder `conv.ovf.u` nicht verwendet werden. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1538">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="3bd02-1539"><xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1539"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-1540">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.ovf.u4` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1540">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1541">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1541">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1542">Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int32" /> und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1542">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1543">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1543">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1544">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1544">Format</span></span>|<span data-ttu-id="3bd02-1545">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1545">Assembly Format</span></span>|<span data-ttu-id="3bd02-1546">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1546">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1547">88</span><span class="sxs-lookup"><span data-stu-id="3bd02-1547">88</span></span>|<span data-ttu-id="3bd02-1548">conv.ovf.u4.un</span><span class="sxs-lookup"><span data-stu-id="3bd02-1548">conv.ovf.u4.un</span></span>|<span data-ttu-id="3bd02-1549">Konvertiert einen Wert ohne Vorzeichen in einen `unsigned int32` (auf dem Stapel als `int32`) und löst bei einem Überlauf eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1549">Converts an unsigned value to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="3bd02-1550">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1550">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1551">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1551">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1552">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1552">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="3bd02-1553">Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1553">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="3bd02-1554">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1554">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1555">Der `conv.ovf.u4.un` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1555">The `conv.ovf.u4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1556">Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1556">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="3bd02-1557">Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1557">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="3bd02-1558">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` erweitert werden, wenn Sie auf den Auswertungs Stapel geladen werden (sofern `conv.ovf.i` oder `conv.ovf.u` nicht verwendet werden. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1558">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="3bd02-1559"><xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1559"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-1560">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.ovf.u4.un` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1560">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4.un` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1561">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1561">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1562">Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int64" /> und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1562">Converts the signed value on top of the evaluation stack to <see langword="unsigned int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1563">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1563">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1564">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1564">Format</span></span>|<span data-ttu-id="3bd02-1565">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1565">Assembly Format</span></span>|<span data-ttu-id="3bd02-1566">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1566">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1567">Ben</span><span class="sxs-lookup"><span data-stu-id="3bd02-1567">BA</span></span>|<span data-ttu-id="3bd02-1568">conv.ovf.u8</span><span class="sxs-lookup"><span data-stu-id="3bd02-1568">conv.ovf.u8</span></span>|<span data-ttu-id="3bd02-1569">Konvertieren Sie in eine `unsigned int64` (auf dem Stapel als `int64`), und lösen Sie bei einem Überlauf eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1569">Convert to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="3bd02-1570">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1570">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1571">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1571">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1572">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1572">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="3bd02-1573">Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1573">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="3bd02-1574">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1574">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1575">Der `conv.ovf.u8` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1575">The `conv.ovf.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1576">Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1576">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="3bd02-1577">Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1577">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="3bd02-1578">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` erweitert werden, wenn Sie auf den Auswertungs Stapel geladen werden (sofern `conv.ovf.i` oder `conv.ovf.u` nicht verwendet werden. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1578">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="3bd02-1579"><xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1579"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-1580">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.ovf.u8` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1580">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1581">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1581">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1582">Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int64" /> und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1582">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1583">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1583">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1584">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1584">Format</span></span>|<span data-ttu-id="3bd02-1585">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1585">Assembly Format</span></span>|<span data-ttu-id="3bd02-1586">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1586">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1587">89</span><span class="sxs-lookup"><span data-stu-id="3bd02-1587">89</span></span>|<span data-ttu-id="3bd02-1588">conv.ovf.u8.un</span><span class="sxs-lookup"><span data-stu-id="3bd02-1588">conv.ovf.u8.un</span></span>|<span data-ttu-id="3bd02-1589">Konvertiert einen Wert ohne Vorzeichen in einen `unsigned int64` (auf dem Stapel als `int64`) und löst bei einem Überlauf eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1589">Converts an unsigned value to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="3bd02-1590">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1590">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1591">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1591">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1592">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1592">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="3bd02-1593">Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1593">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="3bd02-1594">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1594">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1595">Der `conv.ovf.u8.un` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1595">The `conv.ovf.u8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1596">Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1596">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="3bd02-1597">Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1597">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="3bd02-1598">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` erweitert werden, wenn Sie auf den Auswertungs Stapel geladen werden (sofern `conv.ovf.i` oder `conv.ovf.u` nicht verwendet werden. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1598">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="3bd02-1599"><xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1599"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-1600">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.ovf.u8.un` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1600">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8.un` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1601">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1601">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1602">Konvertiert den Ganzzahlwert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="float32" />.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1602">Converts the unsigned integer value on top of the evaluation stack to <see langword="float32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1603">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1603">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1604">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1604">Format</span></span>|<span data-ttu-id="3bd02-1605">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1605">Assembly Format</span></span>|<span data-ttu-id="3bd02-1606">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1606">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1607">76</span><span class="sxs-lookup"><span data-stu-id="3bd02-1607">76</span></span>|<span data-ttu-id="3bd02-1608">". r. un"</span><span class="sxs-lookup"><span data-stu-id="3bd02-1608">conv.r.un</span></span>|<span data-ttu-id="3bd02-1609">Konvertiert eine Ganzzahl ohne Vorzeichen in einen Gleit Komma Wert und überträgt `F` auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1609">Convert unsigned integer to floating-point, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="3bd02-1610">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1610">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1611">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1611">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1612">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1612">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="3bd02-1613">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1613">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1614">Der `conv.r.un` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und belassen den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1614">The `conv.r.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1615">Ganzzahlige Werte von weniger als 4 Bytes werden auf `int32` erweitert, wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn, `conv.i` oder `conv.u` wird verwendet. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1615">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="3bd02-1616">Gleit Komma Werte werden in den `F`-Typ konvertiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1616">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="3bd02-1617">Durch die Konvertierung von Gleit Komma Zahlen in ganzzahlige Werte wird die Zahl in Richtung NULL abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1617">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="3bd02-1618">Bei der Umstellung von einer `float64` in eine `float32`kann die Genauigkeit verloren gehen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1618">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="3bd02-1619">Wenn `value` zu groß für eine `float32 (F)`ist, wird positiv unendlich (wenn `value` positiv ist) oder minus unendlich (wenn `value` negativ ist) zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1619">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="3bd02-1620">Wenn beim Umrechnen eines ganzzahligen Typs in einen anderen ein Überlauf auftritt, werden die hohen Bestell Bits abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1620">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="3bd02-1621">Wenn das Ergebnis kleiner als ein `int32`ist, wird der Wert mit Vorzeichen erweitert, um den Slot auszufüllen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1621">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="3bd02-1622">Wenn beim Umrechnen eines Gleit Komma Typs in eine ganze Zahl ein Überlauf auftritt, wird der zurückgegebene `result` nicht angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1622">If overflow occurs converting a floating-point type to an integer the `result` returned is unspecified.</span></span> <span data-ttu-id="3bd02-1623">Der `conv.r.un` Vorgang nimmt eine ganze Zahl aus dem Stapel, interpretiert sie als unsigned und ersetzt Sie durch eine Gleit Komma Zahl, die die ganze Zahl darstellt: entweder eine `float32`, wenn diese breit genug ist, um die ganze Zahl ohne Genauigkeits Verlust darzustellen, oder eine `float64`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1623">The `conv.r.un` operation takes an integer off the stack, interprets it as unsigned, and replaces it with a floating-point number to represent the integer: either a `float32`, if this is wide enough to represent the integer without loss of precision, or else a `float64`.</span></span>  
  
 <span data-ttu-id="3bd02-1624">Wenn dieses Feld verwendet wird, werden keine Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1624">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="3bd02-1625">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.r.un` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1625">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r.un` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1626">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1626">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1627">Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="float32" />.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1627">Converts the value on top of the evaluation stack to <see langword="float32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1628">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1628">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1629">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1629">Format</span></span>|<span data-ttu-id="3bd02-1630">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1630">Assembly Format</span></span>|<span data-ttu-id="3bd02-1631">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1631">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1632">6B</span><span class="sxs-lookup"><span data-stu-id="3bd02-1632">6B</span></span>|<span data-ttu-id="3bd02-1633">Configuration Manager</span><span class="sxs-lookup"><span data-stu-id="3bd02-1633">conv.r4</span></span>|<span data-ttu-id="3bd02-1634">In `float32`konvertieren, `F` auf Stapel schieben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1634">Convert to `float32`, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="3bd02-1635">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1635">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1636">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1636">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1637">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1637">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="3bd02-1638">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1638">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1639">Der `conv.r4` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und belassen den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1639">The `conv.r4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1640">Ganzzahlige Werte von weniger als 4 Bytes werden auf `int32` erweitert, wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn, `conv.i` oder `conv.u` wird verwendet. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1640">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="3bd02-1641">Gleit Komma Werte werden in den `F`-Typ konvertiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1641">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="3bd02-1642">Durch die Konvertierung von Gleit Komma Zahlen in ganzzahlige Werte wird die Zahl in Richtung NULL abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1642">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="3bd02-1643">Bei der Umstellung von einer `float64` in eine `float32`kann die Genauigkeit verloren gehen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1643">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="3bd02-1644">Wenn `value` zu groß für eine `float32 (F)`ist, wird positiv unendlich (wenn `value` positiv ist) oder minus unendlich (wenn `value` negativ ist) zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1644">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="3bd02-1645">Wenn beim Umrechnen eines ganzzahligen Typs in einen anderen ein Überlauf auftritt, werden die hohen Bestell Bits abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1645">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="3bd02-1646">Wenn das Ergebnis kleiner als ein `int32`ist, wird der Wert mit Vorzeichen erweitert, um den Slot auszufüllen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1646">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="3bd02-1647">Wenn beim Umrechnen eines Gleit Komma Typs in eine ganze Zahl ein Überlauf auftritt, wird der zurückgegebene Wert nicht angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1647">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="3bd02-1648">Wenn dieses Feld verwendet wird, werden keine Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1648">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="3bd02-1649">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.r4` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1649">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r4` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1650">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1650">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1651">Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="float64" />.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1651">Converts the value on top of the evaluation stack to <see langword="float64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1652">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1652">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1653">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1653">Format</span></span>|<span data-ttu-id="3bd02-1654">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1654">Assembly Format</span></span>|<span data-ttu-id="3bd02-1655">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1655">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1656">6C</span><span class="sxs-lookup"><span data-stu-id="3bd02-1656">6C</span></span>|<span data-ttu-id="3bd02-1657">"vs. R8"</span><span class="sxs-lookup"><span data-stu-id="3bd02-1657">conv.r8</span></span>|<span data-ttu-id="3bd02-1658">In `float64`konvertieren, `F` auf Stapel schieben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1658">Convert to `float64`, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="3bd02-1659">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1659">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1660">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1660">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1661">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1661">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="3bd02-1662">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1662">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1663">Der `conv.r8` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und belassen den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1663">The `conv.r8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1664">Ganzzahlige Werte von weniger als 4 Bytes werden auf `int32` erweitert, wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn, `conv.i` oder `conv.u` wird verwendet. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1664">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="3bd02-1665">Gleit Komma Werte werden in den `F`-Typ konvertiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1665">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="3bd02-1666">Durch die Konvertierung von Gleit Komma Zahlen in ganzzahlige Werte wird die Zahl in Richtung NULL abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1666">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="3bd02-1667">Bei der Umstellung von einer `float64` in eine `float32`kann die Genauigkeit verloren gehen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1667">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="3bd02-1668">Wenn `value` zu groß für eine `float32 (F)`ist, wird positiv unendlich (wenn `value` positiv ist) oder minus unendlich (wenn `value` negativ ist) zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1668">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="3bd02-1669">Wenn beim Umrechnen eines ganzzahligen Typs in einen anderen ein Überlauf auftritt, werden die hohen Bestell Bits abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1669">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="3bd02-1670">Wenn das Ergebnis kleiner als ein `int32`ist, wird der Wert mit Vorzeichen erweitert, um den Slot auszufüllen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1670">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="3bd02-1671">Wenn beim Umrechnen eines Gleit Komma Typs in eine ganze Zahl ein Überlauf auftritt, wird der zurückgegebene Wert nicht angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1671">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="3bd02-1672">Wenn dieses Feld verwendet wird, werden keine Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1672">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="3bd02-1673">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.r8` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1673">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r8` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1674">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1674">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1675">Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="unsigned native int" /> und erweitert ihn dann zu <see langword="native int" />.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1675">Converts the value on top of the evaluation stack to <see langword="unsigned native int" />, and extends it to <see langword="native int" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1676">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1676">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1677">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1677">Format</span></span>|<span data-ttu-id="3bd02-1678">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1678">Assembly Format</span></span>|<span data-ttu-id="3bd02-1679">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1679">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1680">E0</span><span class="sxs-lookup"><span data-stu-id="3bd02-1680">E0</span></span>|<span data-ttu-id="3bd02-1681">. u</span><span class="sxs-lookup"><span data-stu-id="3bd02-1681">conv.u</span></span>|<span data-ttu-id="3bd02-1682">In `unsigned native int`konvertieren, `native int` auf Stapel schieben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1682">Convert to `unsigned native int`, pushing `native int` on stack.</span></span>|  
  
 <span data-ttu-id="3bd02-1683">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1683">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1684">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1684">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1685">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1685">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="3bd02-1686">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1686">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1687">Der `conv.u` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und belassen den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1687">The `conv.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1688">Ganzzahlige Werte von weniger als 4 Bytes werden auf `int32` erweitert, wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn, `conv.i` oder `conv.u` wird verwendet. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1688">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="3bd02-1689">Gleit Komma Werte werden in den `F`-Typ konvertiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1689">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="3bd02-1690">Durch die Konvertierung von Gleit Komma Zahlen in ganzzahlige Werte wird die Zahl in Richtung NULL abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1690">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="3bd02-1691">Bei der Umstellung von einer `float64` in eine `float32`kann die Genauigkeit verloren gehen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1691">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="3bd02-1692">Wenn `value` zu groß für eine `float32 (F)`ist, wird positiv unendlich (wenn `value` positiv ist) oder minus unendlich (wenn `value` negativ ist) zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1692">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="3bd02-1693">Wenn beim Umrechnen eines ganzzahligen Typs in einen anderen ein Überlauf auftritt, werden die hohen Bestell Bits abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1693">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="3bd02-1694">Wenn das Ergebnis kleiner als ein `int32`ist, wird der Wert mit Vorzeichen erweitert, um den Slot auszufüllen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1694">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="3bd02-1695">Wenn beim Umrechnen eines Gleit Komma Typs in eine ganze Zahl ein Überlauf auftritt, wird der zurückgegebene Wert nicht angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1695">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="3bd02-1696">Wenn dieses Feld verwendet wird, werden keine Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1696">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="3bd02-1697">Entsprechende Anweisungen, die eine Ausnahme auslösen, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann, finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1697">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="3bd02-1698">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.u` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1698">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1699">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1699">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1700">Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="unsigned int8" /> und erweitert ihn dann zu <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1700">Converts the value on top of the evaluation stack to <see langword="unsigned int8" />, and extends it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1701">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1701">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1702">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1702">Format</span></span>|<span data-ttu-id="3bd02-1703">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1703">Assembly Format</span></span>|<span data-ttu-id="3bd02-1704">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1704">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1705">D2</span><span class="sxs-lookup"><span data-stu-id="3bd02-1705">D2</span></span>|<span data-ttu-id="3bd02-1706">conv.u1</span><span class="sxs-lookup"><span data-stu-id="3bd02-1706">conv.u1</span></span>|<span data-ttu-id="3bd02-1707">In `int8`konvertieren, `int32` auf Stapel schieben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1707">Convert to `int8`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="3bd02-1708">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1708">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1709">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1709">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1710">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1710">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="3bd02-1711">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1711">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1712">Der `conv.u1` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und belassen den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1712">The `conv.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1713">Ganzzahlige Werte von weniger als 4 Bytes werden auf `int32` erweitert, wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn, `conv.i` oder `conv.u` wird verwendet. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1713">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="3bd02-1714">Gleit Komma Werte werden in den `F`-Typ konvertiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1714">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="3bd02-1715">Durch die Konvertierung von Gleit Komma Zahlen in ganzzahlige Werte wird die Zahl in Richtung NULL abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1715">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="3bd02-1716">Bei der Umstellung von einer `float64` in eine `float32`kann die Genauigkeit verloren gehen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1716">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="3bd02-1717">Wenn `value` zu groß für eine `float32 (F)`ist, wird positiv unendlich (wenn `value` positiv ist) oder minus unendlich (wenn `value` negativ ist) zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1717">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="3bd02-1718">Wenn beim Umrechnen eines ganzzahligen Typs in einen anderen ein Überlauf auftritt, werden die hohen Bestell Bits abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1718">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="3bd02-1719">Wenn das Ergebnis kleiner als ein `int32`ist, wird der Wert mit Vorzeichen erweitert, um den Slot auszufüllen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1719">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="3bd02-1720">Wenn beim Umrechnen eines Gleit Komma Typs in eine ganze Zahl ein Überlauf auftritt, wird der zurückgegebene Wert nicht angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1720">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="3bd02-1721">Wenn dieses Feld verwendet wird, werden keine Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1721">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="3bd02-1722">Entsprechende Anweisungen, die eine Ausnahme auslösen, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann, finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1722">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="3bd02-1723">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.u1` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1723">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u1` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1724">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1724">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1725">Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="unsigned int16" /> und erweitert ihn dann zu <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1725">Converts the value on top of the evaluation stack to <see langword="unsigned int16" />, and extends it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1726">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1726">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1727">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1727">Format</span></span>|<span data-ttu-id="3bd02-1728">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1728">Assembly Format</span></span>|<span data-ttu-id="3bd02-1729">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1729">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1730">D1</span><span class="sxs-lookup"><span data-stu-id="3bd02-1730">D1</span></span>|<span data-ttu-id="3bd02-1731">"vs. U2"</span><span class="sxs-lookup"><span data-stu-id="3bd02-1731">conv.u2</span></span>|<span data-ttu-id="3bd02-1732">In `int16`konvertieren, `int32` auf Stapel schieben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1732">Convert to `int16`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="3bd02-1733">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1733">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1734">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1734">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1735">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1735">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="3bd02-1736">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1736">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1737">Der `conv.u2` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und belassen den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1737">The `conv.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1738">Ganzzahlige Werte von weniger als 4 Bytes werden auf `int32` erweitert, wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn, `conv.i` oder `conv.u` wird verwendet. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1738">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="3bd02-1739">Gleit Komma Werte werden in den `F`-Typ konvertiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1739">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="3bd02-1740">Durch die Konvertierung von Gleit Komma Zahlen in ganzzahlige Werte wird die Zahl in Richtung NULL abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1740">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="3bd02-1741">Bei der Umstellung von einer `float64` in eine `float32`kann die Genauigkeit verloren gehen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1741">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="3bd02-1742">Wenn `value` zu groß für eine `float32 (F)`ist, wird positiv unendlich (wenn `value` positiv ist) oder minus unendlich (wenn `value` negativ ist) zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1742">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="3bd02-1743">Wenn beim Umrechnen eines ganzzahligen Typs in einen anderen ein Überlauf auftritt, werden die hohen Bestell Bits abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1743">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="3bd02-1744">Wenn das Ergebnis kleiner als ein `int32`ist, wird der Wert mit Vorzeichen erweitert, um den Slot auszufüllen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1744">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="3bd02-1745">Wenn beim Umrechnen eines Gleit Komma Typs in eine ganze Zahl ein Überlauf auftritt, wird der zurückgegebene Wert nicht angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1745">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="3bd02-1746">Wenn dieses Feld verwendet wird, werden keine Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1746">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="3bd02-1747">Entsprechende Anweisungen, die eine Ausnahme auslösen, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann, finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1747">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="3bd02-1748">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.u2` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1748">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u2` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1749">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1749">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1750">Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="unsigned int32" /> und erweitert ihn dann zu <see langword="int32" />.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1750">Converts the value on top of the evaluation stack to <see langword="unsigned int32" />, and extends it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1751">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1751">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1752">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1752">Format</span></span>|<span data-ttu-id="3bd02-1753">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1753">Assembly Format</span></span>|<span data-ttu-id="3bd02-1754">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1754">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1755">6D</span><span class="sxs-lookup"><span data-stu-id="3bd02-1755">6D</span></span>|<span data-ttu-id="3bd02-1756">"vs. U4"</span><span class="sxs-lookup"><span data-stu-id="3bd02-1756">conv.u4</span></span>|<span data-ttu-id="3bd02-1757">In `unsigned int32`konvertieren, `int32` auf Stapel schieben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1757">Convert to `unsigned int32`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="3bd02-1758">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1758">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1759">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1759">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1760">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1760">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="3bd02-1761">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1761">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1762">Der `conv.u4` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und belassen den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1762">The `conv.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1763">Ganzzahlige Werte von weniger als 4 Bytes werden auf `int32` erweitert, wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn, `conv.i` oder `conv.u` wird verwendet. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1763">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="3bd02-1764">Gleit Komma Werte werden in den `F`-Typ konvertiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1764">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="3bd02-1765">Durch die Konvertierung von Gleit Komma Zahlen in ganzzahlige Werte wird die Zahl in Richtung NULL abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1765">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="3bd02-1766">Bei der Umstellung von einer `float64` in eine `float32`kann die Genauigkeit verloren gehen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1766">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="3bd02-1767">Wenn `value` zu groß für eine `float32 (F)`ist, wird positiv unendlich (wenn `value` positiv ist) oder minus unendlich (wenn `value` negativ ist) zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1767">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="3bd02-1768">Wenn beim Umrechnen eines ganzzahligen Typs in einen anderen ein Überlauf auftritt, werden die hohen Bestell Bits abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1768">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="3bd02-1769">Wenn das Ergebnis kleiner als ein `int32`ist, wird der Wert mit Vorzeichen erweitert, um den Slot auszufüllen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1769">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="3bd02-1770">Wenn beim Umrechnen eines Gleit Komma Typs in eine ganze Zahl ein Überlauf auftritt, wird der zurückgegebene Wert nicht angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1770">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="3bd02-1771">Wenn dieses Feld verwendet wird, werden keine Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1771">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="3bd02-1772">Entsprechende Anweisungen, die eine Ausnahme auslösen, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann, finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1772">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="3bd02-1773">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.u4` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1773">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u4` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1774">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1774">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1775">Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="unsigned int64" /> und erweitert ihn dann zu <see langword="int64" />.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1775">Converts the value on top of the evaluation stack to <see langword="unsigned int64" />, and extends it to <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1776">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1776">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1777">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1777">Format</span></span>|<span data-ttu-id="3bd02-1778">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1778">Assembly Format</span></span>|<span data-ttu-id="3bd02-1779">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1779">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1780">6E</span><span class="sxs-lookup"><span data-stu-id="3bd02-1780">6E</span></span>|<span data-ttu-id="3bd02-1781">conv.u8</span><span class="sxs-lookup"><span data-stu-id="3bd02-1781">conv.u8</span></span>|<span data-ttu-id="3bd02-1782">In `int64`konvertieren, `int64` auf Stapel schieben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1782">Convert to `int64`, pushing `int64` on stack.</span></span>|  
  
 <span data-ttu-id="3bd02-1783">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1783">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1784">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1784">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1785">`value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1785">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="3bd02-1786">Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1786">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1787">Der `conv.u8` Opcode konvertiert die `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und belassen den konvertierten Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1787">The `conv.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="3bd02-1788">Ganzzahlige Werte von weniger als 4 Bytes werden auf `int32` erweitert, wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn, `conv.i` oder `conv.u` wird verwendet. in diesem Fall ist das Ergebnis ebenfalls `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1788">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="3bd02-1789">Gleit Komma Werte werden in den `F`-Typ konvertiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1789">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="3bd02-1790">Durch die Konvertierung von Gleit Komma Zahlen in ganzzahlige Werte wird die Zahl in Richtung NULL abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1790">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="3bd02-1791">Bei der Umstellung von einer `float64` in eine `float32`kann die Genauigkeit verloren gehen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1791">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="3bd02-1792">Wenn `value` zu groß für eine `float32 (F)`ist, wird positiv unendlich (wenn `value` positiv ist) oder minus unendlich (wenn `value` negativ ist) zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1792">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="3bd02-1793">Wenn beim Umrechnen eines ganzzahligen Typs in einen anderen ein Überlauf auftritt, werden die hohen Bestell Bits abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1793">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="3bd02-1794">Wenn das Ergebnis kleiner als ein `int32`ist, wird der Wert mit Vorzeichen erweitert, um den Slot auszufüllen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1794">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="3bd02-1795">Wenn beim Umrechnen eines Gleit Komma Typs in eine ganze Zahl ein Überlauf auftritt, wird der zurückgegebene Wert nicht angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1795">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="3bd02-1796">Wenn dieses Feld verwendet wird, werden keine Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1796">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="3bd02-1797">Entsprechende Anweisungen, die eine Ausnahme auslösen, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann, finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1797">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="3bd02-1798">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `conv.u8` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1798">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u8` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1799">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1799">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1800">Kopiert eine angegebene Anzahl von Bytes von einer Quelladresse an eine Zieladresse.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1800">Copies a specified number bytes from a source address to a destination address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1801">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1801">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1802">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1802">Format</span></span>|<span data-ttu-id="3bd02-1803">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1803">Assembly Format</span></span>|<span data-ttu-id="3bd02-1804">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1804">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1805">FE 17</span><span class="sxs-lookup"><span data-stu-id="3bd02-1805">FE 17</span></span>|<span data-ttu-id="3bd02-1806">cpblk nicht vorhanden</span><span class="sxs-lookup"><span data-stu-id="3bd02-1806">cpblk</span></span>|<span data-ttu-id="3bd02-1807">Kopieren von Daten aus einem Speicherblock in einen anderen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1807">Copy data from one memory block to another.</span></span>|  
  
 <span data-ttu-id="3bd02-1808">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1808">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1809">Die Zieladresse wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1809">The destination address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1810">Die Quelladresse wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1810">The source address is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-1811">Die Anzahl der zu kopierenden Bytes wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1811">The number of bytes to copy is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="3bd02-1812">Die Anzahl von Bytes, die Quelladresse und die Zieladresse werden aus dem Stapel entfernt. die angegebene Anzahl von Bytes wird von der Quelladresse zur Zieladresse kopiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1812">The number of bytes, the source address, and the destination address are popped from the stack; the specified number of bytes are copied from the source address to the destination address.</span></span>  
  
 <span data-ttu-id="3bd02-1813">Die `cpblk` Anweisung kopiert eine Zahl (Type `unsigned int32`) von Bytes von einer Quelladresse (vom Typ `*`, `native int`oder `&`) in eine Zieladresse (vom Typ `*`, `native int`oder `&`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1813">The `cpblk` instruction copies a number (type `unsigned int32`) of bytes from a source address (of type `*`, `native int`, or `&`) to a destination address (of type `*`, `native int`, or `&`).</span></span> <span data-ttu-id="3bd02-1814">Das Verhalten von `cpblk` ist nicht angegeben, wenn sich die Quell-und Zielbereiche überlappen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1814">The behavior of `cpblk` is unspecified if the source and destination areas overlap.</span></span>  
  
 <span data-ttu-id="3bd02-1815">`cpblk` geht davon aus, dass sowohl Quell-als auch Ziel adressiert an der natürlichen Größe des Computers ausgerichtet sind.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1815">`cpblk` assumes that both the source and destination addressed are aligned to the natural size of the machine.</span></span> <span data-ttu-id="3bd02-1816">Der `cpblk` Anweisung kann direkt die `unaligned.<prefix>` Anweisung vorangestellt werden, um anzugeben, dass entweder die Quelle oder das Ziel nicht ausgerichtet ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1816">The `cpblk` instruction can be immediately preceded by the `unaligned.<prefix>` instruction to indicate that either the source or the destination is unaligned.</span></span>  
  
 <span data-ttu-id="3bd02-1817">Der Vorgang der `cpblk` Anweisung kann durch eine unmittelbar vorangehende <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung geändert werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1817">The operation of the `cpblk` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="3bd02-1818"><xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1818"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="3bd02-1819">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `cpblk` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1819">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpblk` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1820">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1820">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1821">Kopiert den Werttyp, der an der Adresse eines Objekts gespeichert ist (Typ <see langword="&amp;" />, <see langword="*" /> oder <see langword="native int" />), an die Adresse des Zielobjekts (Typ <see langword="&amp;" />, <see langword="*" /> oder <see langword="native int" />).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1821">Copies the value type located at the address of an object (type <see langword="&amp;" />, <see langword="*" /> or <see langword="native int" />) to the address of the destination object (type <see langword="&amp;" />, <see langword="*" /> or <see langword="native int" />).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1822">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1822">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1823">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1823">Format</span></span>|<span data-ttu-id="3bd02-1824">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1824">Assembly Format</span></span>|<span data-ttu-id="3bd02-1825">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1825">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1826">70 < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-1826">70 < `T` ></span></span>|<span data-ttu-id="3bd02-1827">cpobj-`classTok`</span><span class="sxs-lookup"><span data-stu-id="3bd02-1827">cpobj `classTok`</span></span>|<span data-ttu-id="3bd02-1828">Kopiert einen Werttyp aus einem Quell Objekt in ein Zielobjekt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1828">Copies a value type from a source object to a destination object.</span></span>|  
  
 <span data-ttu-id="3bd02-1829">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1829">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1830">Der Zielobjekt Verweis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1830">The destination object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1831">Der Quell Objekt Verweis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1831">The source object reference is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-1832">Die zwei Objekt Verweise werden aus dem Stapel entfernt. der Werttyp an der Adresse des Quell Objekts wird in die Adresse des Zielobjekts kopiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1832">The two object references are popped from the stack; the value type at the address of the source object is copied to the address of the destination object.</span></span>  
  
 <span data-ttu-id="3bd02-1833">Das Verhalten von `cpobj` ist nicht angegeben, wenn die Quell-und Zielobjekt Verweise keine Zeiger auf Instanzen der Klasse sind, die durch das Klassen Token `classTok` (eine `typeref` oder `typedef`) dargestellt wird, oder wenn `classTok` keinen Werttyp darstellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1833">The behavior of `cpobj` is unspecified if the source and destination object references are not pointers to instances of the class represented by the class token `classTok` (a `typeref` or `typedef`), or if `classTok` does not represent a value type.</span></span>  
  
 <span data-ttu-id="3bd02-1834"><xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1834"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="3bd02-1835">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `cpobj` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1835">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpobj` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1836">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1836">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1837">Dividiert zwei Werte und legt das Ergebnis als Gleitkommawert (Typ <see langword="F" />) oder Quotient (Typ <see langword="int32" />) auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1837">Divides two values and pushes the result as a floating-point (type <see langword="F" />) or quotient (type <see langword="int32" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1838">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1838">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1839">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1839">Format</span></span>|<span data-ttu-id="3bd02-1840">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1840">Assembly Format</span></span>|<span data-ttu-id="3bd02-1841">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1841">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1842">5B</span><span class="sxs-lookup"><span data-stu-id="3bd02-1842">5B</span></span>|<span data-ttu-id="3bd02-1843">div</span><span class="sxs-lookup"><span data-stu-id="3bd02-1843">div</span></span>|<span data-ttu-id="3bd02-1844">Dividiert zwei Werte, um einen Quotienten oder Gleit Komma Ergebnis zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1844">Divides two values to return a quotient or floating-point result.</span></span>|  
  
 <span data-ttu-id="3bd02-1845">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1845">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1846">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1846">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1847">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1847">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-1848">`value2` und `value1` werden aus dem Stapel entfernt. `value1` wird durch `value2`dividiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1848">`value2` and `value1` are popped from the stack; `value1` is divided by `value2`.</span></span>  
  
4.  <span data-ttu-id="3bd02-1849">Das Ergebnis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1849">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1850">`result` = `value1` div Value2 erfüllt die folgenden Bedingungen:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1850">`result` = `value1` div value2 satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="3bd02-1851">&#124;`result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;und:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1851">&#124; `result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, and:</span></span>  
  
 <span data-ttu-id="3bd02-1852">Sign (`result`) = +, if Sign (`value1`) = Sign (`value2`) oder-, if Sign (`value1`) ~ = Sign (`value2`)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1852">sign(`result`) = +, if sign(`value1`) = sign(`value2`), or -, if sign(`value1`) ~= sign(`value2`)</span></span>  
  
 <span data-ttu-id="3bd02-1853">Die `div`-Anweisung berechnet das Ergebnis und legt es auf dem Stapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1853">The `div` instruction computes the result and pushes it on the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1854">Die ganzzahlige Division wird in Richtung NULL abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1854">Integer division truncates towards zero.</span></span>  
  
 <span data-ttu-id="3bd02-1855">Die Division einer endlichen Zahl durch null erzeugt den ordnungsgemäß signierten unendlichen Wert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1855">Division of a finite number by zero produces the correctly signed infinite value.</span></span>  
  
 <span data-ttu-id="3bd02-1856">Die Division von NULL durch Null oder unendlich durch unendlich erzeugt den NaN-Wert (Not-A-Number).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1856">Dividing zero by zero or infinity by infinity produces the NaN (Not-A-Number) value.</span></span> <span data-ttu-id="3bd02-1857">Eine Zahl, die durch unendlich dividiert wird, erzeugt einen Nullwert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1857">Any number divided by infinity will produce a zero value.</span></span>  
  
 <span data-ttu-id="3bd02-1858">Ganzzahlige Vorgänge lösen <xref:System.ArithmeticException> aus, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1858">Integral operations throw <xref:System.ArithmeticException> if the result cannot be represented in the result type.</span></span> <span data-ttu-id="3bd02-1859">Dies kann vorkommen, wenn `value1` den maximalen negativen Wert und `value2` den Wert-1 hat.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1859">This can happen if `value1` is the maximum negative value, and `value2` is -1.</span></span>  
  
 <span data-ttu-id="3bd02-1860">Ganzzahlige Vorgänge lösen <xref:System.DivideByZeroException> aus, wenn `value2` NULL ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1860">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="3bd02-1861">Beachten Sie, dass auf Intel-basierten Plattformen beim Berechnen (minint div-1) eine <xref:System.OverflowException> ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1861">Note that on Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint div -1).</span></span> <span data-ttu-id="3bd02-1862">Gleit Komma Operationen lösen nie eine Ausnahme aus (Sie führen stattdessen Nane oder Unendlichkeiten aus).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1862">Floating-point operations never throw an exception (they produce NaNs or infinities instead).</span></span>  
  
 <span data-ttu-id="3bd02-1863">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `div` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1863">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1864">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1864">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1865">Dividiert zwei Ganzzahlwerte ohne Vorzeichen und legt das Ergebnis (<see langword="int32" />) auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1865">Divides two unsigned integer values and pushes the result (<see langword="int32" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1866">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1866">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1867">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1867">Format</span></span>|<span data-ttu-id="3bd02-1868">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1868">Assembly Format</span></span>|<span data-ttu-id="3bd02-1869">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1869">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1870">5C</span><span class="sxs-lookup"><span data-stu-id="3bd02-1870">5C</span></span>|<span data-ttu-id="3bd02-1871">div.un</span><span class="sxs-lookup"><span data-stu-id="3bd02-1871">div.un</span></span>|<span data-ttu-id="3bd02-1872">Dividiert zwei Werte ohne Vorzeichen und gibt einen Quotienten zurück.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1872">Divides two values, unsigned, returning a quotient.</span></span>|  
  
 <span data-ttu-id="3bd02-1873">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1873">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1874">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1874">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1875">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1875">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-1876">`value2` und `value1` werden aus dem Stapel entfernt. `value1` wird durch `value2`dividiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1876">`value2` and `value1` are popped from the stack; `value1` is divided by `value2`.</span></span>  
  
4.  <span data-ttu-id="3bd02-1877">Das Ergebnis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1877">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1878">Die `div.un`-Anweisung berechnet `value1` dividiert durch `value2`, die beide als ganze Zahlen ohne Vorzeichen verwendet werden, und legt die `result` auf dem Stapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1878">The `div.un` instruction computes `value1` divided by `value2`, both taken as unsigned integers, and pushes the `result` on the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1879">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `div.un` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1879">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div.un` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1880">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1880">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1881">Kopiert den obersten Wert auf dem Auswertungsstapel und legt die Kopie dann auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1881">Copies the current topmost value on the evaluation stack, and then pushes the copy onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1882">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1882">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1883">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1883">Format</span></span>|<span data-ttu-id="3bd02-1884">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1884">Assembly Format</span></span>|<span data-ttu-id="3bd02-1885">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1885">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1886">25</span><span class="sxs-lookup"><span data-stu-id="3bd02-1886">25</span></span>|<span data-ttu-id="3bd02-1887">Sammlungen</span><span class="sxs-lookup"><span data-stu-id="3bd02-1887">dup</span></span>|<span data-ttu-id="3bd02-1888">Dupliziert den Wert am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1888">Duplicates the value on the top of the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-1889">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1889">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1890">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1890">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1891">`value` wird aus dem Stapel für die Duplizierung entfernt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1891">`value` is popped off of the stack for duplication.</span></span>  
  
3.  <span data-ttu-id="3bd02-1892">`value` wird zurück auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1892">`value` is pushed back onto the stack.</span></span>  
  
4.  <span data-ttu-id="3bd02-1893">Ein doppelter Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1893">A duplicate value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1894">Die `dup` Anweisung dupliziert das oberste Element des Stapels und lässt zwei identische Werte darüber aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1894">The `dup` instruction duplicates the top element of the stack, and leaves two identical values atop it.</span></span>  
  
 <span data-ttu-id="3bd02-1895">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `dup` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1895">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `dup` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1896">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1896">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1897">Überträgt die Steuerung von der <see langword="filter" />-Klausel einer Ausnahme zurück an den CLI-Ausnahmehandler (Common Language Infrastructure).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1897">Transfers control from the <see langword="filter" /> clause of an exception back to the Common Language Infrastructure (CLI) exception handler.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1898">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1898">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1899">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1899">Format</span></span>|<span data-ttu-id="3bd02-1900">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1900">Assembly Format</span></span>|<span data-ttu-id="3bd02-1901">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1901">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1902">FE 11</span><span class="sxs-lookup"><span data-stu-id="3bd02-1902">FE 11</span></span>|<span data-ttu-id="3bd02-1903">"endfilter"</span><span class="sxs-lookup"><span data-stu-id="3bd02-1903">endfilter</span></span>|<span data-ttu-id="3bd02-1904">End Filter-Klausel der Seh-Ausnahmebehandlung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1904">End filter clause of SEH exception handling.</span></span>|  
  
 <span data-ttu-id="3bd02-1905">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1905">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1906">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1906">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1907">`value` aus dem Stapel entfernt wird. `endfilter` ausgeführt wird und die Steuerung an den Ausnahmehandler übertragen wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1907">`value` is popped from the stack; `endfilter` is executed and control is transferred to the exception handler.</span></span>  
  
 <span data-ttu-id="3bd02-1908">`Value` (die den Typ `int32` und einen bestimmten Satz von Werten aufweisen muss), wird von der Filter Klausel zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1908">`Value` (which must be of type `int32` and is one of a specific set of values) is returned from the filter clause.</span></span> <span data-ttu-id="3bd02-1909">Dies sollte einer der folgenden sein:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1909">It should be one of:</span></span>  
  
-   <span data-ttu-id="3bd02-1910">`exception_continue_search` (`value` = 0), um die Suche nach einem Ausnahmehandler fortzusetzen</span><span class="sxs-lookup"><span data-stu-id="3bd02-1910">`exception_continue_search` (`value` = 0) to continue searching for an exception handler</span></span>  
  
-   <span data-ttu-id="3bd02-1911">`exception_execute_handler` (`value` = 1), um die zweite Phase der Ausnahmebehandlung zu starten, bei der schließlich Blöcke ausgeführt werden, bis der Handler gefunden wird, der dieser Filter Klausel zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1911">`exception_execute_handler` (`value` = 1) to start the second phase of exception handling where finally blocks are run until the handler associated with this filter clause is located.</span></span> <span data-ttu-id="3bd02-1912">Bei der Ermittlung wird der Handler ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1912">Upon discovery, the handler is executed.</span></span>  
  
 <span data-ttu-id="3bd02-1913">Andere ganzzahlige Werte verursachen nicht angegebene Ergebnisse.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1913">Other integer values will produce unspecified results.</span></span>  
  
 <span data-ttu-id="3bd02-1914">Der Einstiegspunkt eines Filters, wie in der Ausnahme Tabelle der Methode gezeigt, muss die erste Anweisung im Codeblock des Filters sein.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1914">The entry point of a filter, as shown in the method's exception table, must be the first instruction in the filter's code block.</span></span> <span data-ttu-id="3bd02-1915">Die `endfilter` Anweisung muss die letzte Anweisung im Codeblock des Filters sein (daher kann nur ein `endfilter` für einen einzelnen Filter Block vorhanden sein).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1915">The `endfilter` instruction must be the last instruction in the filter's code block (hence there can only be one `endfilter` for any single filter block).</span></span> <span data-ttu-id="3bd02-1916">Nachdem Sie die `endfilter`-Anweisung ausgeführt haben, wird das Steuerelement logisch an den CLI-Ausnahme Behandlungs Mechanismus zurückfließt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1916">After executing the `endfilter` instruction, control logically flows back to the CLI exception handling mechanism.</span></span>  
  
 <span data-ttu-id="3bd02-1917">Das Steuerelement kann nur über den Ausnahme Mechanismus in einen Filter Block übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1917">Control cannot be transferred into a filter block except through the exception mechanism.</span></span> <span data-ttu-id="3bd02-1918">Das Steuerelement kann nicht aus einem Filter Block übertragen werden, es sei denn, es wird eine `throw` Anweisung verwendet oder die abschließende `endfilter` Anweisung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1918">Control cannot be transferred out of a filter block except through the use of a `throw` instruction or by executing the final `endfilter` instruction.</span></span> <span data-ttu-id="3bd02-1919">Sie können einen `try`-Block nicht in einen `filter`-Block einbetten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1919">You cannot embed a `try` block within a `filter` block.</span></span> <span data-ttu-id="3bd02-1920">Wenn im `filter`-Block eine Ausnahme ausgelöst wird, wird Sie abgefangen und ein Wert von 0 (`exception_continue_search`) zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1920">If an exception is thrown inside the `filter` block, it is intercepted and a value of 0 (`exception_continue_search`) is returned.</span></span>  
  
 <span data-ttu-id="3bd02-1921">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `endfilter` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1921">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfilter` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1922">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1922">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1923">Überträgt die Steuerung aus der <see langword="fault" />-Klausel oder <see langword="finally" />-Klausel eines Ausnahmeblockes zurück an den CLI-Ausnahmehandler (Common Language Infrastructure).</span><span class="sxs-lookup"><span data-stu-id="3bd02-1923">Transfers control from the <see langword="fault" /> or <see langword="finally" /> clause of an exception block back to the Common Language Infrastructure (CLI) exception handler.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1924">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1924">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1925">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1925">Format</span></span>|<span data-ttu-id="3bd02-1926">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1926">Assembly Format</span></span>|<span data-ttu-id="3bd02-1927">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1927">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1928">DC</span><span class="sxs-lookup"><span data-stu-id="3bd02-1928">DC</span></span>|<span data-ttu-id="3bd02-1929">"endfinally"</span><span class="sxs-lookup"><span data-stu-id="3bd02-1929">endfinally</span></span><br /><br /> <span data-ttu-id="3bd02-1930">endfault</span><span class="sxs-lookup"><span data-stu-id="3bd02-1930">endfault</span></span>|<span data-ttu-id="3bd02-1931">Beendet die `finally` oder `fault`-Klausel eines Ausnahme Blocks.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1931">Ends the `finally` or `fault` clause of an exception block.</span></span>|  
  
 <span data-ttu-id="3bd02-1932">Es gibt keine Stapel Übergangs Verhaltensweisen für diese Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1932">There are no stack transition behaviors for this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-1933">`Endfinally` und `endfault` signalisieren das Ende der `finally`-oder `fault` Klausel, sodass die Stapel Entwicklung fortgesetzt werden kann, bis der Ausnahmehandler aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1933">`Endfinally` and `endfault` signal the end of the `finally` or `fault` clause so that stack unwinding can continue until the exception handler is invoked.</span></span> <span data-ttu-id="3bd02-1934">Die `endfinally`-oder `endfault` Anweisung überträgt die Steuerung zurück an den CLI-Ausnahme Mechanismus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1934">The `endfinally` or `endfault` instruction transfers control back to the CLI exception mechanism.</span></span> <span data-ttu-id="3bd02-1935">Der Mechanismus sucht dann nach der nächsten `finally`-Klausel in der Kette, wenn der geschützte Block mit einer LEAVE-Anweisung beendet wurde.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1935">The mechanism then searches for the next `finally` clause in the chain if the protected block was exited with a leave instruction.</span></span> <span data-ttu-id="3bd02-1936">Wenn der geschützte Block mit einer Ausnahme beendet wurde, sucht die CLI nach den nächsten `finally` oder `fault`oder gibt den Ausnahmehandler ein, der während des ersten Durchgangs der Ausnahmebehandlung ausgewählt wurde.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1936">If the protected block was exited with an exception, the CLI will search for the next `finally` or `fault`, or enter the exception handler chosen during the first pass of exception handling.</span></span>  
  
 <span data-ttu-id="3bd02-1937">Eine `endfinally` Anweisung kann nur lexikalisch innerhalb eines `finally` Blocks vorkommen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1937">An `endfinally` instruction might only appear lexically within a `finally` block.</span></span> <span data-ttu-id="3bd02-1938">Anders als bei der `endfilter` Anweisung muss der Block nicht mit einer `endfinally` Anweisung enden, und es können beliebig viele `endfinally` Anweisungen im Block vorhanden sein.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1938">Unlike the `endfilter` instruction, there is no requirement that the block end with an `endfinally` instruction, and there can be as many `endfinally` instructions within the block as required.</span></span> <span data-ttu-id="3bd02-1939">Die gleichen Einschränkungen gelten für die `endfault`-Anweisung und den `fault`-Block.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1939">These same restrictions apply to the `endfault` instruction and the `fault` block.</span></span>  
  
 <span data-ttu-id="3bd02-1940">Das Steuerelement kann nur über den Ausnahme Mechanismus in einen `finally`-Block (oder `fault`) übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1940">Control cannot be transferred into a `finally` (or `fault`) block except through the exception mechanism.</span></span> <span data-ttu-id="3bd02-1941">Das Steuerelement kann nicht aus einem `finally`-oder `fault`-Block übertragen werden, es sei denn, es wird eine `throw`-Anweisung verwendet oder die `endfinally` (oder `endfault`)-Anweisung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1941">Control cannot be transferred out of a `finally` (or `fault`) block except through the use of a `throw` instruction or executing the `endfinally` (or `endfault`) instruction.</span></span> <span data-ttu-id="3bd02-1942">Insbesondere ist es nicht möglich, einen `finally` (oder `fault`)-Block zu "ziehen" oder eine <xref:System.Reflection.Emit.OpCodes.Ret> oder <xref:System.Reflection.Emit.OpCodes.Leave> Anweisung innerhalb eines `finally`-Blocks (oder `fault`) auszuführen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1942">In particular, you cannot "fall out" of a `finally` (or `fault`) block or to execute a <xref:System.Reflection.Emit.OpCodes.Ret> or <xref:System.Reflection.Emit.OpCodes.Leave> instruction within a `finally` (or `fault`) block.</span></span>  
  
 <span data-ttu-id="3bd02-1943">Beachten Sie, dass die Anweisungen `endfault` und `endfinally` Aliase sind, die dem gleichen Opcode entsprechen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1943">Note that the `endfault` and `endfinally` instructions are aliases - they correspond to the same opcode.</span></span>  
  
 <span data-ttu-id="3bd02-1944">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `endfinally` (`endfault`)-Opcode und die `ILGenerator`-Methode <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>verwenden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1944">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfinally` (`endfault`) opcode, as well as the `ILGenerator` method <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.</span></span>  
  
-   <span data-ttu-id="3bd02-1945">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1945">ILGenerator.Emit(OpCode)</span></span>  
  
-   <span data-ttu-id="3bd02-1946">ILGenerator.EndExceptionBlock()</span><span class="sxs-lookup"><span data-stu-id="3bd02-1946">ILGenerator.EndExceptionBlock()</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1947">Initialisiert einen angegebenen Speicherblock an einer bestimmten Adresse mit einer angegebenen Größe und einem angegebenen Anfangswert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1947">Initializes a specified block of memory at a specific address to a given size and initial value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1948">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1948">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1949">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1949">Format</span></span>|<span data-ttu-id="3bd02-1950">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1950">Assembly Format</span></span>|<span data-ttu-id="3bd02-1951">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1951">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1952">FE 18</span><span class="sxs-lookup"><span data-stu-id="3bd02-1952">FE 18</span></span>|<span data-ttu-id="3bd02-1953">initblk</span><span class="sxs-lookup"><span data-stu-id="3bd02-1953">initblk</span></span>|<span data-ttu-id="3bd02-1954">Legen Sie jeden Speicherort in einem Speicherblock auf einen angegebenen Wert fest.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1954">Set each location in a block of memory to a given value.</span></span>|  
  
 <span data-ttu-id="3bd02-1955">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1955">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1956">Eine Startadresse wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1956">A starting address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1957">Ein Initialisierungs Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1957">An initialization value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-1958">Die Anzahl der zu initialisierenden Bytes wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1958">The number of bytes to initialize is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="3bd02-1959">Die Anzahl von Bytes, der Initialisierungs Wert und die Startadresse werden aus dem Stapel entfernt, und die Initialisierung erfolgt gemäß ihren Werten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1959">The number of bytes, the initialization value, and the starting address are popped from the stack, and the initialization is performed as per their values.</span></span>  
  
 <span data-ttu-id="3bd02-1960">Mit der `initblk`-Anweisung wird die Anzahl (`unsigned int32`) von Bytes, beginnend bei der angegebenen Adresse (vom Typ `native int`, `&`oder `*`), auf den Initialisierungs Wert (vom Typ `unsigned int8`) festgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1960">The `initblk` instruction sets the number (`unsigned int32`) of bytes starting at the specified address (of type `native int`, `&`, or `*`) to the initialization value (of type `unsigned int8`).</span></span> <span data-ttu-id="3bd02-1961">`initblk` geht davon aus, dass die Anfangsadresse an der natürlichen Größe des Computers ausgerichtet ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1961">`initblk` assumes that the starting address is aligned to the natural size of the machine.</span></span>  
  
 <span data-ttu-id="3bd02-1962">Der Vorgang der `initblk` Anweisungen kann durch eine unmittelbar vorangehende <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung geändert werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1962">The operation of the `initblk` instructions can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="3bd02-1963"><xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1963"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="3bd02-1964">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `initblk` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1964">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initblk` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1965">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1965">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1966">Initialisiert alle Felder des Werttyps an einer angegebenen Adresse mit einem NULL-Verweis oder dem Wert 0 des entsprechenden primitiven Typs.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1966">Initializes each field of the value type at a specified address to a null reference or a 0 of the appropriate primitive type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1967">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1967">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1968">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1968">Format</span></span>|<span data-ttu-id="3bd02-1969">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1969">Assembly Format</span></span>|<span data-ttu-id="3bd02-1970">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1970">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1971">FE 15 < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-1971">FE 15 < `T` ></span></span>|<span data-ttu-id="3bd02-1972">`initobj` `typeTok`</span><span class="sxs-lookup"><span data-stu-id="3bd02-1972">`initobj` `typeTok`</span></span>|<span data-ttu-id="3bd02-1973">Initialisiert einen Werttyp.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1973">Initializes a value type.</span></span>|  
  
 <span data-ttu-id="3bd02-1974">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1974">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1975">Die Adresse des zu initialisierenden Werttyps wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1975">The address of the value type to initialize is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1976">Die Adresse wird aus dem Stapel entfernt. der Werttyp bei der angegebenen Adresse wird als Typ `typeTok`initialisiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1976">The address is popped from the stack; the value type at the specified address is initialized as type `typeTok`.</span></span>  
  
 <span data-ttu-id="3bd02-1977">Die `initobj`-Anweisung initialisiert jedes Feld des Werttyps, der durch die übersetzte Adresse (vom Typ `native int`, `&`oder `*`) angegeben wird, auf einen NULL-Verweis oder 0 des entsprechenden primitiven Typs.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1977">The `initobj` instruction initializes each field of the value type specified by the pushed address (of type `native int`, `&`, or `*`) to a null reference or a 0 of the appropriate primitive type.</span></span> <span data-ttu-id="3bd02-1978">Nachdem diese Methode aufgerufen wurde, kann die-Instanz aufgerufen werden, um eine Konstruktormethode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1978">After this method is called, the instance is ready for a constructor method to be called.</span></span> <span data-ttu-id="3bd02-1979">Wenn `typeTok` ein Verweistyp ist, hat diese Anweisung dieselbe Auswirkung wie `ldnull` gefolgt von `stind.ref`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1979">If `typeTok` is a reference type, this instruction has the same effect as `ldnull` followed by `stind.ref`.</span></span>  
  
 <span data-ttu-id="3bd02-1980">Im Gegensatz zu <xref:System.Reflection.Emit.OpCodes.Newobj>ruft `initobj` nicht die-Konstruktormethode auf.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1980">Unlike <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` does not call the constructor method.</span></span> <span data-ttu-id="3bd02-1981">`Initobj` ist für die Initialisierung von Werttypen vorgesehen, während `newobj` verwendet wird, um Objekte zuzuordnen und zu initialisieren.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1981">`Initobj` is intended for initializing value types, while `newobj` is used to allocate and initialize objects.</span></span>  
  
 <span data-ttu-id="3bd02-1982">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `initobj` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1982">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initobj` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-1983">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="3bd02-1983">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-1984">Überprüft, ob ein Objektverweis (Typ <see langword="O" />) eine Instanz einer bestimmten Klasse ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1984">Tests whether an object reference (type <see langword="O" />) is an instance of a particular class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-1985">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1985">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-1986">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-1986">Format</span></span>|<span data-ttu-id="3bd02-1987">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-1987">Assembly Format</span></span>|<span data-ttu-id="3bd02-1988">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-1988">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-1989">75 < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-1989">75 < `T` ></span></span>|<span data-ttu-id="3bd02-1990">Isinst-`class`</span><span class="sxs-lookup"><span data-stu-id="3bd02-1990">isinst `class`</span></span>|<span data-ttu-id="3bd02-1991">Testet, ob ein Objekt Verweis eine Instanz von `class`ist, wobei entweder ein NULL-Verweis oder eine Instanz dieser Klasse oder Schnittstelle zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1991">Tests if an object reference is an instance of `class`, returning either a null reference or an instance of that class or interface.</span></span>|  
  
 <span data-ttu-id="3bd02-1992">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-1992">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-1993">Ein Objekt Verweis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1993">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-1994">Der Objekt Verweis wird aus dem Stapel entfernt und getestet, um zu ermitteln, ob es sich um eine Instanz der Klasse handelt, die in `class`übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1994">The object reference is popped from the stack and tested to see if it is an instance of the class passed in `class`.</span></span>  
  
3.  <span data-ttu-id="3bd02-1995">Das Ergebnis (entweder ein Objekt Verweis oder ein NULL-Verweis) wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1995">The result (either an object reference or a null reference) is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-1996">`Class` ist ein Metadatentoken, das die gewünschte Klasse angibt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1996">`Class` is a metadata token indicating the desired class.</span></span> <span data-ttu-id="3bd02-1997">Wenn die Klasse des Objekts am Anfang des Stapels `class` implementiert (wenn `class` eine Schnittstelle ist) oder eine abgeleitete Klasse von `class` ist (wenn `class` eine reguläre Klasse ist), wird Sie in den Typ `class` umgewandelt, und das Ergebnis wird auf dem Stapel abgelegt, so als ob <xref:System.Reflection.Emit.OpCodes.Castclass> aufgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1997">If the class of the object on the top of the stack implements `class` (if `class` is an interface) or is a derived class of `class` (if `class` is a regular class) then it is cast to type `class` and the result is pushed on the stack, exactly as though <xref:System.Reflection.Emit.OpCodes.Castclass> had been called.</span></span> <span data-ttu-id="3bd02-1998">Andernfalls wird ein NULL-Verweis auf dem Stapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1998">Otherwise, a null reference is pushed on the stack.</span></span> <span data-ttu-id="3bd02-1999">Wenn der Objekt Verweis selbst ein NULL-Verweis ist, gibt `isinst` gleichermaßen einen NULL-Verweis zurück.</span><span class="sxs-lookup"><span data-stu-id="3bd02-1999">If the object reference itself is a null reference, then `isinst` likewise returns a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-2000"><xref:System.TypeLoadException> wird ausgelöst, wenn die Klasse nicht gefunden werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2000"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="3bd02-2001">Dies wird in der Regel erkannt, wenn die MSIL-Anweisungen (Microsoft Intermediate Language) in systemeigenen Code anstatt zur Laufzeit konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2001">This is typically detected when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="3bd02-2002">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `isinst` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2002">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `isinst` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2003">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2003">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2004">Beendet die aktuelle Methode und wechselt zur angegebenen Methode.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2004">Exits current method and jumps to specified method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2005">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2005">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2006">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2006">Format</span></span>|<span data-ttu-id="3bd02-2007">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2007">Assembly Format</span></span>|<span data-ttu-id="3bd02-2008">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2008">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2009">27 < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-2009">27 < `T` ></span></span>|<span data-ttu-id="3bd02-2010">"jmp"-`method`</span><span class="sxs-lookup"><span data-stu-id="3bd02-2010">jmp `method`</span></span>|<span data-ttu-id="3bd02-2011">Aktuelle Methode beenden und zur angegebenen Methode springen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2011">Exit current method and jump to specified method.</span></span>|  
  
 <span data-ttu-id="3bd02-2012">Es gibt keine Stapel Übergangs Verhaltensweisen für diese Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2012">There are no stack transition behaviors for this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-2013">Die `jmp`-Anweisung (Jump) überträgt die Steuerung an die durch `method`angegebene Methode, bei der es sich um ein Metadatentoken für einen Methoden Verweis handelt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2013">The `jmp` (jump) instruction transfers control to the method specified by `method`, which is a metadata token for a method reference.</span></span> <span data-ttu-id="3bd02-2014">Die aktuellen Argumente werden an die Ziel Methode übertragen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2014">The current arguments are transferred to the destination method.</span></span>  
  
 <span data-ttu-id="3bd02-2015">Der Auswertungs Stapel muss leer sein, wenn diese Anweisung ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2015">The evaluation stack must be empty when this instruction is executed.</span></span> <span data-ttu-id="3bd02-2016">Die Aufruf Konvention, die Anzahl und der Typ der Argumente an der Zieladresse müssen mit der der aktuellen Methode übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2016">The calling convention, number and type of arguments at the destination address must match that of the current method.</span></span>  
  
 <span data-ttu-id="3bd02-2017">Die `jmp` Anweisung kann nicht verwendet werden, um die Steuerung aus einem `try`-, `filter`-, `catch`-oder `finally`-Block zu übertragen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2017">The `jmp` instruction cannot be used to transferred control out of a `try`, `filter`, `catch`, or `finally` block.</span></span>  
  
 <span data-ttu-id="3bd02-2018">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `jmp` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2018">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `jmp` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2019">ILGenerator. ausgeben (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2019">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2020">Lädt ein Argument, auf das ein angegebener Indexwert verweist, in den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2020">Loads an argument (referenced by a specified index value) onto the stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2021">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2021">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2022">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2022">Format</span></span>|<span data-ttu-id="3bd02-2023">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2023">Assembly Format</span></span>|<span data-ttu-id="3bd02-2024">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2024">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2025">FE 09 < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-2025">FE 09 < `unsigned int16` ></span></span>|<span data-ttu-id="3bd02-2026">ldarg-`index`</span><span class="sxs-lookup"><span data-stu-id="3bd02-2026">ldarg `index`</span></span>|<span data-ttu-id="3bd02-2027">Load-Argument bei `index` auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2027">Load argument at `index` onto stack.</span></span>|  
  
 <span data-ttu-id="3bd02-2028">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2028">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2029">Der Argument Wert an `index` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2029">The argument value at `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2030">Die `ldarg` Anweisung überträgt das an `index`indizierte Argument, bei dem Argumente von 0 bis auf den Auswertungs Stapel indiziert werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2030">The `ldarg` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack.</span></span> <span data-ttu-id="3bd02-2031">Die `ldarg`-Anweisung kann verwendet werden, um einen Werttyp oder einen primitiven Wert auf den Stapel zu laden, indem Sie ihn aus einem eingehenden Argument kopiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2031">The `ldarg` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="3bd02-2032">Der Typ des Argument Werts ist mit dem Typ des Arguments identisch, wie in der Signatur der aktuellen Methode angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2032">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="3bd02-2033">Für Prozeduren, die eine Argumentliste mit variabler Länge verwenden, kann die `ldarg` Anweisung nur für die anfänglichen Fixed-Argumente verwendet werden, nicht für die Argumente im Variablen Teil der Signatur (Weitere Informationen finden Sie in der <xref:System.Reflection.Emit.OpCodes.Arglist> Anweisung).</span><span class="sxs-lookup"><span data-stu-id="3bd02-2033">For procedures that take a variable-length argument list, the `ldarg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details).</span></span>  
  
 <span data-ttu-id="3bd02-2034">Argumente, die einen ganzzahligen Wert enthalten, der kleiner als 4 Bytes ist, werden auf den Typ `int32` erweitert, wenn Sie auf dem Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2034">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="3bd02-2035">Gleit Komma Werte werden auf Ihre systemeigene Größe (Type `F`) erweitert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2035">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="3bd02-2036">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldarg` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2036">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2037">ILGenerator. ausgeben (OpCode, Short)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2037">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2038">Lädt das Argument am Index 0 in den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2038">Loads the argument at index 0 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2039">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2039">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2040">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2040">Format</span></span>|<span data-ttu-id="3bd02-2041">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2041">Assembly Format</span></span>|<span data-ttu-id="3bd02-2042">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2042">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2043">02</span><span class="sxs-lookup"><span data-stu-id="3bd02-2043">02</span></span>|<span data-ttu-id="3bd02-2044">ldarg. 0</span><span class="sxs-lookup"><span data-stu-id="3bd02-2044">ldarg.0</span></span>|<span data-ttu-id="3bd02-2045">Argument 0 auf Stapel laden</span><span class="sxs-lookup"><span data-stu-id="3bd02-2045">Load argument 0 onto stack</span></span>|  
  
 <span data-ttu-id="3bd02-2046">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2046">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2047">Der Argument Wert bei Index 0 wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2047">The argument value at index 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2048">Die `ldarg.0`-Anweisung ist eine effiziente Codierung zum Laden des Argument Werts bei Index 0.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2048">The `ldarg.0` instruction is an efficient encoding for loading the argument value at index 0.</span></span>  
  
 <span data-ttu-id="3bd02-2049">Die `ldarg.0`-Anweisung legt das an 0 indizierte Argument auf dem Auswertungs Stapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2049">The `ldarg.0` instruction pushes the argument indexed at 0 onto the evaluation stack.</span></span> <span data-ttu-id="3bd02-2050">Die `ldarg.0`-Anweisung kann verwendet werden, um einen Werttyp oder einen primitiven Wert auf den Stapel zu laden, indem Sie ihn aus einem eingehenden Argument kopiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2050">The `ldarg.0` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="3bd02-2051">Der Typ des Argument Werts ist mit dem Typ des Arguments identisch, wie in der Signatur der aktuellen Methode angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2051">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="3bd02-2052">Argumente, die einen ganzzahligen Wert enthalten, der kleiner als 4 Bytes ist, werden auf den Typ `int32` erweitert, wenn Sie auf dem Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2052">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="3bd02-2053">Gleit Komma Werte werden auf Ihre systemeigene Größe (Type `F`) erweitert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2053">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="3bd02-2054">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldarg.0` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2054">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.0` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2055">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2055">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2056">Lädt das Argument am Index 1 in den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2056">Loads the argument at index 1 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2057">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2057">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2058">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2058">Format</span></span>|<span data-ttu-id="3bd02-2059">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2059">Assembly Format</span></span>|<span data-ttu-id="3bd02-2060">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2060">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2061">03</span><span class="sxs-lookup"><span data-stu-id="3bd02-2061">03</span></span>|<span data-ttu-id="3bd02-2062">ldarg. 1</span><span class="sxs-lookup"><span data-stu-id="3bd02-2062">ldarg.1</span></span>|<span data-ttu-id="3bd02-2063">Argument 1 auf Stapel laden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2063">Load argument 1 onto stack.</span></span>|  
  
 <span data-ttu-id="3bd02-2064">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2064">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2065">Der Argument Wert bei Index 1 wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2065">The argument value at index 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2066">Die `ldarg.1`-Anweisung ist eine effiziente Codierung zum Laden des Argument Werts an Index 1.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2066">The `ldarg.1` instruction is an efficient encoding for loading the argument value at index 1.</span></span>  
  
 <span data-ttu-id="3bd02-2067">Die `ldarg.1`-Anweisung legt das an 1 indizierte Argument auf dem Auswertungs Stapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2067">The `ldarg.1` instruction pushes the argument indexed at 1 onto the evaluation stack.</span></span> <span data-ttu-id="3bd02-2068">Die `ldarg.1`-Anweisung kann verwendet werden, um einen Werttyp oder einen primitiven Wert auf den Stapel zu laden, indem Sie ihn aus einem eingehenden Argument kopiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2068">The `ldarg.1` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="3bd02-2069">Der Typ des Argument Werts ist mit dem Typ des Arguments identisch, wie in der Signatur der aktuellen Methode angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2069">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="3bd02-2070">Argumente, die einen ganzzahligen Wert enthalten, der kleiner als 4 Bytes ist, werden auf den Typ `int32` erweitert, wenn Sie auf dem Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2070">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="3bd02-2071">Gleit Komma Werte werden auf Ihre systemeigene Größe (Type `F`) erweitert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2071">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="3bd02-2072">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldarg.1` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2072">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.1` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2073">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2073">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2074">Lädt das Argument am Index 2 in den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2074">Loads the argument at index 2 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2075">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2075">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2076">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2076">Format</span></span>|<span data-ttu-id="3bd02-2077">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2077">Assembly Format</span></span>|<span data-ttu-id="3bd02-2078">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2078">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2079">04</span><span class="sxs-lookup"><span data-stu-id="3bd02-2079">04</span></span>|<span data-ttu-id="3bd02-2080">ldarg. 2</span><span class="sxs-lookup"><span data-stu-id="3bd02-2080">ldarg.2</span></span>|<span data-ttu-id="3bd02-2081">Argument 2 auf Stapel laden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2081">Load argument 2 onto stack.</span></span>|  
  
 <span data-ttu-id="3bd02-2082">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2082">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2083">Der Argument Wert am Index 2 wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2083">The argument value at index 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2084">Die `ldarg.2`-Anweisung ist eine effiziente Codierung zum Laden des Argument Werts an Index 2.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2084">The `ldarg.2` instruction is an efficient encoding for loading the argument value at index 2.</span></span>  
  
 <span data-ttu-id="3bd02-2085">Die `ldarg.2`-Anweisung legt das an 2 indizierte Argument auf dem Auswertungs Stapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2085">The `ldarg.2` instruction pushes the argument indexed at 2 onto the evaluation stack.</span></span> <span data-ttu-id="3bd02-2086">Die `ldarg.2`-Anweisung kann verwendet werden, um einen Werttyp oder einen primitiven Wert auf den Stapel zu laden, indem Sie ihn aus einem eingehenden Argument kopiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2086">The `ldarg.2` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="3bd02-2087">Der Typ des Argument Werts ist mit dem Typ des Arguments identisch, wie in der Signatur der aktuellen Methode angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2087">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="3bd02-2088">Argumente, die einen ganzzahligen Wert enthalten, der kleiner als 4 Bytes ist, werden auf den Typ `int32` erweitert, wenn Sie auf dem Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2088">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="3bd02-2089">Gleit Komma Werte werden auf Ihre systemeigene Größe (Type `F`) erweitert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2089">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="3bd02-2090">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldarg.2` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2090">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.2` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2091">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2091">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2092">Lädt das Argument am Index 3 in den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2092">Loads the argument at index 3 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2093">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2093">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2094">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2094">Format</span></span>|<span data-ttu-id="3bd02-2095">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2095">Assembly Format</span></span>|<span data-ttu-id="3bd02-2096">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2096">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2097">05</span><span class="sxs-lookup"><span data-stu-id="3bd02-2097">05</span></span>|<span data-ttu-id="3bd02-2098">ldarg. 3</span><span class="sxs-lookup"><span data-stu-id="3bd02-2098">ldarg.3</span></span>|<span data-ttu-id="3bd02-2099">Argument 3 auf Stapel laden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2099">Load argument 3 onto stack.</span></span>|  
  
 <span data-ttu-id="3bd02-2100">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2100">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2101">Der Argument Wert am Index 3 wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2101">The argument value at index 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2102">Die `ldarg.3`-Anweisung ist eine effiziente Codierung zum Laden des Argument Werts am Index 3.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2102">The `ldarg.3` instruction is an efficient encoding for loading the argument value at index 3.</span></span>  
  
 <span data-ttu-id="3bd02-2103">Die `ldarg.3`-Anweisung legt das an 3 indizierte Argument auf dem Auswertungs Stapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2103">The `ldarg.3` instruction pushes the argument indexed at 3 onto the evaluation stack.</span></span> <span data-ttu-id="3bd02-2104">Die `ldarg.3`-Anweisung kann verwendet werden, um einen Werttyp oder einen primitiven Wert auf den Stapel zu laden, indem Sie ihn aus einem eingehenden Argument kopiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2104">The `ldarg.3` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="3bd02-2105">Der Typ des Argument Werts ist mit dem Typ des Arguments identisch, wie in der Signatur der aktuellen Methode angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2105">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="3bd02-2106">Argumente, die einen ganzzahligen Wert enthalten, der kleiner als 4 Bytes ist, werden auf den Typ `int32` erweitert, wenn Sie auf dem Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2106">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="3bd02-2107">Gleit Komma Werte werden auf Ihre systemeigene Größe (Type `F`) erweitert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2107">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="3bd02-2108">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldarg.3` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2108">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.3` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2109">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2109">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2110">Lädt das Argument, auf das ein angegebener Kurzformindex verweist, in den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2110">Loads the argument (referenced by a specified short form index) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2111">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2111">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2112">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2112">Format</span></span>|<span data-ttu-id="3bd02-2113">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2113">Assembly Format</span></span>|<span data-ttu-id="3bd02-2114">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2114">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2115">0E < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-2115">0E < `unsigned int8` ></span></span>|<span data-ttu-id="3bd02-2116">ldarg. s `index`</span><span class="sxs-lookup"><span data-stu-id="3bd02-2116">ldarg.s `index`</span></span>|<span data-ttu-id="3bd02-2117">Load-Argument bei `index` auf Stapel, Kurzform.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2117">Load argument at `index` onto stack, short form.</span></span>|  
  
 <span data-ttu-id="3bd02-2118">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2118">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2119">Der Argument Wert an `index` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2119">The argument value at `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2120">Die `ldarg.s`-Anweisung ist eine effiziente Codierung zum Laden von Argumenten, die von 4 bis 255 indiziert werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2120">The `ldarg.s` instruction is an efficient encoding for loading arguments indexed from 4 through 255.</span></span>  
  
 <span data-ttu-id="3bd02-2121">Die `ldarg.s` Anweisung überträgt das an `index`indizierte Argument, bei dem Argumente von 0 bis auf den Auswertungs Stapel indiziert werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2121">The `ldarg.s` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack.</span></span> <span data-ttu-id="3bd02-2122">Die `ldarg.s`-Anweisung kann verwendet werden, um einen Werttyp oder einen primitiven Wert auf den Stapel zu laden, indem Sie ihn aus einem eingehenden Argument kopiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2122">The `ldarg.s` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="3bd02-2123">Der Typ des Argument Werts ist mit dem Typ des Arguments identisch, wie in der Signatur der aktuellen Methode angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2123">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="3bd02-2124">Für Prozeduren, die eine Argumentliste mit variabler Länge verwenden, kann die `ldarg.s` Anweisung nur für die anfänglichen Fixed-Argumente verwendet werden, nicht für die Argumente im Variablen Teil der Signatur (Weitere Informationen finden Sie in der <xref:System.Reflection.Emit.OpCodes.Arglist> Anweisung).</span><span class="sxs-lookup"><span data-stu-id="3bd02-2124">For procedures that take a variable-length argument list, the `ldarg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details).</span></span>  
  
 <span data-ttu-id="3bd02-2125">Argumente, die einen ganzzahligen Wert enthalten, der kleiner als 4 Bytes ist, werden auf den Typ `int32` erweitert, wenn Sie auf dem Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2125">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="3bd02-2126">Gleit Komma Werte werden auf Ihre systemeigene Größe (Type `F`) erweitert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2126">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="3bd02-2127">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldarg.s` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2127">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.s` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2128">ILGenerator.Emit(OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2128">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2129">Lädt eine Argumentadresse in den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2129">Load an argument address onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2130">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2130">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2131">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2131">Format</span></span>|<span data-ttu-id="3bd02-2132">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2132">Assembly Format</span></span>|<span data-ttu-id="3bd02-2133">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2133">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2134">FE 0A < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-2134">FE 0A < `unsigned int16` ></span></span>|<span data-ttu-id="3bd02-2135">ldarga-`index`</span><span class="sxs-lookup"><span data-stu-id="3bd02-2135">ldarga `index`</span></span>|<span data-ttu-id="3bd02-2136">Rufen Sie die Adresse des Arguments ab, das von `index`indiziert wurde.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2136">Fetch the address of argument indexed by `index`.</span></span>|  
  
 <span data-ttu-id="3bd02-2137">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2137">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2138">Die Adress `addr` des von `index` indizierten Arguments werden auf dem Stapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2138">The address `addr` of the argument indexed by `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2139">Die `ldarga`-Anweisung ruft die Adresse (vom Typ `*`) des Arguments ab, das von `index`indiziert wird, wobei die Argumente von 0 und höher indiziert werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2139">The `ldarga` instruction fetches the address (of type `*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards.</span></span> <span data-ttu-id="3bd02-2140">Die Adress `addr` wird immer an einer natürlichen Grenze auf dem Zielcomputer ausgerichtet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2140">The address `addr` is always aligned to a natural boundary on the target machine.</span></span>  
  
 <span data-ttu-id="3bd02-2141">Für Prozeduren, die eine Argumentliste mit variabler Länge verwenden, kann die `ldarga` Anweisung nur für die anfänglichen Fixed-Argumente verwendet werden, nicht für die im Variablen Teil der Signatur.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2141">For procedures that take a variable-length argument list, the `ldarga` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="3bd02-2142">`ldarga` wird für die Übergabe der by-ref-Parameter verwendet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2142">`ldarga` is used for by-ref parameter passing.</span></span> <span data-ttu-id="3bd02-2143">In anderen Fällen sollten <xref:System.Reflection.Emit.OpCodes.Ldarg> und <xref:System.Reflection.Emit.OpCodes.Starg> verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2143">For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg> and <xref:System.Reflection.Emit.OpCodes.Starg> should be used.</span></span>  
  
 <span data-ttu-id="3bd02-2144">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldarga` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2144">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2145">ILGenerator. ausgeben (OpCode, Short)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2145">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2146">Lädt eine Argumentadresse in Kurzform in den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2146">Load an argument address, in short form, onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2147">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2147">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2148">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2148">Format</span></span>|<span data-ttu-id="3bd02-2149">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2149">Assembly Format</span></span>|<span data-ttu-id="3bd02-2150">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2150">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2151">0F < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-2151">0F < `unsigned int8` ></span></span>|<span data-ttu-id="3bd02-2152">ldarga. s `index`</span><span class="sxs-lookup"><span data-stu-id="3bd02-2152">ldarga.s `index`</span></span>|<span data-ttu-id="3bd02-2153">Rufen Sie die Adresse des Arguments ab, das von `index`Kurzform indiziert wurde.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2153">Fetch the address of argument indexed by `index`, short form.</span></span>|  
  
 <span data-ttu-id="3bd02-2154">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2154">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2155">Die Adress `addr` des von `index` indizierten Arguments werden auf dem Stapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2155">The address `addr` of the argument indexed by `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2156">`ldarga.s` (Kurzform `ldarga`) sollte für Argument Nummern 0 bis 255 verwendet werden und ist eine effizientere Codierung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2156">`ldarga.s` (the short form of `ldarga`) should be used for argument numbers 0 through 255, and is a more efficient encoding.</span></span>  
  
 <span data-ttu-id="3bd02-2157">Die `ldarga.s`-Anweisung ruft die Adresse (vom Typ`*`) des Arguments ab, das von `index`indiziert wird, wobei die Argumente von 0 und höher indiziert werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2157">The `ldarga.s` instruction fetches the address (of type`*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards.</span></span> <span data-ttu-id="3bd02-2158">Die Adress `addr` wird immer an einer natürlichen Grenze auf dem Zielcomputer ausgerichtet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2158">The address `addr` is always aligned to a natural boundary on the target machine.</span></span>  
  
 <span data-ttu-id="3bd02-2159">Für Prozeduren, die eine Argumentliste mit variabler Länge verwenden, kann die `ldarga.s` Anweisung nur für die anfänglichen Fixed-Argumente verwendet werden, nicht für die im Variablen Teil der Signatur.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2159">For procedures that take a variable-length argument list, the `ldarga.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="3bd02-2160">`ldarga.s` wird für die Übergabe der by-ref-Parameter verwendet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2160">`ldarga.s` is used for by-ref parameter passing.</span></span> <span data-ttu-id="3bd02-2161">In anderen Fällen sollten <xref:System.Reflection.Emit.OpCodes.Ldarg_S> und <xref:System.Reflection.Emit.OpCodes.Starg_S> verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2161">For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg_S> and <xref:System.Reflection.Emit.OpCodes.Starg_S> should be used.</span></span>  
  
 <span data-ttu-id="3bd02-2162">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldarga.s` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2162">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga.s` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2163">ILGenerator.Emit(OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2163">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2164">Legt einen bereitgestellten Wert vom Typ <see langword="int32" /> als <see langword="int32" /> auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2164">Pushes a supplied value of type <see langword="int32" /> onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2165">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2165">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2166">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2166">Format</span></span>|<span data-ttu-id="3bd02-2167">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2167">Assembly Format</span></span>|<span data-ttu-id="3bd02-2168">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2168">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2169">20 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-2169">20 < `int32` ></span></span>|<span data-ttu-id="3bd02-2170">LDC. I4-`num`</span><span class="sxs-lookup"><span data-stu-id="3bd02-2170">ldc.i4 `num`</span></span>|<span data-ttu-id="3bd02-2171">Überträgt den Wert `num` auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2171">Pushes the value `num` onto the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-2172">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2172">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2173">Der Wert `num` der auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2173">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2174">Beachten Sie, dass es besondere kurze (und somit effizientere) Codierungen für die ganzen Zahlen (128 bis 127) und insbesondere für kurze Codierungen für-1 bis 8 gibt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2174">Note that there are special short (and hence more efficient) encodings for the integers -128 through 127, and especially short encodings for -1 through 8.</span></span> <span data-ttu-id="3bd02-2175">Alle kurzen Codierungen schieben 4 Byte-Ganzzahlen auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2175">All short encodings push 4 byte integers on the stack.</span></span> <span data-ttu-id="3bd02-2176">Längere Codierungen werden für 8-Byte-Ganzzahlen und 4-und 8-Byte-Gleit Komma Zahlen sowie für 4-Byte-Werte verwendet, die nicht in die Kurzform passen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2176">Longer encodings are used for 8 byte integers and 4 and 8 byte floating-point numbers, as well as 4-byte values that do not fit in the short forms.</span></span> <span data-ttu-id="3bd02-2177">Es gibt drei Möglichkeiten, eine ganzzahlige 8-Byte-Konstante auf den Stapel zu verschieben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2177">There are three ways to push an 8 byte integer constant onto the stack</span></span>  
  
 1. <span data-ttu-id="3bd02-2178">Verwenden Sie die <xref:System.Reflection.Emit.OpCodes.Ldc_I8> Anweisung für Konstanten, die in mehr als 32 Bits ausgedrückt werden müssen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2178">Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I8> instruction for constants that must be expressed in more than 32 bits.</span></span>  
  
 2. <span data-ttu-id="3bd02-2179">Verwenden Sie die <xref:System.Reflection.Emit.OpCodes.Ldc_I4>-Anweisung, gefolgt von einer <xref:System.Reflection.Emit.OpCodes.Conv_I8> für Konstanten, die 9 bis 32 Bits benötigen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2179">Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I4> instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that require 9 to 32 bits.</span></span>  
  
 3. <span data-ttu-id="3bd02-2180">Verwenden Sie eine kurze Formular Anweisung, gefolgt von einer <xref:System.Reflection.Emit.OpCodes.Conv_I8> für Konstanten, die in 8 oder weniger Bits ausgedrückt werden können.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2180">Use a short form instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that can be expressed in 8 or fewer bits.</span></span>  
  
 <span data-ttu-id="3bd02-2181">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldc.i4` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2181">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2182">ILGenerator. ausgeben (OpCode, int)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2182">ILGenerator.Emit(OpCode, int)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2183">Legt den Ganzzahlwert 0 als <see langword="int32" /> auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2183">Pushes the integer value of 0 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2184">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2184">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2185">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2185">Format</span></span>|<span data-ttu-id="3bd02-2186">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2186">Assembly Format</span></span>|<span data-ttu-id="3bd02-2187">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2187">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2188">16</span><span class="sxs-lookup"><span data-stu-id="3bd02-2188">16</span></span>|<span data-ttu-id="3bd02-2189">ldc.i4.0</span><span class="sxs-lookup"><span data-stu-id="3bd02-2189">ldc.i4.0</span></span>|<span data-ttu-id="3bd02-2190">Überträgt 0 auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2190">Pushes 0 onto the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-2191">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2191">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2192">Der Wert 0 wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2192">The value 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2193">Dies ist eine spezielle kurze Codierung für den Push des ganzzahligen Werts 0.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2193">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="3bd02-2194">Alle speziellen kurzen Codierungen pushen 4 Byte-Ganzzahlen auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2194">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2195">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldc.i4.0` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2195">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.0` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2196">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2196">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2197">Legt den Ganzzahlwert 1 als <see langword="int32" /> auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2197">Pushes the integer value of 1 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2198">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2198">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2199">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2199">Format</span></span>|<span data-ttu-id="3bd02-2200">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2200">Assembly Format</span></span>|<span data-ttu-id="3bd02-2201">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2201">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2202">17</span><span class="sxs-lookup"><span data-stu-id="3bd02-2202">17</span></span>|<span data-ttu-id="3bd02-2203">ldc.i4.1</span><span class="sxs-lookup"><span data-stu-id="3bd02-2203">ldc.i4.1</span></span>|<span data-ttu-id="3bd02-2204">Überträgt 1 auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2204">Pushes 1 onto the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-2205">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2205">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2206">Der Wert 1 wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2206">The value 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2207">Dies ist eine spezielle kurze Codierung für den Push des ganzzahligen Werts 1.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2207">This is a special short encoding for the push of the integer value 1.</span></span> <span data-ttu-id="3bd02-2208">Alle speziellen kurzen Codierungen pushen 4 Byte-Ganzzahlen auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2208">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2209">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldc.i4.1` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2209">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.1` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2210">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2210">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2211">Legt den Ganzzahlwert 2 als <see langword="int32" /> auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2211">Pushes the integer value of 2 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2212">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2212">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2213">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2213">Format</span></span>|<span data-ttu-id="3bd02-2214">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2214">Assembly Format</span></span>|<span data-ttu-id="3bd02-2215">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2215">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2216">18</span><span class="sxs-lookup"><span data-stu-id="3bd02-2216">18</span></span>|<span data-ttu-id="3bd02-2217">ldc.i4.2</span><span class="sxs-lookup"><span data-stu-id="3bd02-2217">ldc.i4.2</span></span>|<span data-ttu-id="3bd02-2218">Überträgt 2 auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2218">Pushes 2 onto the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-2219">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2219">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2220">Der Wert 2 wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2220">The value 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2221">Dies ist eine spezielle kurze Codierung für den Push des ganzzahligen Werts 2.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2221">This is a special short encoding for the push of the integer value 2.</span></span> <span data-ttu-id="3bd02-2222">Alle speziellen kurzen Codierungen pushen 4 Byte-Ganzzahlen auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2222">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2223">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldc.i4.2` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2223">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.2` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2224">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2224">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2225">Legt den Ganzzahlwert 3 als <see langword="int32" /> auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2225">Pushes the integer value of 3 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2226">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2226">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2227">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2227">Format</span></span>|<span data-ttu-id="3bd02-2228">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2228">Assembly Format</span></span>|<span data-ttu-id="3bd02-2229">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2229">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2230">19</span><span class="sxs-lookup"><span data-stu-id="3bd02-2230">19</span></span>|<span data-ttu-id="3bd02-2231">ldc.i4.3</span><span class="sxs-lookup"><span data-stu-id="3bd02-2231">ldc.i4.3</span></span>|<span data-ttu-id="3bd02-2232">Überträgt 3 auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2232">Pushes 3 onto the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-2233">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2233">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2234">Der Wert 3 wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2234">The value 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2235">Dies ist eine spezielle kurze Codierung für den Push des ganzzahligen Werts 3.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2235">This is a special short encoding for the push of the integer value 3.</span></span> <span data-ttu-id="3bd02-2236">Alle speziellen kurzen Codierungen pushen 4 Byte-Ganzzahlen auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2236">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2237">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldc.i4.3` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2237">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.3` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2238">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2238">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2239">Legt den Ganzzahlwert 4 als <see langword="int32" /> auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2239">Pushes the integer value of 4 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2240">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2240">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2241">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2241">Format</span></span>|<span data-ttu-id="3bd02-2242">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2242">Assembly Format</span></span>|<span data-ttu-id="3bd02-2243">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2243">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2244">1a</span><span class="sxs-lookup"><span data-stu-id="3bd02-2244">1A</span></span>|<span data-ttu-id="3bd02-2245">ldc.i4.4</span><span class="sxs-lookup"><span data-stu-id="3bd02-2245">ldc.i4.4</span></span>|<span data-ttu-id="3bd02-2246">Überträgt 4 auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2246">Pushes 4 onto the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-2247">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2247">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2248">Der Wert 4 wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2248">The value 4 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2249">Dies ist eine spezielle kurze Codierung für den Push des ganzzahligen Werts 4.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2249">This is a special short encoding for the push of the integer value 4.</span></span> <span data-ttu-id="3bd02-2250">Alle speziellen kurzen Codierungen pushen 4 Byte-Ganzzahlen auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2250">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2251">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldc.i4.4` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2251">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.4` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2252">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2252">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2253">Legt den Ganzzahlwert 5 als <see langword="int32" /> auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2253">Pushes the integer value of 5 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2254">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2254">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2255">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2255">Format</span></span>|<span data-ttu-id="3bd02-2256">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2256">Assembly Format</span></span>|<span data-ttu-id="3bd02-2257">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2257">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2258">1B</span><span class="sxs-lookup"><span data-stu-id="3bd02-2258">1B</span></span>|<span data-ttu-id="3bd02-2259">ldc.i4.5</span><span class="sxs-lookup"><span data-stu-id="3bd02-2259">ldc.i4.5</span></span>|<span data-ttu-id="3bd02-2260">Überträgt 5 auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2260">Pushes 5 onto the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-2261">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2261">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2262">Der Wert 5 wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2262">The value 5 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2263">Dies ist eine spezielle kurze Codierung für den Push des ganzzahligen Werts 5.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2263">This is a special short encoding for the push of the integer value 5.</span></span> <span data-ttu-id="3bd02-2264">Alle speziellen kurzen Codierungen pushen 4 Byte-Ganzzahlen auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2264">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2265">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldc.i4.5` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2265">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.5` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2266">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2266">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2267">Legt den Ganzzahlwert 6 als <see langword="int32" /> auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2267">Pushes the integer value of 6 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2268">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2268">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2269">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2269">Format</span></span>|<span data-ttu-id="3bd02-2270">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2270">Assembly Format</span></span>|<span data-ttu-id="3bd02-2271">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2271">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2272">1C</span><span class="sxs-lookup"><span data-stu-id="3bd02-2272">1C</span></span>|<span data-ttu-id="3bd02-2273">ldc.i4.6</span><span class="sxs-lookup"><span data-stu-id="3bd02-2273">ldc.i4.6</span></span>|<span data-ttu-id="3bd02-2274">Überträgt 6 auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2274">Pushes 6 onto the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-2275">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2275">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2276">Der Wert 6 wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2276">The value 6 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2277">Dies ist eine spezielle kurze Codierung für den Push des ganzzahligen Werts 6.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2277">This is a special short encoding for the push of the integer value 6.</span></span> <span data-ttu-id="3bd02-2278">Alle speziellen kurzen Codierungen pushen 4 Byte-Ganzzahlen auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2278">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2279">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldc.i4.6` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2279">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.6` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2280">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2280">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2281">Legt den Ganzzahlwert 7 als <see langword="int32" /> auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2281">Pushes the integer value of 7 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2282">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2282">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2283">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2283">Format</span></span>|<span data-ttu-id="3bd02-2284">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2284">Assembly Format</span></span>|<span data-ttu-id="3bd02-2285">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2285">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2286">1D</span><span class="sxs-lookup"><span data-stu-id="3bd02-2286">1D</span></span>|<span data-ttu-id="3bd02-2287">ldc.i4.7</span><span class="sxs-lookup"><span data-stu-id="3bd02-2287">ldc.i4.7</span></span>|<span data-ttu-id="3bd02-2288">Überträgt 7 auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2288">Pushes 7 onto the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-2289">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2289">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2290">Der Wert 7 wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2290">The value 7 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2291">Dies ist eine spezielle kurze Codierung für den Push des ganzzahligen Werts 7.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2291">This is a special short encoding for the push of the integer value 7.</span></span> <span data-ttu-id="3bd02-2292">Alle speziellen kurzen Codierungen pushen 4 Byte-Ganzzahlen auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2292">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2293">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldc.i4.7` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2293">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.7` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2294">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2294">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2295">Legt den Ganzzahlwert 8 als <see langword="int32" /> auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2295">Pushes the integer value of 8 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2296">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2296">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2297">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2297">Format</span></span>|<span data-ttu-id="3bd02-2298">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2298">Assembly Format</span></span>|<span data-ttu-id="3bd02-2299">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2299">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2300">1E</span><span class="sxs-lookup"><span data-stu-id="3bd02-2300">1E</span></span>|<span data-ttu-id="3bd02-2301">ldc.i4.8</span><span class="sxs-lookup"><span data-stu-id="3bd02-2301">ldc.i4.8</span></span>|<span data-ttu-id="3bd02-2302">Überträgt 8 auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2302">Pushes 8 onto the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-2303">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2303">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2304">Der Wert 8 wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2304">The value 8 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2305">Dies ist eine spezielle kurze Codierung für den Push des ganzzahligen Werts 8.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2305">This is a special short encoding for the push of the integer value 8.</span></span> <span data-ttu-id="3bd02-2306">Alle speziellen kurzen Codierungen pushen 4 Byte-Ganzzahlen auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2306">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2307">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldc.i4.8` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2307">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.8` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2308">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2308">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2309">Legt den Ganzzahlwert -1 als <see langword="int32" /> auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2309">Pushes the integer value of -1 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2310">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2310">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2311">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2311">Format</span></span>|<span data-ttu-id="3bd02-2312">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2312">Assembly Format</span></span>|<span data-ttu-id="3bd02-2313">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2313">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2314">15</span><span class="sxs-lookup"><span data-stu-id="3bd02-2314">15</span></span>|<span data-ttu-id="3bd02-2315">ldc.i4.m1</span><span class="sxs-lookup"><span data-stu-id="3bd02-2315">ldc.i4.m1</span></span>|<span data-ttu-id="3bd02-2316">Überträgt-1 auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2316">Pushes -1 onto the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-2317">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2317">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2318">Der Wert-1 wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2318">The value -1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2319">Dies ist eine spezielle kurze Codierung für den Push des ganzzahligen Werts-1.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2319">This is a special short encoding for the push of the integer value -1.</span></span> <span data-ttu-id="3bd02-2320">Alle speziellen kurzen Codierungen pushen 4 Byte-Ganzzahlen auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2320">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2321">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldc.i4.m1` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2321">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.m1` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2322">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2322">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2323">Legt den bereitgestellten <see langword="int8" />-Wert als <see langword="int32" />, Kurzform, auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2323">Pushes the supplied <see langword="int8" /> value onto the evaluation stack as an <see langword="int32" />, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2324">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2324">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2325">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2325">Format</span></span>|<span data-ttu-id="3bd02-2326">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2326">Assembly Format</span></span>|<span data-ttu-id="3bd02-2327">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2327">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2328">1F < `int8` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-2328">1F < `int8` ></span></span>|<span data-ttu-id="3bd02-2329">LDC. I4. s `num`</span><span class="sxs-lookup"><span data-stu-id="3bd02-2329">ldc.i4.s `num`</span></span>|<span data-ttu-id="3bd02-2330">Überträgt `num` als `int32`Kurzform auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2330">Pushes `num` onto the stack as `int32`, short form.</span></span>|  
  
 <span data-ttu-id="3bd02-2331">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2331">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2332">Der Wert `num` der auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2332">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2333">`ldc.i4.s` ist eine effizientere Codierung, um die ganzen Zahlen zwischen-128 und 127 auf dem Auswertungs Stapel zu pushen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2333">`ldc.i4.s` is a more efficient encoding for pushing the integers from -128 to 127 onto the evaluation stack.</span></span>  
  
<span data-ttu-id="3bd02-2334">Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladungen können den `ldc.i4.s` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2334">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldc.i4.s` opcode:</span></span>
  
- <xref:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Byte)?displayProperty=nameWithType>
- <xref:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.SByte)?displayProperty=nameWithType>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2335">Legt einen bereitgestellten Wert vom Typ <see langword="int64" /> als <see langword="int64" /> auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2335">Pushes a supplied value of type <see langword="int64" /> onto the evaluation stack as an <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2336">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2336">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2337">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2337">Format</span></span>|<span data-ttu-id="3bd02-2338">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2338">Assembly Format</span></span>|<span data-ttu-id="3bd02-2339">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2339">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2340">21 < `int64` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-2340">21 < `int64` ></span></span>|<span data-ttu-id="3bd02-2341">LDC. I8 `num`</span><span class="sxs-lookup"><span data-stu-id="3bd02-2341">ldc.i8 `num`</span></span>|<span data-ttu-id="3bd02-2342">Überträgt `num` als `int64`auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2342">Pushes `num` onto the stack as `int64`.</span></span>|  
  
 <span data-ttu-id="3bd02-2343">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2343">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2344">Der Wert `num` der auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2344">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2345">Diese Codierung überträgt einen `int64` Wert auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2345">This encoding pushes an `int64` value onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2346">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldc.i8` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2346">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i8` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2347">ILGenerator.Emit(OpCode, long)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2347">ILGenerator.Emit(OpCode, long)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2348">Legt einen bereitgestellten Wert vom Typ <see langword="float32" /> als Typ <see langword="F" /> (Gleitkommawert) auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2348">Pushes a supplied value of type <see langword="float32" /> onto the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2349">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2349">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2350">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2350">Format</span></span>|<span data-ttu-id="3bd02-2351">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2351">Assembly Format</span></span>|<span data-ttu-id="3bd02-2352">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2352">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2353">22 < `float32` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-2353">22 < `float32` ></span></span>|<span data-ttu-id="3bd02-2354">LDC. R4 `num`</span><span class="sxs-lookup"><span data-stu-id="3bd02-2354">ldc.r4 `num`</span></span>|<span data-ttu-id="3bd02-2355">Überträgt `num` als `F`auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2355">Pushes `num` onto the stack as `F`.</span></span>|  
  
 <span data-ttu-id="3bd02-2356">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2356">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2357">Der Wert `num` der auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2357">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2358">Diese Codierung überträgt einen `float32` Wert auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2358">This encoding pushes a `float32` value onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2359">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldc.r4` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2359">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r4` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2360">ILGenerator.Emit(OpCode, single)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2360">ILGenerator.Emit(OpCode, single)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2361">Legt einen bereitgestellten Wert vom Typ <see langword="float64" /> als Typ <see langword="F" /> (Gleitkommawert) auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2361">Pushes a supplied value of type <see langword="float64" /> onto the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2362">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2362">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2363">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2363">Format</span></span>|<span data-ttu-id="3bd02-2364">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2364">Assembly Format</span></span>|<span data-ttu-id="3bd02-2365">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2365">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2366">23 < `float64` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-2366">23 < `float64` ></span></span>|<span data-ttu-id="3bd02-2367">LDC. R8 `num`</span><span class="sxs-lookup"><span data-stu-id="3bd02-2367">ldc.r8 `num`</span></span>|<span data-ttu-id="3bd02-2368">Überträgt `num` als `F`auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2368">Pushes `num` onto the stack as `F`.</span></span>|  
  
 <span data-ttu-id="3bd02-2369">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2369">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2370">Der Wert `num` der auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2370">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2371">Diese Codierung überträgt einen `float64` Wert auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2371">This encoding pushes a `float64` value onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2372">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldc.r8` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2372">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r8` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2373">ILGenerator. ausgeben (OpCode, Double)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2373">ILGenerator.Emit(OpCode, double)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2374">Lädt das Element an einem angegebenen Arrayindex als der in der Anweisung angegebene Typ auf die oberste Position des Auswertungsstapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2374">Loads the element at a specified array index onto the top of the evaluation stack as the type specified in the instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2375">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2375">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2376">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2376">Format</span></span>|<span data-ttu-id="3bd02-2377">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2377">Assembly Format</span></span>|<span data-ttu-id="3bd02-2378">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2378">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2379">A3 < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-2379">A3 < `T` ></span></span>|<span data-ttu-id="3bd02-2380">ldelta EM-`typeTok`</span><span class="sxs-lookup"><span data-stu-id="3bd02-2380">ldelem `typeTok`</span></span>|<span data-ttu-id="3bd02-2381">Lädt das Element am `index` am Anfang des Stapels als Typ `typeTok`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2381">Loads the element at `index` onto the top of the stack as type `typeTok`.</span></span>|  
  
 <span data-ttu-id="3bd02-2382">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2382">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2383">Ein Objekt Verweis `array` auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2383">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-2384">Ein Indexwert `index` der auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2384">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-2385">`index` und `array` werden aus dem Stapel entfernt. der Wert, der an der Position `index` in `array` gespeichert wird, wird gesucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2385">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="3bd02-2386">Der Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2386">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2387">Die `ldelem` Anweisung lädt den Wert des Elements mit Index `index` (Type `native int`) in das null basierte eindimensionale Array `array` und platziert Sie am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2387">The `ldelem` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="3bd02-2388">Arrays sind Objekte und werden daher durch einen Wert vom Typ `O`dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2388">Arrays are objects, and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="3bd02-2389">Der Typ des Rückgabewerts wird durch das Token `typeTok` in der Anweisung angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2389">The type of the return value is specified by the token `typeTok` in the instruction.</span></span>  
  
 <span data-ttu-id="3bd02-2390"><xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2390"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-2391"><xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` negativ oder größer als die obere Grenze von `array`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2391"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the upper bound of `array`.</span></span>  
  
 <span data-ttu-id="3bd02-2392">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldelem` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2392">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2393">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2393">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2394">Lädt das Element mit dem Typ <see langword="native int" /> an einem angegebenen Arrayindex als <see langword="native int" /> auf die oberste Position des Auswertungsstapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2394">Loads the element with type <see langword="native int" /> at a specified array index onto the top of the evaluation stack as a <see langword="native int" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2395">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2395">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2396">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2396">Format</span></span>|<span data-ttu-id="3bd02-2397">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2397">Assembly Format</span></span>|<span data-ttu-id="3bd02-2398">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2398">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2399">97</span><span class="sxs-lookup"><span data-stu-id="3bd02-2399">97</span></span>|<span data-ttu-id="3bd02-2400">ldelem.i</span><span class="sxs-lookup"><span data-stu-id="3bd02-2400">ldelem.i</span></span>|<span data-ttu-id="3bd02-2401">Lädt das Element mit dem Typ `native int` `index` als `native int`an den Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2401">Loads the element with type `native int` at `index` onto the top of the stack as a `native int`.</span></span>|  
  
 <span data-ttu-id="3bd02-2402">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2402">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2403">Ein Objekt Verweis `array` auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2403">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-2404">Ein Indexwert `index` der auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2404">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-2405">`index` und `array` werden aus dem Stapel entfernt. der Wert, der an der Position `index` in `array` gespeichert wird, wird gesucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2405">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="3bd02-2406">Der Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2406">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2407">Die `ldelem.i` Anweisung lädt den Wert des Elements mit Index `index` (Type `native int`) in das null basierte eindimensionale Array `array` und platziert Sie am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2407">The `ldelem.i` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="3bd02-2408">Arrays sind Objekte und werden daher durch einen Wert vom Typ `O`dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2408">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="3bd02-2409">Der Rückgabewert für `ldelem.i` ist `native int`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2409">The return value for `ldelem.i` is `native int`.</span></span>  
  
 <span data-ttu-id="3bd02-2410">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht `native int`) erweitert werden, wenn Sie auf dem Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2410">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="3bd02-2411"><xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2411"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-2412"><xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2412"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="3bd02-2413"><xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` negativ oder größer als die gebundene `array`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2413"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="3bd02-2414">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldelem.i` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2414">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2415">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2415">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2416">Lädt das Element mit dem Typ <see langword="int8" /> an einem angegebenen Arrayindex als <see langword="int32" /> an die oberste Position des Auswertungsstapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2416">Loads the element with type <see langword="int8" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2417">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2417">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2418">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2418">Format</span></span>|<span data-ttu-id="3bd02-2419">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2419">Assembly Format</span></span>|<span data-ttu-id="3bd02-2420">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2420">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2421">90</span><span class="sxs-lookup"><span data-stu-id="3bd02-2421">90</span></span>|<span data-ttu-id="3bd02-2422">ldelem.i1</span><span class="sxs-lookup"><span data-stu-id="3bd02-2422">ldelem.i1</span></span>|<span data-ttu-id="3bd02-2423">Lädt das Element mit dem Typ `int8` `index` als `int32`an den Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2423">Loads the element with type `int8` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="3bd02-2424">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2424">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2425">Ein Objekt Verweis `array` auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2425">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-2426">Ein Indexwert `index` der auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2426">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-2427">`index` und `array` werden aus dem Stapel entfernt. der Wert, der an der Position `index` in `array` gespeichert wird, wird gesucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2427">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="3bd02-2428">Der Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2428">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2429">Die `ldelem.i1` Anweisung lädt den Wert des Elements mit Index `index` (Type `native int`) in das null basierte eindimensionale Array `array` und platziert Sie am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2429">The `ldelem.i1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="3bd02-2430">Arrays sind Objekte und werden daher durch einen Wert vom Typ `O`dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2430">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="3bd02-2431">Der Rückgabewert für `ldelem.i1` ist `int8`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2431">The return value for `ldelem.i1` is `int8`.</span></span>  
  
 <span data-ttu-id="3bd02-2432">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht `native int`) erweitert werden, wenn Sie auf dem Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2432">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="3bd02-2433"><xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2433"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-2434"><xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2434"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="3bd02-2435"><xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` negativ oder größer als die gebundene `array`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2435"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="3bd02-2436">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldelem.i1` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2436">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i1` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2437">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2437">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2438">Lädt das Element mit dem Typ <see langword="int16" /> an einem angegebenen Arrayindex als <see langword="int32" /> an die oberste Position des Auswertungsstapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2438">Loads the element with type <see langword="int16" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2439">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2439">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2440">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2440">Format</span></span>|<span data-ttu-id="3bd02-2441">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2441">Assembly Format</span></span>|<span data-ttu-id="3bd02-2442">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2442">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2443">92</span><span class="sxs-lookup"><span data-stu-id="3bd02-2443">92</span></span>|<span data-ttu-id="3bd02-2444">ldelem.i2</span><span class="sxs-lookup"><span data-stu-id="3bd02-2444">ldelem.i2</span></span>|<span data-ttu-id="3bd02-2445">Lädt das Element mit dem Typ `int16` `index` als `int32`an den Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2445">Loads the element with type `int16` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="3bd02-2446">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2446">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2447">Ein Objekt Verweis `array` auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2447">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-2448">Ein Indexwert `index` der auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2448">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-2449">`index` und `array` werden aus dem Stapel entfernt. der Wert, der an der Position `index` in `array` gespeichert wird, wird gesucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2449">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="3bd02-2450">Der Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2450">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2451">Die `ldelem.i2` Anweisung lädt den Wert des Elements mit Index `index` (Type `native int`) in das null basierte eindimensionale Array `array` und platziert Sie am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2451">The `ldelem.i2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="3bd02-2452">Arrays sind Objekte und werden daher durch einen Wert vom Typ `O`dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2452">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="3bd02-2453">Der Rückgabewert für `ldelem.i2` ist `int16`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2453">The return value for `ldelem.i2` is `int16`.</span></span>  
  
 <span data-ttu-id="3bd02-2454">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht `native int`) erweitert werden, wenn Sie auf dem Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2454">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="3bd02-2455"><xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2455"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-2456"><xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2456"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="3bd02-2457"><xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` negativ oder größer als die gebundene `array`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2457"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="3bd02-2458">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldelem.i2` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2458">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i2` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2459">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2459">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2460">Lädt das Element mit dem Typ <see langword="int32" /> an einem angegebenen Arrayindex als <see langword="int32" /> an die oberste Position des Auswertungsstapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2460">Loads the element with type <see langword="int32" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2461">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2461">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2462">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2462">Format</span></span>|<span data-ttu-id="3bd02-2463">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2463">Assembly Format</span></span>|<span data-ttu-id="3bd02-2464">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2464">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2465">94</span><span class="sxs-lookup"><span data-stu-id="3bd02-2465">94</span></span>|<span data-ttu-id="3bd02-2466">ldelem.i4</span><span class="sxs-lookup"><span data-stu-id="3bd02-2466">ldelem.i4</span></span>|<span data-ttu-id="3bd02-2467">Lädt das Element mit dem Typ `int32` `index` als `int32`an den Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2467">Loads the element with type `int32` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="3bd02-2468">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2468">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2469">Ein Objekt Verweis `array` auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2469">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-2470">Ein Indexwert `index` der auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2470">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-2471">`index` und `array` werden aus dem Stapel entfernt. der Wert, der an der Position `index` in `array` gespeichert wird, wird gesucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2471">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="3bd02-2472">Der Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2472">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2473">Die `ldelem.i4` Anweisung lädt den Wert des Elements mit Index `index` (Type `native int`) in das null basierte eindimensionale Array `array` und platziert Sie am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2473">The `ldelem.i4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="3bd02-2474">Arrays sind Objekte und werden daher durch einen Wert vom Typ `O`dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2474">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="3bd02-2475">Der Rückgabewert für `ldelem.i4` ist `int32`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2475">The return value for `ldelem.i4` is `int32`.</span></span>  
  
 <span data-ttu-id="3bd02-2476">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht `native int`) erweitert werden, wenn Sie auf dem Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2476">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="3bd02-2477"><xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2477"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-2478"><xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2478"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="3bd02-2479"><xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` negativ oder größer als die gebundene `array`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2479"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="3bd02-2480">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldelem.i4` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2480">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i4` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2481">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2481">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2482">Lädt das Element mit dem Typ <see langword="int64" /> an einem angegebenen Arrayindex als <see langword="int64" /> an die oberste Position des Auswertungsstapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2482">Loads the element with type <see langword="int64" /> at a specified array index onto the top of the evaluation stack as an <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2483">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2483">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2484">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2484">Format</span></span>|<span data-ttu-id="3bd02-2485">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2485">Assembly Format</span></span>|<span data-ttu-id="3bd02-2486">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2486">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2487">96</span><span class="sxs-lookup"><span data-stu-id="3bd02-2487">96</span></span>|<span data-ttu-id="3bd02-2488">ldelem.i8</span><span class="sxs-lookup"><span data-stu-id="3bd02-2488">ldelem.i8</span></span>|<span data-ttu-id="3bd02-2489">Lädt das Element mit dem Typ `int64` `index` als `int64`an den Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2489">Loads the element with type `int64` at `index` onto the top of the stack as an `int64`.</span></span>|  
  
 <span data-ttu-id="3bd02-2490">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2490">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2491">Ein Objekt Verweis `array` auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2491">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-2492">Ein Indexwert `index` der auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2492">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-2493">`index` und `array` werden aus dem Stapel entfernt. der Wert, der an der Position `index` in `array` gespeichert wird, wird gesucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2493">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="3bd02-2494">Der Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2494">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2495">Die `ldelem.i8` Anweisung lädt den Wert des Elements mit Index `index` (Type `native int`) in das null basierte eindimensionale Array `array` und platziert Sie am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2495">The `ldelem.i8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="3bd02-2496">Arrays sind Objekte und werden daher durch einen Wert vom Typ `O`dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2496">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="3bd02-2497">Der Rückgabewert für `ldelem.i8` ist `int64`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2497">The return value for `ldelem.i8` is `int64`.</span></span>  
  
 <span data-ttu-id="3bd02-2498">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht `native int`) erweitert werden, wenn Sie auf dem Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2498">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="3bd02-2499"><xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2499"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-2500"><xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2500"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="3bd02-2501"><xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` negativ oder größer als die gebundene `array`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2501"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="3bd02-2502">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldelem.i8` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2502">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i8` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2503">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2503">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2504">Lädt das Element vom Typ <see langword="float32" /> an einem angegebenen Arrayindex als Typ <see langword="F" /> (Gleitkommawert) an die oberste Position des Auswertungsstapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2504">Loads the element with type <see langword="float32" /> at a specified array index onto the top of the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2505">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2505">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2506">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2506">Format</span></span>|<span data-ttu-id="3bd02-2507">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2507">Assembly Format</span></span>|<span data-ttu-id="3bd02-2508">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2508">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2509">98</span><span class="sxs-lookup"><span data-stu-id="3bd02-2509">98</span></span>|<span data-ttu-id="3bd02-2510">ldelem.r4</span><span class="sxs-lookup"><span data-stu-id="3bd02-2510">ldelem.r4</span></span>|<span data-ttu-id="3bd02-2511">Lädt das Element mit dem Typ `float32` `index` als Typ `F`an den Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2511">Loads the element with type `float32` at `index` onto the top of the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="3bd02-2512">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2512">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2513">Ein Objekt Verweis `array` auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2513">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-2514">Ein Indexwert `index` der auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2514">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-2515">`index` und `array` werden aus dem Stapel entfernt. der Wert, der an der Position `index` in `array` gespeichert wird, wird gesucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2515">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="3bd02-2516">Der Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2516">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2517">Die `ldelem.r4` Anweisung lädt den Wert des Elements mit Index `index` (Type `native int`) in das null basierte eindimensionale Array `array` und platziert Sie am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2517">The `ldelem.r4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="3bd02-2518">Arrays sind Objekte und werden daher durch einen Wert vom Typ `O`dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2518">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="3bd02-2519">Der Rückgabewert für `ldelem.r4` ist `float32`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2519">The return value for `ldelem.r4` is `float32`.</span></span>  
  
 <span data-ttu-id="3bd02-2520">Gleit Komma Werte werden in den Typ `F` konvertiert, wenn Sie auf den Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2520">Floating-point values are converted to type `F` when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="3bd02-2521"><xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2521"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-2522"><xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2522"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="3bd02-2523"><xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` negativ oder größer als die gebundene `array`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2523"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="3bd02-2524">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldelem.r4` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2524">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r4` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2525">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2525">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2526">Lädt das Element vom Typ <see langword="float64" /> an einem angegebenen Arrayindex als Typ <see langword="F" /> (Gleitkommawert) an die oberste Position des Auswertungsstapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2526">Loads the element with type <see langword="float64" /> at a specified array index onto the top of the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2527">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2527">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2528">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2528">Format</span></span>|<span data-ttu-id="3bd02-2529">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2529">Assembly Format</span></span>|<span data-ttu-id="3bd02-2530">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2530">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2531">99</span><span class="sxs-lookup"><span data-stu-id="3bd02-2531">99</span></span>|<span data-ttu-id="3bd02-2532">ldelem.r8</span><span class="sxs-lookup"><span data-stu-id="3bd02-2532">ldelem.r8</span></span>|<span data-ttu-id="3bd02-2533">Lädt das Element mit dem Typ `float64` am `index` als Typ `F`an den Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2533">Loads the element with type `float64` at `index` onto the top of the stack as type `F`.</span></span>|  
  
 <span data-ttu-id="3bd02-2534">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2534">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2535">Ein Objekt Verweis `array` auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2535">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-2536">Ein Indexwert `index` der auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2536">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-2537">`index` und `array` werden aus dem Stapel entfernt. der Wert, der an der Position `index` in `array` gespeichert wird, wird gesucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2537">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="3bd02-2538">Der Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2538">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2539">Die `ldelem.r8` Anweisung lädt den Wert des Elements mit Index `index` (Type `native int`) in das null basierte eindimensionale Array `array` und platziert Sie am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2539">The `ldelem.r8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="3bd02-2540">Arrays sind Objekte und werden daher durch einen Wert vom Typ `O`dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2540">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="3bd02-2541">Der Rückgabewert für `ldelem.r8` ist `float64`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2541">The return value for `ldelem.r8` is `float64`.</span></span>  
  
 <span data-ttu-id="3bd02-2542">Gleit Komma Werte werden in den Typ `F` konvertiert, wenn Sie auf den Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2542">Floating-point values are converted to type `F` when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="3bd02-2543"><xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2543"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-2544"><xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2544"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="3bd02-2545"><xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` negativ oder größer als die gebundene `array`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2545"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="3bd02-2546">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldelem.r8` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2546">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r8` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2547">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2547">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2548">Lädt das Element mit Objektverweis an einem angegebenen Arrayindex als Typ <see langword="O" /> (Objektverweis) an die oberste Position des Auswertungsstapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2548">Loads the element containing an object reference at a specified array index onto the top of the evaluation stack as type <see langword="O" /> (object reference).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2549">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2549">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2550">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2550">Format</span></span>|<span data-ttu-id="3bd02-2551">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2551">Assembly Format</span></span>|<span data-ttu-id="3bd02-2552">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2552">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2553">9A</span><span class="sxs-lookup"><span data-stu-id="3bd02-2553">9A</span></span>|<span data-ttu-id="3bd02-2554">ldelem.ref</span><span class="sxs-lookup"><span data-stu-id="3bd02-2554">ldelem.ref</span></span>|<span data-ttu-id="3bd02-2555">Lädt das Element mit einem Objekt Verweis an `index` an den Anfang des Stapels als Typ `O`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2555">Loads the element with an object reference at `index` onto the top of the stack as type `O`.</span></span>|  
  
 <span data-ttu-id="3bd02-2556">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2556">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2557">Ein Objekt Verweis `array` auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2557">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-2558">Ein Indexwert `index` der auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2558">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-2559">`index` und `array` werden aus dem Stapel entfernt. der Wert, der an der Position `index` in `array` gespeichert wird, wird gesucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2559">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="3bd02-2560">Der Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2560">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2561">Die `ldelem.ref` Anweisung lädt den Wert des Elements mit Index `index` (Type `native int`) in das null basierte eindimensionale Array `array` und platziert Sie am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2561">The `ldelem.ref` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="3bd02-2562">Arrays sind Objekte und werden daher durch einen Wert vom Typ `O`dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2562">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="3bd02-2563">Der Rückgabewert für `ldelem.ref` ist vom Typ `O` (Objekt Verweis).</span><span class="sxs-lookup"><span data-stu-id="3bd02-2563">The return value for `ldelem.ref` is type `O` (object reference).</span></span>  
  
 <span data-ttu-id="3bd02-2564"><xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2564"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-2565"><xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2565"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="3bd02-2566"><xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` negativ oder größer als die gebundene `array`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2566"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="3bd02-2567">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldelem.ref` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2567">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.ref` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2568">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2568">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2569">Lädt das Element mit dem Typ <see langword="unsigned int8" /> an einem angegebenen Arrayindex als <see langword="int32" /> an die oberste Position des Auswertungsstapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2569">Loads the element with type <see langword="unsigned int8" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2570">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2570">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2571">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2571">Format</span></span>|<span data-ttu-id="3bd02-2572">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2572">Assembly Format</span></span>|<span data-ttu-id="3bd02-2573">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2573">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2574">91</span><span class="sxs-lookup"><span data-stu-id="3bd02-2574">91</span></span>|<span data-ttu-id="3bd02-2575">ldelem.u1</span><span class="sxs-lookup"><span data-stu-id="3bd02-2575">ldelem.u1</span></span>|<span data-ttu-id="3bd02-2576">Lädt das Element mit dem Typ `unsigned int8` `index` als `int32`an den Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2576">Loads the element with type `unsigned int8` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="3bd02-2577">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2577">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2578">Ein Objekt Verweis `array` auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2578">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-2579">Ein Indexwert `index` der auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2579">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-2580">`index` und `array` werden aus dem Stapel entfernt. der Wert, der an der Position `index` in `array` gespeichert wird, wird gesucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2580">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="3bd02-2581">Der Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2581">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2582">Die `ldelem.u1` Anweisung lädt den Wert des Elements mit Index `index` (Type `native int`) in das null basierte eindimensionale Array `array` und platziert Sie am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2582">The `ldelem.u1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="3bd02-2583">Arrays sind Objekte und werden daher durch einen Wert vom Typ `O`dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2583">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="3bd02-2584">Der Rückgabewert für `ldelem.u1` ist `int8`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2584">The return value for `ldelem.u1` is `int8`.</span></span>  
  
 <span data-ttu-id="3bd02-2585">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht `native int`) erweitert werden, wenn Sie auf dem Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2585">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="3bd02-2586"><xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2586"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-2587"><xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2587"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="3bd02-2588"><xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` negativ oder größer als die gebundene `array`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2588"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="3bd02-2589">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldelem.u1` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2589">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u1` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2590">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2590">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2591">Lädt das Element mit dem Typ <see langword="unsigned int16" /> an einem angegebenen Arrayindex als <see langword="int32" /> an die oberste Position des Auswertungsstapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2591">Loads the element with type <see langword="unsigned int16" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2592">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2592">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2593">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2593">Format</span></span>|<span data-ttu-id="3bd02-2594">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2594">Assembly Format</span></span>|<span data-ttu-id="3bd02-2595">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2595">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2596">93</span><span class="sxs-lookup"><span data-stu-id="3bd02-2596">93</span></span>|<span data-ttu-id="3bd02-2597">ldelem.u2</span><span class="sxs-lookup"><span data-stu-id="3bd02-2597">ldelem.u2</span></span>|<span data-ttu-id="3bd02-2598">Lädt das Element mit dem Typ `unsigned int16` am Index als `int32`an den oberen Rand des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2598">Loads the element with type `unsigned int16` at index onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="3bd02-2599">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2599">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2600">Ein Objekt Verweis `array` auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2600">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-2601">Ein Indexwert `index` der auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2601">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-2602">`index` und `array` werden aus dem Stapel entfernt. der Wert, der an der Position `index` in `array` gespeichert wird, wird gesucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2602">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="3bd02-2603">Der Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2603">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2604">Die `ldelem.u2` Anweisung lädt den Wert des Elements mit Index `index` (Type `native int`) in das null basierte eindimensionale Array `array` und platziert Sie am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2604">The `ldelem.u2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="3bd02-2605">Arrays sind Objekte und werden daher durch einen Wert vom Typ `O`dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2605">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="3bd02-2606">Der Rückgabewert für `ldelem.u2` ist `int16`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2606">The return value for `ldelem.u2` is `int16`.</span></span>  
  
 <span data-ttu-id="3bd02-2607">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht `native int`) erweitert werden, wenn Sie auf dem Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2607">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="3bd02-2608"><xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2608"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-2609"><xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2609"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="3bd02-2610"><xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` negativ oder größer als die gebundene `array`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2610"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="3bd02-2611">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldelem.u2` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2611">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u2` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2612">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2612">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2613">Lädt das Element mit dem Typ <see langword="unsigned int32" /> an einem angegebenen Arrayindex als <see langword="int32" /> an die oberste Position des Auswertungsstapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2613">Loads the element with type <see langword="unsigned int32" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2614">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2614">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2615">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2615">Format</span></span>|<span data-ttu-id="3bd02-2616">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2616">Assembly Format</span></span>|<span data-ttu-id="3bd02-2617">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2617">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2618">95</span><span class="sxs-lookup"><span data-stu-id="3bd02-2618">95</span></span>|<span data-ttu-id="3bd02-2619">ldelem.u4</span><span class="sxs-lookup"><span data-stu-id="3bd02-2619">ldelem.u4</span></span>|<span data-ttu-id="3bd02-2620">Lädt das Element mit dem Typ `unsigned int32` am Index als `int32`an den oberen Rand des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2620">Loads the element with type `unsigned int32` at index onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="3bd02-2621">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2621">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2622">Ein Objekt Verweis `array` auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2622">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-2623">Ein Indexwert `index` der auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2623">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-2624">`index` und `array` werden aus dem Stapel entfernt. der Wert, der an der Position `index` in `array` gespeichert wird, wird gesucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2624">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="3bd02-2625">Der Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2625">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2626">Die `ldelem.u4` Anweisung lädt den Wert des Elements mit Index `index` (Type `native int`) in das null basierte eindimensionale Array `array` und platziert Sie am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2626">The `ldelem.u4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="3bd02-2627">Arrays sind Objekte und werden daher durch einen Wert vom Typ `O`dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2627">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="3bd02-2628">Der Rückgabewert für `ldelem.u4` ist `int32`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2628">The return value for `ldelem.u4` is `int32`.</span></span>  
  
 <span data-ttu-id="3bd02-2629">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht `native int`) erweitert werden, wenn Sie auf dem Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2629">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="3bd02-2630"><xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2630"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-2631"><xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn Array keine Elemente des erforderlichen Typs enthält.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2631"><xref:System.ArrayTypeMismatchException> is thrown if array does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="3bd02-2632"><xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` negativ oder größer als die gebundene `array`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2632"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="3bd02-2633">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldelem.u4` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2633">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u4` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2634">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2634">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2635">Lädt die Adresse des Arrayelements an einem angegebenen Arrayindex als Typ <see langword="&amp;" /> (verwalteter Zeiger) an die oberste Position des Auswertungsstapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2635">Loads the address of the array element at a specified array index onto the top of the evaluation stack as type <see langword="&amp;" /> (managed pointer).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2636">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2636">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2637">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2637">Format</span></span>|<span data-ttu-id="3bd02-2638">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2638">Assembly Format</span></span>|<span data-ttu-id="3bd02-2639">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2639">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2640">8f < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-2640">8F < `T` ></span></span>|<span data-ttu-id="3bd02-2641">ldelta-`class`</span><span class="sxs-lookup"><span data-stu-id="3bd02-2641">ldelema `class`</span></span>|<span data-ttu-id="3bd02-2642">Lädt die Adresse des Array Elements am `index` als Typ `&` (verwalteter Zeiger) an die oberste Position des Auswertungs Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2642">Loads the address of the array element at `index` onto the top of the evaluation stack as type `&` (managed pointer).</span></span>|  
  
 <span data-ttu-id="3bd02-2643">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2643">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2644">Ein Objekt Verweis `array` auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2644">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-2645">Ein Indexwert `index` der auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2645">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-2646">`index` und `array` werden aus dem Stapel entfernt. die Adresse, die an der Position `index` in `array` gespeichert wird, wird gesucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2646">`index` and `array` are popped from the stack; the address stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="3bd02-2647">Die Adresse wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2647">The address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2648">Der `ldelema` wird verwendet, um die Adresse eines Objekts an einem bestimmten Index in einem Array von Objekten (vom Typ `class`) abzurufen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2648">The `ldelema` is used to retrieve the address of an object at a particular index in an array of objects (of type `class`).</span></span> <span data-ttu-id="3bd02-2649">Die `ldelema` Anweisung lädt die Adresse des Werts an der Index `index` (Type `native int`) im Null basierten eindimensionalen Array `array` und platziert Sie am Anfang des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2649">The `ldelema` instruction loads the address of the value at index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="3bd02-2650">Arrays sind Objekte und werden daher durch einen Wert vom Typ `O`dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2650">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="3bd02-2651">Der Wert muss vom Typ `class` sein, der mit der-Anweisung übermittelt wurde.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2651">The value must be of type `class` passed with the instruction.</span></span>  
  
 <span data-ttu-id="3bd02-2652">Der Rückgabewert für `ldelema` ist ein verwalteter Zeiger (Typ `&`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-2652">The return value for `ldelema` is a managed pointer (type `&`).</span></span>  
  
 <span data-ttu-id="3bd02-2653">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht `native int`) erweitert werden, wenn Sie auf dem Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2653">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="3bd02-2654"><xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2654"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-2655"><xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2655"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="3bd02-2656"><xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` negativ oder größer als die gebundene `array`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2656"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="3bd02-2657">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldelema` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2657">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelema` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2658">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2658">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2659">Sucht den Wert eines Felds in dem Objekt, für das sich derzeit ein Verweis auf dem Auswertungsstapel befindet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2659">Finds the value of a field in the object whose reference is currently on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2660">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2660">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2661">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2661">Format</span></span>|<span data-ttu-id="3bd02-2662">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2662">Assembly Format</span></span>|<span data-ttu-id="3bd02-2663">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2663">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2664">7B < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-2664">7B < `T` ></span></span>|<span data-ttu-id="3bd02-2665">ldfld-`field`</span><span class="sxs-lookup"><span data-stu-id="3bd02-2665">ldfld `field`</span></span>|<span data-ttu-id="3bd02-2666">Überträgt den Wert eines Felds in einem angegebenen-Objekt auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2666">Pushes the value of a field in a specified object onto the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-2667">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2667">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2668">Ein Objekt Verweis (oder Zeiger) wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2668">An object reference (or pointer) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-2669">Der Objekt Verweis (oder Zeiger) wird aus dem Stapel entfernt. der Wert des angegebenen Felds im-Objekt wurde gefunden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2669">The object reference (or pointer) is popped from the stack; the value of the specified field in the object is found.</span></span>  
  
3.  <span data-ttu-id="3bd02-2670">Der im Feld gespeicherte Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2670">The value stored in the field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2671">Die `ldfld` Anweisung überträgt den Wert eines Felds, das sich in einem-Objekt befindet, auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2671">The `ldfld` instruction pushes the value of a field located in an object onto the stack.</span></span> <span data-ttu-id="3bd02-2672">Das Objekt muss sich auf dem Stapel als Objekt Verweis (Type `O`), ein verwalteter Zeiger (Typ `&`), ein nicht verwalteter Zeiger (Typ `native int`), ein vorübergehender Zeiger (Type `*`) oder eine Instanz eines Werttyps befinden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2672">The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type.</span></span> <span data-ttu-id="3bd02-2673">Die Verwendung eines nicht verwalteten Zeigers ist in überprüfbarem Code nicht zulässig.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2673">The use of an unmanaged pointer is not permitted in verifiable code.</span></span> <span data-ttu-id="3bd02-2674">Das-Feld des Objekts wird durch ein Metadatentoken angegeben, das auf einen Feldmember verweisen muss.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2674">The object's field is specified by a metadata token that must refer to a field member.</span></span> <span data-ttu-id="3bd02-2675">Der Rückgabetyp ist der gleiche wie der, der dem Feld zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2675">The return type is the same as the one associated with the field.</span></span> <span data-ttu-id="3bd02-2676">Bei dem Feld kann es sich entweder um ein Instanzfeld (in diesem Fall darf es sich nicht um einen NULL-Verweis handeln) oder um ein statisches Feld handeln.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2676">The field may be either an instance field (in which case the object must not be a null reference) or a static field.</span></span>  
  
 <span data-ttu-id="3bd02-2677">Der `ldfld` Anweisung können entweder oder beide Präfixe <xref:System.Reflection.Emit.OpCodes.Unaligned> und <xref:System.Reflection.Emit.OpCodes.Volatile> vorangestellt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2677">The `ldfld` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes.</span></span>  
  
 <span data-ttu-id="3bd02-2678"><xref:System.NullReferenceException> wird ausgelöst, wenn das Objekt NULL ist und das Feld nicht statisch ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2678"><xref:System.NullReferenceException> is thrown if the object is null and the field is not static.</span></span>  
  
 <span data-ttu-id="3bd02-2679"><xref:System.MissingFieldException> wird ausgelöst, wenn das angegebene Feld in den Metadaten nicht gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2679"><xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata.</span></span> <span data-ttu-id="3bd02-2680">Dies wird in der Regel geprüft, wenn MSIL-Anweisungen (Microsoft Intermediate Language) in systemeigenen Code konvertiert werden, nicht zur Laufzeit.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2680">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="3bd02-2681">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldfld` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2681">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldfld` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2682">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2682">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2683">Sucht die Adresse eines Felds in dem Objekt, für das sich derzeit ein Verweis auf dem Auswertungsstapel befindet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2683">Finds the address of a field in the object whose reference is currently on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2684">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2684">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2685">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2685">Format</span></span>|<span data-ttu-id="3bd02-2686">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2686">Assembly Format</span></span>|<span data-ttu-id="3bd02-2687">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2687">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2688">7C-< `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-2688">7C < `T` ></span></span>|<span data-ttu-id="3bd02-2689">ldflda-`field`</span><span class="sxs-lookup"><span data-stu-id="3bd02-2689">ldflda `field`</span></span>|<span data-ttu-id="3bd02-2690">Überträgt die Adresse `field` in einem angegebenen-Objekt auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2690">Pushes the address of `field` in a specified object onto the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-2691">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2691">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2692">Ein Objekt Verweis (oder Zeiger) wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2692">An object reference (or pointer) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-2693">Der Objekt Verweis (oder Zeiger) wird aus dem Stapel entfernt. die Adresse des angegebenen Felds im-Objekt wurde gefunden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2693">The object reference (or pointer) is popped from the stack; the address of the specified field in the object is found.</span></span>  
  
3.  <span data-ttu-id="3bd02-2694">Die Adresse des angegebenen Felds wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2694">The address of the specified field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2695">Die `ldflda` Anweisung überträgt die Adresse eines Felds, das sich in einem-Objekt befindet, auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2695">The `ldflda` instruction pushes the address of a field located in an object onto the stack.</span></span> <span data-ttu-id="3bd02-2696">Das Objekt muss sich auf dem Stapel als Objekt Verweis (Type `O`), ein verwalteter Zeiger (Typ `&`), ein nicht verwalteter Zeiger (Typ `native int`), ein vorübergehender Zeiger (Type `*`) oder eine Instanz eines Werttyps befinden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2696">The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type.</span></span> <span data-ttu-id="3bd02-2697">Die Verwendung eines nicht verwalteten Zeigers ist in überprüfbarem Code nicht zulässig.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2697">The use of an unmanaged pointer is not permitted in verifiable code.</span></span> <span data-ttu-id="3bd02-2698">Das-Feld des Objekts wird durch ein Metadatentoken angegeben, das auf einen Feldmember verweisen muss.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2698">The object's field is specified by a metadata token that must refer to a field member.</span></span>  
  
 <span data-ttu-id="3bd02-2699">Der von `ldflda` zurückgegebene Wert ist ein verwalteter Zeiger (Typ `&`), es sei denn, das Objekt wird als nicht verwalteter Zeiger auf den Stapel verschoben. in diesem Fall ist die Rückgabeadresse auch ein nicht verwalteter Zeiger (Typ `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-2699">The value returned by `ldflda` is a managed pointer (type `&`) unless the object is pushed onto the stack as an unmanaged pointer, in which case the return address is also an unmanaged pointer (type `native int`).</span></span>  
  
 <span data-ttu-id="3bd02-2700">Der `ldflda` Anweisung können entweder oder beide Präfixe <xref:System.Reflection.Emit.OpCodes.Unaligned> und <xref:System.Reflection.Emit.OpCodes.Volatile> vorangestellt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2700">The `ldflda` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes.</span></span>  
  
 <span data-ttu-id="3bd02-2701"><xref:System.InvalidOperationException> wird ausgelöst, wenn sich das Objekt nicht innerhalb der Anwendungsdomäne befindet, von der aus auf das Objekt zugegriffen wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2701"><xref:System.InvalidOperationException> is thrown if the object is not within the application domain from which it is being accessed.</span></span> <span data-ttu-id="3bd02-2702">Die Adresse eines Felds, das nicht in der Zugriffs Anwendungsdomäne ist, kann nicht geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2702">The address of a field that is not inside the accessing application domain cannot be loaded.</span></span>  
  
 <span data-ttu-id="3bd02-2703"><xref:System.NullReferenceException> wird ausgelöst, wenn das Objekt NULL ist und das Feld nicht statisch ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2703"><xref:System.NullReferenceException> is thrown if the object is null and the field is not static.</span></span>  
  
 <span data-ttu-id="3bd02-2704"><xref:System.MissingFieldException> wird ausgelöst, wenn das angegebene Feld in den Metadaten nicht gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2704"><xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata.</span></span> <span data-ttu-id="3bd02-2705">Dies wird in der Regel geprüft, wenn MSIL-Anweisungen (Microsoft Intermediate Language) in systemeigenen Code konvertiert werden, nicht zur Laufzeit.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2705">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="3bd02-2706">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldflda` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2706">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldflda` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2707">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2707">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2708">Legt einen nicht verwalteten Zeiger (Typ <see langword="native int" />) auf dem Auswertungsstapel ab. Dieser Zeiger zeigt auf den systemeigenen Code, der eine bestimmte Methode implementiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2708">Pushes an unmanaged pointer (type <see langword="native int" />) to the native code implementing a specific method onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2709">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2709">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2710">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2710">Format</span></span>|<span data-ttu-id="3bd02-2711">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2711">Assembly Format</span></span>|<span data-ttu-id="3bd02-2712">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2712">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2713">FE 06 < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-2713">FE 06 < `T` ></span></span>|<span data-ttu-id="3bd02-2714">ldftn-`method`</span><span class="sxs-lookup"><span data-stu-id="3bd02-2714">ldftn `method`</span></span>|<span data-ttu-id="3bd02-2715">Überträgt einen Zeiger auf eine Methode, auf die durch `method` auf dem Stapel verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2715">Pushes a pointer to a method referenced by `method` on the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-2716">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2716">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2717">Der nicht verwaltete Zeiger auf eine bestimmte Methode wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2717">The unmanaged pointer to a specific method is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2718">Die spezifische Methode (`method`) kann mithilfe der <xref:System.Reflection.Emit.OpCodes.Calli> Anweisung aufgerufen werden, wenn Sie auf eine verwaltete Methode (oder einen Stub, der von verwaltetem zu nicht verwaltetem Code übergeht) verweist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2718">The specific method (`method`) can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</span></span>  
  
 <span data-ttu-id="3bd02-2719">Der zurückgegebene Wert zeigt mithilfe der CLR-Aufruf Konvention auf nativen Code.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2719">The value returned points to native code using the CLR calling convention.</span></span> <span data-ttu-id="3bd02-2720">Dieser Methoden Zeiger sollte nicht als Rückruf Routine an den nicht verwalteten nativen Code übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2720">This method pointer should not be passed to unmanaged native code as a callback routine.</span></span>  
  
 <span data-ttu-id="3bd02-2721">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldftn` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2721">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldftn` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2722">ILGenerator. ausgeben (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2722">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2723">Lädt einen Wert vom Typ <see langword="native int" /> indirekt als <see langword="native int" /> in den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2723">Loads a value of type <see langword="native int" /> as a <see langword="native int" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2724">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2724">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2725">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2725">Format</span></span>|<span data-ttu-id="3bd02-2726">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2726">Assembly Format</span></span>|<span data-ttu-id="3bd02-2727">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2727">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2728">4D</span><span class="sxs-lookup"><span data-stu-id="3bd02-2728">4D</span></span>|<span data-ttu-id="3bd02-2729">ldind. i</span><span class="sxs-lookup"><span data-stu-id="3bd02-2729">ldind.i</span></span>|<span data-ttu-id="3bd02-2730">Lädt den `native int` Wert an der Adresse `addr` als `native int`auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2730">Loads the `native int` value at address `addr` onto the stack as a `native int`.</span></span>|  
  
 <span data-ttu-id="3bd02-2731">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2731">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2732">Eine Adresse wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2732">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-2733">Die Adresse wird aus dem Stapel entfernt. der an der Adresse befindliche Wert wird abgerufen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2733">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="3bd02-2734">Der abgerufene Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2734">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2735">Die `ldind.i` Anweisung lädt indirekt einen `native int` Wert aus der angegebenen Adresse (vom Typ `native int`, `&`oder \*) als `native int`auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2735">The `ldind.i` instruction indirectly loads a `native int` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a `native int`.</span></span>  
  
 <span data-ttu-id="3bd02-2736">Alle `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende integrierte Wert Klasse angibt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2736">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="3bd02-2737">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht `native int`) erweitert werden, wenn Sie auf dem Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2737">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="3bd02-2738">Gleit Komma Werte werden in `F` Typ konvertiert, wenn Sie auf den Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2738">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="3bd02-2739">Die ordnungsgemäße Formatierung von Microsoft Intermediate Language (MSIL) stellt sicher, dass die `ldind` Anweisungen in Übereinstimmung mit dem Zeigertyp verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2739">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="3bd02-2740">Die Adresse, die anfänglich auf den Stapel verschoben wird, muss an der natürlichen Größe von Objekten auf dem Computer ausgerichtet sein, oder es kann ein <xref:System.NullReferenceException> auftreten (siehe die <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung für vorbeugende Measures).</span><span class="sxs-lookup"><span data-stu-id="3bd02-2740">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="3bd02-2741">Die Ergebnisse aller MSIL-Anweisungen, die Adressen zurückgeben (z. b. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>), werden sicher ausgerichtet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2741">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="3bd02-2742">Für Datentypen, die größer als 1 Byte sind, ist die Byte-Reihenfolge von der Ziel-CPU abhängig.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2742">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="3bd02-2743">Code, der von Byte Reihenfolge abhängt, kann möglicherweise nicht auf allen Plattformen ausgeführt werden</span><span class="sxs-lookup"><span data-stu-id="3bd02-2743">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="3bd02-2744"><xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2744"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="3bd02-2745">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldind.i` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2745">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2746">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2746">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2747">Lädt einen Wert vom Typ <see langword="int8" /> indirekt als <see langword="int32" /> in den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2747">Loads a value of type <see langword="int8" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2748">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2748">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2749">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2749">Format</span></span>|<span data-ttu-id="3bd02-2750">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2750">Assembly Format</span></span>|<span data-ttu-id="3bd02-2751">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2751">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2752">46</span><span class="sxs-lookup"><span data-stu-id="3bd02-2752">46</span></span>|<span data-ttu-id="3bd02-2753">ldind. I1</span><span class="sxs-lookup"><span data-stu-id="3bd02-2753">ldind.i1</span></span>|<span data-ttu-id="3bd02-2754">Lädt den `int8` Wert an der Adresse `addr` als `int32`auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2754">Loads the `int8` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="3bd02-2755">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2755">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2756">Eine Adresse wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2756">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-2757">Die Adresse wird aus dem Stapel entfernt. der an der Adresse befindliche Wert wird abgerufen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2757">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="3bd02-2758">Der abgerufene Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2758">The fetched value is pushed onto the stack.</span></span> 
  
 <span data-ttu-id="3bd02-2759">Die `ldind.i1` Anweisung lädt indirekt einen `int8` Wert aus der angegebenen Adresse (vom Typ `native int`, `&`oder \*) als `int32`auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2759">The `ldind.i1` instruction indirectly loads an `int8` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="3bd02-2760">Alle `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende integrierte Wert Klasse angibt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2760">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="3bd02-2761">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht `native int`) erweitert werden, wenn Sie auf dem Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2761">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="3bd02-2762">Gleit Komma Werte werden in `F` Typ konvertiert, wenn Sie auf den Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2762">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="3bd02-2763">Die ordnungsgemäße Formatierung von Microsoft Intermediate Language (MSIL) stellt sicher, dass die `ldind` Anweisungen in Übereinstimmung mit dem Zeigertyp verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2763">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="3bd02-2764">Die Adresse, die anfänglich auf den Stapel verschoben wird, muss an der natürlichen Größe von Objekten auf dem Computer ausgerichtet sein, oder es kann ein <xref:System.NullReferenceException> auftreten (siehe die <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung für vorbeugende Measures).</span><span class="sxs-lookup"><span data-stu-id="3bd02-2764">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="3bd02-2765">Die Ergebnisse aller MSIL-Anweisungen, die Adressen zurückgeben (z. b. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>), werden sicher ausgerichtet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2765">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="3bd02-2766">Für Datentypen, die größer als 1 Byte sind, ist die Byte-Reihenfolge von der Ziel-CPU abhängig.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2766">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="3bd02-2767">Code, der von Byte Reihenfolge abhängt, kann möglicherweise nicht auf allen Plattformen ausgeführt werden</span><span class="sxs-lookup"><span data-stu-id="3bd02-2767">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="3bd02-2768"><xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2768"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="3bd02-2769">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldind.i1` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2769">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i1` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2770">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2770">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2771">Lädt einen Wert vom Typ <see langword="int16" /> indirekt als <see langword="int32" /> in den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2771">Loads a value of type <see langword="int16" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2772">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2772">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2773">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2773">Format</span></span>|<span data-ttu-id="3bd02-2774">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2774">Assembly Format</span></span>|<span data-ttu-id="3bd02-2775">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2775">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2776">48</span><span class="sxs-lookup"><span data-stu-id="3bd02-2776">48</span></span>|<span data-ttu-id="3bd02-2777">ldind. I2</span><span class="sxs-lookup"><span data-stu-id="3bd02-2777">ldind.i2</span></span>|<span data-ttu-id="3bd02-2778">Lädt den `int16` Wert an der Adresse `addr` als `int32`auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2778">Loads the `int16` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="3bd02-2779">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2779">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2780">Eine Adresse wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2780">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-2781">Die Adresse wird aus dem Stapel entfernt. der an der Adresse befindliche Wert wird abgerufen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2781">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="3bd02-2782">Der abgerufene Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2782">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2783">Die `ldind.i2` Anweisung lädt indirekt einen `int16` Wert aus der angegebenen Adresse (vom Typ `native int`, `&`oder \*) als `int32`auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2783">The `ldind.i2` instruction indirectly loads an `int16` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="3bd02-2784">Alle `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende integrierte Wert Klasse angibt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2784">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="3bd02-2785">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht `native int`) erweitert werden, wenn Sie auf dem Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2785">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="3bd02-2786">Gleit Komma Werte werden in `F` Typ konvertiert, wenn Sie auf den Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2786">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="3bd02-2787">Die ordnungsgemäße Formatierung von Microsoft Intermediate Language (MSIL) stellt sicher, dass die `ldind` Anweisungen in Übereinstimmung mit dem Zeigertyp verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2787">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="3bd02-2788">Die Adresse, die anfänglich auf den Stapel verschoben wird, muss an der natürlichen Größe von Objekten auf dem Computer ausgerichtet sein, oder es kann ein <xref:System.NullReferenceException> auftreten (siehe die <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung für vorbeugende Measures).</span><span class="sxs-lookup"><span data-stu-id="3bd02-2788">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="3bd02-2789">Die Ergebnisse aller MSIL-Anweisungen, die Adressen zurückgeben (z. b. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>), werden sicher ausgerichtet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2789">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="3bd02-2790">Für Datentypen, die größer als 1 Byte sind, ist die Byte-Reihenfolge von der Ziel-CPU abhängig.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2790">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="3bd02-2791">Code, der von Byte Reihenfolge abhängt, kann möglicherweise nicht auf allen Plattformen ausgeführt werden</span><span class="sxs-lookup"><span data-stu-id="3bd02-2791">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="3bd02-2792"><xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2792"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="3bd02-2793">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldind.i2` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2793">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i2` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2794">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2794">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2795">Lädt einen Wert vom Typ <see langword="int32" /> indirekt als <see langword="int32" /> in den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2795">Loads a value of type <see langword="int32" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2796">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2796">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2797">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2797">Format</span></span>|<span data-ttu-id="3bd02-2798">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2798">Assembly Format</span></span>|<span data-ttu-id="3bd02-2799">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2799">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2800">4a</span><span class="sxs-lookup"><span data-stu-id="3bd02-2800">4A</span></span>|<span data-ttu-id="3bd02-2801">ldind. I4</span><span class="sxs-lookup"><span data-stu-id="3bd02-2801">ldind.i4</span></span>|<span data-ttu-id="3bd02-2802">Lädt den `int32` Wert an der Adresse `addr` als `int32`auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2802">Loads the `int32` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="3bd02-2803">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2803">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2804">Eine Adresse wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2804">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-2805">Die Adresse wird aus dem Stapel entfernt. der an der Adresse befindliche Wert wird abgerufen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2805">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="3bd02-2806">Der abgerufene Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2806">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2807">Die `ldind.i4` Anweisung lädt indirekt einen `int32` Wert aus der angegebenen Adresse (vom Typ `native int`, `&`oder \*) als `int32`auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2807">The `ldind.i4` instruction indirectly loads an `int32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="3bd02-2808">Alle `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende integrierte Wert Klasse angibt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2808">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="3bd02-2809">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht `native int`) erweitert werden, wenn Sie auf dem Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2809">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="3bd02-2810">Gleit Komma Werte werden in `F` Typ konvertiert, wenn Sie auf den Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2810">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="3bd02-2811">Die ordnungsgemäße Formatierung von Microsoft Intermediate Language (MSIL) stellt sicher, dass die `ldind` Anweisungen in Übereinstimmung mit dem Zeigertyp verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2811">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="3bd02-2812">Die Adresse, die anfänglich auf den Stapel verschoben wird, muss an der natürlichen Größe von Objekten auf dem Computer ausgerichtet sein, oder es kann ein <xref:System.NullReferenceException> auftreten (siehe die <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung für vorbeugende Measures).</span><span class="sxs-lookup"><span data-stu-id="3bd02-2812">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="3bd02-2813">Die Ergebnisse aller MSIL-Anweisungen, die Adressen zurückgeben (z. b. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>), werden sicher ausgerichtet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2813">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="3bd02-2814">Für Datentypen, die größer als 1 Byte sind, ist die Byte-Reihenfolge von der Ziel-CPU abhängig.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2814">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="3bd02-2815">Code, der von Byte Reihenfolge abhängt, kann möglicherweise nicht auf allen Plattformen ausgeführt werden</span><span class="sxs-lookup"><span data-stu-id="3bd02-2815">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="3bd02-2816"><xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2816"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="3bd02-2817">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldind.i4` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2817">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i4` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2818">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2818">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2819">Lädt einen Wert vom Typ <see langword="int64" /> indirekt als <see langword="int64" /> in den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2819">Loads a value of type <see langword="int64" /> as an <see langword="int64" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2820">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2820">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2821">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2821">Format</span></span>|<span data-ttu-id="3bd02-2822">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2822">Assembly Format</span></span>|<span data-ttu-id="3bd02-2823">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2823">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2824">4C</span><span class="sxs-lookup"><span data-stu-id="3bd02-2824">4C</span></span>|<span data-ttu-id="3bd02-2825">ldind. I8</span><span class="sxs-lookup"><span data-stu-id="3bd02-2825">ldind.i8</span></span>|<span data-ttu-id="3bd02-2826">Lädt den `int64` Wert an der Adresse `addr` als `int64`auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2826">Loads the `int64` value at address `addr` onto the stack as an `int64`.</span></span>|  
  
 <span data-ttu-id="3bd02-2827">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2827">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2828">Eine Adresse wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2828">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-2829">Die Adresse wird aus dem Stapel entfernt. der an der Adresse befindliche Wert wird abgerufen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2829">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="3bd02-2830">Der abgerufene Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2830">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2831">Die `ldind.i8` Anweisung lädt indirekt einen `int64` Wert aus der angegebenen Adresse (vom Typ `native int`, `&`oder \*) als `int64`auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2831">The `ldind.i8` instruction indirectly loads an `int64` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int64`.</span></span>  
  
 <span data-ttu-id="3bd02-2832">Alle `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende integrierte Wert Klasse angibt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2832">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="3bd02-2833">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht `native int`) erweitert werden, wenn Sie auf dem Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2833">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="3bd02-2834">Gleit Komma Werte werden in `F` Typ konvertiert, wenn Sie auf den Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2834">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="3bd02-2835">Die ordnungsgemäße Formatierung von Microsoft Intermediate Language (MSIL) stellt sicher, dass die `ldind` Anweisungen in Übereinstimmung mit dem Zeigertyp verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2835">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="3bd02-2836">Die Adresse, die anfänglich auf den Stapel verschoben wird, muss an der natürlichen Größe von Objekten auf dem Computer ausgerichtet sein, oder es kann ein <xref:System.NullReferenceException> auftreten (siehe die <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung für vorbeugende Measures).</span><span class="sxs-lookup"><span data-stu-id="3bd02-2836">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="3bd02-2837">Die Ergebnisse aller MSIL-Anweisungen, die Adressen zurückgeben (z. b. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>), werden sicher ausgerichtet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2837">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="3bd02-2838">Für Datentypen, die größer als 1 Byte sind, ist die Byte-Reihenfolge von der Ziel-CPU abhängig.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2838">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="3bd02-2839">Code, der von Byte Reihenfolge abhängt, kann möglicherweise nicht auf allen Plattformen ausgeführt werden</span><span class="sxs-lookup"><span data-stu-id="3bd02-2839">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="3bd02-2840"><xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2840"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="3bd02-2841">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldind.i8` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2841">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i8` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2842">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2842">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2843">Lädt einen Wert vom Typ <see langword="float32" /> indirekt als Typ <see langword="F" /> (Gleitkommawert) in den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2843">Loads a value of type <see langword="float32" /> as a type <see langword="F" /> (float) onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2844">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2844">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2845">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2845">Format</span></span>|<span data-ttu-id="3bd02-2846">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2846">Assembly Format</span></span>|<span data-ttu-id="3bd02-2847">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2847">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2848">4E</span><span class="sxs-lookup"><span data-stu-id="3bd02-2848">4E</span></span>|<span data-ttu-id="3bd02-2849">ldind. R4</span><span class="sxs-lookup"><span data-stu-id="3bd02-2849">ldind.r4</span></span>|<span data-ttu-id="3bd02-2850">Lädt den `float32` Wert an der Adresse `addr` als Typ `F`auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2850">Loads the `float32` value at address `addr` onto the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="3bd02-2851">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2851">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2852">Eine Adresse wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2852">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-2853">Die Adresse wird aus dem Stapel entfernt. der an der Adresse befindliche Wert wird abgerufen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2853">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="3bd02-2854">Der abgerufene Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2854">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2855">Die `ldind.r4` Anweisung lädt indirekt einen `float32` Wert aus der angegebenen Adresse (vom Typ `native int`, `&`oder \*) auf den Stapel als Typ `F`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2855">The `ldind.r4` instruction indirectly loads a `float32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a type `F`.</span></span>  
  
 <span data-ttu-id="3bd02-2856">Alle `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende integrierte Wert Klasse angibt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2856">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="3bd02-2857">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht `native int`) erweitert werden, wenn Sie auf dem Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2857">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="3bd02-2858">Gleit Komma Werte werden in `F` Typ konvertiert, wenn Sie auf den Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2858">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="3bd02-2859">Die ordnungsgemäße Formatierung von Microsoft Intermediate Language (MSIL) stellt sicher, dass die `ldind` Anweisungen in Übereinstimmung mit dem Zeigertyp verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2859">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="3bd02-2860">Die Adresse, die anfänglich auf den Stapel verschoben wird, muss an der natürlichen Größe von Objekten auf dem Computer ausgerichtet sein, oder es kann ein <xref:System.NullReferenceException> auftreten (siehe die <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung für vorbeugende Measures).</span><span class="sxs-lookup"><span data-stu-id="3bd02-2860">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="3bd02-2861">Die Ergebnisse aller MSIL-Anweisungen, die Adressen zurückgeben (z. b. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>), werden sicher ausgerichtet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2861">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="3bd02-2862">Für Datentypen, die größer als 1 Byte sind, ist die Byte-Reihenfolge von der Ziel-CPU abhängig.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2862">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="3bd02-2863">Code, der von Byte Reihenfolge abhängt, kann möglicherweise nicht auf allen Plattformen ausgeführt werden</span><span class="sxs-lookup"><span data-stu-id="3bd02-2863">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="3bd02-2864"><xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2864"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="3bd02-2865">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldind.r4` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2865">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r4` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2866">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2866">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2867">Lädt einen Wert vom Typ <see langword="float64" /> indirekt als Typ <see langword="F" /> (Gleitkommawert) in den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2867">Loads a value of type <see langword="float64" /> as a type <see langword="F" /> (float) onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2868">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2868">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2869">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2869">Format</span></span>|<span data-ttu-id="3bd02-2870">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2870">Assembly Format</span></span>|<span data-ttu-id="3bd02-2871">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2871">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2872">4f</span><span class="sxs-lookup"><span data-stu-id="3bd02-2872">4F</span></span>|<span data-ttu-id="3bd02-2873">ldind. R8</span><span class="sxs-lookup"><span data-stu-id="3bd02-2873">ldind.r8</span></span>|<span data-ttu-id="3bd02-2874">Lädt den `float64` Wert an der Adresse `addr` als Typ `F`auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2874">Loads the `float64` value at address `addr` onto the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="3bd02-2875">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2875">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2876">Eine Adresse wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2876">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-2877">Die Adresse wird aus dem Stapel entfernt. der an der Adresse befindliche Wert wird abgerufen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2877">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="3bd02-2878">Der abgerufene Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2878">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2879">Die `ldind.r8` Anweisung lädt indirekt einen `float64` Wert aus der angegebenen Adresse (vom Typ `native int`, `&`oder \*) als `float64`auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2879">The `ldind.r8` instruction indirectly loads a `float64` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a `float64`.</span></span>  
  
 <span data-ttu-id="3bd02-2880">Alle `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende integrierte Wert Klasse angibt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2880">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="3bd02-2881">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht `native int`) erweitert werden, wenn Sie auf dem Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2881">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="3bd02-2882">Gleit Komma Werte werden in `F` Typ konvertiert, wenn Sie auf den Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2882">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="3bd02-2883">Die ordnungsgemäße Formatierung von Microsoft Intermediate Language (MSIL) stellt sicher, dass die `ldind` Anweisungen in Übereinstimmung mit dem Zeigertyp verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2883">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="3bd02-2884">Die Adresse, die anfänglich auf den Stapel verschoben wird, muss an der natürlichen Größe von Objekten auf dem Computer ausgerichtet sein, oder es kann ein <xref:System.NullReferenceException> auftreten (siehe die <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung für vorbeugende Measures).</span><span class="sxs-lookup"><span data-stu-id="3bd02-2884">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="3bd02-2885">Die Ergebnisse aller MSIL-Anweisungen, die Adressen zurückgeben (z. b. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>), werden sicher ausgerichtet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2885">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="3bd02-2886">Für Datentypen, die größer als 1 Byte sind, ist die Byte-Reihenfolge von der Ziel-CPU abhängig.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2886">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="3bd02-2887">Code, der von Byte Reihenfolge abhängt, kann möglicherweise nicht auf allen Plattformen ausgeführt werden</span><span class="sxs-lookup"><span data-stu-id="3bd02-2887">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="3bd02-2888"><xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2888"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="3bd02-2889">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldind.r8` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2889">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r8` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2890">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2890">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2891">Lädt einen Objektverweis indirekt als Typ <see langword="O" /> (Objektverweis) in den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2891">Loads an object reference as a type <see langword="O" /> (object reference) onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2892">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2892">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2893">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2893">Format</span></span>|<span data-ttu-id="3bd02-2894">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2894">Assembly Format</span></span>|<span data-ttu-id="3bd02-2895">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2895">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2896">50</span><span class="sxs-lookup"><span data-stu-id="3bd02-2896">50</span></span>|<span data-ttu-id="3bd02-2897">ldind.ref</span><span class="sxs-lookup"><span data-stu-id="3bd02-2897">ldind.ref</span></span>|<span data-ttu-id="3bd02-2898">Lädt den Objekt Verweis an der Adresse `addr` auf den Stapel als Typ `O`</span><span class="sxs-lookup"><span data-stu-id="3bd02-2898">Loads the object reference at address `addr` onto the stack as a type `O`</span></span>|  
  
 <span data-ttu-id="3bd02-2899">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2899">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2900">Eine Adresse wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2900">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-2901">Die Adresse wird aus dem Stapel entfernt. der Objekt Verweis an der Adresse wird abgerufen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2901">The address is popped from the stack; the object reference located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="3bd02-2902">Der abgerufene Verweis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2902">The fetched reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2903">Die `ldind.ref` Anweisung lädt indirekt den Objekt Verweis auf die angegebene Adresse (vom Typ "`native int`", "`&`" oder "\*") auf den Stapel als Typ `O`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2903">The `ldind.ref` instruction indirectly loads the object reference the specified address (of type `native int`, `&`, or \*) onto the stack as type `O`.</span></span>  
  
 <span data-ttu-id="3bd02-2904">Alle `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende integrierte Wert Klasse angibt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2904">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="3bd02-2905">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht `native int`) erweitert werden, wenn Sie auf dem Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2905">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="3bd02-2906">Gleit Komma Werte werden in `F` Typ konvertiert, wenn Sie auf den Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2906">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="3bd02-2907">Die ordnungsgemäße Formatierung von Microsoft Intermediate Language (MSIL) stellt sicher, dass die `ldind` Anweisungen in Übereinstimmung mit dem Zeigertyp verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2907">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="3bd02-2908">Die Adresse, die anfänglich auf den Stapel verschoben wird, muss an der natürlichen Größe von Objekten auf dem Computer ausgerichtet sein, oder es kann ein <xref:System.NullReferenceException> auftreten (siehe die <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung für vorbeugende Measures).</span><span class="sxs-lookup"><span data-stu-id="3bd02-2908">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="3bd02-2909">Die Ergebnisse aller MSIL-Anweisungen, die Adressen zurückgeben (z. b. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>), werden sicher ausgerichtet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2909">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="3bd02-2910">Für Datentypen, die größer als 1 Byte sind, ist die Byte-Reihenfolge von der Ziel-CPU abhängig.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2910">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="3bd02-2911">Code, der von Byte Reihenfolge abhängt, kann möglicherweise nicht auf allen Plattformen ausgeführt werden</span><span class="sxs-lookup"><span data-stu-id="3bd02-2911">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="3bd02-2912"><xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2912"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="3bd02-2913">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldind.ref` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2913">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.ref` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2914">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2914">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2915">Lädt einen Wert vom Typ <see langword="unsigned int8" /> indirekt als <see langword="int32" /> in den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2915">Loads a value of type <see langword="unsigned int8" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2916">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2916">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2917">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2917">Format</span></span>|<span data-ttu-id="3bd02-2918">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2918">Assembly Format</span></span>|<span data-ttu-id="3bd02-2919">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2919">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2920">47</span><span class="sxs-lookup"><span data-stu-id="3bd02-2920">47</span></span>|<span data-ttu-id="3bd02-2921">ldind.u1</span><span class="sxs-lookup"><span data-stu-id="3bd02-2921">ldind.u1</span></span>|<span data-ttu-id="3bd02-2922">Lädt den `unsigned int8` Wert an der Adresse `addr` als `int32`auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2922">Loads the `unsigned int8` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="3bd02-2923">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2923">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2924">Eine Adresse wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2924">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-2925">Die Adresse wird aus dem Stapel entfernt. der an der Adresse befindliche Wert wird abgerufen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2925">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="3bd02-2926">Der abgerufene Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2926">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2927">Die `ldind.u1` Anweisung lädt indirekt einen `unsigned int8` Wert aus der angegebenen Adresse (vom Typ`native int`, `&`oder \*) als `int32`auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2927">The `ldind.u1` instruction indirectly loads an `unsigned int8` value from the specified address (of type`native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="3bd02-2928">Alle `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende integrierte Wert Klasse angibt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2928">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="3bd02-2929">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht `native int`) erweitert werden, wenn Sie auf dem Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2929">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="3bd02-2930">Gleit Komma Werte werden in `F` Typ konvertiert, wenn Sie auf den Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2930">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="3bd02-2931">Die ordnungsgemäße Formatierung von Microsoft Intermediate Language (MSIL) stellt sicher, dass die `ldind` Anweisungen in Übereinstimmung mit dem Zeigertyp verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2931">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="3bd02-2932">Die Adresse, die anfänglich auf den Stapel verschoben wird, muss an der natürlichen Größe von Objekten auf dem Computer ausgerichtet sein, oder es kann ein <xref:System.NullReferenceException> auftreten (siehe die <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung für vorbeugende Measures).</span><span class="sxs-lookup"><span data-stu-id="3bd02-2932">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="3bd02-2933">Die Ergebnisse aller MSIL-Anweisungen, die Adressen zurückgeben (z. b. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>), werden sicher ausgerichtet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2933">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="3bd02-2934">Für Datentypen, die größer als 1 Byte sind, ist die Byte-Reihenfolge von der Ziel-CPU abhängig.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2934">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="3bd02-2935">Code, der von Byte Reihenfolge abhängt, kann möglicherweise nicht auf allen Plattformen ausgeführt werden</span><span class="sxs-lookup"><span data-stu-id="3bd02-2935">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="3bd02-2936"><xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2936"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="3bd02-2937">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldind.u1` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2937">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u1` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2938">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2938">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2939">Lädt einen Wert vom Typ <see langword="unsigned int16" /> indirekt als <see langword="int32" /> in den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2939">Loads a value of type <see langword="unsigned int16" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2940">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2940">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2941">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2941">Format</span></span>|<span data-ttu-id="3bd02-2942">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2942">Assembly Format</span></span>|<span data-ttu-id="3bd02-2943">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2943">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2944">49</span><span class="sxs-lookup"><span data-stu-id="3bd02-2944">49</span></span>|<span data-ttu-id="3bd02-2945">ldind.u2</span><span class="sxs-lookup"><span data-stu-id="3bd02-2945">ldind.u2</span></span>|<span data-ttu-id="3bd02-2946">Lädt den `unsigned int16` Wert an der Adresse `addr` als `int32`auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2946">Loads the `unsigned int16` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="3bd02-2947">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2947">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2948">Eine Adresse wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2948">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-2949">Die Adresse wird aus dem Stapel entfernt. der an der Adresse befindliche Wert wird abgerufen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2949">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="3bd02-2950">Der abgerufene Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2950">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2951">Die `ldind.u2` Anweisung lädt indirekt einen `unsigned int16` Wert aus der angegebenen Adresse (vom Typ `native int`, `&`oder \*) als `int32`auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2951">The `ldind.u2` instruction indirectly loads an `unsigned int16` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="3bd02-2952">Alle `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende integrierte Wert Klasse angibt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2952">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="3bd02-2953">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht `native int`) erweitert werden, wenn Sie auf dem Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2953">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="3bd02-2954">Gleit Komma Werte werden in `F` Typ konvertiert, wenn Sie auf den Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2954">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="3bd02-2955">Die ordnungsgemäße Formatierung von Microsoft Intermediate Language (MSIL) stellt sicher, dass die `ldind` Anweisungen in Übereinstimmung mit dem Zeigertyp verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2955">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="3bd02-2956">Die Adresse, die anfänglich auf den Stapel verschoben wird, muss an der natürlichen Größe von Objekten auf dem Computer ausgerichtet sein, oder es kann ein <xref:System.NullReferenceException> auftreten (siehe die <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung für vorbeugende Measures).</span><span class="sxs-lookup"><span data-stu-id="3bd02-2956">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="3bd02-2957">Die Ergebnisse aller MSIL-Anweisungen, die Adressen zurückgeben (z. b. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>), werden sicher ausgerichtet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2957">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="3bd02-2958">Für Datentypen, die größer als 1 Byte sind, ist die Byte-Reihenfolge von der Ziel-CPU abhängig.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2958">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="3bd02-2959">Code, der von Byte Reihenfolge abhängt, kann möglicherweise nicht auf allen Plattformen ausgeführt werden</span><span class="sxs-lookup"><span data-stu-id="3bd02-2959">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="3bd02-2960"><xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2960"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="3bd02-2961">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldind.u2` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2961">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u2` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2962">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2962">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2963">Lädt einen Wert vom Typ <see langword="unsigned int32" /> indirekt als <see langword="int32" /> in den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2963">Loads a value of type <see langword="unsigned int32" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2964">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2964">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2965">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2965">Format</span></span>|<span data-ttu-id="3bd02-2966">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2966">Assembly Format</span></span>|<span data-ttu-id="3bd02-2967">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2967">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2968">4B</span><span class="sxs-lookup"><span data-stu-id="3bd02-2968">4B</span></span>|<span data-ttu-id="3bd02-2969">ldind. U4</span><span class="sxs-lookup"><span data-stu-id="3bd02-2969">ldind.u4</span></span>|<span data-ttu-id="3bd02-2970">Lädt den `unsigned int32` Wert an der Adresse `addr` als `int32`auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2970">Loads the `unsigned int32` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="3bd02-2971">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2971">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2972">Eine Adresse wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2972">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-2973">Die Adresse wird aus dem Stapel entfernt. der an der Adresse befindliche Wert wird abgerufen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2973">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="3bd02-2974">Der abgerufene Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2974">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2975">Die `ldind.u4` Anweisung lädt indirekt einen `unsigned int32` Wert aus der angegebenen Adresse (vom Typ `native int`, `&`oder \*) als `int32`auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2975">The `ldind.u4` instruction indirectly loads an `unsigned int32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="3bd02-2976">Alle `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende integrierte Wert Klasse angibt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2976">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="3bd02-2977">Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht `native int`) erweitert werden, wenn Sie auf dem Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2977">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="3bd02-2978">Gleit Komma Werte werden in `F` Typ konvertiert, wenn Sie auf den Auswertungs Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2978">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="3bd02-2979">Die ordnungsgemäße Formatierung von Microsoft Intermediate Language (MSIL) stellt sicher, dass die `ldind` Anweisungen in Übereinstimmung mit dem Zeigertyp verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2979">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="3bd02-2980">Die Adresse, die anfänglich auf den Stapel verschoben wird, muss an der natürlichen Größe von Objekten auf dem Computer ausgerichtet sein, oder es kann ein <xref:System.NullReferenceException> auftreten (siehe die <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung für vorbeugende Measures).</span><span class="sxs-lookup"><span data-stu-id="3bd02-2980">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="3bd02-2981">Die Ergebnisse aller MSIL-Anweisungen, die Adressen zurückgeben (z. b. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>), werden sicher ausgerichtet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2981">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="3bd02-2982">Für Datentypen, die größer als 1 Byte sind, ist die Byte-Reihenfolge von der Ziel-CPU abhängig.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2982">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="3bd02-2983">Code, der von Byte Reihenfolge abhängt, kann möglicherweise nicht auf allen Plattformen ausgeführt werden</span><span class="sxs-lookup"><span data-stu-id="3bd02-2983">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="3bd02-2984"><xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2984"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="3bd02-2985">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldind.u4` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2985">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u4` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-2986">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-2986">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-2987">Legt die Anzahl der Elemente eines nullbasierten, eindimensionalen Arrays auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2987">Pushes the number of elements of a zero-based, one-dimensional array onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-2988">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2988">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-2989">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-2989">Format</span></span>|<span data-ttu-id="3bd02-2990">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-2990">Assembly Format</span></span>|<span data-ttu-id="3bd02-2991">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-2991">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-2992">8E</span><span class="sxs-lookup"><span data-stu-id="3bd02-2992">8E</span></span>|<span data-ttu-id="3bd02-2993">Ldlen</span><span class="sxs-lookup"><span data-stu-id="3bd02-2993">ldlen</span></span>|<span data-ttu-id="3bd02-2994">Legt die Länge (vom Typ `natural unsigned int`) eines Arrays auf dem Stapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2994">Pushes the length (of type `natural unsigned int`) of an array on the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-2995">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-2995">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-2996">Ein Objekt Verweis auf ein Array wird auf dem Stapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2996">An object reference to an array is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-2997">Der Array Verweis wird aus dem Stapel entfernt, und die Länge wird berechnet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2997">The array reference is popped from the stack and the length is computed.</span></span>  
  
3.  <span data-ttu-id="3bd02-2998">Die Länge wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2998">The length is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-2999">Arrays sind Objekte und werden daher durch einen Wert vom Typ `O`dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-2999">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="3bd02-3000">Die Länge wird als `natural unsigned int`zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3000">The length is returned as a `natural unsigned int`.</span></span>  
  
 <span data-ttu-id="3bd02-3001"><xref:System.NullReferenceException> wird ausgelöst, wenn der Array Verweis ein NULL-Verweis ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3001"><xref:System.NullReferenceException> is thrown if the array reference is a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-3002">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldlen` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3002">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldlen` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3003">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3003">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3004">Lädt die lokale Variable an einem bestimmten Index in den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3004">Loads the local variable at a specific index onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3005">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3005">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3006">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3006">Format</span></span>|<span data-ttu-id="3bd02-3007">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3007">Assembly Format</span></span>|<span data-ttu-id="3bd02-3008">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3008">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3009">FE 0C < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-3009">FE 0C < `unsigned int16` ></span></span>|<span data-ttu-id="3bd02-3010">ldloc-`index`</span><span class="sxs-lookup"><span data-stu-id="3bd02-3010">ldloc `index`</span></span>|<span data-ttu-id="3bd02-3011">Lädt die lokale Variable bei Index `index` auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3011">Loads the local variable at index `index` onto stack.</span></span>|  
  
 <span data-ttu-id="3bd02-3012">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3012">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3013">Der lokale Variablen Wert am angegebenen Index wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3013">The local variable value at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3014">Die `ldloc` Anweisung überträgt den Inhalt der lokalen Variablen Nummer am bestandenen Index in den Auswertungs Stapel, in dem die lokalen Variablen auf 0 (null) nummeriert sind.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3014">The `ldloc` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</span></span> <span data-ttu-id="3bd02-3015">Lokale Variablen werden auf 0 initialisiert, bevor die-Methode nur dann eingegeben wird, wenn das Initialisieren-Flag für die-Methode den Wert true hat.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3015">Local variables are initialized to 0 before entering the method only if the initialize flag on the method is true.</span></span> <span data-ttu-id="3bd02-3016">Es sind 65.535 (2 ^ 16-1) lokale Variablen möglich (0-65534).</span><span class="sxs-lookup"><span data-stu-id="3bd02-3016">There are 65,535 (2^16-1) local variables possible (0-65,534).</span></span> <span data-ttu-id="3bd02-3017">Der Index 65.535 ist ungültig, da wahrscheinliche Implementierungen eine 2-Byte-Ganzzahl verwenden, um sowohl den Index eines lokalen als auch die Gesamtzahl der lokalen Variablen für eine bestimmte Methode zu verfolgen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3017">Index 65,535 is not valid since likely implementations will use a 2-byte integer to track both a local's index, along with the total number of locals for a given method.</span></span> <span data-ttu-id="3bd02-3018">Wenn ein Index von 65535 als gültig fest gegeben wurde, wäre eine breitere Ganzzahl erforderlich, um die Anzahl der lokalen Variablen in einer solchen Methode zu verfolgen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3018">If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</span></span>  
  
 <span data-ttu-id="3bd02-3019">Die Anweisungen `ldloc.0`, `ldloc.1`, `ldloc.2`und `ldloc.3` bieten eine effiziente Codierung für den Zugriff auf die ersten vier lokalen Variablen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3019">The `ldloc.0`, `ldloc.1`, `ldloc.2`, and `ldloc.3` instructions provide an efficient encoding for accessing the first four local variables.</span></span>  
  
 <span data-ttu-id="3bd02-3020">Der Typ des Werts ist mit dem Typ der lokalen Variablen identisch, der im Methoden Header angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3020">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="3bd02-3021">Weitere Informationen finden Sie unter Partition I. lokale Variablen, die kleiner als 4 Bytes sind, werden auf den Typ `int32` erweitert, wenn Sie auf dem Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3021">See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="3bd02-3022">Gleit Komma Werte werden auf Ihre systemeigene Größe (Type `F`) erweitert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3022">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="3bd02-3023">Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladungen können den `ldloc` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3023">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3024">ILGenerator. ausgeben (OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3024">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="3bd02-3025">ILGenerator. ausgeben (OpCode, Short)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3025">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3026">Lädt die lokale Variable am Index 0 in den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3026">Loads the local variable at index 0 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3027">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3027">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3028">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3028">Format</span></span>|<span data-ttu-id="3bd02-3029">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3029">Assembly Format</span></span>|<span data-ttu-id="3bd02-3030">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3030">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3031">06</span><span class="sxs-lookup"><span data-stu-id="3bd02-3031">06</span></span>|<span data-ttu-id="3bd02-3032">ldloc. 0</span><span class="sxs-lookup"><span data-stu-id="3bd02-3032">ldloc.0</span></span>|<span data-ttu-id="3bd02-3033">Lädt die lokale Variable am Index 0 in den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3033">Loads the local variable at index 0 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="3bd02-3034">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3034">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3035">Der lokale Variablen Wert am Index 0 wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3035">The local variable value at the index 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3036">`ldloc.0` ist eine besonders effiziente Codierung für <xref:System.Reflection.Emit.OpCodes.Ldloc>und ermöglicht den Zugriff auf die lokale Variable am Index 0.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3036">`ldloc.0` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 0.</span></span>  
  
 <span data-ttu-id="3bd02-3037">Der Typ des Werts ist mit dem Typ der lokalen Variablen identisch, der im Methoden Header angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3037">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="3bd02-3038">Lokale Variablen, die kleiner als 4 Bytes sind, werden auf den Typ erweitert, `int32` Sie auf den Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3038">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="3bd02-3039">Gleit Komma Werte werden auf Ihre systemeigene Größe (Type `F`) erweitert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3039">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="3bd02-3040">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldloc.0` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3040">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.0` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3041">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3041">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3042">Lädt die lokale Variable am Index 1 in den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3042">Loads the local variable at index 1 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3043">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3043">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3044">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3044">Format</span></span>|<span data-ttu-id="3bd02-3045">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3045">Assembly Format</span></span>|<span data-ttu-id="3bd02-3046">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3046">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3047">07</span><span class="sxs-lookup"><span data-stu-id="3bd02-3047">07</span></span>|<span data-ttu-id="3bd02-3048">ldloc. 1</span><span class="sxs-lookup"><span data-stu-id="3bd02-3048">ldloc.1</span></span>|<span data-ttu-id="3bd02-3049">Lädt die lokale Variable am Index 1 in den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3049">Loads the local variable at index 1 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="3bd02-3050">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3050">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3051">Der lokale Variablen Wert am Index 1 wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3051">The local variable value at the index 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3052">`ldloc.1` ist eine besonders effiziente Codierung für <xref:System.Reflection.Emit.OpCodes.Ldloc>und ermöglicht den Zugriff auf die lokale Variable am Index 1.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3052">`ldloc.1` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 1.</span></span>  
  
 <span data-ttu-id="3bd02-3053">Der Typ des Werts ist mit dem Typ der lokalen Variablen identisch, der im Methoden Header angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3053">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="3bd02-3054">Lokale Variablen, die kleiner als 4 Bytes sind, werden auf den Typ erweitert, `int32` Sie auf den Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3054">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="3bd02-3055">Gleit Komma Werte werden auf Ihre systemeigene Größe (Type `F`) erweitert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3055">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="3bd02-3056">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldloc.1` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3056">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.1` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3057">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3057">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3058">Lädt die lokale Variable am Index 2 in den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3058">Loads the local variable at index 2 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3059">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3059">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3060">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3060">Format</span></span>|<span data-ttu-id="3bd02-3061">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3061">Assembly Format</span></span>|<span data-ttu-id="3bd02-3062">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3062">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3063">08</span><span class="sxs-lookup"><span data-stu-id="3bd02-3063">08</span></span>|<span data-ttu-id="3bd02-3064">ldloc. 2</span><span class="sxs-lookup"><span data-stu-id="3bd02-3064">ldloc.2</span></span>|<span data-ttu-id="3bd02-3065">Lädt die lokale Variable am Index 2 in den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3065">Loads the local variable at index 2 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="3bd02-3066">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3066">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3067">Der lokale Variablen Wert am Index 2 wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3067">The local variable value at the index 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3068">`ldloc.2` ist eine besonders effiziente Codierung für <xref:System.Reflection.Emit.OpCodes.Ldloc>und ermöglicht den Zugriff auf die lokale Variable am Index 2.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3068">`ldloc.2` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 2.</span></span>  
  
 <span data-ttu-id="3bd02-3069">Der Typ des Werts ist mit dem Typ der lokalen Variablen identisch, der im Methoden Header angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3069">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="3bd02-3070">Lokale Variablen, die kleiner als 4 Bytes sind, werden auf den Typ erweitert, `int32` Sie auf den Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3070">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="3bd02-3071">Gleit Komma Werte werden auf Ihre systemeigene Größe (Type `F`) erweitert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3071">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="3bd02-3072">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldloc.2` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3072">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.2` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3073">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3073">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3074">Lädt die lokale Variable am Index 3 in den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3074">Loads the local variable at index 3 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3075">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3075">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3076">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3076">Format</span></span>|<span data-ttu-id="3bd02-3077">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3077">Assembly Format</span></span>|<span data-ttu-id="3bd02-3078">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3078">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3079">09</span><span class="sxs-lookup"><span data-stu-id="3bd02-3079">09</span></span>|<span data-ttu-id="3bd02-3080">ldloc. 3</span><span class="sxs-lookup"><span data-stu-id="3bd02-3080">ldloc.3</span></span>|<span data-ttu-id="3bd02-3081">Lädt die lokale Variable am Index 3 in den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3081">Loads the local variable at index 3 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="3bd02-3082">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3082">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3083">Der lokale Variablen Wert am Index 3 wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3083">The local variable value at the index 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3084">`ldloc.3` ist eine besonders effiziente Codierung für <xref:System.Reflection.Emit.OpCodes.Ldloc>und ermöglicht den Zugriff auf die lokale Variable am Index 3.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3084">`ldloc.3` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 3.</span></span>  
  
 <span data-ttu-id="3bd02-3085">Der Typ des Werts ist mit dem Typ der lokalen Variablen identisch, der im Methoden Header angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3085">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="3bd02-3086">Lokale Variablen, die kleiner als 4 Bytes sind, werden auf den Typ erweitert, `int32` Sie auf den Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3086">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="3bd02-3087">Gleit Komma Werte werden auf Ihre systemeigene Größe (Type `F`) erweitert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3087">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="3bd02-3088">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldloc.3` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3088">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.3` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3089">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3089">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3090">Lädt die lokale Variable an einem bestimmten Index in den Auswertungsstapel, Kurzform.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3090">Loads the local variable at a specific index onto the evaluation stack, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3091">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3091">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3092">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3092">Format</span></span>|<span data-ttu-id="3bd02-3093">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3093">Assembly Format</span></span>|<span data-ttu-id="3bd02-3094">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3094">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3095">11 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-3095">11 < `unsigned int8` ></span></span>|<span data-ttu-id="3bd02-3096">ldloc. s `index`</span><span class="sxs-lookup"><span data-stu-id="3bd02-3096">ldloc.s `index`</span></span>|<span data-ttu-id="3bd02-3097">Lädt die lokale Variable an der Index `index` auf den Stapel, Kurzform.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3097">Loads the local variable at index `index` onto stack, short form.</span></span>|  
  
 <span data-ttu-id="3bd02-3098">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3098">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3099">Der lokale Variablen Wert am angegebenen Index wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3099">The local variable value at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3100">Die `ldloc.s` Anweisung überträgt den Inhalt der lokalen Variablen Nummer am bestandenen Index in den Auswertungs Stapel, in dem die lokalen Variablen auf 0 (null) nummeriert sind.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3100">The `ldloc.s` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</span></span> <span data-ttu-id="3bd02-3101">Lokale Variablen werden vor dem Eingeben der Methode mit 0 initialisiert, wenn das Initialisieren-Flag für die Methode den Wert true hat.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3101">Local variables are initialized to 0 before entering the method if the initialize flag on the method is true.</span></span> <span data-ttu-id="3bd02-3102">In Kurzform sind 256 (2 ^ 8) lokale Variablen möglich (0-255), was eine effizientere Codierung als `ldloc`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3102">There are 256 (2^8) local variables possible (0-255) in the short form, which is a more efficient encoding than `ldloc`.</span></span>  
  
 <span data-ttu-id="3bd02-3103">Der Typ des Werts ist mit dem Typ der lokalen Variablen identisch, der im Methoden Header angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3103">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="3bd02-3104">Weitere Informationen finden Sie unter Partition I. lokale Variablen, die kleiner als 4 Bytes sind, werden auf den Typ `int32` erweitert, wenn Sie auf dem Stapel geladen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3104">See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="3bd02-3105">Gleit Komma Werte werden auf Ihre systemeigene Größe (Type `F`) erweitert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3105">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="3bd02-3106">Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladungen können den `ldloc.s` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3106">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc.s` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3107">ILGenerator. ausgeben (OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3107">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="3bd02-3108">ILGenerator.Emit(OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3108">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3109">Lädt die Adresse der lokalen Variablen am angegebenen Index in den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3109">Loads the address of the local variable at a specific index onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3110">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3110">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3111">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3111">Format</span></span>|<span data-ttu-id="3bd02-3112">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3112">Assembly Format</span></span>|<span data-ttu-id="3bd02-3113">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3113">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3114">FE od < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-3114">FE OD < `unsigned int16` ></span></span>|<span data-ttu-id="3bd02-3115">ldloca-`index`</span><span class="sxs-lookup"><span data-stu-id="3bd02-3115">ldloca `index`</span></span>|<span data-ttu-id="3bd02-3116">Lädt die Adresse der lokalen Variablen beim `index` in den Auswertungs Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3116">Loads the address of the local variable at `index` onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="3bd02-3117">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3117">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3118">Die Adresse, die in der lokalen Variablen am angegebenen Index gespeichert ist, wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3118">The address stored in the local variable at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3119">Die `ldloca` Anweisung überträgt die Adresse der lokalen Variablen Nummer am bestandenen Index auf den Stapel, wobei lokale Variablen auf 0 (null) und dann auf 0 (null).</span><span class="sxs-lookup"><span data-stu-id="3bd02-3119">The `ldloca` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="3bd02-3120">Der Wert, der auf dem Stapel abgelegt wurde, ist bereits ordnungsgemäß für die Verwendung mit Anweisungen wie <xref:System.Reflection.Emit.OpCodes.Ldind_I> und <xref:System.Reflection.Emit.OpCodes.Stind_I>ausgerichtet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3120">The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span></span> <span data-ttu-id="3bd02-3121">Das Ergebnis ist ein vorübergehender Zeiger (Type `*`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-3121">The result is a transient pointer (type `*`).</span></span>  
  
 <span data-ttu-id="3bd02-3122">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldloca` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3122">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3123">ILGenerator. ausgeben (OpCode, Short)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3123">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3124">Lädt die Adresse der lokalen Variablen am angegebenen Index in den Auswertungsstapel, Kurzform.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3124">Loads the address of the local variable at a specific index onto the evaluation stack, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3125">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3125">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3126">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3126">Format</span></span>|<span data-ttu-id="3bd02-3127">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3127">Assembly Format</span></span>|<span data-ttu-id="3bd02-3128">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3128">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3129">12 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-3129">12 < `unsigned int8` ></span></span>|<span data-ttu-id="3bd02-3130">`index` von ldloca. s</span><span class="sxs-lookup"><span data-stu-id="3bd02-3130">ldloca.s `index`</span></span>|<span data-ttu-id="3bd02-3131">Lädt die Adresse der lokalen Variablen `index` in den Auswertungs Stapel, Kurzform.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3131">Loads the address of the local variable at `index` onto the evaluation stack, short form.</span></span>|  
  
 <span data-ttu-id="3bd02-3132">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3132">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3133">Die Adresse, die in der lokalen Variablen am angegebenen Index gespeichert ist, wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3133">The address stored in the local variable at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3134">Die `ldloca.s` Anweisung überträgt die Adresse der lokalen Variablen Nummer am bestandenen Index auf den Stapel, wobei lokale Variablen auf 0 (null) und dann auf 0 (null).</span><span class="sxs-lookup"><span data-stu-id="3bd02-3134">The `ldloca.s` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="3bd02-3135">Der Wert, der auf dem Stapel abgelegt wurde, ist bereits ordnungsgemäß für die Verwendung mit Anweisungen wie <xref:System.Reflection.Emit.OpCodes.Ldind_I> und <xref:System.Reflection.Emit.OpCodes.Stind_I>ausgerichtet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3135">The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span></span> <span data-ttu-id="3bd02-3136">Das Ergebnis ist ein vorübergehender Zeiger (Type `*`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-3136">The result is a transient pointer (type `*`).</span></span>  
  
 <span data-ttu-id="3bd02-3137">Die `ldloca.s`-Anweisung bietet eine effiziente Codierung für die Verwendung mit den lokalen Variablen 0 bis 255.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3137">The `ldloca.s` instruction provides an efficient encoding for use with the local variables 0 through 255.</span></span>  
  
 <span data-ttu-id="3bd02-3138">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldloca.s` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3138">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca.s` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3139">ILGenerator.Emit(OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3139">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3140">Legt einen NULL-Verweis (Typ <see langword="O" />) auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3140">Pushes a null reference (type <see langword="O" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3141">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3141">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3142">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3142">Format</span></span>|<span data-ttu-id="3bd02-3143">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3143">Assembly Format</span></span>|<span data-ttu-id="3bd02-3144">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3144">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3145">14</span><span class="sxs-lookup"><span data-stu-id="3bd02-3145">14</span></span>|<span data-ttu-id="3bd02-3146">ldnull</span><span class="sxs-lookup"><span data-stu-id="3bd02-3146">ldnull</span></span>|<span data-ttu-id="3bd02-3147">einen NULL-Verweis auf den Stapel verschieben</span><span class="sxs-lookup"><span data-stu-id="3bd02-3147">push a null reference onto the stack</span></span>|  
  
 <span data-ttu-id="3bd02-3148">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3148">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3149">Ein NULL-Objekt Verweis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3149">A null object reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3150">`ldnull` legt einen NULL-Verweis (Typ `O`) auf dem Stapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3150">`ldnull` pushes a null reference (type `O`) on the stack.</span></span> <span data-ttu-id="3bd02-3151">Wird verwendet, um Speicherorte zu initialisieren, bevor Sie mit Daten aufgefüllt werden, oder wenn Sie als veraltet markiert werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3151">This is used to initialize locations before they are populated with data, or when they become deprecated.</span></span>  
  
 <span data-ttu-id="3bd02-3152">`ldnull` bietet einen NULL-Verweis, der Größen unabhängig ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3152">`ldnull` provides a null reference that is size-independent.</span></span>  
  
 <span data-ttu-id="3bd02-3153">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldnull` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3153">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldnull` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3154">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3154">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3155">Kopiert das Werttypobjekt, auf das eine Adresse zeigt, an die oberste Position des Auswertungsstapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3155">Copies the value type object pointed to by an address to the top of the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3156">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3156">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3157">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3157">Format</span></span>|<span data-ttu-id="3bd02-3158">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3158">Assembly Format</span></span>|<span data-ttu-id="3bd02-3159">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3159">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3160">71 < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-3160">71 < `T` ></span></span>|<span data-ttu-id="3bd02-3161">ldobj-`class`</span><span class="sxs-lookup"><span data-stu-id="3bd02-3161">ldobj `class`</span></span>|<span data-ttu-id="3bd02-3162">Kopieren Sie die Instanz des Werttyps `class` in den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3162">Copy instance of value type `class` to the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-3163">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3163">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3164">Die Adresse eines Werttyp Objekts wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3164">The address of a value type object is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3165">Die Adresse wird aus dem Stapel entfernt, und die Instanz an dieser bestimmten Adresse wird gesucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3165">The address is popped from the stack and the instance at that particular address is looked up.</span></span>  
  
3.  <span data-ttu-id="3bd02-3166">Der Wert des-Objekts, das an dieser Adresse gespeichert wird, wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3166">The value of the object stored at that address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3167">Die `ldobj`-Anweisung wird verwendet, um einen Werttyp als Parameter zu übergeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3167">The `ldobj` instruction is used to pass a value type as a parameter.</span></span>  
  
 <span data-ttu-id="3bd02-3168">Die `ldobj` Anweisung kopiert den Wert, auf den `addrOfValObj` (vom Typ `&`, `*`oder `native int`) zeigt, an den oberen Rand des Stapels.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3168">The `ldobj` instruction copies the value pointed to by `addrOfValObj` (of type `&`, `*`, or `native int`) to the top of the stack.</span></span> <span data-ttu-id="3bd02-3169">Die Anzahl der kopierten Bytes hängt von der Größe der-Klasse ab (wie durch den `class`-Parameter angegeben).</span><span class="sxs-lookup"><span data-stu-id="3bd02-3169">The number of bytes copied depends on the size of the class (as specified by the `class` parameter).</span></span> <span data-ttu-id="3bd02-3170">Der `class` Parameter ist ein Metadatentoken, das den Werttyp darstellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3170">The `class` parameter is a metadata token representing the value type.</span></span>  
  
 <span data-ttu-id="3bd02-3171">Der Vorgang der `ldobj` Anweisung kann durch eine unmittelbar vorangehende <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung geändert werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3171">The operation of the `ldobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="3bd02-3172"><xref:System.TypeLoadException> wird ausgelöst, wenn die Klasse nicht gefunden werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3172"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="3bd02-3173">Dies wird in der Regel erkannt, wenn die MSIL-Anweisung (Microsoft Intermediate Language) nicht zur Laufzeit in nativen Code konvertiert wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3173">This is typically detected when the Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="3bd02-3174">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldobj` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3174">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldobj` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3175">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3175">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3176">Legt den Wert eines statischen Felds auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3176">Pushes the value of a static field onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3177">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3177">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3178">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3178">Format</span></span>|<span data-ttu-id="3bd02-3179">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3179">Assembly Format</span></span>|<span data-ttu-id="3bd02-3180">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3180">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3181">7e < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-3181">7E < `T` ></span></span>|<span data-ttu-id="3bd02-3182">ldsf-`field`</span><span class="sxs-lookup"><span data-stu-id="3bd02-3182">ldsfld `field`</span></span>|<span data-ttu-id="3bd02-3183">Übersetzen Sie den Wert von `field` auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3183">Push the value of `field` on the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-3184">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3184">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3185">Der Wert des jeweiligen Felds wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3185">The value of the specific field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3186">Die `ldsfld` Anweisung legt den Wert einer statischen (für alle Instanzen einer Klasse freigegebenen) Felder auf dem Stapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3186">The `ldsfld` instruction pushes the value of a static (shared among all instances of a class) field on the stack.</span></span> <span data-ttu-id="3bd02-3187">Der Rückgabetyp ist der, der dem übergebenen Metadatentoken `field`zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3187">The return type is that associated with the passed metadata token `field`.</span></span>  
  
 <span data-ttu-id="3bd02-3188">Die `ldsfld` Anweisung kann ein <xref:System.Reflection.Emit.OpCodes.Volatile> Präfix aufweisen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3188">The `ldsfld` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix.</span></span>  
  
 <span data-ttu-id="3bd02-3189">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldsfld` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3189">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsfld` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3190">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3190">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3191">Legt die Adresse eines statischen Felds auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3191">Pushes the address of a static field onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3192">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3192">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3193">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3193">Format</span></span>|<span data-ttu-id="3bd02-3194">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3194">Assembly Format</span></span>|<span data-ttu-id="3bd02-3195">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3195">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3196">7F < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-3196">7F < `T` ></span></span>|<span data-ttu-id="3bd02-3197">ldsflda-`field`</span><span class="sxs-lookup"><span data-stu-id="3bd02-3197">ldsflda `field`</span></span>|<span data-ttu-id="3bd02-3198">Verschieben Sie die Adresse des `field` auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3198">Push the address of `field` on the stack</span></span>|  
  
 <span data-ttu-id="3bd02-3199">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3199">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3200">Die Adresse eines bestimmten Felds wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3200">The address of a specific field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3201">Die `ldsflda`-Anweisung legt die Adresse eines statischen (von allen Instanzen einer Klasse gemeinsam genutzten) Felds auf dem Stapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3201">The `ldsflda` instruction pushes the address of a static (shared among all instances of a class) field on the stack.</span></span> <span data-ttu-id="3bd02-3202">Die Adresse kann als vorübergehender Zeiger (Type `*`) dargestellt werden, wenn das Metadatentoken `field` auf einen Typ verweist, dessen Arbeitsspeicher verwaltet wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3202">The address may be represented as a transient pointer (type `*`) if the metadata token `field` refers to a type whose memory is managed.</span></span> <span data-ttu-id="3bd02-3203">Andernfalls entspricht Sie einem nicht verwalteten Zeiger (Type `native int`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-3203">Otherwise, it corresponds to an unmanaged pointer (type `native int`).</span></span> <span data-ttu-id="3bd02-3204">Beachten Sie, dass `field` ein statisches Global mit einer zugewiesenen relativen virtuellen Adresse (der Offset des Felds von der Basisadresse, bei der die enthaltende PE-Datei in den Arbeitsspeicher geladen wird) sein kann, in der der Arbeitsspeicher nicht verwaltet wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3204">Note that `field` may be a static global with an assigned relative virtual address (the offset of the field from the base address at which its containing PE file is loaded into memory) where the memory is unmanaged.</span></span>  
  
 <span data-ttu-id="3bd02-3205">Die `ldsflda` Anweisung kann ein <xref:System.Reflection.Emit.OpCodes.Volatile> Präfix aufweisen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3205">The `ldsflda` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix.</span></span>  
  
 <span data-ttu-id="3bd02-3206"><xref:System.MissingFieldException> wird ausgelöst, wenn das Feld in den Metadaten nicht gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3206"><xref:System.MissingFieldException> is thrown if field is not found in the metadata.</span></span> <span data-ttu-id="3bd02-3207">Dies wird in der Regel geprüft, wenn MSIL-Anweisungen (Microsoft Intermediate Language) in systemeigenen Code konvertiert werden, nicht zur Laufzeit.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3207">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at runtime.</span></span>  
  
 <span data-ttu-id="3bd02-3208">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldsflda` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3208">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsflda` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3209">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3209">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3210">Legt einen neuen Objektverweis auf ein in den Metadaten gespeichertes Zeichenfolgenliteral mittels Push ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3210">Pushes a new object reference to a string literal stored in the metadata.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3211">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3211">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3212">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3212">Format</span></span>|<span data-ttu-id="3bd02-3213">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3213">Assembly Format</span></span>|<span data-ttu-id="3bd02-3214">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3214">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3215">72 < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-3215">72 < `T` ></span></span>|<span data-ttu-id="3bd02-3216">ldstr-`mdToken`</span><span class="sxs-lookup"><span data-stu-id="3bd02-3216">ldstr `mdToken`</span></span>|<span data-ttu-id="3bd02-3217">Überträgt ein Zeichen folgen Objekt für die Metadaten-Zeichen folgen Token `mdToken`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3217">Pushes a string object for the metadata string token `mdToken`.</span></span>|  
  
 <span data-ttu-id="3bd02-3218">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3218">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3219">Ein Objekt Verweis auf eine Zeichenfolge wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3219">An object reference to a string is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3220">Die `ldstr` Anweisung überträgt einen Objekt Verweis (Type `O`) auf ein neues Zeichen folgen Objekt, das die in den Metadaten gespeicherte bestimmte Zeichenfolgenliterale darstellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3220">The `ldstr` instruction pushes an object reference (type `O`) to a new string object representing the specific string literal stored in the metadata.</span></span> <span data-ttu-id="3bd02-3221">Die `ldstr`-Anweisung ordnet die erforderliche Menge an Arbeitsspeicher zu und führt jede Formatkonvertierung aus, die zum Konvertieren des Zeichenfolgenliterals aus dem in der Datei verwendeten Formular in das zur Laufzeit erforderliche Zeichen folgen Format erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3221">The `ldstr` instruction allocates the requisite amount of memory and performs any format conversion required to convert the string literal from the form used in the file to the string format required at runtime.</span></span>  
  
 <span data-ttu-id="3bd02-3222">Der Common Language Infrastructure (CLI) garantiert, dass das Ergebnis von zwei `ldstr` Anweisungen, die auf zwei Metadatentoken mit derselben Zeichenfolge verweisen, genau dasselbe Zeichen folgen Objekt zurückgibt (ein Prozess, der als "Zeichen folgen Interning" bezeichnet wird).</span><span class="sxs-lookup"><span data-stu-id="3bd02-3222">The Common Language Infrastructure (CLI) guarantees that the result of two `ldstr` instructions referring to two metadata tokens that have the same sequence of characters return precisely the same string object (a process known as "string interning").</span></span>  
  
 <span data-ttu-id="3bd02-3223">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldstr` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3223">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldstr` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3224">ILGenerator.Emit(OpCode, string)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3224">ILGenerator.Emit(OpCode, string)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3225">Konvertiert ein Metadatentoken in seine Laufzeitdarstellung und legt es auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3225">Converts a metadata token to its runtime representation, pushing it onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3226">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3226">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3227">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3227">Format</span></span>|<span data-ttu-id="3bd02-3228">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3228">Assembly Format</span></span>|<span data-ttu-id="3bd02-3229">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3229">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3230">D0 < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-3230">D0 < `T` ></span></span>|<span data-ttu-id="3bd02-3231">ldtoken-`token`</span><span class="sxs-lookup"><span data-stu-id="3bd02-3231">ldtoken `token`</span></span>|<span data-ttu-id="3bd02-3232">Konvertiert ein Metadatentoken in seine Lauf Zeit Darstellung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3232">Converts a metadata token to its runtime representation.</span></span>|  
  
 <span data-ttu-id="3bd02-3233">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3233">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3234">Das übergebenen Token wird in eine `RuntimeHandle` konvertiert und auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3234">The passed token is converted to a `RuntimeHandle` and pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3235">Die `ldtoken` Anweisung schiebt eine `RuntimeHandle` für das angegebene Metadatentoken.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3235">The `ldtoken` instruction pushes a `RuntimeHandle` for the specified metadata token.</span></span> <span data-ttu-id="3bd02-3236">Eine `RuntimeHandle` kann ein `fieldref/fielddef`, ein `methodref/methoddef`oder ein `typeref/typedef`sein.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3236">A `RuntimeHandle` can be a `fieldref/fielddef`, a `methodref/methoddef`, or a `typeref/typedef`.</span></span>  
  
 <span data-ttu-id="3bd02-3237">Der Wert, der auf dem Stapel abgelegt wird, kann in Aufrufen von `Reflection` Methoden in der System Klassenbibliothek verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3237">The value pushed on the stack can be used in calls to `Reflection` methods in the system class library.</span></span>  
  
 <span data-ttu-id="3bd02-3238">Weitere Informationen zu Lauf Zeit Handles finden Sie in den folgenden Klassen: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>und <xref:System.RuntimeMethodHandle>.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3238">For information on runtime handles, see the following classes: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, and <xref:System.RuntimeMethodHandle>.</span></span>  
  
 <span data-ttu-id="3bd02-3239">Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladungen können den `ldtoken` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3239">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldtoken` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3240">ILGenerator. ausgeben (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3240">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="3bd02-3241">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3241">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
-   <span data-ttu-id="3bd02-3242">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3242">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3243">Legt einen nicht verwalteten Zeiger (Typ <see langword="native int" />) auf systemeigenen Code auf dem Auswertungsstapel ab. Dieser Code implementiert eine bestimmte virtuelle Methode, die einem angegebenen Objekt zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3243">Pushes an unmanaged pointer (type <see langword="native int" />) to the native code implementing a particular virtual method associated with a specified object onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3244">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3244">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3245">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3245">Format</span></span>|<span data-ttu-id="3bd02-3246">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3246">Assembly Format</span></span>|<span data-ttu-id="3bd02-3247">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3247">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3248">FE 07 < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-3248">FE 07 < `T` ></span></span>|<span data-ttu-id="3bd02-3249">ldvirtftn-`method`</span><span class="sxs-lookup"><span data-stu-id="3bd02-3249">ldvirtftn `method`</span></span>|<span data-ttu-id="3bd02-3250">Legt den Zeiger auf die virtuelle Methode eines Objekts `method` auf dem Stapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3250">Pushes the pointer to an object's virtual method `method` on the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-3251">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3251">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3252">Ein Objekt Verweis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3252">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3253">Der Objekt Verweis wird aus dem Stapel entfernt, und die Adresse des Einstiegs Punkts an die Methode (wie vom Metadatentoken angegeben `method`) wird gesucht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3253">The object reference is popped from the stack and the address of the entry point to the method (as specified by the metadata token `method`) is looked up.</span></span>  
  
3.  <span data-ttu-id="3bd02-3254">Der Zeiger auf `method` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3254">The pointer to `method` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3255">Der resultierende nicht verwaltete Zeiger, der von der `ldvirtftn` Anweisung auf den Stapel verschoben wird, kann mithilfe der <xref:System.Reflection.Emit.OpCodes.Calli> Anweisung aufgerufen werden, wenn er auf eine verwaltete Methode (oder einen Stub, der von verwaltetem zu nicht verwaltetem Code übergeht) verweist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3255">The resulting unmanaged pointer pushed onto the stack by the `ldvirtftn` instruction can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</span></span>  
  
 <span data-ttu-id="3bd02-3256">Der nicht verwaltete Zeiger verweist mithilfe der CLR-Aufruf Konvention auf nativen Code.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3256">The unmanaged pointer points to native code using the CLR calling convention.</span></span> <span data-ttu-id="3bd02-3257">Dieser Methoden Zeiger sollte nicht als Rückruf Routine an den nicht verwalteten nativen Code übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3257">This method pointer should not be passed to unmanaged native code as a callback routine.</span></span>  
  
 <span data-ttu-id="3bd02-3258">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ldvirtftn` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3258">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldvirtftn` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3259">ILGenerator. ausgeben (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3259">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3260">Beendet einen geschützten Codebereich, wobei die Steuerung bedingungslos an eine bestimmte Zielanweisung übertragen wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3260">Exits a protected region of code, unconditionally transferring control to a specific target instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3261">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3261">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3262">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3262">Format</span></span>|<span data-ttu-id="3bd02-3263">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3263">Assembly Format</span></span>|<span data-ttu-id="3bd02-3264">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3264">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3265">DD < `int32` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-3265">DD < `int32` ></span></span>|<span data-ttu-id="3bd02-3266">`target` verlassen</span><span class="sxs-lookup"><span data-stu-id="3bd02-3266">leave `target`</span></span>|<span data-ttu-id="3bd02-3267">Beendet einen geschützten Code Bereich.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3267">Exits a protected region of code.</span></span>|  
  
 <span data-ttu-id="3bd02-3268">Für diese Anweisung wurde kein Stapel Übergangs Verhalten angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3268">There is no stack transition behavior specified for this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-3269">Die `leave` Anweisung überträgt die Steuerung bedingungslos an die jeweilige Ziel Anweisung, die als 4-Byte-signierte Abweichung vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3269">The `leave` instruction unconditionally transfers control to the specific target instruction, represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-3270">Die `leave`-Anweisung ähnelt der `br` Anweisung, kann jedoch verwendet werden, um einen `try`-, `filter`-oder `catch`-Block zu beenden, wohingegen die normalen Verzweigungs Anweisungen nur in einem solchen Block verwendet werden können, um die Steuerung darin zu übertragen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3270">The `leave` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</span></span> <span data-ttu-id="3bd02-3271">Die `leave` Anweisung leert den Auswertungs Stapel und stellt sicher, dass die entsprechenden umgebenden `finally` Blöcke ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3271">The `leave` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.</span></span>  
  
 <span data-ttu-id="3bd02-3272">Es ist nicht möglich, eine `leave` Anweisung zu verwenden, um einen `finally` Block zu beenden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3272">You cannot use a `leave` instruction to exit a `finally` block.</span></span> <span data-ttu-id="3bd02-3273">Um die Codegenerierung für Ausnahmehandler zu vereinfachen, ist es innerhalb eines catch-Blocks gültig, eine `leave` Anweisung zu verwenden, um die Steuerung an eine beliebige Anweisung innerhalb des zugeordneten `try` Blocks zu übertragen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3273">To ease code generation for exception handlers it is valid from within a catch block to use a `leave` instruction to transfer control to any instruction within the associated `try` block.</span></span>  
  
 <span data-ttu-id="3bd02-3274">Wenn eine Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3274">If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="3bd02-3275">Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladungen können den `leave` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3275">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `leave` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3276">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3276">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3277">Beendet einen geschützten Codebereich, wobei die Steuerung bedingungslos an eine bestimmte Zielanweisung übertragen wird, Kurzform.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3277">Exits a protected region of code, unconditionally transferring control to a target instruction (short form).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3278">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3278">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3279">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3279">Format</span></span>|<span data-ttu-id="3bd02-3280">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3280">Assembly Format</span></span>|<span data-ttu-id="3bd02-3281">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3281">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3282">DE < `int8` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-3282">DE < `int8` ></span></span>|<span data-ttu-id="3bd02-3283">s-`target`</span><span class="sxs-lookup"><span data-stu-id="3bd02-3283">leave.s `target`</span></span>|<span data-ttu-id="3bd02-3284">Beendet einen geschützten Code Bereich, Kurzform.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3284">Exit a protected region of code, short form.</span></span>|  
  
 <span data-ttu-id="3bd02-3285">Für diese Anweisung wurde kein Stapel Übergangs Verhalten angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3285">There is no stack transition behavior specified for this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-3286">Die `leave.s` Anweisung überträgt die Steuerung bedingungslos an die übergebenen Ziel Anweisung, die als 1-Byte-signierte Abweichung vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3286">The `leave.s` instruction unconditionally transfers control to the passed target instruction, represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="3bd02-3287">Die `leave.s`-Anweisung ähnelt der `br` Anweisung, kann jedoch verwendet werden, um einen `try`-, `filter`-oder `catch`-Block zu beenden, wohingegen die normalen Verzweigungs Anweisungen nur in einem solchen Block verwendet werden können, um die Steuerung darin zu übertragen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3287">The `leave.s` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</span></span> <span data-ttu-id="3bd02-3288">Die `leave.s` Anweisung leert den Auswertungs Stapel und stellt sicher, dass die entsprechenden umgebenden `finally` Blöcke ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3288">The `leave.s` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.</span></span>  
  
 <span data-ttu-id="3bd02-3289">Es ist nicht möglich, eine `leave.s` Anweisung zu verwenden, um einen `finally` Block zu beenden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3289">You cannot use a `leave.s` instruction to exit a `finally` block.</span></span> <span data-ttu-id="3bd02-3290">Um die Codegenerierung für Ausnahmehandler zu vereinfachen, ist es innerhalb eines catch-Blocks gültig, eine `leave.s` Anweisung zu verwenden, um die Steuerung an eine beliebige Anweisung innerhalb des zugeordneten `try` Blocks zu übertragen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3290">To ease code generation for exception handlers it is valid from within a catch block to use a `leave.s` instruction to transfer control to any instruction within the associated `try` block.</span></span>  
  
 <span data-ttu-id="3bd02-3291">Wenn eine Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3291">If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="3bd02-3292">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `leave.s` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3292">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `leave.s` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3293">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3293">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3294">Belegt eine bestimmte Anzahl von Bytes aus dem lokalen dynamischen Speicherpool und legt die Adresse (einen flüchtigen Zeiger, Typ <see langword="*" />) des ersten reservierten Bytes auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3294">Allocates a certain number of bytes from the local dynamic memory pool and pushes the address (a transient pointer, type <see langword="*" />) of the first allocated byte onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3295">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3295">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3296">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3296">Format</span></span>|<span data-ttu-id="3bd02-3297">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3297">Assembly Format</span></span>|<span data-ttu-id="3bd02-3298">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3298">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3299">FE 0F</span><span class="sxs-lookup"><span data-stu-id="3bd02-3299">FE 0F</span></span>|<span data-ttu-id="3bd02-3300">loczuweisung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3300">localloc</span></span>|<span data-ttu-id="3bd02-3301">Zuweisen von Speicherplatz aus dem lokalen Heap</span><span class="sxs-lookup"><span data-stu-id="3bd02-3301">Allocate space from the local heap.</span></span>|  
  
 <span data-ttu-id="3bd02-3302">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3302">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3303">Die Anzahl der zugeordneten Bytes wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3303">The number of bytes to be allocated is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3304">Die Anzahl der Bytes, die aus dem Stapel entfernt werden. eine Menge an Arbeitsspeicher, die der Größe entspricht, wird vom lokalen Heap zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3304">The number of bytes is popped from the stack; an amount of memory corresponding to the size is allocated from the local heap.</span></span>  
  
3.  <span data-ttu-id="3bd02-3305">Ein Zeiger auf das erste Byte des zugeordneten Speichers wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3305">A pointer to the first byte of the allocated memory is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3306">Die `localloc`-Anweisung ordnet `size` (Type `natural unsigned int`) Bytes aus dem lokalen dynamischen Speicherpool zu und gibt die Adresse (einen vorübergehenden Zeiger, eine Typ`*`) des ersten zugeordneten Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3306">The `localloc` instruction allocates `size` (type `natural unsigned int`) bytes from the local dynamic memory pool and returns the address (a transient pointer, type `*`) of the first allocated byte.</span></span> <span data-ttu-id="3bd02-3307">Der zurückgegebene Speicherblock wird nur dann auf 0 initialisiert, wenn das Initialisieren-Flag für die Methode `true`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3307">The block of memory returned is initialized to 0 only if the initialize flag on the method is `true`.</span></span> <span data-ttu-id="3bd02-3308">Wenn die aktuelle Methode eine <xref:System.Reflection.Emit.OpCodes.Ret>ausführt, wird der lokale Speicherpool für die Wiederverwendung verfügbar gemacht.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3308">When the current method executes a <xref:System.Reflection.Emit.OpCodes.Ret>, the local memory pool is made available for reuse.</span></span>  
  
 <span data-ttu-id="3bd02-3309">Die resultierende Adresse wird so ausgerichtet, dass ein beliebiger primitiver Datentyp mithilfe der `stind` Anweisungen (z. b. <xref:System.Reflection.Emit.OpCodes.Stind_I4>) gespeichert und mithilfe der `ldind` Anweisungen (z. b. <xref:System.Reflection.Emit.OpCodes.Ldind_I4>) geladen werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3309">The resulting address is aligned so that any primitive data type can be stored there using the `stind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Stind_I4>) and loaded using the `ldind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).</span></span>  
  
 <span data-ttu-id="3bd02-3310">Die `localloc` Anweisung kann nicht in einem `filter`-, `catch`-, `finally`-oder `fault`-Block auftreten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3310">The `localloc` instruction cannot occur within a `filter`, `catch`, `finally`, or `fault` block.</span></span>  
  
 <span data-ttu-id="3bd02-3311"><xref:System.StackOverflowException> wird ausgelöst, wenn nicht genügend Arbeitsspeicher vorhanden ist, um die Anforderung zu bedienen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3311"><xref:System.StackOverflowException> is thrown if there is insufficient memory to service the request.</span></span>  
  
 <span data-ttu-id="3bd02-3312">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `localloc` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3312">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `localloc` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3313">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3313">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3314">Legt einen typisierten Verweis auf eine Instanz eines bestimmten Typs auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3314">Pushes a typed reference to an instance of a specific type onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3315">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3315">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3316">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3316">Format</span></span>|<span data-ttu-id="3bd02-3317">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3317">Assembly Format</span></span>|<span data-ttu-id="3bd02-3318">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3318">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3319">C6 < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-3319">C6 < `T` ></span></span>|<span data-ttu-id="3bd02-3320">mkref-`class`</span><span class="sxs-lookup"><span data-stu-id="3bd02-3320">mkrefany `class`</span></span>|<span data-ttu-id="3bd02-3321">Legt einen typisierten Verweis vom Typ `class` auf dem Stapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3321">Pushes a typed reference of type `class` onto the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-3322">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3322">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3323">Ein Zeiger auf ein Datenelement wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3323">A pointer to piece of data is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3324">Der Zeiger wird per Pop ausgeblendet und in einen typisierten Verweis vom Typ "`class`" konvertiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3324">The pointer is popped and converted to a typed reference of type `class`.</span></span>  
  
3.  <span data-ttu-id="3bd02-3325">Der typisierte Verweis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3325">The typed reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3326">Die `mkrefany`-Anweisung unterstützt das übergeben dynamisch typisierter Verweise.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3326">The `mkrefany` instruction supports the passing of dynamically typed references.</span></span> <span data-ttu-id="3bd02-3327">Der Zeiger muss den Typ "`&`", "`*`" oder "`native int`" aufweisen und die gültige Adresse eines Datentyps enthalten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3327">The pointer must be of type `&`, `*`, or `native int`, and hold the valid address of a piece of data.</span></span> <span data-ttu-id="3bd02-3328">`Class` ist das Klassen Token, das den Typ der Daten beschreibt, auf die der Zeiger verweist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3328">`Class` is the class token describing the type of the data referenced by the pointer.</span></span> <span data-ttu-id="3bd02-3329">`Mkrefany` legt einen typisierten Verweis auf den Stapel ab, der einen nicht transparenten Deskriptor des Zeigers und den Typ `class`bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3329">`Mkrefany` pushes a typed reference on the stack, providing an opaque descriptor of the pointer and the type `class`.</span></span>  
  
 <span data-ttu-id="3bd02-3330">Der einzige gültige Vorgang, der auf einem typisierten Verweis zulässig ist, besteht darin, ihn an eine Methode zu übergeben, die einen typisierten Verweis als Parameter erfordert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3330">The only valid operation permitted upon a typed reference is to pass it to a method that requires a typed reference as a parameter.</span></span> <span data-ttu-id="3bd02-3331">Der aufgerufene kann dann die Anweisungen <xref:System.Reflection.Emit.OpCodes.Refanytype> und <xref:System.Reflection.Emit.OpCodes.Refanyval> verwenden, um den Typ (Klasse) bzw. die Adresse abzurufen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3331">The callee can then use the <xref:System.Reflection.Emit.OpCodes.Refanytype> and <xref:System.Reflection.Emit.OpCodes.Refanyval> instructions to retrieve the type (class) and the address respectively.</span></span>  
  
 <span data-ttu-id="3bd02-3332"><xref:System.TypeLoadException> wird ausgelöst, wenn `class` nicht gefunden werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3332"><xref:System.TypeLoadException> is thrown if `class` cannot be found.</span></span> <span data-ttu-id="3bd02-3333">Dies wird in der Regel erkannt, wenn MSIL-Anweisungen (Microsoft Intermediate Language) in nativen Code anstatt zur Laufzeit konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3333">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="3bd02-3334">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `mkrefany` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3334">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mkrefany` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3335">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3335">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3336">Multipliziert zwei Werte und legt das Ergebnis auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3336">Multiplies two values and pushes the result on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3337">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3337">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3338">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3338">Format</span></span>|<span data-ttu-id="3bd02-3339">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3339">Assembly Format</span></span>|<span data-ttu-id="3bd02-3340">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3340">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3341">5a</span><span class="sxs-lookup"><span data-stu-id="3bd02-3341">5A</span></span>|<span data-ttu-id="3bd02-3342">Mul</span><span class="sxs-lookup"><span data-stu-id="3bd02-3342">mul</span></span>|<span data-ttu-id="3bd02-3343">Multipliziert zwei Werte im Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3343">Multiplies two values on the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-3344">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3344">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3345">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3345">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3346">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3346">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-3347">`value2` und `value1` werden aus dem Stapel entfernt. `value1` wird mit `value2`multipliziert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3347">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`.</span></span>  
  
4.  <span data-ttu-id="3bd02-3348">Das Ergebnis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3348">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3349">Die `mul`-Anweisung multipliziert `value1` `value2` und legt das Ergebnis auf dem Stapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3349">The `mul` instruction multiplies `value1` by `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="3bd02-3350">Ganzzahlige Vorgänge kürzen die oberen Bits bei einem Überlauf automatisch.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3350">Integer operations silently truncate the upper bits on overflow.</span></span>  
  
 <span data-ttu-id="3bd02-3351">Unter <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> finden Sie einen ganzzahligen spezifischen Multiplikations Vorgang mit Überlauf Behandlung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3351">See <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> for an integer-specific multiply operation with overflow handling.</span></span>  
  
 <span data-ttu-id="3bd02-3352">Für Gleit Komma Typen lautet der Wert 0 \* unendlich = Nan.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3352">For floating-point types, 0 \* infinity = NaN.</span></span>  
  
 <span data-ttu-id="3bd02-3353">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `mul` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3353">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3354">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3354">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3355">Multipliziert zwei Ganzzahlwerte, führt eine Überlaufprüfung durch und legt das Ergebnis auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3355">Multiplies two integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3356">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3356">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3357">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3357">Format</span></span>|<span data-ttu-id="3bd02-3358">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3358">Assembly Format</span></span>|<span data-ttu-id="3bd02-3359">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3359">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3360">D8</span><span class="sxs-lookup"><span data-stu-id="3bd02-3360">D8</span></span>|<span data-ttu-id="3bd02-3361">mul. ovf</span><span class="sxs-lookup"><span data-stu-id="3bd02-3361">mul.ovf</span></span>|<span data-ttu-id="3bd02-3362">Multipliziert zwei ganzzahlige Werte auf dem Stapel mit einer Überlauf Überprüfung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3362">Multiplies two integer values on the stack with an overflow check.</span></span>|  
  
 <span data-ttu-id="3bd02-3363">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3363">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3364">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3364">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3365">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3365">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-3366">`value2` und `value1` werden aus dem Stapel entfernt. `value1` wird mit `value2`mit einer Überlauf Überprüfung multipliziert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3366">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check.</span></span>  
  
4.  <span data-ttu-id="3bd02-3367">Das Ergebnis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3367">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3368">Die `mul.ovf`-Anweisung multipliziert ganzzahlige `value1` nach ganzzahligen `value2` und legt das Ergebnis auf dem Stapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3368">The `mul.ovf` instruction multiplies integer `value1` by integer `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="3bd02-3369">Eine Ausnahme wird ausgelöst, wenn das Ergebnis nicht in den Ergebnistyp passt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3369">An exception is thrown if the result will not fit in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-3370"><xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3370"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-3371">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `mul.ovf` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3371">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3372">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3372">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3373">Multipliziert zwei Ganzzahlwerte ohne Vorzeichen, führt eine Überlaufprüfung durch und legt das Ergebnis auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3373">Multiplies two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3374">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3374">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3375">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3375">Format</span></span>|<span data-ttu-id="3bd02-3376">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3376">Assembly Format</span></span>|<span data-ttu-id="3bd02-3377">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3377">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3378">D9</span><span class="sxs-lookup"><span data-stu-id="3bd02-3378">D9</span></span>|<span data-ttu-id="3bd02-3379">mul. ovf. UN</span><span class="sxs-lookup"><span data-stu-id="3bd02-3379">mul.ovf.un</span></span>|<span data-ttu-id="3bd02-3380">Multipliziert zwei nicht signierte Werte auf dem Stapel mit einer Überlauf Überprüfung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3380">Multiplies two unsigned values on the stack with an overflow check.</span></span>|  
  
 <span data-ttu-id="3bd02-3381">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3381">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3382">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3382">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3383">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3383">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-3384">`value2` und `value1` werden aus dem Stapel entfernt. `value1` wird mit `value2`mit einer Überlauf Überprüfung multipliziert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3384">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check.</span></span>  
  
4.  <span data-ttu-id="3bd02-3385">Das Ergebnis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3385">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3386">Die `mul.ovf.un`-Anweisung multipliziert eine Ganzzahl ohne Vorzeichen `value1` durch eine Ganzzahl ohne Vorzeichen `value2` und legt das Ergebnis auf dem Stapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3386">The `mul.ovf.un` instruction multiplies unsigned integer `value1` by unsigned integer `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="3bd02-3387">Eine Ausnahme wird ausgelöst, wenn das Ergebnis nicht in den Ergebnistyp passt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3387">An exception is thrown if the result will not fit in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-3388"><xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3388"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-3389">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `mul.ovf.un` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3389">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3390">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3390">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3391">Negiert einen Wert und legt das Ergebnis auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3391">Negates a value and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3392">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3392">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3393">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3393">Format</span></span>|<span data-ttu-id="3bd02-3394">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3394">Assembly Format</span></span>|<span data-ttu-id="3bd02-3395">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3395">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3396">65</span><span class="sxs-lookup"><span data-stu-id="3bd02-3396">65</span></span>|<span data-ttu-id="3bd02-3397">Neg</span><span class="sxs-lookup"><span data-stu-id="3bd02-3397">neg</span></span>|<span data-ttu-id="3bd02-3398">Negiert den derzeit auf dem Stapel oberen Wert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3398">Negates the value currently on top of the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-3399">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3399">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3400">Ein Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3400">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3401">Ein Wert wird aus dem Stapel entfernt und negiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3401">A value is popped from the stack and negated.</span></span>  
  
3.  <span data-ttu-id="3bd02-3402">Das Ergebnis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3402">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3403">Die `neg` Anweisung negiert den Wert und legt das Ergebnis auf dem Stapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3403">The `neg` instruction negates value and pushes the result on top of the stack.</span></span> <span data-ttu-id="3bd02-3404">Der Rückgabetyp ist der gleiche wie der Operanden-Typ.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3404">The return type is the same as the operand type.</span></span>  
  
 <span data-ttu-id="3bd02-3405">Die Negation von ganzzahligen Werten ist die standardmäßige zwei Komplement Negation.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3405">Negation of integral values is standard two's complement negation.</span></span> <span data-ttu-id="3bd02-3406">Insbesondere die Negation der negatischsten Zahl (die keine positive Entsprechung hat) ergibt die negativste Zahl.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3406">In particular, negating the most negative number (which does not have a positive counterpart) yields the most negative number.</span></span> <span data-ttu-id="3bd02-3407">Verwenden Sie stattdessen die <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> Anweisung (Subtrahieren von 0), um diesen Überlauf zu erkennen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3407">To detect this overflow use the <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> instruction instead (that is, subtract from 0).</span></span>  
  
 <span data-ttu-id="3bd02-3408">Das neinieren einer Gleit Komma Zahl kann keinen Überlauf verursachen, und die Negation von Nan gibt NaN zurück.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3408">Negating a floating-point number cannot overflow, and negating NaN returns NaN.</span></span>  
  
 <span data-ttu-id="3bd02-3409">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `neg` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3409">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `neg` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3410">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3410">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3411">Legt einen Objektverweis auf ein neues nullbasiertes, eindimensionales Array auf dem Auswertungsstapel ab, dessen Elemente einen bestimmten Typ aufweisen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3411">Pushes an object reference to a new zero-based, one-dimensional array whose elements are of a specific type onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3412">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3412">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3413">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3413">Format</span></span>|<span data-ttu-id="3bd02-3414">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3414">Assembly Format</span></span>|<span data-ttu-id="3bd02-3415">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3415">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3416">8d < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-3416">8D < `T` ></span></span>|<span data-ttu-id="3bd02-3417">`etype` für die</span><span class="sxs-lookup"><span data-stu-id="3bd02-3417">newarr `etype`</span></span>|<span data-ttu-id="3bd02-3418">Erstellt ein neues Array mit Elementen vom Typ `etype`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3418">Creates a new array with elements of type `etype`.</span></span>|  
  
 <span data-ttu-id="3bd02-3419">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3419">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3420">Die Anzahl der Elemente im Array wird auf dem Stapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3420">The number of elements in the array is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3421">Die Anzahl der Elemente wird aus dem Stapel entfernt, und das Array wird erstellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3421">The number of elements is popped from the stack and the array is created.</span></span>  
  
3.  <span data-ttu-id="3bd02-3422">Ein Objekt Verweis auf das neue Array wird auf dem Stapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3422">An object reference to the new array is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3423">Die `newarr` Anweisung überträgt einen Objekt Verweis (Type `O`) auf ein neues NULL basiertes, eindimensionales Array, dessen Elemente vom Typ `etype` sind (ein Metadatentoken, das den Typ beschreibt).</span><span class="sxs-lookup"><span data-stu-id="3bd02-3423">The `newarr` instruction pushes an object reference (type `O`) to a new zero-based, one-dimensional array whose elements are of type `etype` (a metadata token describing the type).</span></span> <span data-ttu-id="3bd02-3424">Die Anzahl der Elemente im neuen Array sollte als `native int`angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3424">The number of elements in the new array should be specified as a `native int`.</span></span> <span data-ttu-id="3bd02-3425">Gültige Array Indizes reichen von Null bis zur maximalen Anzahl von Elementen minus 1.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3425">Valid array indexes range from zero to the maximum number of elements minus one.</span></span>  
  
 <span data-ttu-id="3bd02-3426">Die Elemente eines Arrays können ein beliebiger Typ sein, einschließlich Werttypen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3426">The elements of an array can be any type, including value types.</span></span>  
  
 <span data-ttu-id="3bd02-3427">Null basierte, eindimensionale Arrays von Zahlen werden mithilfe eines Metadatentokens erstellt, das auf den entsprechenden Werttyp verweist (<xref:System.Int32>usw.).</span><span class="sxs-lookup"><span data-stu-id="3bd02-3427">Zero-based, one-dimensional arrays of numbers are created using a metadata token referencing the appropriate value type (<xref:System.Int32>, and so on).</span></span> <span data-ttu-id="3bd02-3428">Elemente des Arrays werden mit 0 des entsprechenden Typs initialisiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3428">Elements of the array are initialized to 0 of the appropriate type.</span></span>  
  
 <span data-ttu-id="3bd02-3429">Nicht null basierte eindimensionale Arrays und mehrdimensionale Arrays werden mithilfe von <xref:System.Reflection.Emit.OpCodes.Newobj> anstatt `newarr`erstellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3429">Nonzero-based one-dimensional arrays and multidimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newobj> rather than `newarr`.</span></span> <span data-ttu-id="3bd02-3430">Üblicherweise werden Sie mithilfe der Methoden der <xref:System.Array>-Klasse in der .NET Framework erstellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3430">More commonly, they are created using the methods of the <xref:System.Array> class in the .NET Framework.</span></span>  
  
 <span data-ttu-id="3bd02-3431"><xref:System.OutOfMemoryException> wird ausgelöst, wenn nicht genügend Arbeitsspeicher vorhanden ist, um die Anforderung zu erfüllen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3431"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="3bd02-3432"><xref:System.OverflowException> wird ausgelöst, wenn `numElems` kleiner als 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3432"><xref:System.OverflowException> is thrown if `numElems` is less than 0.</span></span>  
  
 <span data-ttu-id="3bd02-3433">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `newarr` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3433">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newarr` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3434">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3434">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3435">Erstellt ein neues Objekt oder eine neue Instanz eines Werttyps, wobei ein Objektverweis (Typ <see langword="O" />) auf dem Auswertungsstapel abgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3435">Creates a new object or a new instance of a value type, pushing an object reference (type <see langword="O" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3436">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3436">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3437">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3437">Format</span></span>|<span data-ttu-id="3bd02-3438">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3438">Assembly Format</span></span>|<span data-ttu-id="3bd02-3439">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3439">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3440">73 < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-3440">73 < `T` ></span></span>|<span data-ttu-id="3bd02-3441">newobj-`ctor`</span><span class="sxs-lookup"><span data-stu-id="3bd02-3441">newobj `ctor`</span></span>|<span data-ttu-id="3bd02-3442">Ordnet ein nicht initialisiertes Objekt oder einen Werttyp zu und ruft die `ctor`der Konstruktormethode auf.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3442">Allocates an uninitialized object or value type and calls the constructor method `ctor`.</span></span>|  
  
 <span data-ttu-id="3bd02-3443">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3443">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3444">Durch `argn` `arg1` Argumente werden nacheinander in den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3444">Arguments `arg1` through `argn` are pushed on the stack in sequence.</span></span>  
  
2.  <span data-ttu-id="3bd02-3445">Durch `arg1` `argn` Argumente werden aus dem Stapel entfernt und zur Objekt Erstellung an `ctor` übergeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3445">Arguments `argn` through `arg1` are popped from the stack and passed to `ctor` for object creation.</span></span>  
  
3.  <span data-ttu-id="3bd02-3446">Ein Verweis auf das neue-Objekt wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3446">A reference to the new object is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3447">Die `newobj`-Anweisung erstellt ein neues-Objekt oder eine neue Instanz eines Werttyps.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3447">The `newobj` instruction creates a new object or a new instance of a value type.</span></span> <span data-ttu-id="3bd02-3448">`Ctor` ist ein Metadatentoken (ein `methodref` oder `methoddef`, das als Konstruktor gekennzeichnet werden muss), das den Namen, die Klasse und die Signatur des aufzurufenden Konstruktors angibt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3448">`Ctor` is a metadata token (a `methodref` or `methoddef` that must be marked as a constructor) that indicates the name, class and signature of the constructor to call.</span></span>  
  
 <span data-ttu-id="3bd02-3449">Die `newobj`-Anweisung ordnet eine neue Instanz der-Klasse zu, die `ctor` zugeordnet ist, und initialisiert alle Felder in der neuen-Instanz auf 0 (des richtigen Typs) oder auf NULL-Verweise nach Bedarf.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3449">The `newobj` instruction allocates a new instance of the class associated with `ctor` and initializes all the fields in the new instance to 0 (of the proper type) or null references as appropriate.</span></span> <span data-ttu-id="3bd02-3450">Anschließend wird der Konstruktor `ctor` mit den angegebenen Argumenten zusammen mit der neu erstellten-Instanz aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3450">It then calls the constructor `ctor` with the given arguments along with the newly created instance.</span></span> <span data-ttu-id="3bd02-3451">Nachdem der Konstruktor aufgerufen wurde, wird der jetzt initialisierte Objekt Verweis (Type `O`) auf dem Stapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3451">After the constructor has been called, the now initialized object reference (type `O`) is pushed on the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3452">Aus Sicht des Konstruktors lautet das nicht initialisierte Objekt Argument 0, und die anderen Argumente, die an newobj übergeben werden, folgen in der angegebenen Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3452">From the constructor's point of view, the uninitialized object is argument 0 and the other arguments passed to newobj follow in order.</span></span>  
  
 <span data-ttu-id="3bd02-3453">Alle NULL basierten, eindimensionalen Arrays werden mithilfe von <xref:System.Reflection.Emit.OpCodes.Newarr>erstellt, nicht `newobj`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3453">All zero-based, one-dimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newarr>, not `newobj`.</span></span> <span data-ttu-id="3bd02-3454">Andererseits werden alle anderen Arrays (mehr als eine Dimension oder eindimensional, aber nicht NULL basiert) mit `newobj`erstellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3454">On the other hand, all other arrays (more than one dimension, or one-dimensional but not zero-based) are created using `newobj`.</span></span>  
  
 <span data-ttu-id="3bd02-3455">Werttypen werden in der Regel nicht mit `newobj`erstellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3455">Value types are not usually created using `newobj`.</span></span> <span data-ttu-id="3bd02-3456">Sie werden in der Regel entweder als Argumente oder lokale Variablen zugewiesen, wobei `newarr` (für null-basierte, eindimensionale Arrays) oder als Felder von Objekten verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3456">They are usually allocated either as arguments or local variables, using `newarr` (for zero-based, one-dimensional arrays), or as fields of objects.</span></span> <span data-ttu-id="3bd02-3457">Nach der Zuweisung werden Sie mit <xref:System.Reflection.Emit.OpCodes.Initobj>initialisiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3457">Once allocated, they are initialized using <xref:System.Reflection.Emit.OpCodes.Initobj>.</span></span> <span data-ttu-id="3bd02-3458">Die `newobj` Anweisung kann jedoch verwendet werden, um eine neue Instanz eines Werttyps auf dem Stapel zu erstellen, die dann als Argument, in einem lokalen gespeichert usw., weitergegeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3458">However, the `newobj` instruction can be used to create a new instance of a value type on the stack, that can then be passed as an argument, stored in a local, and so on.</span></span>  
  
 <span data-ttu-id="3bd02-3459"><xref:System.OutOfMemoryException> wird ausgelöst, wenn nicht genügend Arbeitsspeicher vorhanden ist, um die Anforderung zu erfüllen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3459"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="3bd02-3460"><xref:System.MissingMethodException> wird ausgelöst, wenn eine Konstruktormethode `ctor` mit dem angegeben Namen, der Klasse und der Signatur nicht gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3460"><xref:System.MissingMethodException> is thrown if a constructor method `ctor` with the indicated name, class and signature could not be found.</span></span> <span data-ttu-id="3bd02-3461">Dies wird in der Regel erkannt, wenn MSIL-Anweisungen (Microsoft Intermediate Language) in systemeigenen Code konvertiert werden, anstatt zur Laufzeit.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3461">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="3bd02-3462">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `newobj` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3462">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newobj` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3463">ILGenerator.Emit(OpCode, ConstructorInfo)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3463">ILGenerator.Emit(OpCode, ConstructorInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3464">Füllt Speicherplatz auf, wenn Opcodes gepatcht werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3464">Fills space if opcodes are patched.</span></span> <span data-ttu-id="3bd02-3465">Es wird keine sinnvolle Operation ausgeführt, obwohl ein Verarbeitungszyklus ausgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3465">No meaningful operation is performed although a processing cycle can be consumed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3466">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3466">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3467">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3467">Format</span></span>|<span data-ttu-id="3bd02-3468">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3468">Assembly Format</span></span>|<span data-ttu-id="3bd02-3469">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3469">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3470">00</span><span class="sxs-lookup"><span data-stu-id="3bd02-3470">00</span></span>|<span data-ttu-id="3bd02-3471">NOP</span><span class="sxs-lookup"><span data-stu-id="3bd02-3471">nop</span></span>|<span data-ttu-id="3bd02-3472">Führt einen Vorgang ohne Verhalten aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3472">Performs an operation without behavior.</span></span>|  
  
 <span data-ttu-id="3bd02-3473">Für diese Anweisung ist kein Stapel Übergangs Verhalten definiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3473">There is no stack transitional behavior defined for this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-3474">Der `nop` Vorgang bewirkt nichts.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3474">The `nop` operation does nothing.</span></span> <span data-ttu-id="3bd02-3475">Wenn Opcodes gepatcht werden, soll der Speicherplatz ausgefüllt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3475">It is intended to fill in space if opcodes are patched.</span></span>  
  
 <span data-ttu-id="3bd02-3476">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `nop` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3476">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `nop` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3477">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3477">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3478">Berechnet das bitweise Komplement des Ganzzahlwerts an oberster Position des Stapels und legt das Ergebnis als denselben Typ auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3478">Computes the bitwise complement of the integer value on top of the stack and pushes the result onto the evaluation stack as the same type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3479">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3479">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3480">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3480">Format</span></span>|<span data-ttu-id="3bd02-3481">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3481">Assembly Format</span></span>|<span data-ttu-id="3bd02-3482">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3482">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3483">66</span><span class="sxs-lookup"><span data-stu-id="3bd02-3483">66</span></span>|<span data-ttu-id="3bd02-3484">not</span><span class="sxs-lookup"><span data-stu-id="3bd02-3484">not</span></span>|<span data-ttu-id="3bd02-3485">Berechnet das bitweise Komplement eines-Werts.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3485">Computes the bitwise complement of a value.</span></span>|  
  
 <span data-ttu-id="3bd02-3486">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3486">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3487">`value` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3487">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3488">`value` aus dem Stapel und dessen bitweises Komplement berechnet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3488">`value` is popped from the stack and its bitwise complement computed.</span></span>  
  
3.  <span data-ttu-id="3bd02-3489">Das Ergebnis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3489">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3490">Die `not`-Anweisung berechnet das bitweise Komplement eines ganzzahligen Werts und legt das Ergebnis auf dem Stapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3490">The `not` instruction computes the bitwise complement of an integer value and pushes the result onto the stack.</span></span> <span data-ttu-id="3bd02-3491">Der Rückgabetyp ist der gleiche wie der Operanden-Typ.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3491">The return type is the same as the operand type.</span></span>  
  
 <span data-ttu-id="3bd02-3492">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `not` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3492">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `not` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3493">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3493">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3494">Berechnet das bitweise Komplement der beiden Ganzzahlwerte an oberster Position des Stapels und legt das Ergebnis auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3494">Compute the bitwise complement of the two integer values on top of the stack and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3495">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3495">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3496">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3496">Format</span></span>|<span data-ttu-id="3bd02-3497">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3497">Assembly Format</span></span>|<span data-ttu-id="3bd02-3498">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3498">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3499">60</span><span class="sxs-lookup"><span data-stu-id="3bd02-3499">60</span></span>|<span data-ttu-id="3bd02-3500">oder</span><span class="sxs-lookup"><span data-stu-id="3bd02-3500">or</span></span>|<span data-ttu-id="3bd02-3501">Berechnet das bitweise OR von zwei ganzzahligen Werten und gibt eine ganze Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3501">Computes the bitwise OR of two integer values, returns an integer.</span></span>|  
  
 <span data-ttu-id="3bd02-3502">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3502">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3503">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3503">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3504">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3504">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-3505">`value2` und `value1` werden aus dem Stapel und deren bitweises oder berechnetes Element per Pop ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3505">`value2` and `value1` are popped from the stack and their bitwise OR computed.</span></span>  
  
4.  <span data-ttu-id="3bd02-3506">Das Ergebnis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3506">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3507">Die `or`-Anweisung berechnet das bitweise OR von zwei Werten über dem Stapel und überträgt das Ergebnis auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3507">The `or` instruction computes the bitwise OR of two values atop the stack, pushing the result onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3508">`Or` ist ein ganzzahliger spezifischer Vorgang.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3508">`Or` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="3bd02-3509">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `or` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3509">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `or` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3510">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3510">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3511">Entfernt den Wert, der sich derzeit an oberster Position des Auswertungsstapels befindet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3511">Removes the value currently on top of the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3512">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3512">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3513">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3513">Format</span></span>|<span data-ttu-id="3bd02-3514">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3514">Assembly Format</span></span>|<span data-ttu-id="3bd02-3515">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3515">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3516">26</span><span class="sxs-lookup"><span data-stu-id="3bd02-3516">26</span></span>|<span data-ttu-id="3bd02-3517">pop</span><span class="sxs-lookup"><span data-stu-id="3bd02-3517">pop</span></span>|<span data-ttu-id="3bd02-3518">Holt den obersten Wert aus dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3518">Pops the top value from the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-3519">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3519">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3520">Der oberste Wert wird aus dem Stapel entfernt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3520">The top value is popped from the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3521">Die `pop` Anweisung entfernt das oberste Element aus dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3521">The `pop` instruction removes the top element from the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3522">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `pop` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3522">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `pop` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3523">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3523">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3524">Dies ist eine reservierte Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3524">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3525">Dies ist eine reservierte Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3525">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3526">Dies ist eine reservierte Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3526">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3527">Dies ist eine reservierte Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3527">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3528">Dies ist eine reservierte Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3528">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3529">Dies ist eine reservierte Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3529">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3530">Dies ist eine reservierte Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3530">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3531">Dies ist eine reservierte Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3531">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3532">Gibt an, dass beim nachfolgenden Vorgang zur Arrayadresse zur Laufzeit keine Typüberprüfung durchgeführt wird und dass ein verwalteter Zeiger zurückgegeben wird, der nur bedingt geändert werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3532">Specifies that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer whose mutability is restricted.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3533">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3533">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3534">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3534">Format</span></span>|<span data-ttu-id="3bd02-3535">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3535">Assembly Format</span></span>|<span data-ttu-id="3bd02-3536">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3536">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3537">FE 1E</span><span class="sxs-lookup"><span data-stu-id="3bd02-3537">FE 1E</span></span>|<span data-ttu-id="3bd02-3538">ReadOnly.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3538">readonly.</span></span>|<span data-ttu-id="3bd02-3539">Gibt an, dass der nachfolgende Array Adress Vorgang zur Laufzeit keine Typüberprüfung ausführt und einen verwalteten Zeiger mit eingeschränkter Veränderbarkeit zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3539">Specify that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer with restricted mutability.</span></span>|  
  
 <span data-ttu-id="3bd02-3540">Dieses Präfix kann nur unmittelbar vor der `ldelema` Anweisung und Aufrufen der speziellen `Address`-Methode für Arrays angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3540">This prefix can only appear immediately preceding the `ldelema` instruction and calls to the special `Address` method on arrays.</span></span> <span data-ttu-id="3bd02-3541">Die Auswirkung auf den nachfolgenden Vorgang ist zweierlei:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3541">Its effect on the subsequent operation is twofold:</span></span>  
  
1.  <span data-ttu-id="3bd02-3542">Zur Laufzeit wird kein Vorgang zur Typüberprüfung durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3542">At run time, no type check operation is performed.</span></span> <span data-ttu-id="3bd02-3543">Beachten Sie, dass es normalerweise eine implizite Typüberprüfung für die `ldelema` und `stelem` Anweisungen gibt, wenn Sie für Verweistyp Arrays verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3543">Note that there is normally an implicit type check for the `ldelema` and `stelem` instructions when used on reference type arrays.</span></span> <span data-ttu-id="3bd02-3544">Es gibt nie eine Lauf Zeittyp Überprüfung für Wert Klassen, daher ist `readonly` in diesem Fall kein op.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3544">There is never a run-time type check for value classes, so `readonly` is a no-op in that case.</span></span>  
  
2.  <span data-ttu-id="3bd02-3545">Der Verifier behandelt das Ergebnis des address-of-Vorgangs als verwalteten Zeiger mit eingeschränkter Veränderbarkeit.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3545">The verifier treats the result of the address-of operation as a managed pointer with restricted mutability.</span></span>  
  
 <span data-ttu-id="3bd02-3546">Der Zeiger hat eine eingeschränkte Veränderlichkeit, da der definierende Typ steuert, ob der Wert mutiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3546">The pointer is said to have restricted mutability because the defining type controls whether the value can be mutated.</span></span> <span data-ttu-id="3bd02-3547">Für Wert Klassen, die keine öffentlichen Felder oder Methoden verfügbar machen, die den Wert direkt aktualisieren, ist der Zeiger schreibgeschützt (daher der Name des Präfixes).</span><span class="sxs-lookup"><span data-stu-id="3bd02-3547">For value classes that expose no public fields or methods that update the value in place, the pointer is read-only (hence the name of the prefix).</span></span> <span data-ttu-id="3bd02-3548">Insbesondere die Klassen, die primitive Typen darstellen (z. b. System. Int32), machen keine Mutatoren verfügbar und sind daher schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3548">In particular, the classes representing primitive types (for example, System.Int32) do not expose mutators and thus are read-only.</span></span>  
  
 <span data-ttu-id="3bd02-3549">Ein auf diese Weise beschränkte verwalteter Zeiger kann nur auf folgende Weise verwendet werden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3549">A managed pointer restricted in this fashion can be used only in the following ways:</span></span>  
  
-   <span data-ttu-id="3bd02-3550">Als `object` Parameter für die Anweisungen `ldfld`, `ldflda`, `stfld`, `call`oder`constrained callvirt`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3550">As the `object` parameter for the `ldfld`, `ldflda`, `stfld`, `call`, or`constrained callvirt` instructions.</span></span>  
  
-   <span data-ttu-id="3bd02-3551">Als `pointer` Parameter für die `ldobj` Anweisung oder eine der `ldind` Anweisungen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3551">As the `pointer` parameter to the `ldobj` instruction or to one of the `ldind` instructions.</span></span>  
  
-   <span data-ttu-id="3bd02-3552">Als `source` Parameter für die `cpobj` Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3552">As the `source` parameter to the `cpobj` instruction.</span></span>  
  
 <span data-ttu-id="3bd02-3553">Alle anderen Vorgänge, einschließlich der `stobj`-, `initobj`-oder `mkrefany` Vorgänge oder einer der `stind` Anweisungen, sind nicht zulässig.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3553">All other operations disallowed, including the `stobj`, `initobj`, or `mkrefany` operations, or any of the `stind` instructions.</span></span>  
  
 <span data-ttu-id="3bd02-3554">Der Zweck des `readonly` Präfixes besteht darin, eine Typüberprüfung zu vermeiden, wenn ein Element aus einem Array in generischem Code abgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3554">The purpose of the `readonly` prefix is to avoid a type check when fetching an element from an array in generic code.</span></span> <span data-ttu-id="3bd02-3555">Der Ausdruck `arr[i].m()`z. b., bei dem der Elementtyp des Arrays `arr` ein generischer Typ ist, der auf eine Schnittstelle mit der Methode `m`beschränkt wurde, möglicherweise mit der folgenden MSIL kompiliert wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3555">For example, the expression `arr[i].m()`, where the element type of the array `arr` is a generic type that has been constrained to have an interface with method `m`, might compile to the following MSIL.</span></span>  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 <span data-ttu-id="3bd02-3556">Ohne das Präfix `readonly` würde die `ldelema` Anweisung eine Typüberprüfung durchführen, wenn "! 0" ein Verweistyp ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3556">Without the `readonly` prefix, the `ldelema` instruction would perform a type check in the case where !0 was a reference type.</span></span> <span data-ttu-id="3bd02-3557">Diese Typüberprüfung ist nicht nur ineffizient, sondern ist semantisch falsch.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3557">Not only is this type check inefficient, but it is semantically incorrect.</span></span> <span data-ttu-id="3bd02-3558">Die Typüberprüfung für `ldelema` ist eine genaue Entsprechung, die zu stark ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3558">The type check for `ldelema` is an exact match, which is too strong.</span></span> <span data-ttu-id="3bd02-3559">Wenn das Array Unterklassen vom Typ! 0 enthielt, würde der obige Code die Typüberprüfung nicht durchführen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3559">If the array held subclasses of type !0, the code above would fail the type check.</span></span>  
  
 <span data-ttu-id="3bd02-3560">Die Adresse des Array Elements wird anstelle des-Elements selbst abgerufen, um ein Handle für `arr[i]` zu haben, das sowohl für Werttypen als auch für Verweis Typen geeignet ist und daher an die `constrained callvirt` Anweisung übermittelt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3560">The address of the array element is fetched, instead of the element itself, in order to have a handle for `arr[i]` that works for both value types and reference types, and thus can be passed to the `constrained callvirt` instruction.</span></span>  
  
 <span data-ttu-id="3bd02-3561">Im allgemeinen wäre es unsicher, die Lauf Zeit Überprüfung zu überspringen, wenn das Array Elemente eines Verweis Typs enthielt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3561">In general it would be unsafe to skip the run-time check if the array held elements of a reference type.</span></span> <span data-ttu-id="3bd02-3562">Um sicher zu sein, muss sichergestellt werden, dass keine Änderungen am Array über diesen Zeiger vorgenommen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3562">To be safe, it is necessary to ensure that no modifications to the array are made through this pointer.</span></span> <span data-ttu-id="3bd02-3563">Dies wird von den verifiziererregeln sichergestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3563">The verifier rules ensure this.</span></span> <span data-ttu-id="3bd02-3564">Der eingeschränkte verwaltete Zeiger kann als Objekt von Instanzmethodenaufrufen weitergegeben werden, sodass er für Werttypen nicht streng schreibgeschützt ist, aber es gibt kein typsicherheits Problem für Werttypen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3564">The restricted managed pointer can be passed as the object of instance method calls, so it is not strictly speaking read-only for value types, but there is no type safety problem for value types.</span></span>  
  
 <span data-ttu-id="3bd02-3565">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `readonly` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3565">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `readonly` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3566">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3566">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3567">Ruft das Typtoken ab, das in einen typisierten Verweis eingebettet ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3567">Retrieves the type token embedded in a typed reference.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3568">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3568">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3569">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3569">Format</span></span>|<span data-ttu-id="3bd02-3570">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3570">Assembly Format</span></span>|<span data-ttu-id="3bd02-3571">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3571">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3572">FE 1D</span><span class="sxs-lookup"><span data-stu-id="3bd02-3572">FE 1D</span></span>|<span data-ttu-id="3bd02-3573">refanytype</span><span class="sxs-lookup"><span data-stu-id="3bd02-3573">refanytype</span></span>|<span data-ttu-id="3bd02-3574">Überträgt das Typtoken, das in einem typisierten Verweis gespeichert ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3574">Pushes the type token stored in a typed reference.</span></span>|  
  
 <span data-ttu-id="3bd02-3575">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3575">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3576">Ein Werttyp Verweis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3576">A value type reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3577">Der typisierte Verweis wird aus dem Stapel abgerufen, und das zugehörige Typtoken wird abgerufen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3577">The typed reference is popped from the stack and its corresponding type token retrieved.</span></span>  
  
3.  <span data-ttu-id="3bd02-3578">Das Typtoken wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3578">The type token is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3579">Ein typisierter Verweis enthält ein Typtoken und eine Adresse für eine Objektinstanz.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3579">A typed reference contains a type token and an address to an object instance.</span></span>  
  
 <span data-ttu-id="3bd02-3580">Die `refanytype`-Anweisung ruft das Typtoken ab, das in den typisierten Verweis eingebettet ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3580">The `refanytype` instruction retrieves the type token embedded in the typed reference.</span></span> <span data-ttu-id="3bd02-3581">Weitere Informationen zum Erstellen von typisierten verweisen finden Sie in der <xref:System.Reflection.Emit.OpCodes.Mkrefany>-Anweisung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3581">See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for information on creating typed references.</span></span>  
  
 <span data-ttu-id="3bd02-3582">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `refanytype` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3582">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanytype` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3583">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3583">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3584">Ruft die Adresse (Typ <see langword="&amp;" />) ab, die in einen typisierten Verweis eingebettet ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3584">Retrieves the address (type <see langword="&amp;" />) embedded in a typed reference.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3585">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3585">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3586">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3586">Format</span></span>|<span data-ttu-id="3bd02-3587">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3587">Assembly Format</span></span>|<span data-ttu-id="3bd02-3588">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3588">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3589">C2 < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-3589">C2 < `T` ></span></span>|<span data-ttu-id="3bd02-3590">refanyval-`type`</span><span class="sxs-lookup"><span data-stu-id="3bd02-3590">refanyval `type`</span></span>|<span data-ttu-id="3bd02-3591">Legt die in einem typisierten Verweis gespeicherte Adresse ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3591">Pushes the address stored in a typed reference.</span></span>|  
  
 <span data-ttu-id="3bd02-3592">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3592">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3593">Ein Werttyp Verweis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3593">A value type reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3594">Der typisierte Verweis wird aus dem Stapel abgerufen, und die entsprechende Adresse wird abgerufen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3594">The typed reference is popped from the stack and the corresponding address retrieved.</span></span>  
  
3.  <span data-ttu-id="3bd02-3595">Die Adresse wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3595">The address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3596">Ein typisierter Verweis enthält ein Typtoken und eine Adresse für eine Objektinstanz.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3596">A typed reference contains a type token and an address to an object instance.</span></span>  
  
 <span data-ttu-id="3bd02-3597">Die `refanyval`-Anweisung ruft die Adresse ab, die in einen typisierten Verweis eingebettet ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3597">The `refanyval` instruction retrieves the address embedded in the a typed reference.</span></span> <span data-ttu-id="3bd02-3598">Der Typ, der in den typisierten Verweis im Stapel eingebettet ist, muss mit dem Typ, der durch `type` angegeben wird (ein Metadatentoken, entweder `typedef` oder `typeref`), identisch sein.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3598">The type embedded in the typed reference supplied on the stack must match the type specified by `type` (a metadata token, either a `typedef` or a `typeref`).</span></span> <span data-ttu-id="3bd02-3599">Weitere Informationen finden Sie unter <xref:System.Reflection.Emit.OpCodes.Mkrefany>-Anweisung für verwandte Inhalte.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3599">See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for related content.</span></span>  
  
 <span data-ttu-id="3bd02-3600"><xref:System.InvalidCastException> wird ausgelöst, wenn `type` nicht mit dem im Typverweis gespeicherten Typ identisch ist (in diesem Fall ist `type` die Klasse, die für die <xref:System.Reflection.Emit.OpCodes.Mkrefany> Anweisung bereitgestellt wird, die den genannten typisierten Verweis erstellt hat).</span><span class="sxs-lookup"><span data-stu-id="3bd02-3600"><xref:System.InvalidCastException> is thrown if `type` is not identical to the type stored in the type reference (in this case, `type` is the class supplied to the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction that constructed said typed reference).</span></span>  
  
 <span data-ttu-id="3bd02-3601"><xref:System.TypeLoadException> wird ausgelöst, wenn `type` nicht gefunden werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3601"><xref:System.TypeLoadException> is thrown if `type` cannot be found.</span></span>  
  
 <span data-ttu-id="3bd02-3602">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `refanyval` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3602">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanyval` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3603">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3603">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3604">Dividiert zwei Werte und legt den Rest auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3604">Divides two values and pushes the remainder onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3605">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3605">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3606">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3606">Format</span></span>|<span data-ttu-id="3bd02-3607">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3607">Assembly Format</span></span>|<span data-ttu-id="3bd02-3608">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3608">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3609">5D</span><span class="sxs-lookup"><span data-stu-id="3bd02-3609">5D</span></span>|<span data-ttu-id="3bd02-3610">REM</span><span class="sxs-lookup"><span data-stu-id="3bd02-3610">rem</span></span>|<span data-ttu-id="3bd02-3611">Überträgt den Rest der Division `value1` durch `value2` auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3611">Pushes the remainder of dividing `value1` by `value2` onto the stack.</span></span>|  
  
  
 <span data-ttu-id="3bd02-3612">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3612">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3613">Ein `value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3613">A `value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3614">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3614">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-3615">`value2` und `value1` werden aus dem Stapel entfernt, und der Rest `value1` `div` `value2` berechnet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3615">`value2` and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed.</span></span>  
  
4.  <span data-ttu-id="3bd02-3616">Das Ergebnis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3616">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3617">`result` = `value1` `rem` `value2` erfüllt die folgenden Bedingungen:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3617">`result` = `value1` `rem` `value2` satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="3bd02-3618">`result` = `value1` - `value2` `×` (`value1` `div` `value2`) und:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3618">`result` = `value1` - `value2` `×` (`value1` `div` `value2`), and:</span></span>  
  
 <span data-ttu-id="3bd02-3619">0 = &#124; `result` &#124; < &#124; `value2` &#124;, Sign (`result`) = Sign (`value1`), wobei `div` die Divisions Anweisung ist, die in Richtung NULL abgeschnitten wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3619">0 = &#124; `result` &#124; < &#124; `value2` &#124;, sign(`result`) = sign(`value1`), where `div` is the division instruction that truncates towards zero.</span></span>  
  
 <span data-ttu-id="3bd02-3620">Wenn `value2` NULL ist oder `value1` unendlich unendlich ist, ist das Ergebnis NaN.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3620">If `value2` is zero or `value1` is infinity the result is NaN.</span></span> <span data-ttu-id="3bd02-3621">Wenn `value2` unendlich ist, wird das Ergebnis `value1` (negiert für `-infinity`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-3621">If `value2` is infinity, the result is `value1` (negated for `-infinity`).</span></span>  
  
 <span data-ttu-id="3bd02-3622">Ganzzahlige Vorgänge lösen <xref:System.DivideByZeroException> aus, wenn `value2` NULL ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3622">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="3bd02-3623">Beachten Sie, dass auf den Intel-basierten Plattformen beim Berechnen (minint `rem`-1) eine <xref:System.OverflowException> ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3623">Note that on the Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint `rem` -1).</span></span>  
  
 <span data-ttu-id="3bd02-3624">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `rem` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3624">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3625">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3625">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3626">Dividiert zwei Werte ohne Vorzeichen und legt den Rest auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3626">Divides two unsigned values and pushes the remainder onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3627">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3627">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3628">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3628">Format</span></span>|<span data-ttu-id="3bd02-3629">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3629">Assembly Format</span></span>|<span data-ttu-id="3bd02-3630">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3630">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3631">5E</span><span class="sxs-lookup"><span data-stu-id="3bd02-3631">5E</span></span>|<span data-ttu-id="3bd02-3632">REM. UN</span><span class="sxs-lookup"><span data-stu-id="3bd02-3632">rem.un</span></span>|<span data-ttu-id="3bd02-3633">Überträgt den Rest der Division nicht signierter `value1` durch unsignierte `value2` auf den Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3633">Pushes the remainder of dividing unsigned `value1` by unsigned `value2` onto the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-3634">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3634">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3635">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3635">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3636">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3636">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-3637">`value2` und `value1` werden aus dem Stapel entfernt, und der Rest `value1` `div` `value2` berechnet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3637">`value2` and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed.</span></span>  
  
4.  <span data-ttu-id="3bd02-3638">Das Ergebnis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3638">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3639">`result` = `value1` `rem.un` `value2` erfüllt die folgenden Bedingungen:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3639">`result` = `value1` `rem.un` `value2` satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="3bd02-3640">`result` = `value1` - `value2` x (`value1` `div.un` `value2`) und:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3640">`result` = `value1` - `value2` x(`value1` `div.un` `value2`), and:</span></span>  
  
 <span data-ttu-id="3bd02-3641">0 = `result` < `value2`, wobei `div.un` die Anweisung ohne Vorzeichen ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3641">0 = `result` < `value2`, where `div.un` is the unsigned division instruction.</span></span>  
  
 <span data-ttu-id="3bd02-3642">Die `rem.un`-Anweisung berechnet `result` und legt Sie auf dem Stapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3642">The `rem.un` instruction computes `result` and pushes it on the stack.</span></span> <span data-ttu-id="3bd02-3643">`Rem.un` behandelt die Argumente als ganze Zahlen ohne Vorzeichen, während <xref:System.Reflection.Emit.OpCodes.Rem> Sie als ganze Zahlen mit Vorzeichen behandelt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3643">`Rem.un` treats its arguments as unsigned integers, while <xref:System.Reflection.Emit.OpCodes.Rem> treats them as signed integers.</span></span>  
  
 <span data-ttu-id="3bd02-3644">`Rem.un` ist für Gleit Komma Zahlen nicht angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3644">`Rem.un` is unspecified for floating-point numbers.</span></span>  
  
 <span data-ttu-id="3bd02-3645">Ganzzahlige Vorgänge lösen <xref:System.DivideByZeroException> aus, wenn `value2` NULL ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3645">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="3bd02-3646">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `rem.un` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3646">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem.un` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3647">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3647">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3648">Wird von der aktuellen Methode zurückgegeben und legt einen Rückgabewert (sofern vorhanden) vom Auswertungsstapel des Aufgerufenen auf dem Auswertungsstapel des Aufrufenden ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3648">Returns from the current method, pushing a return value (if present) from the callee's evaluation stack onto the caller's evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3649">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3649">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3650">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3650">Format</span></span>|<span data-ttu-id="3bd02-3651">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3651">Assembly Format</span></span>|<span data-ttu-id="3bd02-3652">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3652">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3653">2A</span><span class="sxs-lookup"><span data-stu-id="3bd02-3653">2A</span></span>|<span data-ttu-id="3bd02-3654">TZI</span><span class="sxs-lookup"><span data-stu-id="3bd02-3654">ret</span></span>|<span data-ttu-id="3bd02-3655">Gibt die von der-Methode zurück und gibt möglicherweise einen Wert zurück</span><span class="sxs-lookup"><span data-stu-id="3bd02-3655">Returns from method, possibly returning a value.</span></span>|  
  
 <span data-ttu-id="3bd02-3656">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3656">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3657">Der Rückgabewert wird vom aufgerufener Auswertungs Stapel ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3657">The return value is popped from the callee evaluation stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3658">Der in Schritt 1 abgelegte Rückgabewert wird auf den Auswertungs Stapel des Aufrufers übermittelt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3658">The return value obtained in step 1 is pushed onto the caller evaluation stack.</span></span>  
  
 <span data-ttu-id="3bd02-3659">Wenn der Rückgabewert nicht auf dem Auswertungs Stapel des aufgerufenen vorhanden ist, wird kein Wert zurückgegeben (kein Stapel Übergangs Verhalten für die aufgerufene Methode oder die aufrufermethode).</span><span class="sxs-lookup"><span data-stu-id="3bd02-3659">If the return value is not present on the callee evaluation stack, no value is returned (no stack transition behaviors for either the callee or caller method).</span></span>  
  
 <span data-ttu-id="3bd02-3660">Der Typ des Rückgabewerts der aktuellen Methode bestimmt den Typ des Werts, der vom oberen Rand des Stapels abgerufen und auf den Stapel der Methode kopiert wird, der die aktuelle Methode aufgerufen hat.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3660">The type of the return value, if any, of the current method determines the type of value to be fetched from the top of the stack and copied onto the stack of the method that called the current method.</span></span> <span data-ttu-id="3bd02-3661">Der Auswertungs Stapel für die aktuelle Methode muss leer sein, es sei denn, der Wert wird zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3661">The evaluation stack for the current method must be empty except for the value to be returned.</span></span>  
  
 <span data-ttu-id="3bd02-3662">Die `ret` Anweisung kann nicht verwendet werden, um die Steuerung aus einem`try`-, `filter`-, `catch`-oder `finally`-Block zu übertragen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3662">The `ret` instruction cannot be used to transfer control out of a`try`, `filter`, `catch`, or `finally` block.</span></span> <span data-ttu-id="3bd02-3663">Verwenden Sie in einem `try` oder `catch`die <xref:System.Reflection.Emit.OpCodes.Leave>-Anweisung mit einem Ziel einer `ret` Anweisung, die sich außerhalb aller einschließenden Ausnahme Blöcke befindet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3663">From within a `try` or `catch`, use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction with a destination of a `ret` instruction that is outside all enclosing exception blocks.</span></span> <span data-ttu-id="3bd02-3664">Da die `filter`-und `finally` Blöcke logisch Teil der Ausnahmebehandlung sind und nicht die Methode, in der Ihr Code eingebettet ist, führen ordnungsgemäß generierte MSIL-Anweisungen (Microsoft Intermediate Language) nicht innerhalb eines `filter` oder `finally`eine Methode aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3664">Because the `filter` and `finally` blocks are logically part of exception handling and not the method in which their code is embedded, correctly generated Microsoft Intermediate Language (MSIL) instructions do not perform a method return from within a `filter` or `finally`.</span></span>  
  
 <span data-ttu-id="3bd02-3665">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `ret` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3665">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ret` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3666">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3666">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3667">Löst erneut die aktuelle Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3667">Rethrows the current exception.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3668">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3668">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3669">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3669">Format</span></span>|<span data-ttu-id="3bd02-3670">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3670">Assembly Format</span></span>|<span data-ttu-id="3bd02-3671">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3671">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3672">FE 1a</span><span class="sxs-lookup"><span data-stu-id="3bd02-3672">FE 1A</span></span>|<span data-ttu-id="3bd02-3673">erneut auslösen</span><span class="sxs-lookup"><span data-stu-id="3bd02-3673">rethrow</span></span>|<span data-ttu-id="3bd02-3674">Löst die aktuelle Ausnahme erneut aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3674">Rethrows the current exception</span></span>|  
  
 <span data-ttu-id="3bd02-3675">Für diese Anweisung ist kein Stapel Übergangs Verhalten definiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3675">No stack transition behavior is defined for this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-3676">Die `rethrow`-Anweisung ist nur innerhalb des Texts eines `catch` Handlers zulässig.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3676">The `rethrow` instruction is only permitted within the body of a `catch` handler.</span></span> <span data-ttu-id="3bd02-3677">Sie löst dieselbe Ausnahme aus, die von diesem Handler abgefangen wurde.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3677">It throws the same exception that was caught by this handler.</span></span>  
  
 <span data-ttu-id="3bd02-3678">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `rethrow` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3678">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rethrow` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3679">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3679">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3680">Verschiebt einen ganzzahligen Wert um eine angegebene Anzahl von Bits nach links, wobei die frei werdenden Stellen mit 0-Bits aufgefüllt werden, und legt das Ergebnis auf den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3680">Shifts an integer value to the left (in zeroes) by a specified number of bits, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3681">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3681">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3682">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3682">Format</span></span>|<span data-ttu-id="3bd02-3683">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3683">Assembly Format</span></span>|<span data-ttu-id="3bd02-3684">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3684">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3685">62</span><span class="sxs-lookup"><span data-stu-id="3bd02-3685">62</span></span>|<span data-ttu-id="3bd02-3686">SHL</span><span class="sxs-lookup"><span data-stu-id="3bd02-3686">shl</span></span>|<span data-ttu-id="3bd02-3687">Verschiebt eine Ganzzahl nach links (Verschiebung in Nullen).</span><span class="sxs-lookup"><span data-stu-id="3bd02-3687">Shifts an integer to the left (shifting in zeros).</span></span>|  
  
 <span data-ttu-id="3bd02-3688">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3688">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3689">Ein Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3689">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3690">Die Menge der zu Verschiebe Bits wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3690">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-3691">Die Anzahl der zu Verschiebe enden Bits und der Wert aus dem Stapel. der Wert wird um die angegebene Anzahl von Bits nach links verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3691">The number of bits to be shifted and the value are popped from the stack; the value is shifted left by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="3bd02-3692">Das Ergebnis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3692">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3693">Die `shl` Anweisung verschiebt den Wert (Typ `int32`, `int64` oder `native int`) um die angegebene Anzahl von Bits nach links.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3693">The `shl` instruction shifts the value (type `int32`, `int64` or `native int`) left by the specified number of bits.</span></span> <span data-ttu-id="3bd02-3694">Die Anzahl der Bits ist ein Wert vom Typ `int32` oder `native int`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3694">The number of bits is a value of type `int32` or `native int`.</span></span> <span data-ttu-id="3bd02-3695">Der Rückgabewert ist nicht angegeben, wenn die Anzahl von Bits, die verschoben werden sollen, größer oder gleich der Breite (in Bits) des angegebenen Werts ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3695">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="3bd02-3696">`Shl` fügt bei jeder Schicht ein NULL-Bit an der niedrigsten Position ein.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3696">`Shl` inserts a zero bit in the lowest position on each shift.</span></span>  
  
 <span data-ttu-id="3bd02-3697">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `shl` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3697">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shl` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3698">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3698">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3699">Verschiebt einen ganzzahligen Wert um eine angegebene Anzahl von Bits nach rechts, wobei das Vorzeichen mitgeführt wird, und legt das Ergebnis auf den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3699">Shifts an integer value (in sign) to the right by a specified number of bits, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3700">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3700">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3701">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3701">Format</span></span>|<span data-ttu-id="3bd02-3702">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3702">Assembly Format</span></span>|<span data-ttu-id="3bd02-3703">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3703">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3704">63</span><span class="sxs-lookup"><span data-stu-id="3bd02-3704">63</span></span>|<span data-ttu-id="3bd02-3705">SHR</span><span class="sxs-lookup"><span data-stu-id="3bd02-3705">shr</span></span>|<span data-ttu-id="3bd02-3706">Verschiebt eine Ganzzahl nach rechts (verschiebt das Vorzeichen).</span><span class="sxs-lookup"><span data-stu-id="3bd02-3706">Shifts an integer to the right (shifting in sign).</span></span>|  
  
 <span data-ttu-id="3bd02-3707">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3707">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3708">Ein Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3708">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3709">Die Menge der zu Verschiebe Bits wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3709">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-3710">Die Anzahl der zu Verschiebe enden Bits und der Wert aus dem Stapel. der Wert wird um die angegebene Anzahl von Bits nach rechts verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3710">The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="3bd02-3711">Das Ergebnis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3711">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3712">Die `shr.un` Anweisung verschiebt den Wert (Type `int32`, `int64` oder `native int`) um die angegebene Anzahl von Bits nach rechts.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3712">The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits.</span></span> <span data-ttu-id="3bd02-3713">Die Anzahl der Bits ist ein Wert vom Typ `int32` oder `native int`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3713">The number of bits is a value of type `int32` or `native int`.</span></span> <span data-ttu-id="3bd02-3714">Der Rückgabewert ist nicht angegeben, wenn die Anzahl von Bits, die verschoben werden sollen, größer oder gleich der Breite (in Bits) des angegebenen Werts ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3714">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="3bd02-3715">`Shr` repliziert das hohe Bestell Bit für jede Schicht, wobei das Vorzeichen des ursprünglichen Werts in der `result`beibehalten wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3715">`Shr` replicates the high order bit on each shift, preserving the sign of the original value in the `result`.</span></span>  
  
 <span data-ttu-id="3bd02-3716">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `shr` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3716">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3717">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3717">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3718">Verschiebt einen ganzzahligen Wert ohne Vorzeichen um eine angegebene Anzahl von Bits nach rechts, wobei die frei werdenden Stellen mit 0-Bits aufgefüllt werden, und legt das Ergebnis auf den Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3718">Shifts an unsigned integer value (in zeroes) to the right by a specified number of bits, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3719">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3719">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3720">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3720">Format</span></span>|<span data-ttu-id="3bd02-3721">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3721">Assembly Format</span></span>|<span data-ttu-id="3bd02-3722">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3722">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3723">64</span><span class="sxs-lookup"><span data-stu-id="3bd02-3723">64</span></span>|<span data-ttu-id="3bd02-3724">shr. UN</span><span class="sxs-lookup"><span data-stu-id="3bd02-3724">shr.un</span></span>|<span data-ttu-id="3bd02-3725">Verschiebt eine Ganzzahl nach rechts (Verschiebung in Nullen).</span><span class="sxs-lookup"><span data-stu-id="3bd02-3725">Shifts an integer to the right (shifting in zeroes).</span></span>|  
  
 <span data-ttu-id="3bd02-3726">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3726">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3727">Ein Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3727">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3728">Die Menge der zu Verschiebe Bits wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3728">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-3729">Die Anzahl der zu Verschiebe enden Bits und der Wert aus dem Stapel. der Wert wird um die angegebene Anzahl von Bits nach rechts verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3729">The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="3bd02-3730">Das Ergebnis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3730">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3731">Die `shr.un` Anweisung verschiebt den Wert (Type `int32`, `int64` oder `native int`) um die angegebene Anzahl von Bits nach rechts.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3731">The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits.</span></span> <span data-ttu-id="3bd02-3732">Die Anzahl der Bits ist ein Wert vom Typ `int32`, `int64` oder `native int`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3732">The number of bits is a value of type `int32`, `int64` or `native int`.</span></span> <span data-ttu-id="3bd02-3733">Der Rückgabewert ist nicht angegeben, wenn die Anzahl von Bits, die verschoben werden sollen, größer oder gleich der Breite (in Bits) des angegebenen Werts ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3733">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="3bd02-3734">`Shr.un` fügt bei jeder Schicht ein NULL-Bit an der höchsten Position ein.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3734">`Shr.un` inserts a zero bit in the highest position on each shift.</span></span>  
  
 <span data-ttu-id="3bd02-3735">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `shr.un` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3735">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr.un` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3736">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3736">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3737">Legt die Größe eines bereitgestellten Werttyps in Bytes auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3737">Pushes the size, in bytes, of a supplied value type onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3738">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3738">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3739">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3739">Format</span></span>|<span data-ttu-id="3bd02-3740">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3740">Assembly Format</span></span>|<span data-ttu-id="3bd02-3741">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3741">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3742">FE 1C < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-3742">FE 1C < `T` ></span></span>|<span data-ttu-id="3bd02-3743">sizeof-`valType`</span><span class="sxs-lookup"><span data-stu-id="3bd02-3743">sizeof `valType`</span></span>|<span data-ttu-id="3bd02-3744">Überträgt die Größe eines Werttyps in Bytes als `unsigned int32`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3744">Push the size, in bytes, of a value type as an `unsigned int32`.</span></span>|  
  
 <span data-ttu-id="3bd02-3745">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3745">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3746">Die Größe (in Bytes) des bereitgestellten Werttyps (`valType`) wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3746">The size (in bytes) of the supplied value type (`valType`) is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3747">`valType` muss ein Metadatentoken (ein `typeref` oder `typedef`) sein, das einen Werttyp, Verweistyp oder einen generischen Typparameter angibt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3747">`valType` must be a metadata token (a `typeref` or `typedef`) that specifies a value type, reference type, or generic type parameter.</span></span>  
  
 <span data-ttu-id="3bd02-3748">Bei einem Verweistyp ist die zurückgegebene Größe die Größe eines Verweis Werts des entsprechenden Typs (4 Bytes auf 32-Bit-Systemen), nicht die Größe der Daten, die in Objekten gespeichert werden, auf die durch den Verweis Wert verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3748">For a reference type, the size returned is the size of a reference value of the corresponding type (4 bytes on 32-bit systems), not the size of the data stored in objects referred to by the reference value.</span></span> <span data-ttu-id="3bd02-3749">Ein generischer Typparameter kann nur im Text des Typs oder der Methode verwendet werden, der ihn definiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3749">A generic type parameter can be used only in the body of the type or method that defines it.</span></span> <span data-ttu-id="3bd02-3750">Wenn dieser Typ oder diese Methode instanziiert wird, wird der generische Typparameter durch einen Werttyp oder Verweistyp ersetzt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3750">When that type or method is instantiated, the generic type parameter is replaced by a value type or reference type.</span></span>  
  
 <span data-ttu-id="3bd02-3751">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `sizeof` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3751">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sizeof` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3752">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3752">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3753">Speichert den an der obersten Position des Auswertungsstapels befindlichen Wert im Argumentslot an einem angegebenen Index.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3753">Stores the value on top of the evaluation stack in the argument slot at a specified index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3754">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3754">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3755">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3755">Format</span></span>|<span data-ttu-id="3bd02-3756">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3756">Assembly Format</span></span>|<span data-ttu-id="3bd02-3757">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3757">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3758">FE 0B < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-3758">FE 0B < `unsigned int16` ></span></span>|<span data-ttu-id="3bd02-3759">starg-`num`</span><span class="sxs-lookup"><span data-stu-id="3bd02-3759">starg `num`</span></span>|<span data-ttu-id="3bd02-3760">Holt den obersten Wert aus dem Stapel und speichert ihn in Argument Slot `num`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3760">Pops the top value from the stack and stores it in argument slot `num`.</span></span>|  
  
 <span data-ttu-id="3bd02-3761">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3761">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3762">Der Wert, der sich derzeit oberhalb des Stapels befindet, wird per Pop ausgerückt und in Argument Slot `num`platziert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3762">The value currently on top of the stack is popped and placed in argument slot `num`.</span></span>  
  
 <span data-ttu-id="3bd02-3763">Die `starg`-Anweisung holt einen Wert aus dem Stapel und platziert Sie in Argument Slot `num`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3763">The `starg` instruction pops a value from the stack and places it in argument slot `num`.</span></span> <span data-ttu-id="3bd02-3764">Der Typ des Werts muss mit dem Typ des Arguments identisch sein, wie in der Signatur der aktuellen Methode angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3764">The type of the value must match the type of the argument, as specified in the current method's signature.</span></span>  
  
 <span data-ttu-id="3bd02-3765">Für Prozeduren, die eine Variable Argumentliste akzeptieren, kann die `starg` Anweisung nur für die anfänglichen Fixed-Argumente verwendet werden, nicht für die Argumente im Variablen Teil der Signatur.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3765">For procedures that take a variable argument list, the `starg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="3bd02-3766">Durch das Ausführen eines Stores in Argumenten mit einem ganzzahligen Wert, der kleiner als 4 Bytes ist, wird der Wert abgeschnitten, wenn er vom Stapel zum-Argument verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3766">Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</span></span> <span data-ttu-id="3bd02-3767">Gleit Komma Werte werden von ihrer nativen Größe (Type `F`) auf die Größe gerundet, die dem Argument zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3767">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="3bd02-3768">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `starg` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3768">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `starg` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3769">ILGenerator. ausgeben (OpCode, Short)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3769">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3770">Speichert den an der obersten Position des Auswertungsstapels befindlichen Wert im Argumentslot an einem angegebenen Index, Kurzform.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3770">Stores the value on top of the evaluation stack in the argument slot at a specified index, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3771">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3771">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3772">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3772">Format</span></span>|<span data-ttu-id="3bd02-3773">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3773">Assembly Format</span></span>|<span data-ttu-id="3bd02-3774">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3774">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3775">10 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-3775">10 < `unsigned int8` ></span></span>|<span data-ttu-id="3bd02-3776">starg. s `num`</span><span class="sxs-lookup"><span data-stu-id="3bd02-3776">starg.s `num`</span></span>|<span data-ttu-id="3bd02-3777">Holt den obersten Wert aus dem Stapel und speichert ihn im Argument Slot `num`Kurzform.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3777">Pops the top value from the stack and stores it in argument slot `num`, short form.</span></span>|  
  
 <span data-ttu-id="3bd02-3778">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3778">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3779">Der Wert, der sich derzeit oberhalb des Stapels befindet, wird per Pop ausgerückt und in Argument Slot `num`platziert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3779">The value currently on top of the stack is popped and placed in argument slot `num`.</span></span>  
  
 <span data-ttu-id="3bd02-3780">Die `starg.s`-Anweisung holt einen Wert aus dem Stapel und platziert Sie in Argument Slot `num`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3780">The `starg.s` instruction pops a value from the stack and places it in argument slot `num`.</span></span> <span data-ttu-id="3bd02-3781">Der Typ des Werts muss mit dem Typ des Arguments identisch sein, wie in der Signatur der aktuellen Methode angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3781">The type of the value must match the type of the argument, as specified in the current method's signature.</span></span>  
  
 <span data-ttu-id="3bd02-3782">Die `starg.s`-Anweisung bietet eine effiziente Codierung für die Verwendung mit den ersten 256-Argumenten.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3782">The `starg.s` instruction provides an efficient encoding for use with the first 256 arguments.</span></span>  
  
 <span data-ttu-id="3bd02-3783">Für Prozeduren, die eine Variable Argumentliste akzeptieren, kann die `starg.s` Anweisung nur für die anfänglichen Fixed-Argumente verwendet werden, nicht für die Argumente im Variablen Teil der Signatur.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3783">For procedures that take a variable argument list, the `starg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="3bd02-3784">Durch das Ausführen eines Stores in Argumenten mit einem ganzzahligen Wert, der kleiner als 4 Bytes ist, wird der Wert abgeschnitten, wenn er vom Stapel zum-Argument verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3784">Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</span></span> <span data-ttu-id="3bd02-3785">Gleit Komma Werte werden von ihrer nativen Größe (Type `F`) auf die Größe gerundet, die dem Argument zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3785">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="3bd02-3786">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `starg.s` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3786">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `starg.s` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3787">ILGenerator.Emit(OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3787">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3788">Ersetzt das Arrayelement am angegebenen Index durch den Wert im Auswertungsstapel, dessen Typ in der Anweisung angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3788">Replaces the array element at a given index with the value on the evaluation stack, whose type is specified in the instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3789">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3789">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3790">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3790">Format</span></span>|<span data-ttu-id="3bd02-3791">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3791">Assembly Format</span></span>|<span data-ttu-id="3bd02-3792">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3792">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3793">A4 < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-3793">A4 < `T` ></span></span>|<span data-ttu-id="3bd02-3794">stelem-`typeTok`</span><span class="sxs-lookup"><span data-stu-id="3bd02-3794">stelem `typeTok`</span></span>|<span data-ttu-id="3bd02-3795">Ersetzt das Array Element am angegebenen Index durch einen Wert vom Typ `typeTok` auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3795">Replaces the array element at the supplied index with a value of type `typeTok` on the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-3796">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3796">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3797">Ein Objekt Verweis auf ein Array, `array`, wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3797">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3798">Ein Indexwert `index`zu einem Element in `array` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3798">An index value, `index`, to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-3799">Ein Wert des in der Anweisung angegebenen Typs wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3799">A value of the type specified in the instruction is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="3bd02-3800">Der Wert, der Index und der Array Verweis werden aus dem Stapel entfernt. der Wert wird in das Array Element am angegebenen Index eingefügt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3800">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="3bd02-3801">Die `stelem` Anweisung ersetzt den Wert des Elements am angegebenen Null basierten Index im eindimensionalen Array `array` mit dem Wert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3801">The `stelem` instruction replaces the value of the element at the supplied zero-based index in the one-dimensional array `array` with the value.</span></span> <span data-ttu-id="3bd02-3802">Der-Wert weist den Typ auf, der durch das Token `typeTok` in der Anweisung angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3802">The value has the type specified by the token `typeTok` in the instruction.</span></span>  
  
 <span data-ttu-id="3bd02-3803">Arrays sind Objekte und werden daher durch einen Wert vom Typ `O`dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3803">Arrays are objects, and hence represented by a value of type `O`.</span></span> <span data-ttu-id="3bd02-3804">Der Index ist vom Typ `native int`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3804">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="3bd02-3805"><xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3805"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-3806"><xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` negativ oder größer als die gebundene `array`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3806"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="3bd02-3807"><xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3807"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="3bd02-3808">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `stelem` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3808">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3809">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3809">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3810">Ersetzt das Arrayelement am angegebenen Index durch den <see langword="native int" />-Wert im Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3810">Replaces the array element at a given index with the <see langword="native int" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3811">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3811">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3812">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3812">Format</span></span>|<span data-ttu-id="3bd02-3813">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3813">Assembly Format</span></span>|<span data-ttu-id="3bd02-3814">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3814">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3815">9B</span><span class="sxs-lookup"><span data-stu-id="3bd02-3815">9B</span></span>|<span data-ttu-id="3bd02-3816">stelem.i</span><span class="sxs-lookup"><span data-stu-id="3bd02-3816">stelem.i</span></span>|<span data-ttu-id="3bd02-3817">Ersetzt ein Array Element am angegebenen Index durch den `native int` Wert auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3817">Replaces an array element at the supplied index with the `native int` value on the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-3818">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3818">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3819">Ein Objekt Verweis auf ein Array, `array`, wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3819">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3820">Ein gültiger Index für ein Element in `array` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3820">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-3821">Ein Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3821">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="3bd02-3822">Der Wert, der Index und der Array Verweis werden aus dem Stapel entfernt. der Wert wird in das Array Element am angegebenen Index eingefügt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3822">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="3bd02-3823">Die `stelem.i` Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` durch den `native int` Wert, der auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3823">The `stelem.i` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `native int` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3824">Arrays sind Objekte und werden daher durch einen Wert vom Typ `O`dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3824">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="3bd02-3825">Der Index ist vom Typ `native int`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3825">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="3bd02-3826"><xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3826"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-3827"><xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` negativ oder größer als die gebundene `array`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3827"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="3bd02-3828"><xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3828"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="3bd02-3829">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `stelem.i` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3829">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3830">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3830">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3831">Ersetzt das Arrayelement am angegebenen Index durch den <see langword="int8" />-Wert im Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3831">Replaces the array element at a given index with the <see langword="int8" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3832">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3832">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3833">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3833">Format</span></span>|<span data-ttu-id="3bd02-3834">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3834">Assembly Format</span></span>|<span data-ttu-id="3bd02-3835">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3835">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3836">9C</span><span class="sxs-lookup"><span data-stu-id="3bd02-3836">9C</span></span>|<span data-ttu-id="3bd02-3837">stelem.i1</span><span class="sxs-lookup"><span data-stu-id="3bd02-3837">stelem.i1</span></span>|<span data-ttu-id="3bd02-3838">Ersetzt ein Array Element am angegebenen Index durch den `int8` Wert auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3838">Replaces an array element at the supplied index with the `int8` value on the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-3839">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3839">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3840">Ein Objekt Verweis auf ein Array, `array`, wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3840">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3841">Ein gültiger Index für ein Element in `array` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3841">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-3842">Ein Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3842">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="3bd02-3843">Der Wert, der Index und der Array Verweis werden aus dem Stapel entfernt. der Wert wird in das Array Element am angegebenen Index eingefügt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3843">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="3bd02-3844">Die `stelem.i1` Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` durch den `int8` Wert, der auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3844">The `stelem.i1` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int8` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3845">Arrays sind Objekte und werden daher durch einen Wert vom Typ `O`dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3845">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="3bd02-3846">Der Index ist vom Typ `native int`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3846">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="3bd02-3847"><xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3847"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-3848"><xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` negativ oder größer als die gebundene `array`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3848"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="3bd02-3849"><xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3849"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="3bd02-3850">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `stelem.i1` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3850">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i1` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3851">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3851">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3852">Ersetzt das Arrayelement am angegebenen Index durch den <see langword="int16" />-Wert im Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3852">Replaces the array element at a given index with the <see langword="int16" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3853">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3853">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3854">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3854">Format</span></span>|<span data-ttu-id="3bd02-3855">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3855">Assembly Format</span></span>|<span data-ttu-id="3bd02-3856">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3856">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3857">9D</span><span class="sxs-lookup"><span data-stu-id="3bd02-3857">9D</span></span>|<span data-ttu-id="3bd02-3858">stelem.i2</span><span class="sxs-lookup"><span data-stu-id="3bd02-3858">stelem.i2</span></span>|<span data-ttu-id="3bd02-3859">Ersetzt ein Array Element am angegebenen Index durch den `int16` Wert auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3859">Replaces an array element at the supplied index with the `int16` value on the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-3860">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3860">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3861">Ein Objekt Verweis auf ein Array, `array`, wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3861">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3862">Ein gültiger Index für ein Element in `array` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3862">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-3863">Ein Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3863">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="3bd02-3864">Der Wert, der Index und der Array Verweis werden aus dem Stapel entfernt. der Wert wird in das Array Element am angegebenen Index eingefügt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3864">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="3bd02-3865">Die `stelem.i2` Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` durch den `int16` Wert, der auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3865">The `stelem.i2` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int16` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3866">Arrays sind Objekte und werden daher durch einen Wert vom Typ `O`dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3866">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="3bd02-3867">Der Index ist vom Typ `native int`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3867">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="3bd02-3868"><xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3868"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-3869"><xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` negativ oder größer als die gebundene `array`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3869"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="3bd02-3870"><xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3870"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="3bd02-3871">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `stelem.i2` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3871">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i2` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3872">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3872">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3873">Ersetzt das Arrayelement am angegebenen Index durch den <see langword="int32" />-Wert im Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3873">Replaces the array element at a given index with the <see langword="int32" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3874">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3874">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3875">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3875">Format</span></span>|<span data-ttu-id="3bd02-3876">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3876">Assembly Format</span></span>|<span data-ttu-id="3bd02-3877">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3877">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3878">9E</span><span class="sxs-lookup"><span data-stu-id="3bd02-3878">9E</span></span>|<span data-ttu-id="3bd02-3879">stelem.i4</span><span class="sxs-lookup"><span data-stu-id="3bd02-3879">stelem.i4</span></span>|<span data-ttu-id="3bd02-3880">Ersetzt ein Array Element am angegebenen Index durch den `int32` Wert auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3880">Replaces an array element at the supplied index with the `int32` value on the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-3881">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3881">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3882">Ein Objekt Verweis auf ein Array, `array`, wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3882">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3883">Ein gültiger Index für ein Element in `array` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3883">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-3884">Ein Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3884">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="3bd02-3885">Der Wert, der Index und der Array Verweis werden aus dem Stapel entfernt. der Wert wird in das Array Element am angegebenen Index eingefügt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3885">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="3bd02-3886">Die `stelem.i4` Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` durch den `int32` Wert, der auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3886">The `stelem.i4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int32` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3887">Arrays sind Objekte und werden daher durch einen Wert vom Typ `O`dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3887">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="3bd02-3888">Der Index ist vom Typ `native int`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3888">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="3bd02-3889"><xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3889"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-3890"><xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` negativ oder größer als die gebundene `array`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3890"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="3bd02-3891"><xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3891"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="3bd02-3892">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `stelem.i4` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3892">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i4` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3893">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3893">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3894">Ersetzt das Arrayelement am angegebenen Index durch den <see langword="int64" />-Wert im Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3894">Replaces the array element at a given index with the <see langword="int64" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3895">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3895">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3896">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3896">Format</span></span>|<span data-ttu-id="3bd02-3897">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3897">Assembly Format</span></span>|<span data-ttu-id="3bd02-3898">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3898">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3899">9F</span><span class="sxs-lookup"><span data-stu-id="3bd02-3899">9F</span></span>|<span data-ttu-id="3bd02-3900">stelem.i8</span><span class="sxs-lookup"><span data-stu-id="3bd02-3900">stelem.i8</span></span>|<span data-ttu-id="3bd02-3901">Ersetzt ein Array Element am angegebenen Index durch den `int64` Wert auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3901">Replaces an array element at the supplied index with the `int64` value on the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-3902">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3902">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3903">Ein Objekt Verweis auf ein Array, `array`, wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3903">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3904">Ein gültiger Index für ein Element in `array` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3904">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-3905">Ein Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3905">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="3bd02-3906">Der Wert, der Index und der Array Verweis werden aus dem Stapel entfernt. der Wert wird in das Array Element am angegebenen Index eingefügt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3906">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="3bd02-3907">Die `stelem.i8` Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` durch den `int64` Wert, der auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3907">The `stelem.i8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int64` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3908">Arrays sind Objekte und werden daher durch einen Wert vom Typ `O`dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3908">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="3bd02-3909">Der Index ist vom Typ `native int`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3909">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="3bd02-3910"><xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3910"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-3911"><xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` negativ oder größer als die gebundene `array`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3911"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="3bd02-3912"><xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3912"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="3bd02-3913">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `stelem.i8` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3913">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i8` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3914">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3914">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3915">Ersetzt das Arrayelement am angegebenen Index durch den <see langword="float32" />-Wert im Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3915">Replaces the array element at a given index with the <see langword="float32" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3916">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3916">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3917">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3917">Format</span></span>|<span data-ttu-id="3bd02-3918">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3918">Assembly Format</span></span>|<span data-ttu-id="3bd02-3919">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3919">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3920">A0</span><span class="sxs-lookup"><span data-stu-id="3bd02-3920">A0</span></span>|<span data-ttu-id="3bd02-3921">stelem.r4</span><span class="sxs-lookup"><span data-stu-id="3bd02-3921">stelem.r4</span></span>|<span data-ttu-id="3bd02-3922">Ersetzt ein Array Element am angegebenen Index durch den `float32` Wert auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3922">Replaces an array element at the supplied index with the `float32` value on the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-3923">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3923">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3924">Ein Objekt Verweis auf ein Array, `array`, wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3924">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3925">Ein gültiger Index für ein Element in `array` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3925">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-3926">Ein Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3926">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="3bd02-3927">Der Wert, der Index und der Array Verweis werden aus dem Stapel entfernt. der Wert wird in das Array Element am angegebenen Index eingefügt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3927">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="3bd02-3928">Die `stelem.r4` Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` durch den `float32` Wert, der auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3928">The `stelem.r4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float32` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3929">Arrays sind Objekte und werden daher durch einen Wert vom Typ `O`dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3929">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="3bd02-3930">Der Index ist vom Typ `native int`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3930">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="3bd02-3931"><xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3931"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-3932"><xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` negativ oder größer als die gebundene `array`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3932"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="3bd02-3933"><xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3933"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="3bd02-3934">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `stelem.r4` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3934">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r4` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3935">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3935">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3936">Ersetzt das Arrayelement am angegebenen Index durch den <see langword="float64" />-Wert im Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3936">Replaces the array element at a given index with the <see langword="float64" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3937">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3937">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3938">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3938">Format</span></span>|<span data-ttu-id="3bd02-3939">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3939">Assembly Format</span></span>|<span data-ttu-id="3bd02-3940">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3940">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3941">A1</span><span class="sxs-lookup"><span data-stu-id="3bd02-3941">A1</span></span>|<span data-ttu-id="3bd02-3942">stelem.r8</span><span class="sxs-lookup"><span data-stu-id="3bd02-3942">stelem.r8</span></span>|<span data-ttu-id="3bd02-3943">Ersetzt ein Array Element am angegebenen Index durch den `float64` Wert auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3943">Replaces an array element at the supplied index with the `float64` value on the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-3944">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3944">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3945">Ein Objekt Verweis auf ein Array, `array`, wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3945">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3946">Ein gültiger Index für ein Element in `array` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3946">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-3947">Ein Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3947">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="3bd02-3948">Der Wert, der Index und der Array Verweis werden aus dem Stapel entfernt. der Wert wird in das Array Element am angegebenen Index eingefügt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3948">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="3bd02-3949">Die `stelem.r8` Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` durch den `float64` Wert, der auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3949">The `stelem.r8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float64` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3950">Arrays sind Objekte und werden daher durch einen Wert vom Typ `O`dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3950">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="3bd02-3951">Der Index ist vom Typ `native int`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3951">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="3bd02-3952"><xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3952"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-3953"><xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` negativ oder größer als die gebundene `array`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3953"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="3bd02-3954"><xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3954"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="3bd02-3955">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `stelem.r8` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3955">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r8` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3956">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3956">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3957">Ersetzt das Arrayelement am angegebenen Index durch den Wert des Objektverweises (Typ <see langword="O" />) im Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3957">Replaces the array element at a given index with the object ref value (type <see langword="O" />) on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3958">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3958">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3959">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3959">Format</span></span>|<span data-ttu-id="3bd02-3960">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3960">Assembly Format</span></span>|<span data-ttu-id="3bd02-3961">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3961">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3962">A2</span><span class="sxs-lookup"><span data-stu-id="3bd02-3962">A2</span></span>|<span data-ttu-id="3bd02-3963">stelem.ref</span><span class="sxs-lookup"><span data-stu-id="3bd02-3963">stelem.ref</span></span>|<span data-ttu-id="3bd02-3964">Ersetzt ein Array Element am angegebenen Index durch den `ref` Wert (Type `O`) auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3964">Replaces an array element at the supplied index with the `ref` value (type `O`) on the stack.</span></span>|  
  
 <span data-ttu-id="3bd02-3965">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3965">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3966">Ein Objekt Verweis auf ein Array, `array`, wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3966">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3967">Ein gültiger Index für ein Element in `array` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3967">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-3968">Ein Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3968">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="3bd02-3969">Der Wert, der Index und der Array Verweis werden aus dem Stapel entfernt. der Wert wird in das Array Element am angegebenen Index eingefügt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3969">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="3bd02-3970">Die `stelem.ref` Anweisung ersetzt den Wert des Elements am angegebenen Index im eindimensionalen Array `array` durch den `ref` (Type `O`)-Wert, der auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3970">The `stelem.ref` instruction replaces the value of the element at the supplied index in the one-dimensional array `array` with the `ref` (type `O`) value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-3971">Arrays sind Objekte und werden daher durch einen Wert vom Typ `O`dargestellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3971">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="3bd02-3972">Der Index ist vom Typ `native int`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3972">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="3bd02-3973">Beachten Sie, dass `stelem.ref` den angegebenen Wert implizit in den Elementtyp `array` umwandelt, bevor der Wert dem Array Element zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3973">Note that `stelem.ref` implicitly casts the supplied value to the element type of `array` before assigning the value to the array element.</span></span> <span data-ttu-id="3bd02-3974">Diese Umwandlung kann auch für verifizierten Code fehlschlagen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3974">This cast can fail, even for verified code.</span></span> <span data-ttu-id="3bd02-3975">Daher kann die `stelem.ref` Anweisung <xref:System.InvalidCastException>auslösen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3975">Thus the `stelem.ref` instruction can throw <xref:System.InvalidCastException>.</span></span> <span data-ttu-id="3bd02-3976">Bei eindimensionalen Arrays, die nicht NULL basiert sind, und bei mehrdimensionalen Arrays stellt die <xref:System.Array>-Klasse eine <xref:System.Array.SetValue%2A>-Methode bereit.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3976">For one-dimensional arrays that aren't zero-based and for multidimensional arrays, the <xref:System.Array> class provides a <xref:System.Array.SetValue%2A> method.</span></span>  
  
 <span data-ttu-id="3bd02-3977"><xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3977"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-3978"><xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` negativ oder größer als die gebundene `array`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3978"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="3bd02-3979"><xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3979"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="3bd02-3980">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `stelem.ref` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3980">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.ref` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-3981">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-3981">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-3982">Ersetzt den im Feld eines Objektsverweises oder Zeigers gespeicherten Wert durch einen neuen Wert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3982">Replaces the value stored in the field of an object reference or pointer with a new value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-3983">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3983">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-3984">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-3984">Format</span></span>|<span data-ttu-id="3bd02-3985">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-3985">Assembly Format</span></span>|<span data-ttu-id="3bd02-3986">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-3986">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-3987">7D < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-3987">7D < `T` ></span></span>|<span data-ttu-id="3bd02-3988">stdie `field`</span><span class="sxs-lookup"><span data-stu-id="3bd02-3988">stfld `field`</span></span>|<span data-ttu-id="3bd02-3989">Ersetzt den Wert `field` des-Objekts durch einen neuen Wert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3989">Replaces the value of `field` of the object with a new value.</span></span>|  
  
 <span data-ttu-id="3bd02-3990">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-3990">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-3991">Ein Objekt Verweis oder-Zeiger wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3991">An object reference or pointer is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-3992">Ein Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3992">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-3993">Der Wert und der Objekt Verweis/-Zeiger werden aus dem Stapel entfernt. der Wert `field` im-Objekt wird durch den angegebenen Wert ersetzt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3993">The value and the object reference/pointer are popped from the stack; the value of `field` in the object is replaced with the supplied value.</span></span>  
  
 <span data-ttu-id="3bd02-3994">Die `stfld` Anweisung ersetzt den Wert eines Felds eines Objekts (Type `O`) oder über einen Zeiger (Typ `native int`, `&`oder `*`) mit einem angegebenen Wert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3994">The `stfld` instruction replaces the value of a field of an object (type `O`) or via a pointer (type `native int`, `&`, or `*`) with a given value.</span></span> <span data-ttu-id="3bd02-3995">`Field` ist ein Metadatentoken, das auf einen Feld Element Verweis verweist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3995">`Field` is a metadata token that refers to a field member reference.</span></span> <span data-ttu-id="3bd02-3996">Die `stfld`-Anweisung kann ein Präfix von entweder <xref:System.Reflection.Emit.OpCodes.Unaligned> und <xref:System.Reflection.Emit.OpCodes.Volatile>haben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3996">The `stfld` instruction can have a prefix of either or both of <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile>.</span></span>  
  
 <span data-ttu-id="3bd02-3997"><xref:System.NullReferenceException> wird ausgelöst, wenn der Objekt Verweis oder Zeiger ein NULL-Verweis ist und das Feld nicht statisch ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3997"><xref:System.NullReferenceException> is thrown if the object reference or pointer is a null reference and the field isn't static.</span></span>  
  
 <span data-ttu-id="3bd02-3998"><xref:System.MissingFieldException> wird ausgelöst, wenn `field` in den Metadaten nicht gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3998"><xref:System.MissingFieldException> is thrown if `field` is not found in the metadata.</span></span> <span data-ttu-id="3bd02-3999">Dies wird in der Regel geprüft, wenn die MSIL-Anweisung (Microsoft Intermediate Language) in nativen Code konvertiert wird, nicht zur Laufzeit.</span><span class="sxs-lookup"><span data-stu-id="3bd02-3999">This is typically checked when the Microsoft Intermediate Language (MSIL) instruction is converted to native code, not at runtime.</span></span>  
  
 <span data-ttu-id="3bd02-4000">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `stfld` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4000">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stfld` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-4001">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4001">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-4002">Speichert einen Wert vom Typ <see langword="native int" /> an einer angegebenen Adresse.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4002">Stores a value of type <see langword="native int" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4003">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4003">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-4004">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-4004">Format</span></span>|<span data-ttu-id="3bd02-4005">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-4005">Assembly Format</span></span>|<span data-ttu-id="3bd02-4006">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-4006">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-4007">DF</span><span class="sxs-lookup"><span data-stu-id="3bd02-4007">DF</span></span>|<span data-ttu-id="3bd02-4008">stind. i</span><span class="sxs-lookup"><span data-stu-id="3bd02-4008">stind.i</span></span>|<span data-ttu-id="3bd02-4009">Speichert einen `native int` Wert an einer angegebenen Adresse.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4009">Stores a `native int` value at a given address.</span></span>|  
  
 <span data-ttu-id="3bd02-4010">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4010">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-4011">Eine Adresse wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4011">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-4012">Ein Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4012">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-4013">Der Wert und die Adresse werden aus dem Stapel entfernt. der Wert wird bei der Adresse gespeichert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4013">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="3bd02-4014">Die `stind.i` Anweisung speichert einen `native int` Wert an der angegebenen Adresse (Typ `native int`, `*`oder `&`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-4014">The `stind.i` instruction stores a `native int` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="3bd02-4015">Der typsichere Vorgang erfordert, dass die `stind.i` Anweisung in Übereinstimmung mit dem Typ des Zeigers verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4015">Type safe operation requires that the `stind.i` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="3bd02-4016">Der Vorgang der `stind.i` Anweisung kann durch eine unmittelbar vorangehende <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung geändert werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4016">The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="3bd02-4017"><xref:System.NullReferenceException> wird ausgelöst, wenn `addr` nicht auf natürliche Weise für den Argumenttyp ausgerichtet ist, der durch das Anweisungs Suffix impliziert wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4017"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="3bd02-4018">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `stind.i` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4018">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-4019">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4019">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-4020">Speichert einen Wert vom Typ <see langword="int8" /> an einer angegebenen Adresse.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4020">Stores a value of type <see langword="int8" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4021">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4021">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-4022">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-4022">Format</span></span>|<span data-ttu-id="3bd02-4023">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-4023">Assembly Format</span></span>|<span data-ttu-id="3bd02-4024">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-4024">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-4025">52</span><span class="sxs-lookup"><span data-stu-id="3bd02-4025">52</span></span>|<span data-ttu-id="3bd02-4026">stind. I1</span><span class="sxs-lookup"><span data-stu-id="3bd02-4026">stind.i1</span></span>|<span data-ttu-id="3bd02-4027">Speichert einen `int8` Wert an einer angegebenen Adresse.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4027">Stores an `int8` value at a given address.</span></span>|  
  
 <span data-ttu-id="3bd02-4028">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4028">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-4029">Eine Adresse wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4029">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-4030">Ein Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4030">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-4031">Der Wert und die Adresse werden aus dem Stapel entfernt. der Wert wird bei der Adresse gespeichert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4031">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="3bd02-4032">Die `stind.i1`-Anweisung speichert einen `int8`-Wert an der angegebenen Adresse (Typ `native int`, `*`oder `&`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-4032">The `stind.i1` instruction stores an `int8` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="3bd02-4033">Der typsichere Vorgang erfordert, dass die `stind.i1` Anweisung in Übereinstimmung mit dem Typ des Zeigers verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4033">Type safe operation requires that the `stind.i1` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="3bd02-4034">Der Vorgang der `stind.i1` Anweisung kann durch eine unmittelbar vorangehende <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung geändert werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4034">The operation of the `stind.i1` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="3bd02-4035"><xref:System.NullReferenceException> wird ausgelöst, wenn `addr` nicht auf natürliche Weise für den Argumenttyp ausgerichtet ist, der durch das Anweisungs Suffix impliziert wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4035"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="3bd02-4036">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `stind.i1` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4036">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i1` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-4037">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4037">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-4038">Speichert einen Wert vom Typ <see langword="int16" /> an einer angegebenen Adresse.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4038">Stores a value of type <see langword="int16" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4039">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4039">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-4040">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-4040">Format</span></span>|<span data-ttu-id="3bd02-4041">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-4041">Assembly Format</span></span>|<span data-ttu-id="3bd02-4042">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-4042">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-4043">53</span><span class="sxs-lookup"><span data-stu-id="3bd02-4043">53</span></span>|<span data-ttu-id="3bd02-4044">stind.i2</span><span class="sxs-lookup"><span data-stu-id="3bd02-4044">stind.i2</span></span>|<span data-ttu-id="3bd02-4045">Speichert einen `int16` Wert an einer angegebenen Adresse.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4045">Stores an `int16` value at a given address.</span></span>|  
  
 <span data-ttu-id="3bd02-4046">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4046">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-4047">Eine Adresse wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4047">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-4048">Ein Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4048">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-4049">Der Wert und die Adresse werden aus dem Stapel entfernt. der Wert wird bei der Adresse gespeichert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4049">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="3bd02-4050">Die `stind.i2`-Anweisung speichert einen `int16`-Wert an der angegebenen Adresse (Typ `native int`, `*`oder `&`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-4050">The `stind.i2` instruction stores an `int16` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="3bd02-4051">Der typsichere Vorgang erfordert, dass die `stind.2i` Anweisung in Übereinstimmung mit dem Typ des Zeigers verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4051">Type safe operation requires that the `stind.2i` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="3bd02-4052">Der Vorgang der `stind.i2` Anweisung kann durch eine unmittelbar vorangehende <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung geändert werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4052">The operation of the `stind.i2` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="3bd02-4053"><xref:System.NullReferenceException> wird ausgelöst, wenn `addr` nicht auf natürliche Weise für den Argumenttyp ausgerichtet ist, der durch das Anweisungs Suffix impliziert wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4053"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="3bd02-4054">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `stind.i2` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4054">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i2` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-4055">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4055">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-4056">Speichert einen Wert vom Typ <see langword="int32" /> an einer angegebenen Adresse.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4056">Stores a value of type <see langword="int32" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4057">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4057">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-4058">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-4058">Format</span></span>|<span data-ttu-id="3bd02-4059">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-4059">Assembly Format</span></span>|<span data-ttu-id="3bd02-4060">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-4060">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-4061">54</span><span class="sxs-lookup"><span data-stu-id="3bd02-4061">54</span></span>|<span data-ttu-id="3bd02-4062">stind. I4</span><span class="sxs-lookup"><span data-stu-id="3bd02-4062">stind.i4</span></span>|<span data-ttu-id="3bd02-4063">Speichert einen `int32` Wert an einer angegebenen Adresse.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4063">Stores an `int32` value at a given address.</span></span>|  
  
 <span data-ttu-id="3bd02-4064">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4064">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-4065">Eine Adresse wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4065">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-4066">Ein Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4066">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-4067">Der Wert und die Adresse werden aus dem Stapel entfernt. der Wert wird bei der Adresse gespeichert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4067">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="3bd02-4068">Die `stind.i4`-Anweisung speichert einen `int32`-Wert an der angegebenen Adresse (Typ `native int`, `*`oder `&`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-4068">The `stind.i4` instruction stores an `int32` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="3bd02-4069">Der typsichere Vorgang erfordert, dass die `stind.i4` Anweisung in Übereinstimmung mit dem Typ des Zeigers verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4069">Type safe operation requires that the `stind.i4` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="3bd02-4070">Der Vorgang der `stind.i4` Anweisung kann durch eine unmittelbar vorangehende <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung geändert werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4070">The operation of the `stind.i4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="3bd02-4071"><xref:System.NullReferenceException> wird ausgelöst, wenn `addr` nicht auf natürliche Weise für den Argumenttyp ausgerichtet ist, der durch das Anweisungs Suffix impliziert wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4071"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="3bd02-4072">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `stind.i4` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4072">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i4` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-4073">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4073">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-4074">Speichert einen Wert vom Typ <see langword="int64" /> an einer angegebenen Adresse.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4074">Stores a value of type <see langword="int64" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4075">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4075">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-4076">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-4076">Format</span></span>|<span data-ttu-id="3bd02-4077">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-4077">Assembly Format</span></span>|<span data-ttu-id="3bd02-4078">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-4078">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-4079">55</span><span class="sxs-lookup"><span data-stu-id="3bd02-4079">55</span></span>|<span data-ttu-id="3bd02-4080">stind. I8</span><span class="sxs-lookup"><span data-stu-id="3bd02-4080">stind.i8</span></span>|<span data-ttu-id="3bd02-4081">Speichert einen `int64` Wert an einer angegebenen Adresse.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4081">Stores an `int64` value at a given address.</span></span>|  
  
 <span data-ttu-id="3bd02-4082">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4082">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-4083">Eine Adresse wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4083">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-4084">Ein Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4084">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-4085">Der Wert und die Adresse werden aus dem Stapel entfernt. der Wert wird bei der Adresse gespeichert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4085">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="3bd02-4086">Die `stind.i8`-Anweisung speichert einen `int64`-Wert an der angegebenen Adresse (Typ `native int`, `*`oder `&`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-4086">The `stind.i8` instruction stores an `int64` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="3bd02-4087">Der typsichere Vorgang erfordert, dass die `stind.i8` Anweisung in Übereinstimmung mit dem Typ des Zeigers verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4087">Type safe operation requires that the `stind.i8` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="3bd02-4088">Der Vorgang der `stind.i` Anweisung kann durch eine unmittelbar vorangehende <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung geändert werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4088">The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="3bd02-4089"><xref:System.NullReferenceException> wird ausgelöst, wenn `addr` nicht auf natürliche Weise für den Argumenttyp ausgerichtet ist, der durch das Anweisungs Suffix impliziert wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4089"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="3bd02-4090">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `stind.i8` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4090">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i8` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-4091">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4091">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-4092">Speichert einen Wert vom Typ <see langword="float32" /> an einer angegebenen Adresse.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4092">Stores a value of type <see langword="float32" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4093">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4093">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-4094">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-4094">Format</span></span>|<span data-ttu-id="3bd02-4095">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-4095">Assembly Format</span></span>|<span data-ttu-id="3bd02-4096">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-4096">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-4097">56</span><span class="sxs-lookup"><span data-stu-id="3bd02-4097">56</span></span>|<span data-ttu-id="3bd02-4098">stind. R4</span><span class="sxs-lookup"><span data-stu-id="3bd02-4098">stind.r4</span></span>|<span data-ttu-id="3bd02-4099">Speichert einen `float32` Wert an einer angegebenen Adresse.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4099">Stores a `float32` value at a given address.</span></span>|  
  
 <span data-ttu-id="3bd02-4100">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4100">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-4101">Eine Adresse wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4101">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-4102">Ein Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4102">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-4103">Der Wert und die Adresse werden aus dem Stapel entfernt. der Wert wird bei der Adresse gespeichert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4103">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="3bd02-4104">Die `stind.r4` Anweisung speichert einen `float32` Wert an der angegebenen Adresse (Typ `native int`, `*`oder `&`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-4104">The `stind.r4` instruction stores a `float32` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="3bd02-4105">Der typsichere Vorgang erfordert, dass die `stind.r4` Anweisung in Übereinstimmung mit dem Typ des Zeigers verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4105">Type safe operation requires that the `stind.r4` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="3bd02-4106">Der Vorgang der `stind.r4` Anweisung kann durch eine unmittelbar vorangehende <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung geändert werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4106">The operation of the `stind.r4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="3bd02-4107"><xref:System.NullReferenceException> wird ausgelöst, wenn `addr` nicht auf natürliche Weise für den Argumenttyp ausgerichtet ist, der durch das Anweisungs Suffix impliziert wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4107"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="3bd02-4108">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `stind.r4` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4108">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r4` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-4109">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4109">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-4110">Speichert einen Wert vom Typ <see langword="float64" /> an einer angegebenen Adresse.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4110">Stores a value of type <see langword="float64" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4111">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4111">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-4112">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-4112">Format</span></span>|<span data-ttu-id="3bd02-4113">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-4113">Assembly Format</span></span>|<span data-ttu-id="3bd02-4114">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-4114">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-4115">57</span><span class="sxs-lookup"><span data-stu-id="3bd02-4115">57</span></span>|<span data-ttu-id="3bd02-4116">stind. R8</span><span class="sxs-lookup"><span data-stu-id="3bd02-4116">stind.r8</span></span>|<span data-ttu-id="3bd02-4117">Speichert einen `float64` Wert an einer angegebenen Adresse.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4117">Stores a `float64` value at a given address.</span></span>|  
  
 <span data-ttu-id="3bd02-4118">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4118">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-4119">Eine Adresse wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4119">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-4120">Ein Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4120">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-4121">Der Wert und die Adresse werden aus dem Stapel entfernt. der Wert wird bei der Adresse gespeichert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4121">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="3bd02-4122">Die `stind.r8` Anweisung speichert einen `float64` Wert an der angegebenen Adresse (Typ `native int`, `*`oder `&`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-4122">The `stind.r8` instruction stores a `float64` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="3bd02-4123">Der typsichere Vorgang erfordert, dass die `stind.r8` Anweisung in Übereinstimmung mit dem Typ des Zeigers verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4123">Type safe operation requires that the `stind.r8` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="3bd02-4124">Der Vorgang der `stind.r8` Anweisung kann durch eine unmittelbar vorangehende <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung geändert werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4124">The operation of the `stind.r8` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="3bd02-4125"><xref:System.NullReferenceException> wird ausgelöst, wenn `addr` nicht auf natürliche Weise für den Argumenttyp ausgerichtet ist, der durch das Anweisungs Suffix impliziert wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4125"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="3bd02-4126">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `stind.r8` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4126">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r8` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-4127">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4127">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-4128">Speichert einen Objektverweiswert an einer angegebenen Adresse.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4128">Stores a object reference value at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4129">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4129">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-4130">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-4130">Format</span></span>|<span data-ttu-id="3bd02-4131">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-4131">Assembly Format</span></span>|<span data-ttu-id="3bd02-4132">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-4132">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-4133">51</span><span class="sxs-lookup"><span data-stu-id="3bd02-4133">51</span></span>|<span data-ttu-id="3bd02-4134">stind.ref</span><span class="sxs-lookup"><span data-stu-id="3bd02-4134">stind.ref</span></span>|<span data-ttu-id="3bd02-4135">Speichert einen Objekt Verweis (Type `O`)-Wert an einer angegebenen Adresse.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4135">Stores an object reference (type `O`) value at a given address.</span></span>|  
  
 <span data-ttu-id="3bd02-4136">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4136">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-4137">Eine Adresse wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4137">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-4138">Ein Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4138">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-4139">Der Wert und die Adresse werden aus dem Stapel entfernt. der Wert wird bei der Adresse gespeichert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4139">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="3bd02-4140">Die `stind.ref` Anweisung speichert einen Objekt Verweis Wert an der angegebenen Adresse (Typ `native int`, `*`oder `&`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-4140">The `stind.ref` instruction stores an object reference value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="3bd02-4141">Der typsichere Vorgang erfordert, dass die `stind.ref` Anweisung in Übereinstimmung mit dem Typ des Zeigers verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4141">Type safe operation requires that the `stind.ref` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="3bd02-4142">Der Vorgang der `stind.ref` Anweisung kann durch eine unmittelbar vorangehende <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung geändert werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4142">The operation of the `stind.ref` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="3bd02-4143"><xref:System.NullReferenceException> wird ausgelöst, wenn `addr` nicht auf natürliche Weise für den Argumenttyp ausgerichtet ist, der durch das Anweisungs Suffix impliziert wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4143"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="3bd02-4144">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `stind.ref` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4144">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.ref` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-4145">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4145">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-4146">Holt den aktuellen Wert von der obersten Position des Auswertungsstapels und speichert ihn in der Liste der lokalen Variablen am angegebenen Index.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4146">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a specified index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4147">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4147">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-4148">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-4148">Format</span></span>|<span data-ttu-id="3bd02-4149">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-4149">Assembly Format</span></span>|<span data-ttu-id="3bd02-4150">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-4150">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-4151">FE 0E < `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-4151">FE 0E < `unsigned int16` ></span></span>|<span data-ttu-id="3bd02-4152">stloc-`index`</span><span class="sxs-lookup"><span data-stu-id="3bd02-4152">stloc `index`</span></span>|<span data-ttu-id="3bd02-4153">Holt einen Wert aus dem Stapel und speichert ihn in der lokalen Variablen `index`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4153">Pops a value from the stack and stores it in local variable `index`.</span></span>|  
  
 <span data-ttu-id="3bd02-4154">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4154">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-4155">Ein Wert wird aus dem Stapel entfernt und in der lokalen Variablen `index`platziert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4155">A value is popped off of the stack and placed in local variable `index`.</span></span>  
  
 <span data-ttu-id="3bd02-4156">Die `stloc`-Anweisung holt den obersten Wert aus dem Auswertungs Stapel und verschiebt ihn in die Nummer `index`der lokalen Variablen, wobei lokale Variablen auf 0 (null) nummerieren.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4156">The `stloc` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="3bd02-4157">Der Typ des Werts muss mit dem Typ der lokalen Variablen identisch sein, wie in der lokalen Signatur der aktuellen Methode angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4157">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="3bd02-4158">Beim Speichern in lokale Variablen, die einen ganzzahligen Wert kleiner als 4 Bytes enthalten, wird der Wert abgeschnitten, wenn er vom Stapel zur lokalen Variablen verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4158">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="3bd02-4159">Gleit Komma Werte werden von ihrer nativen Größe (Type `F`) auf die Größe gerundet, die dem Argument zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4159">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="3bd02-4160">Zum Korrigieren von MSIL-Anweisungen (Microsoft Intermediate Language) müssen `index` ein gültiger lokaler Index sein.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4160">Correct Microsoft Intermediate Language (MSIL) instructions require that `index` be a valid local index.</span></span> <span data-ttu-id="3bd02-4161">Für die `stloc`-Anweisung müssen `index` im Bereich von 0 bis 65534 einschließlich liegen (insbesondere 65535 ist ungültig).</span><span class="sxs-lookup"><span data-stu-id="3bd02-4161">For the `stloc` instruction, `index` must lie in the range 0 to 65534 inclusive (specifically, 65535 is not valid).</span></span> <span data-ttu-id="3bd02-4162">Der Grund für das Ausschließen von 65535 ist pragmatisch: wahrscheinliche Implementierungen verwenden eine 2-Byte-Ganzzahl, um sowohl den Index eines lokalen als auch die Gesamtzahl der lokalen Variablen für eine bestimmte Methode zu verfolgen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4162">The reason for excluding 65535 is pragmatic: likely implementations will use a 2-byte integer to track both a local's index, as well as the total number of locals for a given method.</span></span> <span data-ttu-id="3bd02-4163">Wenn ein Index von 65535 als gültig fest gegeben wurde, wäre eine breitere Ganzzahl erforderlich, um die Anzahl der lokalen Variablen in einer solchen Methode zu verfolgen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4163">If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</span></span>  
  
 <span data-ttu-id="3bd02-4164">Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladungen können den `stloc` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4164">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-4165">ILGenerator. ausgeben (OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4165">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="3bd02-4166">ILGenerator. ausgeben (OpCode, Short)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4166">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-4167">Holt den aktuellen Wert von der obersten Position des Auswertungsstapels und speichert ihn in der Liste der lokalen Variablen am Index 0.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4167">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 0.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4168">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4168">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-4169">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-4169">Format</span></span>|<span data-ttu-id="3bd02-4170">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-4170">Assembly Format</span></span>|<span data-ttu-id="3bd02-4171">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-4171">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-4172">0a</span><span class="sxs-lookup"><span data-stu-id="3bd02-4172">0A</span></span>|<span data-ttu-id="3bd02-4173">stloc. 0</span><span class="sxs-lookup"><span data-stu-id="3bd02-4173">stloc.0</span></span>|<span data-ttu-id="3bd02-4174">Holt einen Wert aus dem Stapel in die lokale Variable 0.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4174">Pops a value from the stack into local variable 0.</span></span>|  
  
 <span data-ttu-id="3bd02-4175">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4175">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-4176">Ein Wert wird aus dem Stapel entfernt und in der lokalen, von 0 indizierten Variablen platziert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4176">A value is popped off of the stack and placed in the local variable indexed by 0.</span></span>  
  
 <span data-ttu-id="3bd02-4177">Die `stloc.0`-Anweisung holt den obersten Wert aus dem Auswertungs Stapel und verschiebt ihn in die von 0 indizierte lokale Variable.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4177">The `stloc.0` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 0.</span></span> <span data-ttu-id="3bd02-4178">Der Typ des Werts muss mit dem Typ der lokalen Variablen identisch sein, wie in der lokalen Signatur der aktuellen Methode angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4178">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="3bd02-4179">`stloc.0` ist eine besonders effiziente Codierung zum Speichern von Werten in der lokalen Variablen 0.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4179">`stloc.0` is an especially efficient encoding for storing values in local variable 0.</span></span>  
  
 <span data-ttu-id="3bd02-4180">Beim Speichern in lokale Variablen, die einen ganzzahligen Wert kleiner als 4 Bytes enthalten, wird der Wert abgeschnitten, wenn er vom Stapel zur lokalen Variablen verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4180">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="3bd02-4181">Gleit Komma Werte werden von ihrer nativen Größe (Type `F`) auf die Größe gerundet, die dem Argument zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4181">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="3bd02-4182">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `stloc.0` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4182">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.0` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-4183">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4183">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-4184">Holt den aktuellen Wert von der obersten Position des Auswertungsstapels und speichert ihn in der Liste der lokalen Variablen am Index 1.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4184">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 1.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4185">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4185">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-4186">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-4186">Format</span></span>|<span data-ttu-id="3bd02-4187">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-4187">Assembly Format</span></span>|<span data-ttu-id="3bd02-4188">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-4188">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-4189">0 B</span><span class="sxs-lookup"><span data-stu-id="3bd02-4189">0B</span></span>|<span data-ttu-id="3bd02-4190">stloc. 1</span><span class="sxs-lookup"><span data-stu-id="3bd02-4190">stloc.1</span></span>|<span data-ttu-id="3bd02-4191">Holt einen Wert aus dem Stapel in die lokale Variable 1.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4191">Pops a value from the stack into local variable 1.</span></span>|  
  
 <span data-ttu-id="3bd02-4192">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4192">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-4193">Ein Wert wird aus dem Stapel entfernt und in der lokalen, von 1 indizierten Variablen platziert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4193">A value is popped off of the stack and placed in the local variable indexed by 1.</span></span>  
  
 <span data-ttu-id="3bd02-4194">Die `stloc.1`-Anweisung holt den obersten Wert aus dem Auswertungs Stapel und verschiebt ihn in die von 1 indizierte lokale Variable.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4194">The `stloc.1` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 1.</span></span> <span data-ttu-id="3bd02-4195">Der Typ des Werts muss mit dem Typ der lokalen Variablen identisch sein, wie in der lokalen Signatur der aktuellen Methode angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4195">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="3bd02-4196">`stloc.1` ist eine besonders effiziente Codierung zum Speichern von Werten in der lokalen Variablen 1.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4196">`stloc.1` is an especially efficient encoding for storing values in local variable 1.</span></span>  
  
 <span data-ttu-id="3bd02-4197">Beim Speichern in lokale Variablen, die einen ganzzahligen Wert kleiner als 4 Bytes enthalten, wird der Wert abgeschnitten, wenn er vom Stapel zur lokalen Variablen verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4197">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="3bd02-4198">Gleit Komma Werte werden von ihrer nativen Größe (Type `F`) auf die Größe gerundet, die dem Argument zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4198">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="3bd02-4199">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `stloc.1` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4199">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.1` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-4200">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4200">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-4201">Holt den aktuellen Wert von der obersten Position des Auswertungsstapels und speichert ihn in der Liste der lokalen Variablen am Index 2.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4201">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 2.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4202">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4202">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-4203">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-4203">Format</span></span>|<span data-ttu-id="3bd02-4204">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-4204">Assembly Format</span></span>|<span data-ttu-id="3bd02-4205">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-4205">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-4206">0C</span><span class="sxs-lookup"><span data-stu-id="3bd02-4206">0C</span></span>|<span data-ttu-id="3bd02-4207">stloc. 2</span><span class="sxs-lookup"><span data-stu-id="3bd02-4207">stloc.2</span></span>|<span data-ttu-id="3bd02-4208">Holt einen Wert aus dem Stapel in die lokale Variable 2.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4208">Pops a value from the stack into local variable 2</span></span>|  
  
 <span data-ttu-id="3bd02-4209">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4209">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-4210">Ein Wert wird aus dem Stapel entfernt und in der lokalen, von 2 indizierten Variablen platziert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4210">A value is popped off of the stack and placed in the local variable indexed by 2.</span></span>  
  
 <span data-ttu-id="3bd02-4211">Die `stloc.2`-Anweisung holt den obersten Wert aus dem Auswertungs Stapel und verschiebt ihn in die von 2 indizierte lokale Variable.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4211">The `stloc.2` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 2.</span></span> <span data-ttu-id="3bd02-4212">Der Typ des Werts muss mit dem Typ der lokalen Variablen identisch sein, wie in der lokalen Signatur der aktuellen Methode angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4212">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="3bd02-4213">`stloc.2` ist eine besonders effiziente Codierung zum Speichern von Werten in der lokalen Variablen 2.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4213">`stloc.2` is an especially efficient encoding for storing values in local variable 2.</span></span>  
  
 <span data-ttu-id="3bd02-4214">Beim Speichern in lokale Variablen, die einen ganzzahligen Wert kleiner als 4 Bytes enthalten, wird der Wert abgeschnitten, wenn er vom Stapel zur lokalen Variablen verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4214">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="3bd02-4215">Gleit Komma Werte werden von ihrer nativen Größe (Type `F`) auf die Größe gerundet, die dem Argument zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4215">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="3bd02-4216">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `stloc.2` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4216">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.2` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-4217">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4217">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-4218">Holt den aktuellen Wert von der obersten Position des Auswertungsstapels und speichert ihn in der Liste der lokalen Variablen am Index 3.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4218">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 3.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4219">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4219">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-4220">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-4220">Format</span></span>|<span data-ttu-id="3bd02-4221">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-4221">Assembly Format</span></span>|<span data-ttu-id="3bd02-4222">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-4222">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-4223">0D</span><span class="sxs-lookup"><span data-stu-id="3bd02-4223">0D</span></span>|<span data-ttu-id="3bd02-4224">stloc. 3</span><span class="sxs-lookup"><span data-stu-id="3bd02-4224">stloc.3</span></span>|<span data-ttu-id="3bd02-4225">Holt einen Wert aus dem Stapel in die lokale Variable 3.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4225">Pops a value from the stack into local variable 3</span></span>|  
  
 <span data-ttu-id="3bd02-4226">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4226">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-4227">Ein Wert wird aus dem Stapel entfernt und in der lokalen, von 3 indizierten Variablen platziert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4227">A value is popped off of the stack and placed in the local variable indexed by 3.</span></span>  
  
 <span data-ttu-id="3bd02-4228">Die `stloc.3`-Anweisung holt den obersten Wert aus dem Auswertungs Stapel und verschiebt ihn in die von 3 indizierte lokale Variable.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4228">The `stloc.3` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 3.</span></span> <span data-ttu-id="3bd02-4229">Der Typ des Werts muss mit dem Typ der lokalen Variablen identisch sein, wie in der lokalen Signatur der aktuellen Methode angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4229">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="3bd02-4230">`stloc.3` ist eine besonders effiziente Codierung zum Speichern von Werten in der lokalen Variablen 3.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4230">`stloc.3` is an especially efficient encoding for storing values in local variable 3.</span></span>  
  
 <span data-ttu-id="3bd02-4231">Beim Speichern in lokale Variablen, die einen ganzzahligen Wert kleiner als 4 Bytes enthalten, wird der Wert abgeschnitten, wenn er vom Stapel zur lokalen Variablen verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4231">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="3bd02-4232">Gleit Komma Werte werden von ihrer nativen Größe (Type `F`) auf die Größe gerundet, die dem Argument zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4232">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="3bd02-4233">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `stloc.3` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4233">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.3` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-4234">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4234">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-4235">Holt den aktuellen Wert von der obersten Position des Auswertungsstapels und speichert ihn in der Liste der lokalen Variablen am <paramref name="index" /> (Kurzform).</span><span class="sxs-lookup"><span data-stu-id="3bd02-4235">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at <paramref name="index" /> (short form).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4236">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4236">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-4237">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-4237">Format</span></span>|<span data-ttu-id="3bd02-4238">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-4238">Assembly Format</span></span>|<span data-ttu-id="3bd02-4239">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-4239">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-4240">13 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-4240">13 < `unsigned int8` ></span></span>|<span data-ttu-id="3bd02-4241">stloc. s `index`</span><span class="sxs-lookup"><span data-stu-id="3bd02-4241">stloc.s `index`</span></span>|<span data-ttu-id="3bd02-4242">Holt einen Wert aus dem Stapel und speichert ihn in der lokalen Variablen `index`Kurzform.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4242">Pops a value from the stack and stores it in local variable `index`, short form.</span></span>|  
  
 <span data-ttu-id="3bd02-4243">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4243">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-4244">Ein Wert wird aus dem Stapel entfernt und in der lokalen Variablen `index`platziert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4244">A value is popped off of the stack and placed in local variable `index`.</span></span>  
  
 <span data-ttu-id="3bd02-4245">Die `stloc.s`-Anweisung holt den obersten Wert aus dem Auswertungs Stapel und verschiebt ihn in die Nummer `index`der lokalen Variablen, wobei lokale Variablen auf 0 (null) nummerieren.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4245">The `stloc.s` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="3bd02-4246">Der Typ des Werts muss mit dem Typ der lokalen Variablen identisch sein, wie in der lokalen Signatur der aktuellen Methode angegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4246">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="3bd02-4247">Die `stloc.s`-Anweisung bietet eine effiziente Codierung für lokale Variablen 0 bis 255.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4247">The `stloc.s` instruction provides an efficient encoding for local variables 0 through 255.</span></span>  
  
 <span data-ttu-id="3bd02-4248">Beim Speichern in lokale Variablen, die einen ganzzahligen Wert kleiner als 4 Bytes enthalten, wird der Wert abgeschnitten, wenn er vom Stapel zur lokalen Variablen verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4248">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="3bd02-4249">Gleit Komma Werte werden von ihrer nativen Größe (Type `F`) auf die Größe gerundet, die dem Argument zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4249">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="3bd02-4250">Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladungen können den `stloc.s` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4250">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc.s` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-4251">ILGenerator. ausgeben (OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4251">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="3bd02-4252">ILGenerator.Emit(OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4252">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-4253">Kopiert einen Wert mit dem angegebenen Typ vom Auswertungsstapel in die angegebene Speicheradresse.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4253">Copies a value of a specified type from the evaluation stack into a supplied memory address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4254">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4254">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-4255">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-4255">Format</span></span>|<span data-ttu-id="3bd02-4256">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-4256">Assembly Format</span></span>|<span data-ttu-id="3bd02-4257">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-4257">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-4258">81 < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-4258">81 < `T` ></span></span>|<span data-ttu-id="3bd02-4259">stobj-`class`</span><span class="sxs-lookup"><span data-stu-id="3bd02-4259">stobj `class`</span></span>|<span data-ttu-id="3bd02-4260">Speichert einen Wert vom Typ `class` aus dem Stapel in den Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4260">Stores a value of type `class` from the stack into memory.</span></span>|  
  
 <span data-ttu-id="3bd02-4261">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4261">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-4262">Eine Adresse wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4262">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-4263">Ein Werttyp Objekt vom Typ "`class`" wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4263">A value type object of type `class` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-4264">Das-Objekt und die-Adresse werden aus dem Stapel entfernt. Das Werttyp Objekt wird an der Adresse gespeichert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4264">The object and the address are popped from the stack; the value type object is stored at the address.</span></span>  
  
 <span data-ttu-id="3bd02-4265">Die `stobj` Anweisung kopiert das Werttyp Objekt in die von der Adresse angegebene Adresse (ein Zeiger vom Typ `native int`, `*`oder `&`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-4265">The `stobj` instruction copies the value type object into the address specified by the address (a pointer of type `native int`, `*`, or `&`).</span></span> <span data-ttu-id="3bd02-4266">Die Anzahl der kopierten Bytes hängt von der Größe der durch `class`dargestellten Klasse ab, einem Metadatentoken, das einen Werttyp darstellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4266">The number of bytes copied depends on the size of the class represented by `class`, a metadata token representing a value type.</span></span>  
  
 <span data-ttu-id="3bd02-4267">Der Vorgang der `stobj` Anweisung kann durch eine unmittelbar vorangehende <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung geändert werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4267">The operation of the `stobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="3bd02-4268"><xref:System.TypeLoadException> wird ausgelöst, wenn die Klasse nicht gefunden werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4268"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="3bd02-4269">Dies wird in der Regel erkannt, wenn MSIL-Anweisungen (Microsoft Intermediate Language) in systemeigenen Code anstatt zur Laufzeit konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4269">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</span></span>  
  
 <span data-ttu-id="3bd02-4270">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `stobj` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4270">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stobj` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-4271">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4271">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-4272">Ersetzt den Wert eines statischen Felds durch einen Wert vom Auswertungsstapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4272">Replaces the value of a static field with a value from the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4273">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4273">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-4274">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-4274">Format</span></span>|<span data-ttu-id="3bd02-4275">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-4275">Assembly Format</span></span>|<span data-ttu-id="3bd02-4276">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-4276">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-4277">80 < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-4277">80 < `T` ></span></span>|<span data-ttu-id="3bd02-4278">stsfld-`field`</span><span class="sxs-lookup"><span data-stu-id="3bd02-4278">stsfld `field`</span></span>|<span data-ttu-id="3bd02-4279">Ersetzt den Wert in `field` durch einen angegebenen Wert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4279">Replaces the value in `field` with a supplied value.</span></span>|  
  
 <span data-ttu-id="3bd02-4280">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4280">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-4281">Ein Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4281">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-4282">Ein Wert wird aus dem Stapel ausgeblendet und in `field`gespeichert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4282">A value is popped from the stack and stored in `field`.</span></span>  
  
 <span data-ttu-id="3bd02-4283">Die `stsfld` Anweisung ersetzt den Wert eines statischen Felds durch einen Wert aus dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4283">The `stsfld` instruction replaces the value of a static field with a value from the stack.</span></span> <span data-ttu-id="3bd02-4284">`field` ist ein Metadatentoken, das auf einen statischen Feldmember verweisen muss.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4284">`field` is a metadata token that must refer to a static field member.</span></span>  
  
 <span data-ttu-id="3bd02-4285">Der `stsfld` Anweisung kann <xref:System.Reflection.Emit.OpCodes.Volatile>vorangestellt sein.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4285">The `stsfld` instruction may be prefixed by <xref:System.Reflection.Emit.OpCodes.Volatile>.</span></span>  
  
 <span data-ttu-id="3bd02-4286"><xref:System.MissingFieldException> wird ausgelöst, wenn das Feld in den Metadaten nicht gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4286"><xref:System.MissingFieldException> is thrown if field is not found in the metadata.</span></span> <span data-ttu-id="3bd02-4287">Dies wird in der Regel geprüft, wenn MSIL-Anweisungen (Microsoft Intermediate Language) in systemeigenen Code konvertiert werden, nicht zur Laufzeit.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4287">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="3bd02-4288">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `stsfld` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4288">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stsfld` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-4289">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4289">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-4290">Subtrahiert einen Wert von einem anderen Wert und legt das Ergebnis auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4290">Subtracts one value from another and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4291">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4291">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-4292">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-4292">Format</span></span>|<span data-ttu-id="3bd02-4293">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-4293">Assembly Format</span></span>|<span data-ttu-id="3bd02-4294">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-4294">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-4295">59</span><span class="sxs-lookup"><span data-stu-id="3bd02-4295">59</span></span>|<span data-ttu-id="3bd02-4296">sub</span><span class="sxs-lookup"><span data-stu-id="3bd02-4296">sub</span></span>|<span data-ttu-id="3bd02-4297">Subtrahiert einen Wert von einem anderen und gibt einen neuen numerischen Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4297">Subtracts one value from another, returning a new numeric value.</span></span>|  
  
 <span data-ttu-id="3bd02-4298">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4298">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-4299">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4299">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-4300">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4300">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-4301">`value2` und `value1` werden aus dem Stapel entfernt. `value2` wird von `value1`subtrahiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4301">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1`.</span></span>  
  
4.  <span data-ttu-id="3bd02-4302">Das Ergebnis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4302">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-4303">Ein Überlauf für ganzzahlige Vorgänge wird nicht erkannt (für eine ordnungsgemäße Überlauf Behandlung finden Sie unter <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).</span><span class="sxs-lookup"><span data-stu-id="3bd02-4303">Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).</span></span>  
  
 <span data-ttu-id="3bd02-4304">Ganzzahlige Subtraktion umschlossen und nicht als ganze Zahl.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4304">Integer subtraction wraps, rather than saturates.</span></span> <span data-ttu-id="3bd02-4305">Beispiel: bei 8-Bit-Ganzzahlen, bei denen `value1` auf 0 festgelegt ist und `value2` auf 1 festgelegt ist, ist das "umschließende" Ergebnis 255.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4305">For example: assuming 8-bit integers, where `value1` is set to 0 and `value2` is set to 1, the "wrapped" result will be 255.</span></span>  
  
 <span data-ttu-id="3bd02-4306">Gleit Komma Überlauf gibt `+inf` (`PositiveInfinity`) oder `-inf` (`NegativeInfinity`) zurück.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4306">Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`).</span></span>  
  
 <span data-ttu-id="3bd02-4307">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `sub` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4307">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-4308">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4308">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-4309">Subtrahiert einen Ganzzahlwert von einem anderen Ganzzahlwert, führt eine Überlaufprüfung durch und legt das Ergebnis auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4309">Subtracts one integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4310">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4310">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-4311">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-4311">Format</span></span>|<span data-ttu-id="3bd02-4312">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-4312">Assembly Format</span></span>|<span data-ttu-id="3bd02-4313">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-4313">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-4314">De</span><span class="sxs-lookup"><span data-stu-id="3bd02-4314">DA</span></span>|<span data-ttu-id="3bd02-4315">sub.ovf</span><span class="sxs-lookup"><span data-stu-id="3bd02-4315">sub.ovf</span></span>|<span data-ttu-id="3bd02-4316">Subtrahiert einen ganzzahligen Wert von einem anderen mit einer Überlauf Überprüfung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4316">Subtracts one integer value from another with an overflow check.</span></span>|  
  
 <span data-ttu-id="3bd02-4317">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4317">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-4318">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4318">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-4319">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4319">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-4320">`value2` und `value1` werden aus dem Stapel entfernt. `value2` wird von `value1` mit einer Überprüfung auf Überlauf subtrahiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4320">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="3bd02-4321">Das Ergebnis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4321">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-4322"><xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4322"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-4323">Dieser Vorgang wird für ganze Zahlen mit Vorzeichen ausgeführt. Verwenden Sie für Gleit Komma Werte <xref:System.Reflection.Emit.OpCodes.Sub>.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4323">This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.</span></span>  
  
 <span data-ttu-id="3bd02-4324">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `sub.ovf` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4324">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-4325">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4325">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-4326">Subtrahiert einen Ganzzahlwert ohne Vorzeichen von einem anderen Ganzzahlwert, führt eine Überlaufprüfung durch und legt das Ergebnis auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4326">Subtracts one unsigned integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4327">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4327">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-4328">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-4328">Format</span></span>|<span data-ttu-id="3bd02-4329">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-4329">Assembly Format</span></span>|<span data-ttu-id="3bd02-4330">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-4330">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-4331">DB</span><span class="sxs-lookup"><span data-stu-id="3bd02-4331">DB</span></span>|<span data-ttu-id="3bd02-4332">sub.ovf.un</span><span class="sxs-lookup"><span data-stu-id="3bd02-4332">sub.ovf.un</span></span>|<span data-ttu-id="3bd02-4333">Subtrahiert einen ganzzahligen Wert ohne Vorzeichen von einem anderen mit einer Überlauf Überprüfung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4333">Subtracts one unsigned integer value from another with an overflow check.</span></span>|  
  
 <span data-ttu-id="3bd02-4334">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4334">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-4335">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4335">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-4336">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4336">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-4337">`value2` und `value1` werden aus dem Stapel entfernt. `value2` wird von `value1` mit einer Überprüfung auf Überlauf subtrahiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4337">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="3bd02-4338">Das Ergebnis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4338">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-4339"><xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4339"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="3bd02-4340">Dieser Vorgang wird für ganze Zahlen mit Vorzeichen ausgeführt. Verwenden Sie für Gleit Komma Werte <xref:System.Reflection.Emit.OpCodes.Sub>.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4340">This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.</span></span>  
  
 <span data-ttu-id="3bd02-4341">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `sub.ovf.un` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4341">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-4342">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4342">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-4343">Implementiert eine Sprungtabelle.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4343">Implements a jump table.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4344">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4344">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-4345">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-4345">Format</span></span>|<span data-ttu-id="3bd02-4346">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-4346">Assembly Format</span></span>|<span data-ttu-id="3bd02-4347">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-4347">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-4348">45 < `unsigned int32` > < `int32` >... < `int32` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-4348">45 < `unsigned int32` > < `int32` >... < `int32` ></span></span>|<span data-ttu-id="3bd02-4349">Switch (`N`, `t1`, `t2`... `tN`)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4349">switch (`N`, `t1`, `t2`... `tN`)</span></span>|<span data-ttu-id="3bd02-4350">Springt zu einem `N`-Werte.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4350">Jumps to one of `N` values.</span></span>|  
  
 <span data-ttu-id="3bd02-4351">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4351">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-4352">Ein Wert wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4352">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-4353">Der Wert wird aus dem Stapel entfernt, und die Ausführung wird an die Anweisung an dem Offset übertragen, der durch den-Wert indiziert wird, wobei der Wert kleiner als `N`ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4353">The value is popped off the stack and execution is transferred to the instruction at the offset indexed by the value, where the value is less than `N`.</span></span>  
  
 <span data-ttu-id="3bd02-4354">Die `switch` Anweisung implementiert eine Sprung Tabelle.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4354">The `switch` instruction implements a jump table.</span></span> <span data-ttu-id="3bd02-4355">Das Format der Anweisung ist eine `unsigned int32` die die Anzahl der Ziele `N`darstellt, gefolgt von `N` Int32-Werten, die Sprung Ziele angeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4355">The format of the instruction is an `unsigned int32` representing the number of targets `N`, followed by `N` int32 values specifying jump targets.</span></span> <span data-ttu-id="3bd02-4356">Diese Ziele werden als Offsets (positiv oder negativ) ab dem Anfang der Anweisung dargestellt, die dieser `switch` Anweisung folgt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4356">These targets are represented as offsets (positive or negative) from the beginning of the instruction following this `switch` instruction.</span></span>  
  
 <span data-ttu-id="3bd02-4357">Die `switch`-Anweisung holt einen Wert aus dem Stapel und vergleicht ihn als ganze Zahl ohne Vorzeichen mit `N`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4357">The `switch` instruction pops a value off the stack and compares it, as an unsigned integer, to `N`.</span></span> <span data-ttu-id="3bd02-4358">Wenn value kleiner als `N`ist, wird die Ausführung an das Ziel übertragen, das durch den Wert indiziert wird, wobei Ziele von 0 nummeriert werden (z. b. wenn der Wert 0 das erste Ziel annimmt, der Wert 1 das zweite Ziel hat usw.).</span><span class="sxs-lookup"><span data-stu-id="3bd02-4358">If value is less than `N`, execution is transferred to the target indexed by value, where targets are numbered from 0 (for example, a value of 0 takes the first target, a value of 1 takes the second target, and so on).</span></span> <span data-ttu-id="3bd02-4359">Wenn der Wert größer oder gleich `N`ist, wird die Ausführung bei der nächsten Anweisung fortgesetzt (durchlaufen).</span><span class="sxs-lookup"><span data-stu-id="3bd02-4359">If the value is greater than or equal to `N`, execution continues at the next instruction (fall through).</span></span>  
  
 <span data-ttu-id="3bd02-4360">Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4360">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="3bd02-4361">Steuerelement Übertragungen in und aus `try`-, `catch`-, `filter`-und `finally`-Blöcken können von dieser Anweisung nicht ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4361">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span> <span data-ttu-id="3bd02-4362">(Solche Übertragungen sind stark eingeschränkt und müssen stattdessen die Leave-Anweisung verwenden).</span><span class="sxs-lookup"><span data-stu-id="3bd02-4362">(Such transfers are severely restricted and must use the leave instruction instead).</span></span>  
  
 <span data-ttu-id="3bd02-4363">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `switch` Opcode verwenden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4363">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `switch` opcode.</span></span> <span data-ttu-id="3bd02-4364">Das `Label[]`-Argument ist ein Array von Bezeichnungen, das 32-Bit-Offsets darstellt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4364">The `Label[]` argument is an array of Labels representing 32-bit offsets.</span></span>  
  
-   <span data-ttu-id="3bd02-4365">ILGenerator. ausgeben (OpCode, Bezeichnung [])</span><span class="sxs-lookup"><span data-stu-id="3bd02-4365">ILGenerator.Emit(OpCode, Label[])</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3bd02-4366">Im folgenden Codebeispiel wird die Verwendung des `Switch` Opcodes veranschaulicht, um mithilfe eines Arrays von <xref:System.Reflection.Emit.Label>eine Sprung Tabelle zu generieren.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4366">The following code sample illustrates the use of the `Switch` opcode to generate a jump table using an array of <xref:System.Reflection.Emit.Label>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-4367">Führt eine Postfix-Methodenaufrufanweisung in der Weise aus, dass der Stapelrahmen der aktuellen Methode vor der Ausführung der eigentlichen Aufrufanweisung entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4367">Performs a postfixed method call instruction such that the current method's stack frame is removed before the actual call instruction is executed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4368">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4368">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-4369">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-4369">Format</span></span>|<span data-ttu-id="3bd02-4370">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-4370">Assembly Format</span></span>|<span data-ttu-id="3bd02-4371">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-4371">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-4372">FE 14</span><span class="sxs-lookup"><span data-stu-id="3bd02-4372">FE 14</span></span>|<span data-ttu-id="3bd02-4373">Rohr.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4373">tail.</span></span>|<span data-ttu-id="3bd02-4374">Der nachfolgende-Rückruf beendet aktuelle Methoden</span><span class="sxs-lookup"><span data-stu-id="3bd02-4374">Subsequent call terminates current methods</span></span>|  
  
 <span data-ttu-id="3bd02-4375">Es ist kein Stapel Übergangs Verhalten für diese Anweisung definiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4375">There is no stack transition behavior defined for this instruction.</span></span>  
  
 <span data-ttu-id="3bd02-4376">Die `tail`-Präfix Anweisung muss unmittelbar vor einer <xref:System.Reflection.Emit.OpCodes.Call>-, <xref:System.Reflection.Emit.OpCodes.Calli>-oder <xref:System.Reflection.Emit.OpCodes.Callvirt>-Anweisung stehen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4376">The `tail` prefix instruction must immediately precede a <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, or <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction.</span></span> <span data-ttu-id="3bd02-4377">Gibt an, dass der Stapel Rahmen der aktuellen Methode entfernt werden soll, bevor die-Anweisung ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4377">It indicates that the current method's stack frame should be removed before the call instruction is executed.</span></span> <span data-ttu-id="3bd02-4378">Außerdem impliziert dies, dass der Wert, der vom folgenden-Befehl zurückgegeben wird, auch der von der aktuellen Methode zurückgegebene Wert ist, und der-Befehl kann daher in einen Methoden übergreifenden Sprung konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4378">It also implies that the value returned from the following call is also the value returned by the current method, and the call can therefore be converted into a cross-method jump.</span></span>  
  
 <span data-ttu-id="3bd02-4379">Der Stapel muss leer sein, mit Ausnahme der Argumente, die durch den folgenden-Befehl übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4379">The stack must be empty except for the arguments being transferred by the following call.</span></span> <span data-ttu-id="3bd02-4380">Die Anweisung, die auf die-Anweisung folgt, muss ein ret sein. Daher ist die einzige gültige Code Sequenz `tail. call` (oder `calli` oder `callvirt`).</span><span class="sxs-lookup"><span data-stu-id="3bd02-4380">The instruction following the call instruction must be a ret. Thus the only valid code sequence is `tail. call` (or `calli` or `callvirt`).</span></span> <span data-ttu-id="3bd02-4381">Korrekte MSIL-Anweisungen (Microsoft Intermediate Language) dürfen nicht mit der `call` Anweisung verzweigt werden, Sie können jedoch mit der nachfolgenden <xref:System.Reflection.Emit.OpCodes.Ret>verzweigen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4381">Correct Microsoft Intermediate Language (MSIL) instructions must not branch to the `call` instruction, but they may branch to the subsequent <xref:System.Reflection.Emit.OpCodes.Ret>.</span></span>  
  
 <span data-ttu-id="3bd02-4382">Der aktuelle Frame kann nicht verworfen werden, wenn die Steuerung von nicht vertrauenswürdigem Code zu vertrauenswürdigem Code übertragen wird, da dadurch die Code Identitäts Sicherheit gefährdet wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4382">The current frame cannot be discarded when control is transferred from untrusted code to trusted code, since this would jeopardize code identity security.</span></span> <span data-ttu-id="3bd02-4383">Die .NET Framework Sicherheitsüberprüfungen können daher dazu führen, dass die `tail` ignoriert werden und eine Standard <xref:System.Reflection.Emit.OpCodes.Call>-Anweisung verlässt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4383">The .NET Framework security checks can therefore cause the `tail` to be ignored, leaving a standard <xref:System.Reflection.Emit.OpCodes.Call> instruction.</span></span> <span data-ttu-id="3bd02-4384">Entsprechend wird das `tail` Präfix ignoriert, wenn es verwendet wird, um eine Methode zu beenden, die als synchronisiert markiert ist, um das Beenden eines synchronisierten Bereichs nach dem Zurückgeben des Aufrufes zuzulassen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4384">Similarly, in order to allow the exit of a synchronized region to occur after the call returns, the `tail` prefix is ignored when used to exit a method that is marked synchronized.</span></span>  
  
 <span data-ttu-id="3bd02-4385">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `tail` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4385">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `tail` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-4386">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4386">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst"><span data-ttu-id="3bd02-4387">Eine Instanz eines eines Opcodeobjekts.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4387">An instance of an Opcode object.</span></span></param>
        <summary><span data-ttu-id="3bd02-4388">Gibt True oder False zurück, wenn der bereitgestellte Opcode ein Einzelbyte-Argument akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4388">Returns true or false if the supplied opcode takes a single byte argument.</span></span></summary>
        <returns><span data-ttu-id="3bd02-4389"><see langword="true" /> oder <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4389"><see langword="true" /> or <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4390">Diese Methode kann verwendet werden, um zu ermitteln, welche MSIL-Opcodes "Kurzform" sind, um Sie in optimiertem Code zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4390">This method can be used to find which MSIL opcodes are "short form", for use in optimized code.</span></span>  
  
 <span data-ttu-id="3bd02-4391">`TakesSingleByteArgument` gibt `true` zurück, wenn die <xref:System.Reflection.Emit.OpCode> Instanz in den folgenden Fällen ein einzelnes Byte Argument annimmt:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4391">`TakesSingleByteArgument` returns `true` if the <xref:System.Reflection.Emit.OpCode> instance takes a single byte argument in the following cases:</span></span>  
  
-   <span data-ttu-id="3bd02-4392">Der Opcode führt eine Verzweigungs Anweisung für eine Adresse mit Byte Größe aus (z. b. <xref:System.Reflection.Emit.OpCodes.Br_S> und <xref:System.Reflection.Emit.OpCodes.Bgt_S>).</span><span class="sxs-lookup"><span data-stu-id="3bd02-4392">The opcode performs a branch instruction to a byte-sized address (for example, <xref:System.Reflection.Emit.OpCodes.Br_S> and <xref:System.Reflection.Emit.OpCodes.Bgt_S>).</span></span>  
  
-   <span data-ttu-id="3bd02-4393">Der Opcode überträgt einen Bytewert auf den Stapel (z. b. <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).</span><span class="sxs-lookup"><span data-stu-id="3bd02-4393">The opcode pushes a byte value onto the stack (for example, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).</span></span>  
  
-   <span data-ttu-id="3bd02-4394">Der Opcode verweist auf eine Variable oder ein Argument über das Byte-Format "Kurzform" (z. b. <xref:System.Reflection.Emit.OpCodes.Ldloc_S> und <xref:System.Reflection.Emit.OpCodes.Stloc_S>).</span><span class="sxs-lookup"><span data-stu-id="3bd02-4394">The opcode references a variable or argument via the byte-sized "short form" (for example, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> and <xref:System.Reflection.Emit.OpCodes.Stloc_S>).</span></span>  
  
 <span data-ttu-id="3bd02-4395">Andernfalls wird `false`zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4395">Otherwise, it returns `false`.</span></span>  
  
 <span data-ttu-id="3bd02-4396">Das folgende Beispiel veranschaulicht die Verwendung von `TakesSingleByteArgument`, indem die `OpCodes`-Klasse reflektiert und getestet wird, ob jedes `OpCode` Feld ein Single-Byte-Argument annimmt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4396">The example below demonstrates the use of `TakesSingleByteArgument` by reflecting on to the `OpCodes` class and testing to see whether each `OpCode` field takes a single-byte argument.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-4397">Löst das Ausnahmeobjekt aus, das sich momentan auf dem Auswertungsstapel befindet.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4397">Throws the exception object currently on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4398">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4398">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-4399">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-4399">Format</span></span>|<span data-ttu-id="3bd02-4400">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-4400">Assembly Format</span></span>|<span data-ttu-id="3bd02-4401">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-4401">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-4402">7A</span><span class="sxs-lookup"><span data-stu-id="3bd02-4402">7A</span></span>|<span data-ttu-id="3bd02-4403">throw</span><span class="sxs-lookup"><span data-stu-id="3bd02-4403">throw</span></span>|<span data-ttu-id="3bd02-4404">Löst eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4404">Throws an exception.</span></span>|  
  
 <span data-ttu-id="3bd02-4405">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4405">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-4406">Ein Objekt Verweis (auf eine Ausnahme) wird auf dem Stapel abgelegt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4406">An object reference (to an exception) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-4407">Der Objekt Verweis wird aus dem Stapel entfernt, und die Ausnahme wird ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4407">The object reference is popped from the stack and the exception thrown.</span></span>  
  
 <span data-ttu-id="3bd02-4408">Die `throw`-Anweisung löst das Ausnahme Objekt (Typ `O`) aus, das sich zurzeit im Stapel befinden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4408">The `throw` instruction throws the exception object (type `O`) currently on the stack.</span></span>  
  
 <span data-ttu-id="3bd02-4409"><xref:System.NullReferenceException> wird ausgelöst, wenn der Objekt Verweis ein NULL-Verweis ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4409"><xref:System.NullReferenceException> is thrown if the object reference is a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-4410">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `throw` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4410">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `throw` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-4411">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4411">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-4412">Gibt an, dass eine Adresse, die sich momentan oben auf dem Stapel befindet, möglicherweise nicht an der eigentlichen Größe der unmittelbar darauf folgenden <see langword="ldind" />-Anweisung, <see langword="stind" />-Anweisung, <see langword="ldfld" />-Anweisung, <see langword="stfld" />-Anweisung, <see langword="ldobj" />-Anweisung, <see langword="stobj" />-Anweisung, <see langword="initblk" />-Anweisung oder <see langword="cpblk" />-Anweisung ausgerichtet ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4412">Indicates that an address currently atop the evaluation stack might not be aligned to the natural size of the immediately following <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" />, or <see langword="cpblk" /> instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4413">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4413">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-4414">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-4414">Format</span></span>|<span data-ttu-id="3bd02-4415">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-4415">Assembly Format</span></span>|<span data-ttu-id="3bd02-4416">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-4416">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-4417">FE 12 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-4417">FE 12 < `unsigned int8` ></span></span>|<span data-ttu-id="3bd02-4418">nicht ausgerichtete.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4418">unaligned.</span></span> `alignment`|<span data-ttu-id="3bd02-4419">Gibt an, dass die nachfolgende Zeiger Anweisung möglicherweise nicht ausgerichtet ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4419">Indicates that the subsequent pointer instruction may be unaligned.</span></span>|  
  
 <span data-ttu-id="3bd02-4420">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4420">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-4421">Eine Adresse wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4421">An address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-4422">`Unaligned` gibt an, dass die Adresse (ein nicht verwalteter Zeiger, `native int`) im Stapel möglicherweise nicht an der natürlichen Größe der direkt folgenden `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`oder `cpblk`-Anweisung ausgerichtet ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4422">`Unaligned` specifies that the address (an unmanaged pointer, `native int`) on the stack might not be aligned to the natural size of the immediately following `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="3bd02-4423">Das heißt, bei einer <xref:System.Reflection.Emit.OpCodes.Ldind_I4> Anweisung ist die Ausrichtung der Adresse möglicherweise nicht auf eine 4-Byte-Grenze fest.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4423">That is, for a <xref:System.Reflection.Emit.OpCodes.Ldind_I4> instruction the alignment of the address may not be to a 4-byte boundary.</span></span> <span data-ttu-id="3bd02-4424">Bei `initblk` und `cpblk` ist die Standardausrichtung Architektur abhängig (4-Byte auf 32-Bit-CPUs, 8 Bytes auf 64-Bit-CPUs).</span><span class="sxs-lookup"><span data-stu-id="3bd02-4424">For `initblk` and `cpblk` the default alignment is architecture dependent (4-byte on 32-bit CPUs, 8-byte on 64-bit CPUs).</span></span> <span data-ttu-id="3bd02-4425">Code-Generatoren, deren Ausgabe nicht auf eine 32-Bit-Wort Größe beschränkt ist, müssen `unaligned` verwenden, wenn die Ausrichtung zur Kompilierzeit nicht als 8-Byte-Wert bekannt ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4425">Code generators that do not restrict their output to a 32-bit word size must use `unaligned` if the alignment is not known at compile time to be 8-byte.</span></span>  
  
 <span data-ttu-id="3bd02-4426">Der Wert von Alignment muss 1, 2 oder 4 lauten und bedeutet, dass der generierte Code davon ausgehen soll, dass die Adresse Byte, Doppelbyte bzw. vier Byte ausgerichtet ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4426">The value of alignment must be 1, 2, or 4 and means that the generated code should assume that the address is byte, double-byte, or quad-byte aligned, respectively.</span></span> <span data-ttu-id="3bd02-4427">Beachten Sie, dass vorübergehende Zeiger (Typ `*`) immer ausgerichtet sind.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4427">Note that transient pointers (type `*`) are always aligned.</span></span>  
  
 <span data-ttu-id="3bd02-4428">Obwohl die Ausrichtung für eine `cpblk` Anweisung logisch zwei Zahlen erfordert (eine für die Quelle und eine für das Ziel), gibt es keine merkliche Auswirkung auf die Leistung, wenn nur die niedrigere Zahl angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4428">While the alignment for a `cpblk` instruction would logically require two numbers (one for the source and one for the destination), there is no noticeable impact on performance if only the lower number is specified.</span></span>  
  
 <span data-ttu-id="3bd02-4429">Die `unaligned`-und `volatile` Präfixe können in jeder Reihenfolge kombiniert werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4429">The `unaligned` and `volatile` prefixes can be combined in either order.</span></span> <span data-ttu-id="3bd02-4430">Sie müssen unmittelbar vor einer `ldind`-, `stind`-, `ldfld`-, `stfld`-, `ldobj`-, `stobj`-, `initblk`-oder `cpblk`-Anweisung stehen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4430">They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="3bd02-4431">Nur das <xref:System.Reflection.Emit.OpCodes.Volatile> Präfix ist für die <xref:System.Reflection.Emit.OpCodes.Ldsfld>-und <xref:System.Reflection.Emit.OpCodes.Stsfld> Anweisungen zulässig.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4431">Only the <xref:System.Reflection.Emit.OpCodes.Volatile> prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.</span></span>  
  
 <span data-ttu-id="3bd02-4432">Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladungen können den `unaligned` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4432">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `unaligned` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-4433">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4433">ILGenerator.Emit(OpCode, Label)</span></span>  
  
-   <span data-ttu-id="3bd02-4434">ILGenerator.Emit(Opcode, Byte)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4434">ILGenerator.Emit(Opcode, Byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-4435">Konvertiert die Darstellung eines mittels Boxing gepackten Werttyps in seine mittels Unboxing entpackte Entsprechung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4435">Converts the boxed representation of a value type to its unboxed form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4436">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4436">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-4437">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-4437">Format</span></span>|<span data-ttu-id="3bd02-4438">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-4438">Assembly Format</span></span>|<span data-ttu-id="3bd02-4439">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-4439">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-4440">79 < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-4440">79 < `T` ></span></span>|<span data-ttu-id="3bd02-4441">Unboxing-`valType`</span><span class="sxs-lookup"><span data-stu-id="3bd02-4441">unbox `valType`</span></span>|<span data-ttu-id="3bd02-4442">Extrahiert die Werttyp Daten aus `obj`, der zugehörigen geboxten Darstellung.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4442">Extracts the value type data from `obj`, its boxed representation.</span></span>|  
  
 <span data-ttu-id="3bd02-4443">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4443">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-4444">Ein Objekt Verweis wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4444">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-4445">Der Objekt Verweis wird aus dem Stapel entfernt und in einen Werttyp Zeiger entpackt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4445">The object reference is popped from the stack and unboxed to a value type pointer.</span></span>  
  
3.  <span data-ttu-id="3bd02-4446">Der Werttyp Zeiger wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4446">The value type pointer is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-4447">Ein Werttyp verfügt über zwei separate Darstellungen innerhalb der Common Language Infrastructure (CLI):</span><span class="sxs-lookup"><span data-stu-id="3bd02-4447">A value type has two separate representations within the Common Language Infrastructure (CLI):</span></span>  
  
-   <span data-ttu-id="3bd02-4448">Ein "RAW"-Formular, das verwendet wird, wenn ein Werttyp in ein anderes Objekt eingebettet ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4448">A 'raw' form used when a value type is embedded within another object.</span></span>  
  
-   <span data-ttu-id="3bd02-4449">Ein geschachteltes Formular, in dem die Daten im Werttyp in ein Objekt umwickelt (geschachtelt) werden, damit es als unabhängige Entität vorhanden sein kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4449">A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</span></span>  
  
 <span data-ttu-id="3bd02-4450">Die `unbox`-Anweisung konvertiert den Objekt Verweis (Type `O`), die einfügende Darstellung eines Werttyps, in einen Werttyp Zeiger (einen verwalteten Zeiger, Typ `&`), seine Unboxing-Form.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4450">The `unbox` instruction converts the object reference (type `O`), the boxed representation of a value type, to a value type pointer (a managed pointer, type `&`), its unboxed form.</span></span> <span data-ttu-id="3bd02-4451">Der angegebene Werttyp (`valType`) ist ein Metadatentoken, das den Typ des Werttyps angibt, der innerhalb des geschachtelten Objekts</span><span class="sxs-lookup"><span data-stu-id="3bd02-4451">The supplied value type (`valType`) is a metadata token indicating the type of value type contained within the boxed object.</span></span>  
  
 <span data-ttu-id="3bd02-4452">Im Gegensatz zu <xref:System.Reflection.Emit.OpCodes.Box>, die erforderlich ist, um eine Kopie eines Werttyps für die Verwendung im-Objekt zu erstellen, ist `unbox` nicht erforderlich, um den Werttyp aus dem-Objekt zu kopieren.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4452">Unlike <xref:System.Reflection.Emit.OpCodes.Box>, which is required to make a copy of a value type for use in the object, `unbox` is not required to copy the value type from the object.</span></span> <span data-ttu-id="3bd02-4453">In der Regel wird nur die Adresse des Werttyps berechnet, der bereits in dem geschachtelten Objekt vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4453">Typically it simply computes the address of the value type that is already present inside of the boxed object.</span></span>  
  
 <span data-ttu-id="3bd02-4454"><xref:System.InvalidCastException> wird ausgelöst, wenn das Objekt nicht als `valType`geschachtelt wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4454"><xref:System.InvalidCastException> is thrown if the object is not boxed as `valType`.</span></span>  
  
 <span data-ttu-id="3bd02-4455"><xref:System.NullReferenceException> wird ausgelöst, wenn der Objekt Verweis ein NULL-Verweis ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4455"><xref:System.NullReferenceException> is thrown if the object reference is a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-4456"><xref:System.TypeLoadException> wird ausgelöst, wenn der Werttyp `valType` nicht gefunden werden kann.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4456"><xref:System.TypeLoadException> is thrown if the value type `valType` cannot be found.</span></span> <span data-ttu-id="3bd02-4457">Dies wird in der Regel erkannt, wenn MSIL-Anweisungen (Microsoft Intermediate Language) in systemeigenen Code konvertiert werden, anstatt zur Laufzeit.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4457">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="3bd02-4458">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `unbox` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4458">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-4459">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4459">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-4460">Konvertiert die geschachtelte Darstellung eines n der Anweisung angegebenen Typs in seine nicht geschachtelte Form.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4460">Converts the boxed representation of a type specified in the instruction to its unboxed form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4461">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4461">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-4462">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-4462">Format</span></span>|<span data-ttu-id="3bd02-4463">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-4463">Assembly Format</span></span>|<span data-ttu-id="3bd02-4464">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-4464">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-4465">A5 < `T` ></span><span class="sxs-lookup"><span data-stu-id="3bd02-4465">A5 < `T` ></span></span>|<span data-ttu-id="3bd02-4466">unbox. Any-`typeTok`</span><span class="sxs-lookup"><span data-stu-id="3bd02-4466">unbox.any `typeTok`</span></span>|<span data-ttu-id="3bd02-4467">Extrahieren Sie die Daten aus `obj`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4467">Extract the data from `obj`, its boxed representation.</span></span>|  
  
 <span data-ttu-id="3bd02-4468">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4468">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-4469">Ein Objekt Verweis `obj` auf den Stapel verschoben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4469">An object reference `obj` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-4470">Der Objekt Verweis wird aus dem Stapel entfernt und in den in der Anweisung angegebenen Typ entpackt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4470">The object reference is popped from the stack and unboxed to the type specified in the instruction.</span></span>  
  
3.  <span data-ttu-id="3bd02-4471">Der resultierende Objekt Verweis oder Werttyp wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4471">The resulting object reference or value type is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-4472">Bei Anwendung auf die geschachtelte Form eines Werttyps extrahiert die `unbox.any` Anweisung den Wert, der in `obj` (vom Typ `O`) enthalten ist, und entspricht daher `unbox`, gefolgt von `ldobj`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4472">When applied to the boxed form of a value type, the `unbox.any` instruction extracts the value contained within `obj` (of type `O`), and is therefore equivalent to `unbox` followed by `ldobj`.</span></span>  
  
 <span data-ttu-id="3bd02-4473">Wenn die `unbox.any` Anweisung auf einen Verweistyp angewendet wird, hat dies die gleiche Wirkung wie `castclass` `typeTok`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4473">When applied to a reference type, the `unbox.any` instruction has the same effect as `castclass` `typeTok`.</span></span>  
  
 <span data-ttu-id="3bd02-4474">Wenn der Operand `typeTok` ein generischer Typparameter ist, wird das Laufzeitverhalten durch den Typ bestimmt, der für diesen generischen Typparameter angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4474">If the operand `typeTok` is a generic type parameter, then the runtime behavior is determined by the type that is specified for that generic type parameter.</span></span>  
  
 <span data-ttu-id="3bd02-4475"><xref:System.InvalidCastException> wird ausgelöst, wenn `obj` kein geschachtelter Typ ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4475"><xref:System.InvalidCastException> is thrown if `obj` is not a boxed type.</span></span>  
  
 <span data-ttu-id="3bd02-4476"><xref:System.NullReferenceException> wird ausgelöst, wenn `obj` ein NULL-Verweis ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4476"><xref:System.NullReferenceException> is thrown if `obj` is a null reference.</span></span>  
  
 <span data-ttu-id="3bd02-4477">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `unbox.any` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4477">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox.any` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-4478">ILGenerator.Emit(OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4478">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-4479">Gibt an, dass es sich bei einer Adresse, die sich momentan oben auf dem Auswertungsstapel befindet, möglicherweise um eine flüchtige Adresse handelt und daher die aus diesem Speicherort gelesenen Ergebnisse nicht zwischengespeichert werden können oder mehrere für diesen Speicherort ausgeführte Speichervorgänge nicht unterdrückt werden können.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4479">Specifies that an address currently atop the evaluation stack might be volatile, and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4480">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4480">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-4481">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-4481">Format</span></span>|<span data-ttu-id="3bd02-4482">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-4482">Assembly Format</span></span>|<span data-ttu-id="3bd02-4483">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-4483">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-4484">FE 13</span><span class="sxs-lookup"><span data-stu-id="3bd02-4484">FE 13</span></span>|<span data-ttu-id="3bd02-4485">ständigem.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4485">volatile.</span></span>|<span data-ttu-id="3bd02-4486">Gibt an, dass der nachfolgende Zeiger Verweis flüchtig ist.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4486">Indicates that the subsequent pointer reference is volatile.</span></span>|  
  
 <span data-ttu-id="3bd02-4487">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4487">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-4488">Eine Adresse wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4488">An address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-4489">`volatile`.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4489">`volatile`.</span></span> <span data-ttu-id="3bd02-4490">Gibt an, dass es sich bei der Adresse um eine flüchtige Adresse handelt (d. h., Sie kann extern mit dem aktuellen Ausführungs Thread referenziert werden), und die Ergebnisse der Lesevorgänge können nicht zwischengespeichert werden</span><span class="sxs-lookup"><span data-stu-id="3bd02-4490">specifies that the address is a volatile address (that is, it can be referenced externally to the current thread of execution) and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</span></span> <span data-ttu-id="3bd02-4491">Das Markieren eines Zugriffs als `volatile` wirkt sich nur auf diesen einzelnen Zugriff aus. andere Zugriffe auf denselben Speicherort müssen separat gekennzeichnet werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4491">Marking an access as `volatile` affects only that single access; other accesses to the same location must be marked separately.</span></span> <span data-ttu-id="3bd02-4492">Der Zugriff auf flüchtige Speicherorte muss nicht atomarisch ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4492">Access to volatile locations need not be performed atomically.</span></span>  
  
 <span data-ttu-id="3bd02-4493">Die <xref:System.Reflection.Emit.OpCodes.Unaligned>-und `volatile` Präfixe können in jeder Reihenfolge kombiniert werden.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4493">The <xref:System.Reflection.Emit.OpCodes.Unaligned> and `volatile` prefixes can be combined in either order.</span></span> <span data-ttu-id="3bd02-4494">Sie müssen unmittelbar vor einer `ldind`-, `stind`-, `ldfld`-, `stfld`-, `ldobj`-, `stobj`-, `initblk`-oder `cpblk`-Anweisung stehen.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4494">They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="3bd02-4495">Nur das `volatile` Präfix ist für die <xref:System.Reflection.Emit.OpCodes.Ldsfld>-und <xref:System.Reflection.Emit.OpCodes.Stsfld> Anweisungen zulässig.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4495">Only the `volatile` prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.</span></span>  
  
 <span data-ttu-id="3bd02-4496">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `volatile` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4496">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `volatile` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-4497">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4497">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3bd02-4498">Berechnet das bitweise XOR der beidem auf dem Stapel an oberster Position befindlichen Werte und legt das Ergebnis auf dem Auswertungsstapel ab.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4498">Computes the bitwise XOR of the top two values on the evaluation stack, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3bd02-4499">In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4499">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="3bd02-4500">Format</span><span class="sxs-lookup"><span data-stu-id="3bd02-4500">Format</span></span>|<span data-ttu-id="3bd02-4501">AssemblyFormat</span><span class="sxs-lookup"><span data-stu-id="3bd02-4501">Assembly Format</span></span>|<span data-ttu-id="3bd02-4502">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="3bd02-4502">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="3bd02-4503">61</span><span class="sxs-lookup"><span data-stu-id="3bd02-4503">61</span></span>|<span data-ttu-id="3bd02-4504">xor</span><span class="sxs-lookup"><span data-stu-id="3bd02-4504">xor</span></span>|<span data-ttu-id="3bd02-4505">Berechnet das bitweise XOR von zwei ganzzahligen Werten und gibt eine ganze Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4505">Computes the bitwise XOR of two integer values and returns an integer.</span></span>|  
  
 <span data-ttu-id="3bd02-4506">Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4506">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="3bd02-4507">`value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4507">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="3bd02-4508">`value2` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4508">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="3bd02-4509">`value2` und `value1` werden aus dem Stapel und Ihrem bitweisen XOR-Element aus dem Stapel entfernt.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4509">`value2` and `value1` are popped from the stack and their bitwise XOR computed.</span></span>  
  
4.  <span data-ttu-id="3bd02-4510">Der bitweise XOR-Wert von `value2` und `value1` wird auf den Stapel verschoben.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4510">The bitwise XOR of `value2` and `value1` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="3bd02-4511">Die `xor`-Anweisung berechnet das bitweise XOR der obersten beiden Werte im Stapel und verlässt das Ergebnis auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4511">The `xor` instruction computes the bitwise XOR of the top two values on the stack and leaves the result on the stack.</span></span>  
  
 <span data-ttu-id="3bd02-4512">`Xor` ist ein ganzzahliger spezifischer Vorgang.</span><span class="sxs-lookup"><span data-stu-id="3bd02-4512">`Xor` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="3bd02-4513">Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A>-Methoden Überladung kann den `xor` Opcode verwenden:</span><span class="sxs-lookup"><span data-stu-id="3bd02-4513">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `xor` opcode:</span></span>  
  
-   <span data-ttu-id="3bd02-4514">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="3bd02-4514">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
