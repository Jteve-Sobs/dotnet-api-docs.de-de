<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="922fb9597fe60f2fe290329ee8a5f430c0343e13" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36645509" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt Felddarstellungen der MSIL (Microsoft Intermediate Language)-Anweisungen für die Ausgabe durch die <see cref="T:System.Reflection.Emit.ILGenerator" />-Klassenmember bereit, beispielsweise <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine ausführliche Beschreibung der Member-Opcodes finden Sie in der Common Language Infrastructure (CLI)-Dokumentation, insbesondere "Partition III: CIL Instruction Set" und "Partition II: Metadata Definition and Semantics". Die Dokumentation ist online verfügbar. Sie finden sie unter [ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))](http://go.microsoft.com/fwlink/?LinkID=65552) auf der Ecma International-Website.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, die zur Erstellung einer dynamischen Methode mit <xref:System.Reflection.Emit.ILGenerator> auszugebende `OpCodes` in einem <xref:System.Reflection.Emit.MethodBuilder>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Addiert zwei Werte und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|58|Hinzufügen|Addiert zwei numerische Werte, einen neuen numerischen Wert zurückgeben.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` sind per pop ausgelesen, aus dem Stapel; `value1` hinzugefügt `value2`.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 Überlauf für Ganzzahloperationen nicht erkannt wird (ordnungsgemäße überlaufbearbeitung, finden Sie unter <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).  
  
 Ganze Zahl hinzufügen, anstatt das Sättigungsverfahren. Vorausgesetzt, z. B. 8-Bit-Ganzzahlen, in denen `value1` auf 255 festgelegt und `value2` festgelegt ist auf 1, ist das umschlossene Ergebnis 0 statt 256.  
  
 Gleitkommaüberlauf gibt `+inf` (`PositiveInfinity`) oder `-inf` (`NegativeInfinity`).  
  
 Die zulässigen Operandentypen und ihre entsprechenden Ergebnisdatentyp werden in der folgenden Tabelle aufgeführt. Wenn kein Eintrag für einen bestimmten Typenkombination vorhanden ist (z. B. `int32` und `float`; `int32` und `int64`), ist eine ungültige Microsoft Intermediate Language (MSIL), und es wird ein Fehler generiert.  
  
|Operanden|Wert1-Typ|value2-Typ|Ergebnistyp|  
|-------------|-----------------|-----------------|-----------------|  
|Hinzufügen|`int32`|`int32`|`int32`|  
|Hinzufügen|`int32`|`native int`|`native int`|  
|Hinzufügen|`int32`|`&`|`&`|  
|Hinzufügen|`int32`|`*`|`*`|  
|Hinzufügen|`int64`|`int64`|`int64`|  
|Hinzufügen|`native int`|`int32`|`native int`|  
|Hinzufügen|`native int`|`native int`|`native int`|  
|Hinzufügen|`native int`|`&`|`&`|  
|Hinzufügen|`native int`|`*`|`*`|  
|Hinzufügen|`F`|`F`|`F`|  
|Hinzufügen|`&`|`int32`|`&`|  
|Hinzufügen|`&`|`native int`|`&`|  
|Hinzufügen|`*`|`int32`|`*`|  
|Hinzufügen|`*`|`native int`|`*`|  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `add` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Addiert zwei ganze Zahlen, führt eine Überlaufprüfung durch und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|D6|Add.ovf|Addiert zwei ganze Zahl mit Vorzeichen Werte mit eine überlaufprüfung.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` sind per pop ausgelesen, aus dem Stapel; `value1` hinzugefügt `value2` mit einem Häkchen auf Überläufe.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt wird.  
  
 Sie können diesen Vorgang ausführen, auf Ganzzahlen mit Vorzeichen. Verwenden Sie für Gleitkommawerte, <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 Die zulässigen Operandentypen und ihre entsprechenden Ergebnisdatentyp werden in der folgenden Tabelle aufgeführt. Wenn kein Eintrag für einen bestimmten Typenkombination vorhanden ist (z. B. `int32` und `float`; `int32` und `int64`), ist eine ungültige Anweisung für die Microsoft Intermediate Language (MSIL), und es wird ein Fehler generiert.  
  
|Operanden|Wert1-Typ|value2-Typ|Ergebnistyp|  
|-------------|-----------------|-----------------|-----------------|  
|Hinzufügen|`int32`|`int32`|`int32`|  
|Hinzufügen|`int32`|`native int`|`native int`|  
|Hinzufügen|`int32`|`&`|`&`|  
|Hinzufügen|`int32`|`*`|`*`|  
|Hinzufügen|`int64`|`int64`|`int64`|  
|Hinzufügen|`native int`|`int32`|`native int`|  
|Hinzufügen|`native int`|`native int`|`native int`|  
|Hinzufügen|`native int`|`&`|`&`|  
|Hinzufügen|`native int`|`*`|`*`|  
|Hinzufügen|`F`|`F`|`F`|  
|Hinzufügen|`&`|`int32`|`&`|  
|Hinzufügen|`&`|`native int`|`&`|  
|Hinzufügen|`*`|`int32`|`*`|  
|Hinzufügen|`*`|`native int`|`*`|  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `add.ovf` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Addiert zwei Ganzzahlwerte ohne Vorzeichen, führt eine Überlaufprüfung durch und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|D7|Add.ovf.un|Fügt zwei Ganzzahlwerte ohne Vorzeichen mit eine überlaufprüfung hinzu.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` sind per pop ausgelesen, aus dem Stapel; `value1` hinzugefügt `value2` mit einem Häkchen auf Überläufe.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt wird.  
  
 Sie können diesen Vorgang ausführen, auf Ganzzahlen mit Vorzeichen. Verwenden Sie für Gleitkommawerte, <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 Die zulässigen Operandentypen und ihre entsprechenden Ergebnisdatentyp werden in der folgenden Tabelle aufgeführt. Wenn kein Eintrag für einen bestimmten Typenkombination vorhanden ist (z. B. `int32` und `float`; `int32` und `int64`), ist eine ungültige Anweisung für die Microsoft Intermediate Language (MSIL), und es wird ein Fehler generiert.  
  
|Operanden|Wert1-Typ|value2-Typ|Ergebnistyp|  
|-------------|-----------------|-----------------|-----------------|  
|Hinzufügen|`int32`|`int32`|`int32`|  
|Hinzufügen|`int32`|`native int`|`native int`|  
|Hinzufügen|`int32`|`&`|`&`|  
|Hinzufügen|`int32`|`*`|`*`|  
|Hinzufügen|`int64`|`int64`|`int64`|  
|Hinzufügen|`native int`|`int32`|`native int`|  
|Hinzufügen|`native int`|`native int`|`native int`|  
|Hinzufügen|`native int`|`&`|`&`|  
|Hinzufügen|`native int`|`*`|`*`|  
|Hinzufügen|`F`|`F`|`F`|  
|Hinzufügen|`&`|`int32`|`&`|  
|Hinzufügen|`&`|`native int`|`&`|  
|Hinzufügen|`*`|`int32`|`*`|  
|Hinzufügen|`*`|`native int`|`*`|  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `add.ovf.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Berechnet das bitweise AND für zwei Werte und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Anweisung|Beschreibung |  
|------------|-----------------|-----------------|  
|5F|und|Bestimmt den bitweisen AND von zwei ganzzahligen Werten.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value1` und `value2` sind per pop ausgelesen, aus dem Stapel; das bitweise AND von zwei Werten berechnet wird.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 Die `and` Anweisung berechnet das bitweise AND für die beiden oberen Werte auf dem Stapel und das Ergebnis auf dem Stapel verbleibt.  
  
 `And` ist ein Integer-spezifische-Vorgang.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `and` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt einen nicht verwalteten Zeiger auf die Argumentliste der aktuellen Methode zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 00|arglist|Gibt ein Handle des Argument-Liste für die aktuelle Methode zurück.|  
  
 Durch diesen Vorgang werden keine Auswertung Stapel Verhaltensweisen ausgeführt.  
  
 Die `arglist` Anweisung gibt ein nicht transparentes Handle (einen nicht verwalteten Zeiger vom Typ `native int`), die die Argumentliste der aktuellen Methode darstellt. Dieses Handle ist nur während der Lebensdauer der aktuellen Methode gültig. Sie können jedoch das Handle an andere Methoden übergeben, als die aktuelle Methode für den Thread des Steuerelements ist. Sie können nur ausführen, die `arglist` Anweisung innerhalb einer Methode, die eine Variable Anzahl von Argumenten akzeptiert.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `arglist` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn zwei Werte übereinstimmen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|3B < `int32` >|beq `target`|Verzweigung für die zielanweisung am Offset `target` , wenn die beiden Werte gleich sind.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` aus dem Stapel; ausgelesen werden, wenn `value1` gleich `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `beq` -Anweisung übergibt die Steuerung an den angegebenen zielanweisung Wenn `value1` gleich `value2`. Der Effekt ist derselbe, wie das Ausführen einer `ceq` Anweisung, gefolgt von einer `brtrue` Verzweigung, die bestimmte zielanweisung. Bei der zielinstruktion wird als ein mit Vorzeichen 4-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Im folgenden werden die zulässigen Operandentypen gekapselt:  
  
 Wenn bei der zielinstruktion mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe.  
  
 Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden (die Übertragung stark eingeschränkt werden, und verwenden, müssen die <xref:System.Reflection.Emit.OpCodes.Leave> Anweisung stattdessen).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `beq` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn zwei Werte übereinstimmen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|2E < `int8` >|beq.s `target`|Verzweigung für die zielanweisung am Offset `target` wenn gleich, Kurzform:|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` aus dem Stapel; ausgelesen werden, wenn `value1` gleich `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `beq.s` -Anweisung übergibt die Steuerung an den angegebenen zielanweisung Wenn `value1` gleich `value2`. Der Effekt ist derselbe, wie das Ausführen einer `ceq` Anweisung, gefolgt von einer `brtrue` Verzweigung, die bestimmte zielanweisung. Bei der zielinstruktion wird als eine signierten 1-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Im folgenden werden die zulässigen Operandentypen gekapselt:  
  
 Wenn bei der zielinstruktion mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe.  
  
 Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden (die Übertragung stark eingeschränkt werden, und verwenden, müssen die <xref:System.Reflection.Emit.OpCodes.Leave> Anweisung stattdessen).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `beq.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn der erste Wert größer oder gleich dem zweiten Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|3C `<int32>`|bge `target`|Die Verzweigung für die zielanweisung am angegebenen Offset, wenn der erste Wert größer als oder gleich dem zweiten Wert ist.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` aus dem Stapel; ausgelesen werden, wenn `value1` ist größer als oder gleich `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `bge` -Anweisung übergibt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist größer als oder gleich `value2`. Der Effekt ist identisch mit der Ausführung einer `clt.un` Anweisung, gefolgt von einem `brfalse` Verzweigung, die bestimmte zielanweisung. Bei der zielinstruktion wird als ein mit Vorzeichen 4-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `bge` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn der erste Wert größer oder gleich dem zweiten Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|2F `<int8>`|bge.s `target`|Die Verzweigung für die zielanweisung am angegebenen Offset ist der erste Wert größer als oder gleich dem zweiten Wert, Kurzform.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` aus dem Stapel; ausgelesen werden, wenn `value1` ist größer als oder gleich `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `bge.s` -Anweisung übergibt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist größer als oder gleich `value2`. Der Effekt ist identisch mit der Ausführung einer `clt.un` Anweisung, gefolgt von einem `brfalse` Verzweigung, die bestimmte zielanweisung. Bei der zielinstruktion wird als eine signierten 1-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `bge.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert größer als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|41 `<int32>`|bge.un `target`|Die Verzweigung für die zielanweisung am angegebenen Offset ist der erste Wert größer als oder gleich dem zweiten Wert (Werte ohne Vorzeichen).|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` aus dem Stapel; ausgelesen werden, wenn `value1` ist größer als oder gleich `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `bge.un` -Anweisung übergibt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist größer als oder gleich `value2`, wenn mithilfe der Ganzzahl ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen. Der Effekt ist identisch mit der Ausführung einer `clt` Anweisung, gefolgt von einem `brfalse` Verzweigung, die bestimmte zielanweisung. Bei der zielinstruktion wird als ein mit Vorzeichen 4-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `bge.un` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert größer als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|34 < `int8` >|bge.un.s `target`|Die Verzweigung für die zielanweisung am angegebenen Offset ist der erste Wert größer als oder gleich dem zweiten Wert (Werte ohne Vorzeichen), Kurzform.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` aus dem Stapel; ausgelesen werden, wenn `value1` ist größer als oder gleich `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `bge.un.s` -Anweisung übergibt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist größer als oder gleich `value2`, wenn mithilfe der Ganzzahl ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen. Der Effekt ist identisch mit der Ausführung einer `clt` Anweisung, gefolgt von einem `brfalse` Verzweigung, die bestimmte zielanweisung. Bei der zielinstruktion wird als eine signierten 1-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `bge.un.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn der erste Wert größer als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|3D < `int32` >|bgt `target`|Die Verzweigung für die zielanweisung am angegebenen Offset, wenn der erste Wert größer als der zweite Wert ist.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` aus dem Stapel; ausgelesen werden, wenn `value1` ist größer als `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `bgt` -Anweisung übergibt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist größer als `value2`. Der Effekt ist identisch mit der Ausführung einer `cgt` Anweisung, gefolgt von einem `brtrue` Verzweigung, die bestimmte zielanweisung. Bei der zielinstruktion wird als ein mit Vorzeichen 4-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `bgt` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn der erste Wert größer als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|30 < `int8` >|bgt.s `target`|Die Verzweigung für die zielanweisung am angegebenen Offset ist der erste Wert größer als der zweite Wert, Kurzform.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` aus dem Stapel; ausgelesen werden, wenn `value1` ist größer als `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `bgt.s` -Anweisung übergibt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist größer als `value2`. Der Effekt ist identisch mit der Ausführung einer `cgt` Anweisung, gefolgt von einem `brtrue` Verzweigung, die bestimmte zielanweisung. Bei der zielinstruktion wird als eine signierten 1-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `bgt.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert größer als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|42 < `int32` >|bgt.un `target`|Die Verzweigung für die zielanweisung am angegebenen Offset ist der erste Wert größer als der zweite Wert (Werte ohne Vorzeichen).|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` aus dem Stapel; ausgelesen werden, wenn `value1` ist größer als `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `bgt.un` -Anweisung übergibt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist größer als `value2`, wenn mithilfe der Ganzzahl ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen. Der Effekt ist identisch mit der Ausführung einer `cgt.un` Anweisung, gefolgt von einem `brtrue` Verzweigung, die bestimmte zielanweisung. Bei der zielinstruktion wird als ein mit Vorzeichen 4-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `bgt.un` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert größer als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|35 < `int8` >|bgt.un.s `target`|Die Verzweigung für die zielanweisung am angegebenen Offset ist der erste Wert größer als der zweite Wert (Werte ohne Vorzeichen), Kurzform.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` aus dem Stapel; ausgelesen werden, wenn `value1` ist größer als `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `bgt.un.s` -Anweisung übergibt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist größer als `value2`, wenn mithilfe der Ganzzahl ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen. Der Effekt ist identisch mit der Ausführung einer `cgt.un` Anweisung, gefolgt von einem `brtrue` Verzweigung, die bestimmte zielanweisung. Bei der zielinstruktion wird als eine signierten 1-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `bgt.un.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn der erste Wert kleiner oder gleich dem zweiten Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|3E `<int32>`|Aktivieren `target`|Die Verzweigung für die zielanweisung am angegebenen Offset, wenn der erste Wert kleiner als oder gleich dem zweiten Wert ist.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` aus dem Stapel; ausgelesen werden, wenn `value1` ist kleiner als oder gleich `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `ble` -Anweisung übergibt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist kleiner als oder gleich `value2`. Der Effekt ist identisch mit der Ausführung einer `cgt` Anweisung (`cgt.un` für float) gefolgt von einem `brfalse` Verzweigung, die bestimmte zielanweisung. Bei der zielinstruktion wird als ein mit Vorzeichen 4-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ble` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn der erste Wert kleiner oder gleich dem zweiten Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|31 `<int8>`|ble.s `target`|Die Verzweigung für die zielanweisung am angegebenen Offset, wenn der erste Wert kleiner als oder gleich dem zweiten Wert, Kurzform ist.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` aus dem Stapel; ausgelesen werden, wenn `value1` ist kleiner als oder gleich `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `ble.s` -Anweisung übergibt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist kleiner als oder gleich `value2`. Der Effekt ist identisch mit der Ausführung einer `cgt` Anweisung (`cgt.un` für float) Anweisung, gefolgt von einer`brfalse` Verzweigung, die bestimmte zielanweisung. Bei der zielinstruktion wird als eine signierten 1-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ble.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert kleiner oder gleich dem zweiten Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|43 `<int32>`|ble.un `target`|Die Verzweigung für die zielanweisung am angegebenen Offset, wenn der erste Wert kleiner als oder gleich dem zweiten Wert (Werte ohne Vorzeichen) ist.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` aus dem Stapel; ausgelesen werden, wenn `value1` ist kleiner als oder gleich `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `ble.un` -Anweisung übergibt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist kleiner als oder gleich `value2`, wenn mithilfe der Ganzzahl ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen. Der Effekt ist identisch mit der Ausführung einer `cgt.un` Anweisung (`cgt` für float) gefolgt von einem `brfalse` Verzweigung, die bestimmte zielanweisung. Bei der zielinstruktion wird als ein mit Vorzeichen 4-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ble.un` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert kleiner oder gleich dem zweiten Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|36 `<int8>`|ble.un.s `target`|Die Verzweigung für die zielanweisung am angegebenen Offset, wenn der erste Wert kleiner als oder gleich dem zweiten Wert (Werte ohne Vorzeichen), Kurzform ist.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` aus dem Stapel; ausgelesen werden, wenn `value1` ist kleiner als oder gleich `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `ble.un.s` -Anweisung übergibt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist kleiner als oder gleich `value2`, wenn mithilfe der Ganzzahl ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen. Der Effekt ist identisch mit der Ausführung einer `cgt.un` Anweisung (`cgt` für float) gefolgt von einem `brfalse` Verzweigung, die bestimmte zielanweisung. Bei der zielinstruktion wird als eine signierten 1-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ble.un.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn der erste Wert kleiner als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|3F &LT; `int32` >|blt `target`|Die Verzweigung für die zielanweisung am angegebenen Offset begonnen, wenn der erste Wert ist kleiner als der zweite Wert.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` aus dem Stapel; ausgelesen werden, wenn `value1` ist kleiner als `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `blt` -Anweisung übergibt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist kleiner als oder gleich `value2`. Der Effekt ist identisch mit der Ausführung einer `clt` Anweisung, gefolgt von einem `brtrue` Verzweigung, die bestimmte zielanweisung. Bei der zielinstruktion wird als ein mit Vorzeichen 4-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `blt` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn der erste Wert kleiner als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|32 < `int8` >|blt.s `target`|Die Verzweigung für die zielanweisung am angegebenen Offset begonnen, wenn der erste Wert ist kleiner als der zweite Wert, Kurzform.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` aus dem Stapel; ausgelesen werden, wenn `value1` ist kleiner als `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `blt.s` -Anweisung übergibt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist kleiner als `value2`. Der Effekt ist identisch mit der Ausführung einer `clt` Anweisung, gefolgt von einem `brtrue` Verzweigung, die bestimmte zielanweisung. Bei der zielinstruktion wird als eine signierten 1-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `blt.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert kleiner als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|44 < `int32` >|blt.un `target`|Die Verzweigung für die zielanweisung am angegebenen Offset begonnen, wenn der erste Wert ist kleiner als der zweite Wert (Werte ohne Vorzeichen).|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` aus dem Stapel; ausgelesen werden, wenn `value1` ist kleiner als `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `blt.un` -Anweisung übergibt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist kleiner als `value2`, wenn mithilfe der Ganzzahl ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen. Der Effekt ist identisch mit der Ausführung einer `clt.un` Anweisung, gefolgt von einem `brtrue` Verzweigung, die bestimmte zielanweisung. Bei der zielinstruktion wird als ein mit Vorzeichen 4-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `blt.un` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert kleiner als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|37 < `int8` >|blt.un.s `target`|Die Verzweigung für die zielanweisung am angegebenen Offset begonnen, wenn der erste Wert ist kleiner als der zweite Wert (Werte ohne Vorzeichen), Kurzform.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` aus dem Stapel; ausgelesen werden, wenn `value1` ist kleiner als `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `blt.un` -Anweisung übergibt die Steuerung an den angegebenen zielanweisung Wenn `value1` ist kleiner als `value2`, wenn mithilfe der Ganzzahl ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen. Der Effekt ist identisch mit der Ausführung einer `clt.un` Anweisung, gefolgt von einem `brtrue` Verzweigung, die bestimmte zielanweisung. Bei der zielinstruktion wird als ein mit Vorzeichen 4-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `blt.un.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn zwei Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte ungleich sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|40 < `int32` >|bne.un `target`|Verzweigung zum Ziel Anweisung am angegebenen Offset, wenn zwei Ganzzahlwerte ohne Vorzeichen sind (Werte ohne Vorzeichen) nicht gleich.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` aus dem Stapel; ausgelesen werden, wenn `value1` stimmt nicht mit `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `bne.un` -Anweisung übergibt die Steuerung an den angegebenen zielanweisung Wenn `value1` stimmt nicht mit `value2`, wenn mithilfe der Ganzzahl ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen. Der Effekt ist identisch mit der Ausführung einer `ceq` Anweisung, gefolgt von einem `brfalse` Verzweigung, die bestimmte zielanweisung. Bei der zielinstruktion wird als ein mit Vorzeichen 4-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `bne.un` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn zwei Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte ungleich sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|33 < `int8` >|bne.un.s `target`|Verzweigung zum Ziel Anweisung am angegebenen Offset, wenn zwei Ganzzahlwerte ohne Vorzeichen sind nicht gleich (Werte ohne Vorzeichen), Kurzform.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` aus dem Stapel; ausgelesen werden, wenn `value1` stimmt nicht mit `value2`, der Branch-Vorgang ausgeführt wird.  
  
 Die `bne.un` -Anweisung übergibt die Steuerung an den angegebenen zielanweisung Wenn `value1` stimmt nicht mit `value2`, wenn mithilfe der Ganzzahl ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen. Der Effekt ist identisch mit der Ausführung einer `ceq` Anweisung, gefolgt von einem `brfalse` Verzweigung, die bestimmte zielanweisung. Bei der zielinstruktion wird als ein mit Vorzeichen 4-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `bne.un.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert einen Werttyp in einen Objektverweis (Typ <see langword="O" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|8C < `T` >|Kontrollkästchen `valTypeToken`|Konvertiert einen Werttyp (des Typs im angegebenen `valTypeToken`) in einen Objektverweis "true".|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Werttyp ist auf dem Stapel abgelegt.  
  
2.  Der Werttyp wird vom Stapel geholt. die `box` Vorgang ausgeführt wird.  
  
3.  Ein Objektverweis auf die resultierende "geschachtelter" Werttyp wird auf dem Stapel abgelegt.  
  
 Ein Werttyp verfügt über zwei separate Darstellungen innerhalb der Common Language Infrastructure (CLI):  
  
-   Eine "rohen" Form verwendet, wenn ein Werttyp in einem anderen Objekt oder auf dem Stapel eingebettet ist.  
  
-   Eine "geschachtelte" Form, in dem die Daten in den Werttyp in ein Objekt umschlossen (geschachtelt) ist, damit es als unabhängige Entität vorhanden ist.  
  
 Die `box` Anweisung konvertiert den "rohen" (nicht geschachtelten) Werttyp in einen Objektverweis (Typ `O`). Dies wird erreicht, indem Sie ein neues Objekt erstellen und Kopieren der Daten aus den Werttyp in das neu zugeordnete Objekt. `valTypeToken` ist ein Metadatentoken, das den Typ des Werttyps auf dem Stapel angibt.  
  
 <xref:System.OutOfMemoryException> wird ausgelöst, wenn nicht genügend zum Erfüllen der Anforderung Arbeitsspeicher.  
  
 <xref:System.TypeLoadException> wird ausgelöst, wenn die Klasse nicht gefunden werden kann. Dies wird in der Regel erkannt, wenn Microsoft Intermediate Language (MSIL) nicht zur Laufzeit, sondern auf systemeigenen Code konvertiert wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `box` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung bedingungslos an eine Zielanweisung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|38 < `int32` >|Brasilien `target`|Verzweigungen, an eine zielanweisung am angegebenen Offset.|  
  
 Durch diesen Vorgang werden keine Auswertung Stapel Verhaltensweisen ausgeführt.  
  
 Die `br` -Anweisung überträgt die Steuerung bedingungslos an eine zielanweisung. Bei der zielinstruktion wird als ein mit Vorzeichen 4-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `br` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung bedingungslos an eine Zielanweisung (Kurzform).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|2B < `int8` >|br.s `target`|Verzweigungen, an eine zielanweisung am angegebenen Offset, Kurzform.|  
  
 Durch diesen Vorgang werden keine Auswertung Stapel Verhaltensweisen ausgeführt.  
  
 Die `br.s` -Anweisung überträgt die Steuerung bedingungslos an eine zielanweisung. Bei der zielinstruktion wird als eine signierten 1-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `br.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Signalisiert CLI (Common Language Infrastructure), den Debugger darüber zu informieren, dass ein Haltepunkt erreicht wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|01|break|Informieren Sie einem Debugger, dass ein Haltepunkt erreicht wurde.|  
  
 Durch diesen Vorgang werden keine Auswertung Stapel Verhaltensweisen ausgeführt.  
  
 Die `break` Anweisung ist für das debugging-Unterstützung. Er kennzeichnet die CLI, um den Debugger darüber zu informieren, dass ein Haltepunkt erreicht wurde. Es wurde keine anderen Auswirkungen auf den Interpreter-Zustand.  
  
 Die `break` -Anweisung besitzt die kleinste mögliche Größe aktivieren Anweisungscode mit einem Haltepunkt Patchen und minimale Störung an den umgebenden Code zu generieren.  
  
 Die `break` Anweisung kann an einen Debugger, nothing, oder eine Sicherheitsausnahme ausgelöst. Das genaue Verhalten ist implementierungsdefiniert.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `break` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn <paramref name="value" /> entweder <see langword="false" />, ein NULL-Verweis (<see langword="Nothing" /> in Visual Basic) oder 0 (null) ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|39 < `int32` >|brfalse `target`<br /><br /> brnull `target`<br /><br /> brzero `target`|Verzweigungen an eine zielanweisung am angegebenen Offset bei `false`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird von einem früheren Vorgang auf dem Stapel abgelegt.  
  
2.  `value` wird vom Stapel geholt. Wenn `value` ist `false`, Verzweigung zur `target`.  
  
 Die `brfalse` Anweisung (und seine Aliase `brnull` und `brzero`) übergibt die Steuerung an den angegebenen zielanweisung Wenn `value` (des Typs `int32`, `int64`,-Objektverweis `O`verwaltete Zeiger `&`, flüchtige Zeiger `*`, `native int`) 0 (null) (`false`). Wenn `value` ist ungleich Null (`true`) Ausführung wird mit der nächsten Anweisung fortgesetzt.  
  
 Bei der zielinstruktion wird als ein mit Vorzeichen 4-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `brfalse` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn <paramref name="value" /> entweder <see langword="false" />, ein NULL-Verweis oder 0 (null) ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|2C &LT;`int8` >|brfalse.s `target`<br /><br /> brnull.s `target`<br /><br /> brzero.s `target`|Verzweigungen an eine zielanweisung am angegebenen Offset bei `false`, Kurzform.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird von einem früheren Vorgang auf dem Stapel abgelegt.  
  
2.  `value` wird vom Stapel geholt. Wenn `value` ist `false`, Verzweigung zur `target`.  
  
 Die `brfalse.s` Anweisung (und seine Aliase `brnull` und `brzero`) übergibt die Steuerung an den angegebenen zielanweisung Wenn `value` (des Typs `int32`, `int64`,-Objektverweis `O`verwaltete Zeiger `&`, flüchtige Zeiger `*`, `native int`) 0 (null) (`false`). Wenn `value` ist ungleich Null (`true`) Ausführung wird mit der nächsten Anweisung fortgesetzt.  
  
 Bei der zielinstruktion wird als eine signierten 1-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `brfalse.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn <paramref name="value" /> entweder <see langword="true" />, nicht NULL oder ungleich 0 (null) ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|3A < `int32` >|brtrue `target`<br /><br /> brinst `target`|An eine zielanweisung am angegebenen Offset verzweigen, wenn nicht 0 (null) (`true`).|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird von einem früheren Vorgang auf dem Stapel abgelegt.  
  
2.  `value` wird vom Stapel geholt. Wenn `value` ist `true`, Verzweigung zur `target`.  
  
 Die `brtrue` -Anweisung übergibt die Steuerung an den angegebenen zielanweisung Wenn `value` (Typ `native int`) ist ungleich Null (`true`). Wenn `value` 0 (null) (`false`) Ausführung wird mit der nächsten Anweisung fortgesetzt.  
  
 Wenn `value` ist ein Objektverweis (Typ `O`) dann `brinst` (Alias für `brtrue`) übergibt die Steuerung, wenn es sich um eine Instanz eines Objekts darstellt (z. B. wenn es sich nicht um den Verweis null-Objekt ist finden Sie unter <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 Bei der zielinstruktion wird als ein mit Vorzeichen 4-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `brtrue` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn <paramref name="value" /> entweder <see langword="true" />, nicht NULL oder ungleich 0 (null) ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|2D < `int8` >|brtrue.s `target`<br /><br /> brinst.s `target`|An eine zielanweisung am angegebenen Offset verzweigen, wenn nicht 0 (null) (`true`), Kurzform.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird von einem früheren Vorgang auf dem Stapel abgelegt.  
  
2.  `value` wird vom Stapel geholt. Wenn `value` ist `true`, Verzweigung zur `target`.  
  
 Die `brtrue.s` -Anweisung übergibt die Steuerung an den angegebenen zielanweisung Wenn `value` (Typ `native int`) ist ungleich Null (`true`). Wenn `value` 0 (null) (`false`) Ausführung wird mit der nächsten Anweisung fortgesetzt.  
  
 Wenn `value` ist ein Objektverweis (Typ `O`) dann `brinst` (Alias für `brtrue`) übergibt die Steuerung, wenn es sich um eine Instanz eines Objekts darstellt (z. B. wenn es sich nicht um den Verweis null-Objekt ist finden Sie unter <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 Bei der zielinstruktion wird als eine signierten 1-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Wenn bei der zielinstruktion mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe. Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `brtrue.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Methode auf, die der übergebene Methodendeskriptor angibt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|28 < `T` >|Rufen Sie `methodDesc`|Rufen Sie die Methode von beschriebenen `methodDesc`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Methodenargumente `arg1` über `argN` auf den Stapel verschoben werden.  
  
2.  Methodenargumente `arg1` über `argN` werden aus dem Stapel; geholt Aufruf der Methode mit diesen Argumenten ausgeführt wird und die Steuerung an die Methode, die von der Methodendeskriptor bezeichnet. Nach Abschluss des Vorgangs ist ein Rückgabewert von der aufgerufenen Methode generiert und an den Aufrufer gesendet.  
  
3.  Der Rückgabewert ist auf dem Stapel abgelegt.  
  
 Die `call` -Anweisung ruft die Methode auf, der mit der Anweisung übergebene Methodendeskriptor. Der Methodendeskriptor ist ein Metadatentoken, der die Methode zum Aufruf und die Anzahl, Typ und Reihenfolge der Argumente, die auf dem Stapel an Ermittlungsmethode sowie die Aufrufkonvention zu verwendende platziert wurden angibt. Die `call` Anweisung kann direkt vorangestellt eine `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) als Präfix Anweisung, um anzugeben, dass der aktuelle Status der Methode freigegeben werden sollen, bevor die Steuerung zu übertragen. Wenn der Aufruf Steuerung auf eine höhere Vertrauensstellung als die Ursprungsmethode übergibt, wird der Stapelrahmen nicht freigegeben. Stattdessen wird die Ausführung im Hintergrund fortgesetzt als wäre die `tail` wurde nicht angegeben wurde. Das Metadatentoken enthält ausreichende Informationen, um zu bestimmen, ob eine statische Methode, eine Instanzmethode, eine virtuelle Methode oder eine globale Funktion aufgerufen wird. In all diesen Fällen wird die Zieladresse vollständig von der Methodendeskriptor bestimmt (vergleichen Sie dies mit der <xref:System.Reflection.Emit.OpCodes.Callvirt> Anweisung zum Aufrufen von virtueller Methoden, hängt die Zieladresse auch den Laufzeittyp der Instanz Verweis abgelegt werden, bevor die <xref:System.Reflection.Emit.OpCodes.Callvirt>).  
  
 Die Argumente werden in Reihenfolge von links nach rechts auf dem Stapel gespeichert. Das erste Argument ist, also berechnet und in im Stapel befindet, und klicken Sie dann das zweite Argument und gibt dann das dritte platziert werden, bis alle erforderlichen Argumente über den Stapel in absteigender Reihenfolge sind. Es gibt drei wichtige Sonderfälle:  
  
 1. Aufrufe mit einer Instanz (oder virtuell) Methode muss mithilfe von Push übertragen, Instanzenverweis vor allen für den Benutzer sichtbaren Argumenten. Der Instanzverweis darf nicht null-Verweis sein. Die Signatur in den Metadaten enthält keinen Eintrag in der Parameterliste für den `this` Zeiger; stattdessen wird eine Bit, um anzugeben, ob die Methode übergeben werden muss die `this` Zeiger.  
  
 2. Es ist zulässig, rufen Sie eine virtuelle Methode mit `call` (statt `callvirt`); Dies gibt an, dass die Methode mit der Klasse, die von Methode statt als angegebenen dynamisch vom aufgerufenen Objekt aufgelöst werden.  
  
 3. Beachten Sie, dass ein Delegat `Invoke` Methode kann aufgerufen werden, entweder mit der `call` oder `callvirt` Anweisung.  
  
 <xref:System.Security.SecurityException> kann ausgelöst werden, wenn die Systemsicherheit den Aufrufer Zugriff für die aufgerufene Methode nicht erteilt. Die sicherheitsüberprüfung kann auftreten, wenn die Microsoft Intermediate Language (MSIL)-Anweisungen in systemeigenen Code anstatt zur Laufzeit konvertiert werden.  
  
> [!NOTE]
>  Erwägen Sie beim Aufruf von Methoden von System.Object für Werttypen die `constrained` das Präfix der `callvirt` Anweisung statt Ausgeben einer `call` Anweisung. Dies beseitigt die Notwendigkeit der auszugebende andere IL abhängig davon, ob der Werttyp die Methode überschreibt, die ein potenzielles Problem der Versionskontrolle zu vermeiden. Erwägen Sie die `constrained` Präfix Schnittstellenmethoden für Werttypen, da die Wert-Datentypmethode Implementieren der Schnittstellenmethode aufrufen kann geändert werden, mithilfe einer `MethodImpl`. Diese Probleme werden ausführlich in die <xref:System.Reflection.Emit.OpCodes.Constrained> Opcode.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> methodenüberladungen können die `call` Opcode:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
-   ILGenerator.EmitCall (OpCode MethodInfo Type  
  
> [!NOTE]
>  Die <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> Methode dient zur `varargs` aufrufen. Verwenden der <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methode für die normale Aufrufe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die angegebene Methode auf dem Auswertungsstapel (als Zeiger auf einen Einstiegspunkt) mit Argumenten auf, die durch eine Aufrufkonvention beschrieben sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|29 < `T` >|calli `callSiteDescr`|Ruft die Methode, die mit Argumenten, die durch die Aufrufkonvention beschrieben gezeigt wird.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Methodenargumente `arg1` über `argN` auf den Stapel verschoben werden.  
  
2.  Die Zeiger auf den Eintrag ist auf dem Stapel abgelegt.  
  
3.  Methodenargumente `arg1` über `argN` und die Zeiger auf den Eintrag aus dem Stapel geholt werden; der Aufruf der Methode erfolgt. Nach Abschluss des Vorgangs ist ein Rückgabewert von der aufgerufenen Methode generiert und an den Aufrufer gesendet.  
  
4.  Der Rückgabewert ist auf dem Stapel abgelegt.  
  
 Die `calli` -Anweisung ruft die Zeiger auf den Eintrag mit den Argumenten `arg1` über `argN`. Die Datentypen der diese Argumente werden durch die bestimmte Aufrufkonvention beschrieben (`callSiteDesc`). Die `calli` Anweisung möglicherweise direkt vorangestellt eine `tail` Präfix (<xref:System.Reflection.Emit.OpCodes.Tailcall>) angeben, dass der aktuelle Status der Methode freigegeben werden sollen, bevor die Steuerung zu übertragen. Wenn der Aufruf übertragen würde wird Steuerelement auf eine höhere Vertrauensstellung als die Ursprungsmethode Stack-Frame nicht freigegeben. stattdessen die Ausführung im Hintergrund fortgesetzt wird als wäre die `tail` wurde nicht angegeben wurde.  
  
 Die Zeiger auf den Eintrag wird davon ausgegangen, dass ein bestimmter Zeiger in systemeigenen Code (des Zielcomputers) sein, die mit den Argumenten, die durch die Aufrufkonvention (ein Metadatentoken für eine eigenständige Signatur) beschriebenen legitimen aufgerufen werden kann. Ein solchen Zeiger kann erstellt werden, mithilfe der <xref:System.Reflection.Emit.OpCodes.Ldftn> oder <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> Anweisungen oder von systemeigenem Code übergeben.  
  
 Die Aufrufkonvention nicht dynamisch markiert ist, sodass code mit einem `calli` Anweisung funktioniert nicht ordnungsgemäß, wenn das Ziel die angegebene Aufrufkonvention verwendet.  
  
 Die Argumente werden in Reihenfolge von links nach rechts auf dem Stapel gespeichert. Das erste Argument ist, also berechnet und in im Stapel befindet, und klicken Sie dann das zweite Argument und gibt dann das dritte platziert werden, bis alle erforderlichen Argumente über den Stapel in absteigender Reihenfolge sind. Die Argument-Erstellung Codesequenz für eine Instanz oder eine virtuelle Methode muss mithilfe von Push übertragen, die auf Instanz verweisen (der kein null-Verweis sein muss) vor allen für den Benutzer sichtbaren Argumenten.  
  
 <xref:System.Security.SecurityException> kann ausgelöst werden, wenn die Sicherheit des Systems den Aufrufer Zugriff für die aufgerufene Methode nicht erteilt. Die sicherheitsüberprüfung kann auftreten, wenn die Microsoft Intermediate Language (MSIL)-Anweisungen in systemeigenen Code anstatt zur Laufzeit konvertiert werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> Methoden können verwendet werden, um das Ausführen einer `calli` Anweisung auf dem Stapel. Beachten Sie, dass `calli` sollte aufgerufen werden, über die folgenden Methoden, anstatt mit der <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Klasse, um die Anweisung direkt auf dem Stapel platzieren.  
  
-   ILGenerator.EmitCalli(Opcode, CallingConventions, Type, Type[], Type[]) for calls using a managed calling convention.  
  
-   ILGenerator.EmitCalli(Opcode, CallingConvention, Type, Type[]) for calls using an unmanaged calling convention.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine spät gebundene Methode für ein Objekt auf und legt den Rückgabewert auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|6F &LT; `T` >|callvirt `method`|Ruft eine bestimmte Methode zugeordnete `obj`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis `obj` auf dem Stapel abgelegt wird.  
  
2.  Methodenargumente `arg1` über `argN` auf den Stapel verschoben werden.  
  
3.  Methodenargumente `arg1` über `argN` und der Objektverweis `obj` werden aus dem Stapel; geholt Aufruf der Methode mit diesen Argumenten ausgeführt wird und die Steuerung an die Methode in `obj` verweist auf die Methode Metadatentoken. Nach Abschluss des Vorgangs ist ein Rückgabewert von der aufgerufenen Methode generiert und an den Aufrufer gesendet.  
  
4.  Der Rückgabewert ist auf dem Stapel abgelegt.  
  
 Die `callvirt` Anweisung ruft eine spät gebundene Methode für ein Objekt. D. h. die Methode ist basierend auf den Laufzeittyp des ausgewählt `obj` anstelle der Kompilierzeit-Klasse, die im Methodenzeiger sichtbar. `Callvirt` Dient zum Aufrufen von virtuellen Methoden und Instanzenmethoden. Die `callvirt` Anweisung möglicherweise direkt vorangestellt eine `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) Präfix, um anzugeben, dass der aktuelle Stapelrahmen freigegeben werden sollen, bevor die Steuerung zu übertragen. Wenn der Aufruf übertragen würde werden Steuerelement auf eine höhere Vertrauensstellung als die ursprüngliche Methode den Stapelrahmen nicht veröffentlicht.  
  
 Das Metadatentoken der Methode enthält Name, Klasse und die Signatur der Methode aufrufen. Die zugeordnete Klasse `obj` ist die Klasse, von denen es eine Instanz ist. Wenn die Klasse eine nicht statische Methode, die die angegebene Methodennamen und derselben Signatur übereinstimmt definiert, wird diese Methode aufgerufen. Andernfalls werden alle Klassen in der Kette Basisklasse dieser Klasse in der Reihenfolge überprüft. Es ist ein Fehler, wenn keine Methode gefunden wird.  
  
 `Callvirt` wird das Objekt und die zugeordneten Argumente vom Stapel Auswertung vor dem Aufrufen der Methode. Wenn die Methode einen Rückgabewert verfügt, ist es auf dem Stapel nach dem Abschluss der Methode abgelegt. Auf der Seite aufgerufener der `obj` Parameter als Argument 0, erfolgt `arg1` als Argument 1 und So weiter.  
  
 Die Argumente werden in Reihenfolge von links nach rechts auf dem Stapel gespeichert. Das erste Argument ist, also berechnet und in im Stapel befindet, und klicken Sie dann das zweite Argument und gibt dann das dritte platziert werden, bis alle erforderlichen Argumente über den Stapel in absteigender Reihenfolge sind. Die Instanzenverweis `obj` (immer erforderlich, für `callvirt`) müssen vor allen für den Benutzer sichtbaren Argumenten abgelegt werden. Die Signatur (in das Metadatentoken) muss keinen Eintrag in der Parameterliste für diesen Zeiger.  
  
 Beachten Sie, dass eine virtuelle Methode auch aufgerufen werden kann, mithilfe der <xref:System.Reflection.Emit.OpCodes.Call> Anweisung.  
  
 <xref:System.MissingMethodException> wird ausgelöst, wenn eine nicht statische Methode mit dem angegebenen Namen und derselben Signatur nicht konnte, können Sie in der zugeordneten Klasse gefunden werden `obj` oder eine der zugehörigen Basisklassen. Dies wird in der Regel erkannt, wenn Microsoft Intermediate Language (MSIL)-Anweisungen in systemeigenen Code anstatt zur Laufzeit konvertiert werden.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn Obj null ist.  
  
 <xref:System.Security.SecurityException> wird ausgelöst, wenn die Systemsicherheit den Aufrufer Zugriff für die aufgerufene Methode nicht erteilt. Die sicherheitsüberprüfung kann auftreten, wenn die CIL in systemeigenen Code anstatt zur Laufzeit konvertiert wird.  
  
> [!NOTE]
>  Erwägen Sie beim Aufruf von Methoden von System.Object für Werttypen, die `constrained` das Präfix der `callvirt` Anweisung. Dies beseitigt die Notwendigkeit der auszugebende andere IL abhängig davon, ob der Werttyp die Methode überschreibt, die ein potenzielles Problem der Versionskontrolle zu vermeiden. Erwägen Sie die `constrained` Präfix Schnittstellenmethoden für Werttypen, da die Wert-Datentypmethode Implementieren der Schnittstellenmethode aufrufen kann geändert werden, mithilfe einer `MethodImpl`. Diese Probleme werden ausführlich in die <xref:System.Reflection.Emit.OpCodes.Constrained> Opcode.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `callvirt` Opcode:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
-   ILGenerator.EmitCall (OpCode MethodInfo Type  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wandelt ein als Verweis übergebenes Objekt in die angegebene Klasse um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|74 < `T` >|castclass `class`|Wandelt ein Objekt in ein neues Objekt des Typs `class`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis ist auf dem Stapel abgelegt.  
  
2.  Der Objektverweis wird vom Stapel geholt. Das referenzierte Objekt umgewandelt wird wie die angegebene `class`.  
  
3.  Bei Erfolg wird ein neuer Objektverweis auf dem Stapel abgelegt.  
  
 Die `castclass` Anweisung versucht, den Objektverweis umwandeln (Typ `O`) über den Stapel zu einer angegebenen Klasse. Die neue Klasse wird durch ein Metadatentoken, der angibt, der gewünschten Klasse angegeben. Wenn die Klasse des Objekts oben im Stapel nicht die neue Klasse (vorausgesetzt, die neue Klasse ist eine Schnittstelle) implementiert und keine der neuen Klasse abgeleiteten Klasse ist ein <xref:System.InvalidCastException> ausgelöst wird. Wenn der Objektverweis ein null-Verweis ist `castclass` erfolgreich ausgeführt und das neue Objekt als null-Verweis zurückgegeben.  
  
 <xref:System.InvalidCastException> wird ausgelöst, wenn Obj Klasse umgewandelt werden kann.  
  
 <xref:System.TypeLoadException> wird ausgelöst, wenn die Klasse nicht gefunden werden kann. Dies wird in der Regel erkannt, wenn eine Microsoft Intermediate Language (MSIL)-Anweisung in nativen Code anstatt zur Laufzeit konvertiert wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `castclass` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Vergleicht zwei Werte. Wenn sie gleich sind, wird der Ganzzahlwert 1 <see langword="(int32" />) auf dem Auswertungsstapel abgelegt, andernfalls wird 0 (<see langword="int32" />) auf dem Auswertungsstapel abgelegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 01|ceq|Schiebt 1, wenn `value1` gleich `value2`ist, andernfalls wird 0.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` sind per pop ausgelesen, aus dem Stapel; `value1` im Vergleich zu `value2`.  
  
4.  Wenn `value1` gleich `value2`, 1 auf dem Stapel abgelegt wird; andernfalls wird 0 auf dem Stapel abgelegt.  
  
 Die `ceq` -Anweisung vergleicht `value1` und `value2`. Wenn `value1` gleich `value2`, dann 1 (des Typs `int32`) auf dem Stapel abgelegt wird. Andernfalls 0 (des Typs `int32`) auf dem Stapel abgelegt wird.  
  
 Für Gleitkommazahl `ceq` gibt 0 zurück, wenn die Zahlen ungeordnet sind (eine oder beide sind "NaN"). Unbegrenzte Werte entsprechen den selbst.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ceq` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Vergleicht zwei Werte. Wenn der erste Wert größer als der zweite Wert ist, wird der Ganzzahlwert 1 <see langword="(int32" />) auf dem Auswertungsstapel abgelegt, andernfalls wird 0 (<see langword="int32" />) auf dem Auswertungsstapel abgelegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 02|cgt|Verschiebt den 1, wenn `value1` ist größer als `value2`ist, andernfalls wird 0.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` sind per pop ausgelesen, aus dem Stapel; `cgt` testet, ob `value1` ist größer als `value2`.  
  
4.  Wenn `value1` ist größer als `value2`, 1 auf dem Stapel abgelegt wird; andernfalls wird 0 auf dem Stapel abgelegt.  
  
 Die `cgt` -Anweisung vergleicht `value1` und `value2`. Wenn `value1` ist streng größer als `value2`, ein `int32` Wert 1 auf dem Stapel abgelegt wird. Andernfalls ein `int32` Wert 0 wird auf dem Stapel abgelegt.  
  
-   Für Gleitkommazahlen `cgt` gibt 0 zurück, wenn die Zahlen ungeordnet sind (d. h., wenn eine oder beide Argumente NaN sind).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `cgt` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Vergleicht zwei Werte ohne Vorzeichen oder zwei ungeordnete Werte. Wenn der erste Wert größer als der zweite Wert ist, wird der Ganzzahlwert 1 <see langword="(int32" />) auf dem Auswertungsstapel abgelegt, andernfalls wird 0 (<see langword="int32" />) auf dem Auswertungsstapel abgelegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 03|cgt.un|Verschiebt den 1, wenn `value1` ist größer als `value2`ist, andernfalls wird 0 (Werte ohne Vorzeichen).|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` sind per pop ausgelesen, aus dem Stapel; `cgt.un` testet, ob `value1` ist größer als `value2`.  
  
4.  Wenn `value1` ist größer als `value2`, 1 auf dem Stapel abgelegt wird; andernfalls wird 0 auf dem Stapel abgelegt.  
  
 Ein `int32` Wert 1 wird auf dem Stapel abgelegt, wenn einer der folgenden `true` :  
  
 Für Gleitkommazahlen `value1` nicht sortiert wird, ist in Bezug auf `value2`.  
  
 Bei Ganzzahlwerten `value1` ist streng größer als `value2` Wenn Sie als Zahlen ohne Vorzeichen interpretiert.  
  
 Andernfalls ein `int32` Wert 0 wird auf dem Stapel abgelegt.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `cgt.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Löst <see cref="T:System.ArithmeticException" /> aus, wenn der Wert keine endliche Zahl ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|C3|ckfinite|löst <xref:System.ArithmeticException> Wenn der Wert keine endliche Zahl ist.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt...  
  
2.  `value` wird vom Stapel geholt und die `ckfinite` Anweisung auf ihm ausgeführt wird.  
  
3.  `value` wird wieder auf dem Stapel abgelegt werden, wenn keine Ausnahme ausgelöst wird.  
  
 Die `ckfinite instruction` löst <xref:System.ArithmeticException> Wenn `value` (eine Gleitkommazahl) ist entweder ein "not a Number" Wert (NaN) oder eine `+-` Unendlichkeitswert. `Ckfinite` jedes Mal, wenn keine Ausnahme ausgelöst wird, lässt der Wert auf dem Stapel. Ausführung ist nicht angegeben, wenn `value` keine Gleitkommazahl ist.  
  
 <xref:System.ArithmeticException> wird ausgelöst, wenn `value` ist keine Zahl 'normale'.  
  
 Beachten Sie, dass eine besondere Ausnahme oder eine abgeleitete Klasse von <xref:System.ArithmeticException> möglicherweise besser geeignet, den falschen Wert an den Ausnahmehandler übergeben.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ckfinite` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Vergleicht zwei Werte. Wenn der erste Wert kleiner als der zweite Wert ist, wird der Ganzzahlwert 1 <see langword="(int32" />) auf dem Auswertungsstapel abgelegt, andernfalls wird 0 (<see langword="int32" />) auf dem Auswertungsstapel abgelegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 04|clt|Verschiebt den 1, wenn `value1` ist kleiner als `value2`ist, andernfalls wird 0.|  
  
 Im Stapel laufen in sequenzieller Reihenfolge ist: `value1` auf dem Stapel abgelegt wird.  
  
1.  `value2` wird auf dem Stapel abgelegt.  
  
2.  `value2` und `value1` sind per pop ausgelesen, aus dem Stapel; `clt` testet, ob `value1` ist kleiner als `value2`.  
  
3.  Wenn `value1` ist kleiner als `value2`, 1 auf dem Stapel abgelegt wird; andernfalls wird 0 auf dem Stapel abgelegt.  
  
 Die `clt` -Anweisung vergleicht `value1` und `value2`. Wenn `value1` ist kleiner als `value2`, ein `int32` Wert 1 auf dem Stapel abgelegt wird. Andernfalls ein `int32` Wert 0 wird auf dem Stapel abgelegt.  
  
-   Für Gleitkommazahlen `clt` gibt 0 zurück, wenn die Zahlen ungeordnet sind (d. h., wenn eine oder beide Argumente NaN sind).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `clt` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Vergleicht die Werte ohne Vorzeichen oder die ungeordneten Werte <paramref name="value1" /> und <paramref name="value2" />. Wenn <paramref name="value1" /> kleiner als <paramref name="value2" /> ist, wird der Ganzzahlwert 1 <see langword="(int32" />) auf dem Auswertungsstapel abgelegt, andernfalls wird 0 (<see langword="int32" />) auf dem Auswertungsstapel abgelegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 05|clt.un|Verschiebt den 1, wenn `value1` ist kleiner als `value2`ist, andernfalls wird 0 (Werte ohne Vorzeichen).|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` sind per pop ausgelesen, aus dem Stapel; `clt.un` testet, ob `value1` ist kleiner als `value2`.  
  
4.  Wenn `value1` ist kleiner als `value2`, 1 auf dem Stapel abgelegt wird; andernfalls wird 0 auf dem Stapel abgelegt.  
  
 Die `clt.un` -Anweisung vergleicht `value1` und `value2`. Ein `int32` Wert 1 wird auf dem Stapel abgelegt, wenn eine der folgenden Aussagen zutrifft:  
  
-   `value1` ist kleiner als `value2` (wie bei `clt`).  
  
-   Für Gleitkommazahlen `value1` nicht sortiert wird, ist in Bezug auf `value2`.  
  
-   Bei Ganzzahlwerten `value1` ist kleiner als `value2` Wenn Sie als Zahlen ohne Vorzeichen interpretiert.  
  
 Andernfalls ein `int32` Wert 0 wird auf dem Stapel abgelegt.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `clt.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Schränkt den Typ ein, für den eine virtuelle Methode aufgerufen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Microsoft intermediate Language (MSIL) Assemblyformat sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 16 < `T` >|eingeschränkt. `thisType`|Aufruf eine virtuelle Methode für einen Typ als Typ Eingeschränkte `T`.|  
  
 Die `constrained` Präfix ist nur zulässig, eine `callvirt` Anweisung.  
  
 Der Status des Stapels MSIL zu diesem Zeitpunkt muss wie folgt lauten:  
  
1.  Ein verwalteter Zeiger `ptr`, auf dem Stapel abgelegt wird. Der Typ des `ptr` muss ein verwalteter Zeiger sein (`&`) zu `thisType`. Beachten Sie, dass dies der Fall, der einem schmalzeichenliteral ohne Präfix unterscheidet `callvirt` -Anweisung, die einen Verweis erwartet `thisType`.  
  
2.  Methodenargumente `arg1` über `argN` werden auf dem Stapel abgelegt, so wie dies bei einem schmalzeichenliteral ohne Präfix `callvirt` Anweisung.  
  
 Die `constrained` Präfix soll ermöglicht `callvirt` Anweisungen, um eine einheitliche Weise unabhängig davon, ob erfolgen `thisType` ein Werttyp oder ein Verweistyp ist.  
  
 Wenn eine `callvirt` `method` -Anweisung vorangestellt `constrained` `thisType`, die Anweisung wird wie folgt ausgeführt:  
  
-   Wenn `thisType` ist ein Verweistyp (im Gegensatz zu einem Werttyp) `ptr` dereferenziert und 'this' Zeiger zum Übergeben der `callvirt` von `method`.  
  
-   Wenn `thisType` ist ein Werttyp und `thisType` implementiert `method` klicken Sie dann `ptr` übergeben unverändert als das this-Zeiger auf eine `call` `method` -Anweisung, für die Implementierung von `method` von `thisType`.  
  
-   Wenn `thisType` ist ein Werttyp und `thisType` implementiert nicht `method` dann `ptr` dereferenziert, geschachtelt und als der this-Zeiger zum Übergeben der `callvirt` `method` Anweisung.  
  
 Dieser letzte Fall kann auftreten, nur, wenn `method` wurde definiert, auf <xref:System.Object>, <xref:System.ValueType>, oder <xref:System.Enum> und nicht überschrieben werden, indem `thisType`. In diesem Fall führt das Boxing eine Kopie des ursprünglichen Objekts vorgenommen werden. Jedoch, da keine der Methoden der <xref:System.Object>, <xref:System.ValueType>, und <xref:System.Enum> ändern Sie den Zustand des Objekts, die diese Tatsache nicht erkannt werden.  
  
 Die `constrained` Präfix unterstützt IL-Generatoren, generischen Code zu erstellen. Normalerweise die `callvirt` Anweisung gilt nicht für Werttypen. Stattdessen ist es erforderlich, dass die IL-Compilern umfassend die 'this' Transformation, die zum Zeitpunkt der Kompilierung, je nach Art der oben beschriebenen `ptr` und der aufgerufenen Methode. Jedoch wenn `ptr` ist ein generischer Typ, der zum Zeitpunkt der Kompilierung bekannt ist es ist nicht möglich, stellen diese Transformation zum Zeitpunkt der Kompilierung.  
  
 Die `constrained` Opcode ermöglicht, einen Aufruf einer virtuellen Funktion in eine einheitliche Weise unabhängig davon, ob die IL-Compilern `ptr` ein Werttyp oder ein Verweistyp ist. Gedacht für den Fall, in dem `thisType` wird eine Variablen des generischen Typs, der `constrained` Präfix auch eignet sich für nicht generische Typen und können reduzieren die Komplexität virtuelle Aufrufe in Sprachen, die den Unterschied zwischen Werttypen ausblenden zu generieren und Verweistypen.  
  
 Mithilfe der `constrained` Präfix vermeidet auch potenziellen Versionsproblemen mit Werttypen. Wenn die `constrained` Präfix nicht verwendet wird, andere IL ausgegeben werden muss, je nachdem, ob ein Werttyp eine Methode von System.Object überschreibt. Angenommen, ein Werttyp `V` die Object.ToString()-Methode überschreibt eine `call` `V.ToString()` Anweisung ausgegeben wird; Wenn nicht, eine `box` Anweisung und eine `callvirt` `Object.ToString()` Anweisung ausgegeben werden. Ein Problem Versioning kann im ersten Fall, wenn die Außerkraftsetzung später entfernt wird, und klicken Sie im letzteren Fall auftreten, wenn eine Überschreibung später hinzugefügt wird.  
  
 Die `constrained` Präfix kann auch für das Aufrufen von Methoden der Schnittstelle auf Typen mit Werten verwendet werden, da die Implementierung der Schnittstellenmethode Wert-Datentypmethode über geändert werden kann eine `MethodImpl`. Wenn die `constrained` Präfix wird nicht verwendet, der Compiler gezwungen, die den Wert des Typs-Methoden zum Binden an zum Zeitpunkt der Kompilierung auswählen. Mithilfe der `constrained` Präfix ermöglicht die MSIL zum Binden an die Methode, die die Schnittstellenmethode, zur Laufzeit und nicht zum Zeitpunkt der Kompilierung implementiert.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `constrained` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|D3|conv.i|Konvertieren in `native int`, der Speicherort `native int` auf dem Stapel ab.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.i` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode, und lassen, die konvertierte Wert oben im Stapel. Ganzzahlige Werte von weniger als 4 Bytes wurden erweitert, um `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.i` oder `conv.u` verwendet wird, in diesem Fall ist auch das Ergebnis `native int`). In Gleitkommazahlen-Punktwerte konvertiert die `F` Typ.  
  
 Konvertieren von Gleitkommazahlen Ganzzahlwerte schneidet die Zahl in Richtung 0 (null) ab. Beim Konvertieren von einer `float64` zu einem `float32`, Genauigkeit verloren. Wenn `value` ist zu groß für einem `float32 (F)`, plus unendlich (Wenn `value` positiv ist) oder minus unendlich dar (Wenn `value` ist ein negativer Wert) zurückgegeben. Wenn Überlauf beim Konvertieren einer Integer-Datentyp in einen anderen auftritt, werden die höherwertigen Bits abgeschnitten. Wenn das Ergebnis kleiner als ein `int32`, der Wert ist signaturerweitert zum Ausfüllen des Slots.  
  
 Wenn es sich bei Auftreten eines Überlaufs ist die Konvertierung von einem Gleitkommatyp in eine ganze Zahl, die der zurückgegebene Wert nicht angegeben.  
  
 Jemals werden keine Ausnahmen ausgelöst, wenn Sie dieses Feld verwenden. Finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> entsprechende Anweisungen, die eine Ausnahme auslöst, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.i` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="int8" /> und erweitert ihn dann zu <see langword="int32" /> (durch Auffüllen).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|67|i1|Konvertieren in `int8`, der Speicherort `int32` auf dem Stapel ab.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.i1` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode, und lassen, die konvertierte Wert oben im Stapel. Ganzzahlige Werte von weniger als 4 Bytes wurden erweitert, um `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.i` oder `conv.u` verwendet wird, in diesem Fall ist auch das Ergebnis `native int`). In Gleitkommazahlen-Punktwerte konvertiert die `F` Typ.  
  
 Konvertieren von Gleitkommazahlen Ganzzahlwerte schneidet die Zahl in Richtung 0 (null) ab. Beim Konvertieren von einer `float64` zu einem `float32`, Genauigkeit verloren. Wenn `value` ist zu groß für einem `float32 (F)`, plus unendlich (Wenn `value` positiv ist) oder minus unendlich dar (Wenn `value` ist ein negativer Wert) zurückgegeben. Wenn Überlauf beim Konvertieren einer Integer-Datentyp in einen anderen auftritt, werden die höherwertigen Bits abgeschnitten. Wenn das Ergebnis kleiner als ein `int32`, der Wert ist signaturerweitert zum Ausfüllen des Slots.  
  
 Wenn es sich bei Auftreten eines Überlaufs ist die Konvertierung von einem Gleitkommatyp in eine ganze Zahl, die der zurückgegebene Wert nicht angegeben.  
  
 Jemals werden keine Ausnahmen ausgelöst, wenn Sie dieses Feld verwenden. Finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> entsprechende Anweisungen, die eine Ausnahme auslöst, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.i1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="int16" /> und erweitert ihn dann zu <see langword="int32" /> (durch Auffüllen).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|68|i2|Konvertieren in `int16`, der Speicherort `int32` auf dem Stapel ab.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.i2` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode, und lassen, die konvertierte Wert oben im Stapel. Ganzzahlige Werte von weniger als 4 Bytes wurden erweitert, um `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.i` oder `conv.u` verwendet wird, in diesem Fall ist auch das Ergebnis `native int`). In Gleitkommazahlen-Punktwerte konvertiert die `F` Typ.  
  
 Konvertieren von Gleitkommazahlen Ganzzahlwerte schneidet die Zahl in Richtung 0 (null) ab. Beim Konvertieren von einer `float64` zu einem `float32`, Genauigkeit verloren. Wenn `value` ist zu groß für einem `float32 (F)`, plus unendlich (Wenn `value` positiv ist) oder minus unendlich dar (Wenn `value` ist ein negativer Wert) zurückgegeben. Wenn Überlauf beim Konvertieren einer Integer-Datentyp in einen anderen auftritt, werden die höherwertigen Bits abgeschnitten. Wenn das Ergebnis kleiner als ein `int32`, der Wert ist signaturerweitert zum Ausfüllen des Slots.  
  
 Wenn es sich bei Auftreten eines Überlaufs ist die Konvertierung von einem Gleitkommatyp in eine ganze Zahl, die der zurückgegebene Wert nicht angegeben.  
  
 Jemals werden keine Ausnahmen ausgelöst, wenn Sie dieses Feld verwenden. Finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> entsprechende Anweisungen, die eine Ausnahme auslöst, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.i2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|69|i4|Konvertieren in `int32`, der Speicherort `int32` auf dem Stapel ab.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.i4` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode, und lassen, die konvertierte Wert oben im Stapel. Ganzzahlige Werte von weniger als 4 Bytes wurden erweitert, um `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.i` oder `conv.u` verwendet wird, in diesem Fall ist auch das Ergebnis `native int`). In Gleitkommazahlen-Punktwerte konvertiert die `F` Typ.  
  
 Konvertieren von Gleitkommazahlen Ganzzahlwerte schneidet die Zahl in Richtung 0 (null) ab. Beim Konvertieren von einer `float64` zu einem `float32`, Genauigkeit verloren. Wenn `value` ist zu groß für einem `float32 (F)`, plus unendlich (Wenn `value` positiv ist) oder minus unendlich dar (Wenn `value` ist ein negativer Wert) zurückgegeben. Wenn Überlauf beim Konvertieren einer Integer-Datentyp in einen anderen auftritt, werden die höherwertigen Bits abgeschnitten. Wenn das Ergebnis kleiner als ein `int32`, der Wert ist signaturerweitert zum Ausfüllen des Slots.  
  
 Wenn es sich bei Auftreten eines Überlaufs ist die Konvertierung von einem Gleitkommatyp in eine ganze Zahl, die der zurückgegebene Wert nicht angegeben.  
  
 Jemals werden keine Ausnahmen ausgelöst, wenn Sie dieses Feld verwenden. Finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> entsprechende Anweisungen, die eine Ausnahme auslöst, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.i4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|6A|i8|Konvertieren in `int64`, der Speicherort `int64` auf dem Stapel ab.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.i8` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode, und lassen, die konvertierte Wert oben im Stapel. Ganzzahlige Werte von weniger als 4 Bytes wurden erweitert, um `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.i` oder `conv.u` verwendet wird, in diesem Fall ist auch das Ergebnis `native int`). In Gleitkommazahlen-Punktwerte konvertiert die `F` Typ.  
  
 Konvertieren von Gleitkommazahlen Ganzzahlwerte schneidet die Zahl in Richtung 0 (null) ab. Beim Konvertieren von einer `float64` zu einem `float32`, Genauigkeit verloren. Wenn `value` ist zu groß für einem `float32 (F)`, plus unendlich (Wenn `value` positiv ist) oder minus unendlich dar (Wenn `value` ist ein negativer Wert) zurückgegeben. Wenn Überlauf beim Konvertieren einer Integer-Datentyp in einen anderen auftritt, werden die höherwertigen Bits abgeschnitten. Wenn das Ergebnis kleiner als ein `int32`, der Wert ist signaturerweitert zum Ausfüllen des Slots.  
  
 Wenn es sich bei Auftreten eines Überlaufs ist die Konvertierung von einem Gleitkommatyp in eine ganze Zahl, die der zurückgegebene Wert nicht angegeben.  
  
 Jemals werden keine Ausnahmen ausgelöst, wenn Sie dieses Feld verwenden. Finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> entsprechende Anweisungen, die eine Ausnahme auslöst, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.i8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="native int" /> mit Vorzeichen und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|D4|conv.ovf.i|Konvertieren in eine `native int` (auf dem Stapel als `native int`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.i` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode und Bereiche, die konvertierte Wert oben im Stapel. Ist der Wert zu groß oder zu klein, um durch den Zieltyp dargestellt werden, wird eine Ausnahme ausgelöst.  
  
 Beim Konvertieren von Gleitkommazahlen in Ganzzahlwerte werden die Zahlen in Richtung 0 abgeschnitten. Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.ovf.i` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="native int" /> mit Vorzeichen und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|8A|conv.ovf.i.un|Konvertiert einen Wert ohne Vorzeichen in eine `native int` (auf dem Stapel als `native int`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.i.un` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode und Bereiche, die konvertierte Wert oben im Stapel. Ist der Wert zu groß oder zu klein, um durch den Zieltyp dargestellt werden, wird eine Ausnahme ausgelöst.  
  
 Beim Konvertieren von Gleitkommazahlen in Ganzzahlwerte werden die Zahlen in Richtung 0 abgeschnitten. Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.ovf.i.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int8" /> mit Vorzeichen und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|B3|conv.ovf.i1|Konvertieren in ein `int8` (auf dem Stapel als `int32`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.i1` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode und Bereiche, die konvertierte Wert oben im Stapel. Ist der Wert zu groß oder zu klein, um durch den Zieltyp dargestellt werden, wird eine Ausnahme ausgelöst.  
  
 Beim Konvertieren von Gleitkommazahlen in Ganzzahlwerte werden die Zahlen in Richtung 0 abgeschnitten. Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.ovf.i1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int8" /> mit Vorzeichen und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|82|conv.ovf.i1.un|Konvertiert einen Wert ohne Vorzeichen in eine `int8` (auf dem Stapel als `int32`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.i1.un` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode und Bereiche, die konvertierte Wert oben im Stapel. Ist der Wert zu groß oder zu klein, um durch den Zieltyp dargestellt werden, wird eine Ausnahme ausgelöst.  
  
 Beim Konvertieren von Gleitkommazahlen in Ganzzahlwerte werden die Zahlen in Richtung 0 abgeschnitten. Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.ovf.i1.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int16" /> mit Vorzeichen und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|B5|conv.ovf. i2|Konvertieren in ein `int16` (auf dem Stapel als `int32`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.i2` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode und Bereiche, die konvertierte Wert oben im Stapel. Ist der Wert zu groß oder zu klein, um durch den Zieltyp dargestellt werden, wird eine Ausnahme ausgelöst.  
  
 Beim Konvertieren von Gleitkommazahlen in Ganzzahlwerte werden die Zahlen in Richtung 0 abgeschnitten. Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.ovf.i2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int16" /> mit Vorzeichen und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|83|conv.ovf.i2.un|Konvertiert einen Wert ohne Vorzeichen in eine `int16` (auf dem Stapel als `int32`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.i2.un` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode und Bereiche, die konvertierte Wert oben im Stapel. Ist der Wert zu groß oder zu klein, um durch den Zieltyp dargestellt werden, wird eine Ausnahme ausgelöst.  
  
 Beim Konvertieren von Gleitkommazahlen in Ganzzahlwerte werden die Zahlen in Richtung 0 abgeschnitten. Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.ovf.i2.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int32" /> mit Vorzeichen und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|B7|conv.ovf. i4|Konvertieren in ein `int32` (auf dem Stapel als `int32`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.i4` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode und Bereiche, die konvertierte Wert oben im Stapel. Ist der Wert zu groß oder zu klein, um durch den Zieltyp dargestellt werden, wird eine Ausnahme ausgelöst.  
  
 Beim Konvertieren von Gleitkommazahlen in Ganzzahlwerte werden die Zahlen in Richtung 0 abgeschnitten. Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.ovf.i4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int32" /> mit Vorzeichen und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|84|conv.ovf.i4.un|Konvertiert einen Wert ohne Vorzeichen in eine `int32` (auf dem Stapel als `int32`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.i4.un` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode und Bereiche, die konvertierte Wert oben im Stapel. Ist der Wert zu groß oder zu klein, um durch den Zieltyp dargestellt werden, wird eine Ausnahme ausgelöst.  
  
 Beim Konvertieren von Gleitkommazahlen in Ganzzahlwerte werden die Zahlen in Richtung 0 abgeschnitten. Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.ovf.i4.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int64" /> mit Vorzeichen und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|B9|i8|Konvertieren in ein `int64` (auf dem Stapel als `int64`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.i8` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode und Bereiche, die konvertierte Wert oben im Stapel. Ist der Wert zu groß oder zu klein, um durch den Zieltyp dargestellt werden, wird eine Ausnahme ausgelöst.  
  
 Beim Konvertieren von Gleitkommazahlen in Ganzzahlwerte werden die Zahlen in Richtung 0 abgeschnitten. Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.ovf.i8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int64" /> mit Vorzeichen und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|85|conv.ovf.i8.un|Konvertiert einen Wert ohne Vorzeichen in eine `int64` (auf dem Stapel als `int64`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.i8.un` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode und Bereiche, die konvertierte Wert oben im Stapel. Ist der Wert zu groß oder zu klein, um durch den Zieltyp dargestellt werden, wird eine Ausnahme ausgelöst.  
  
 Beim Konvertieren von Gleitkommazahlen in Ganzzahlwerte werden die Zahlen in Richtung 0 abgeschnitten. Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.ovf.i8.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned native int" /> und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|D5|conv.ovf.u|Konvertieren in ein `unsigned native int` (auf dem Stapel als `native int`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.u` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode und Bereiche, die konvertierte Wert oben im Stapel. Ist der Wert zu groß oder zu klein, um durch den Zieltyp dargestellt werden, wird eine Ausnahme ausgelöst.  
  
 Beim Konvertieren von Gleitkommazahlen in Ganzzahlwerte werden die Zahlen in Richtung 0 abgeschnitten. Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.ovf.u` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned native int" /> und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|8 B|conv.ovf.u.un|Konvertiert Wert ohne Vorzeichen in eine `unsigned native int` (auf dem Stapel als `native int`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.u.un` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode und Bereiche, die konvertierte Wert oben im Stapel. Ist der Wert zu groß oder zu klein, um durch den Zieltyp dargestellt werden, wird eine Ausnahme ausgelöst.  
  
 Beim Konvertieren von Gleitkommazahlen in Ganzzahlwerte werden die Zahlen in Richtung 0 abgeschnitten. Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.uvf.u.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int8" /> und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|B4|conv.ovf. U1|Konvertieren in ein `unsigned int8` (auf dem Stapel als `int32`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.u1` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode und Bereiche, die konvertierte Wert oben im Stapel. Ist der Wert zu groß oder zu klein, um durch den Zieltyp dargestellt werden, wird eine Ausnahme ausgelöst.  
  
 Beim Konvertieren von Gleitkommazahlen in Ganzzahlwerte werden die Zahlen in Richtung 0 abgeschnitten. Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.ovf.u1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int8" /> und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|86|conv.ovf.u1.un|Konvertiert einen Wert ohne Vorzeichen in eine `unsigned int8` (auf dem Stapel als `int32`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.u1.un` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode und Bereiche, die konvertierte Wert oben im Stapel. Ist der Wert zu groß oder zu klein, um durch den Zieltyp dargestellt werden, wird eine Ausnahme ausgelöst.  
  
 Beim Konvertieren von Gleitkommazahlen in Ganzzahlwerte werden die Zahlen in Richtung 0 abgeschnitten. Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.ovf.u1.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int16" /> und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|B6|conv.ovf. u2|Konvertieren in ein `unsigned int16` (auf dem Stapel als `int32`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.u2` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode und Bereiche, die konvertierte Wert oben im Stapel. Ist der Wert zu groß oder zu klein, um durch den Zieltyp dargestellt werden, wird eine Ausnahme ausgelöst.  
  
 Beim Konvertieren von Gleitkommazahlen in Ganzzahlwerte werden die Zahlen in Richtung 0 abgeschnitten. Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.ovf.u2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int16" /> und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|87|conv.ovf.u2.un|Konvertiert einen Wert ohne Vorzeichen in eine `unsigned int16` (auf dem Stapel als `int32`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.u2.un` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode und Bereiche, die konvertierte Wert oben im Stapel. Ist der Wert zu groß oder zu klein, um durch den Zieltyp dargestellt werden, wird eine Ausnahme ausgelöst.  
  
 Beim Konvertieren von Gleitkommazahlen in Ganzzahlwerte werden die Zahlen in Richtung 0 abgeschnitten. Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.ovf.u2.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int32" /> und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|B8|U4|Konvertieren in ein `unsigned int32` (auf dem Stapel als `int32`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.u4` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode und Bereiche, die konvertierte Wert oben im Stapel. Ist der Wert zu groß oder zu klein, um durch den Zieltyp dargestellt werden, wird eine Ausnahme ausgelöst.  
  
 Beim Konvertieren von Gleitkommazahlen in Ganzzahlwerte werden die Zahlen in Richtung 0 abgeschnitten. Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.ovf.u4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int32" /> und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|88|conv.ovf.u4.un|Konvertiert einen Wert ohne Vorzeichen in eine `unsigned int32` (auf dem Stapel als `int32`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.u4.un` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode und Bereiche, die konvertierte Wert oben im Stapel. Ist der Wert zu groß oder zu klein, um durch den Zieltyp dargestellt werden, wird eine Ausnahme ausgelöst.  
  
 Beim Konvertieren von Gleitkommazahlen in Ganzzahlwerte werden die Zahlen in Richtung 0 abgeschnitten. Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.ovf.u4.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int64" /> und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|BA|U8|Konvertieren in ein `unsigned int64` (auf dem Stapel als `int64`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.u8` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode und Bereiche, die konvertierte Wert oben im Stapel. Ist der Wert zu groß oder zu klein, um durch den Zieltyp dargestellt werden, wird eine Ausnahme ausgelöst.  
  
 Beim Konvertieren von Gleitkommazahlen in Ganzzahlwerte werden die Zahlen in Richtung 0 abgeschnitten. Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.ovf.u8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int64" /> und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|89|conv.ovf.u8.un|Konvertiert einen Wert ohne Vorzeichen in eine `unsigned int64` (auf dem Stapel als `int64`) und löst eine Ausnahme bei einem Überlauf.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.ovf.u8.un` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode und Bereiche, die konvertierte Wert oben im Stapel. Ist der Wert zu groß oder zu klein, um durch den Zieltyp dargestellt werden, wird eine Ausnahme ausgelöst.  
  
 Beim Konvertieren von Gleitkommazahlen in Ganzzahlwerte werden die Zahlen in Richtung 0 abgeschnitten. Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.ovf.i` oder `conv.ovf.u` verwendet werden, in diesem Fall ist auch das Ergebnis `native int`).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.ovf.u8.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Ganzzahlwert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|76|conv.r.un|Convert-Ganzzahl ohne Vorzeichen in Gleitkommazahlen betätigen `F` auf dem Stapel ab.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.r.un` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode, und lassen, die konvertierte Wert oben im Stapel. Ganzzahlige Werte von weniger als 4 Bytes wurden erweitert, um `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.i` oder `conv.u` verwendet wird, in diesem Fall ist auch das Ergebnis `native int`). In Gleitkommazahlen-Punktwerte konvertiert die `F` Typ.  
  
 Konvertieren von Gleitkommazahlen Ganzzahlwerte schneidet die Zahl in Richtung 0 (null) ab. Beim Konvertieren von einer `float64` zu einem `float32`, Genauigkeit verloren. Wenn `value` ist zu groß für einem `float32 (F)`, plus unendlich (Wenn `value` positiv ist) oder minus unendlich dar (Wenn `value` ist ein negativer Wert) zurückgegeben. Wenn Überlauf beim Konvertieren einer Integer-Datentyp in einen anderen auftritt, werden die höherwertigen Bits abgeschnitten. Wenn das Ergebnis kleiner als ein `int32`, der Wert ist signaturerweitert zum Ausfüllen des Slots.  
  
 Wenn Überlauf auftritt, Konvertieren von einem Gleitkommatyp in eine ganze Zahl die `result` zurückgegeben wird, nicht angegeben. Die `conv.r.un` Vorgang akzeptiert eine ganze Zahl vom Stapel, wird er als ohne Vorzeichen interpretiert, und ersetzt ihn durch eine Gleitkommazahl, die ganze Zahl darstellt: entweder ein `float32`, ist dies breit genug, um die ganze Zahl ohne Genauigkeitsverlust darstellen, oder andernfalls eine `float64`.  
  
 Jemals werden keine Ausnahmen ausgelöst, wenn Sie dieses Feld verwenden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.r.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|6B|R4|Konvertieren in `float32`, der Speicherort `F` auf dem Stapel ab.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.r4` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode, und lassen, die konvertierte Wert oben im Stapel. Ganzzahlige Werte von weniger als 4 Bytes wurden erweitert, um `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.i` oder `conv.u` verwendet wird, in diesem Fall ist auch das Ergebnis `native int`). In Gleitkommazahlen-Punktwerte konvertiert die `F` Typ.  
  
 Konvertieren von Gleitkommazahlen Ganzzahlwerte schneidet die Zahl in Richtung 0 (null) ab. Beim Konvertieren von einer `float64` auf eine `float32`, Genauigkeit verloren. Wenn `value` ist zu groß für einem `float32 (F)`, plus unendlich (Wenn `value` positiv ist) oder minus unendlich dar (Wenn `value` ist ein negativer Wert) zurückgegeben. Wenn Überlauf beim Konvertieren einer Integer-Datentyp in einen anderen auftritt, werden die höherwertigen Bits abgeschnitten. Wenn das Ergebnis kleiner als ein `int32`, der Wert ist signaturerweitert zum Ausfüllen des Slots.  
  
 Wenn es sich bei Auftreten eines Überlaufs ist die Konvertierung von einem Gleitkommatyp in eine ganze Zahl, die der zurückgegebene Wert nicht angegeben.  
  
 Jemals werden keine Ausnahmen ausgelöst, wenn Sie dieses Feld verwenden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.r4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="float64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|6C|conv. r8|Konvertieren in `float64`, der Speicherort `F` auf dem Stapel ab.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.r8` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode, und lassen, die konvertierte Wert oben im Stapel. Ganzzahlige Werte von weniger als 4 Bytes wurden erweitert, um `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.i` oder `conv.u` verwendet wird, in diesem Fall ist auch das Ergebnis `native int`). In Gleitkommazahlen-Punktwerte konvertiert die `F` Typ.  
  
 Konvertieren von Gleitkommazahlen Ganzzahlwerte schneidet die Zahl in Richtung 0 (null) ab. Beim Konvertieren von einer `float64` auf eine `float32`, Genauigkeit verloren. Wenn `value` ist zu groß für einem `float32 (F)`, plus unendlich (Wenn `value` positiv ist) oder minus unendlich dar (Wenn `value` ist ein negativer Wert) zurückgegeben. Wenn Überlauf beim Konvertieren einer Integer-Datentyp in einen anderen auftritt, werden die höherwertigen Bits abgeschnitten. Wenn das Ergebnis kleiner als ein `int32`, der Wert ist signaturerweitert zum Ausfüllen des Slots.  
  
 Wenn es sich bei Auftreten eines Überlaufs ist die Konvertierung von einem Gleitkommatyp in eine ganze Zahl, die der zurückgegebene Wert nicht angegeben.  
  
 Jemals werden keine Ausnahmen ausgelöst, wenn Sie dieses Feld verwenden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.r8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="unsigned native int" /> und erweitert ihn dann zu <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|E0|conv.u|Konvertieren in `unsigned native int`, der Speicherort `native int` auf dem Stapel ab.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.u` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode, und lassen, die konvertierte Wert oben im Stapel. Ganzzahlige Werte von weniger als 4 Bytes wurden erweitert, um `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.i` oder `conv.u` verwendet wird, in diesem Fall ist auch das Ergebnis `native int`). In Gleitkommazahlen-Punktwerte konvertiert die `F` Typ.  
  
 Konvertieren von Gleitkommazahlen Ganzzahlwerte schneidet die Zahl in Richtung 0 (null) ab. Beim Konvertieren von einer `float64` auf eine `float32`, Genauigkeit verloren. Wenn `value` ist zu groß für einem `float32 (F)`, plus unendlich (Wenn `value` positiv ist) oder minus unendlich dar (Wenn `value` ist ein negativer Wert) zurückgegeben. Wenn Überlauf beim Konvertieren einer Integer-Datentyp in einen anderen auftritt, werden die höherwertigen Bits abgeschnitten. Wenn das Ergebnis kleiner als ein `int32`, der Wert ist signaturerweitert zum Ausfüllen des Slots.  
  
 Wenn es sich bei Auftreten eines Überlaufs ist die Konvertierung von einem Gleitkommatyp in eine ganze Zahl, die der zurückgegebene Wert nicht angegeben.  
  
 Jemals werden keine Ausnahmen ausgelöst, wenn Sie dieses Feld verwenden. Finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> entsprechende Anweisungen, die eine Ausnahme auslöst, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.u` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="unsigned int8" /> und erweitert ihn dann zu <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|D2|conv. U1|Konvertieren in `int8`, der Speicherort `int32` auf dem Stapel ab.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.u1` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode, und lassen, die konvertierte Wert oben im Stapel. Ganzzahlige Werte von weniger als 4 Bytes wurden erweitert, um `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.i` oder `conv.u` verwendet wird, in diesem Fall ist auch das Ergebnis `native int`). In Gleitkommazahlen-Punktwerte konvertiert die `F` Typ.  
  
 Konvertieren von Gleitkommazahlen Ganzzahlwerte schneidet die Zahl in Richtung 0 (null) ab. Beim Konvertieren von einer `float64` auf eine `float32`, Genauigkeit verloren. Wenn `value` ist zu groß für einem `float32 (F)`, plus unendlich (Wenn `value` positiv ist) oder minus unendlich dar (Wenn `value` ist ein negativer Wert) zurückgegeben. Wenn Überlauf beim Konvertieren einer Integer-Datentyp in einen anderen auftritt, werden die höherwertigen Bits abgeschnitten. Wenn das Ergebnis kleiner als ein `int32`, der Wert ist signaturerweitert zum Ausfüllen des Slots.  
  
 Wenn es sich bei Auftreten eines Überlaufs ist die Konvertierung von einem Gleitkommatyp in eine ganze Zahl, die der zurückgegebene Wert nicht angegeben.  
  
 Jemals werden keine Ausnahmen ausgelöst, wenn Sie dieses Feld verwenden. Finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> entsprechende Anweisungen, die eine Ausnahme auslöst, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.u1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="unsigned int16" /> und erweitert ihn dann zu <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|D1|conv. u2|Konvertieren in `int16`, der Speicherort `int32` auf dem Stapel ab.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.u2` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode, und lassen, die konvertierte Wert oben im Stapel. Ganzzahlige Werte von weniger als 4 Bytes wurden erweitert, um `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.i` oder `conv.u` verwendet wird, in diesem Fall ist auch das Ergebnis `native int`). In Gleitkommazahlen-Punktwerte konvertiert die `F` Typ.  
  
 Konvertieren von Gleitkommazahlen Ganzzahlwerte schneidet die Zahl in Richtung 0 (null) ab. Beim Konvertieren von einer `float64` auf eine `float32`, Genauigkeit verloren. Wenn `value` ist zu groß für einem `float32 (F)`, plus unendlich (Wenn `value` positiv ist) oder minus unendlich dar (Wenn `value` ist ein negativer Wert) zurückgegeben. Wenn Überlauf beim Konvertieren einer Integer-Datentyp in einen anderen auftritt, werden die höherwertigen Bits abgeschnitten. Wenn das Ergebnis kleiner als ein `int32`, der Wert ist signaturerweitert zum Ausfüllen des Slots.  
  
 Wenn es sich bei Auftreten eines Überlaufs ist die Konvertierung von einem Gleitkommatyp in eine ganze Zahl, die der zurückgegebene Wert nicht angegeben.  
  
 Jemals werden keine Ausnahmen ausgelöst, wenn Sie dieses Feld verwenden. Finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> entsprechende Anweisungen, die eine Ausnahme auslöst, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.u2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="unsigned int32" /> und erweitert ihn dann zu <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|6D|U4|Konvertieren in `unsigned int32`, der Speicherort `int32` auf dem Stapel ab.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.u4` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode, und lassen, die konvertierte Wert oben im Stapel. Ganzzahlige Werte von weniger als 4 Bytes wurden erweitert, um `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.i` oder `conv.u` verwendet wird, in diesem Fall ist auch das Ergebnis `native int`). In Gleitkommazahlen-Punktwerte konvertiert die `F` Typ.  
  
 Konvertieren von Gleitkommazahlen Ganzzahlwerte schneidet die Zahl in Richtung 0 (null) ab. Beim Konvertieren von einer `float64` auf eine `float32`, Genauigkeit verloren. Wenn `value` ist zu groß für einem `float32 (F)`, plus unendlich (Wenn `value` positiv ist) oder minus unendlich dar (Wenn `value` ist ein negativer Wert) zurückgegeben. Wenn Überlauf beim Konvertieren einer Integer-Datentyp in einen anderen auftritt, werden die höherwertigen Bits abgeschnitten. Wenn das Ergebnis kleiner als ein `int32`, der Wert ist signaturerweitert zum Ausfüllen des Slots.  
  
 Wenn es sich bei Auftreten eines Überlaufs ist die Konvertierung von einem Gleitkommatyp in eine ganze Zahl, die der zurückgegebene Wert nicht angegeben.  
  
 Jemals werden keine Ausnahmen ausgelöst, wenn Sie dieses Feld verwenden. Finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> entsprechende Anweisungen, die eine Ausnahme auslöst, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.u4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="unsigned int64" /> und erweitert ihn dann zu <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|6E|U8|Konvertieren in `int64`, der Speicherort `int64` auf dem Stapel ab.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird aus dem Stapel und die Konvertierung wird der Vorgang wird ausgeführt.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf dem Stapel abgelegt.  
  
 Die `conv.u8` Opcode konvertiert die `value` oberster Position des Stapels in den angegebenen Opcode, und lassen, die konvertierte Wert oben im Stapel. Ganzzahlige Werte von weniger als 4 Bytes wurden erweitert, um `int32` werden beim Laden in den Auswertungsstapel (es sei denn, `conv.i` oder `conv.u` verwendet wird, in diesem Fall ist auch das Ergebnis `native int`). In Gleitkommazahlen-Punktwerte konvertiert die `F` Typ.  
  
 Konvertieren von Gleitkommazahlen Ganzzahlwerte schneidet die Zahl in Richtung 0 (null) ab. Beim Konvertieren von einer `float64` auf eine `float32`, Genauigkeit verloren. Wenn `value` ist zu groß für einem `float32 (F)`, plus unendlich (Wenn `value` positiv ist) oder minus unendlich dar (Wenn `value` ist ein negativer Wert) zurückgegeben. Wenn Überlauf beim Konvertieren einer Integer-Datentyp in einen anderen auftritt, werden die höherwertigen Bits abgeschnitten. Wenn das Ergebnis kleiner als ein `int32`, der Wert ist signaturerweitert zum Ausfüllen des Slots.  
  
 Wenn es sich bei Auftreten eines Überlaufs ist die Konvertierung von einem Gleitkommatyp in eine ganze Zahl, die der zurückgegebene Wert nicht angegeben.  
  
 Jemals werden keine Ausnahmen ausgelöst, wenn Sie dieses Feld verwenden. Finden Sie unter <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> und <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> entsprechende Anweisungen, die eine Ausnahme auslöst, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `conv.u8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopiert eine angegebene Anzahl von Bytes von einer Quelladresse an eine Zieladresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 17|cpblk|Kopieren Sie Daten aus einem Speicherblock zu einem anderen.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Die Zieladresse wird auf dem Stapel abgelegt.  
  
2.  Die Quelladresse wird auf dem Stapel abgelegt.  
  
3.  Die Anzahl der zu kopierenden Bytes wird auf dem Stapel abgelegt.  
  
4.  Die Anzahl der Bytes, die Quelladresse und die Zieladresse werden vom Stapel geholt. die angegebene Anzahl von Bytes werden von der Quelladresse an die Zieladresse kopiert.  
  
 Die `cpblk` -Anweisung kopiert eine Anzahl (Typ `unsigned int32`) von Bytes von einer Quelladresse (des Typs `*`, `native int`, oder `&`) an eine Zieladresse (des Typs `*`, `native int`, oder `&`). Das Verhalten des `cpblk` ist nicht angegeben, wenn sich Quelle und Ziel überlappen.  
  
 `cpblk` wird davon ausgegangen, dass die Quell- und die Zieladresse an die Größe des Computers ausgerichtet sind. Die `cpblk` Anweisung kann unmittelbar vorangestellt werden die `unaligned.<prefix>` Anweisung, um anzugeben, dass die Quelle oder das Ziel nicht ausgerichteten ist.  
  
 Der Vorgang von der `cpblk` Anweisung kann geändert werden, eine sofort abgrenzen, indem Sie <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> unmittelbar vorangestellt wird.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `cpblk` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopiert den Werttyp, der an der Adresse eines Objekts gespeichert ist (Typ <see langword="&amp;" />, <see langword="*" /> oder <see langword="native int" />), an die Adresse des Zielobjekts (Typ <see langword="&amp;" />, <see langword="*" /> oder <see langword="native int" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|70 < `T` >|cpobj `classTok`|Kopiert einen Wert geben ein Datenquellenobjekt in einem Zielobjekt.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Zielobjektverweis wird auf dem Stapel abgelegt.  
  
2.  Der Objektverweis für die Quelle ist auf dem Stapel abgelegt.  
  
3.  Die zwei Objektverweise werden vom Stapel geholt. der Werttyp an der Adresse des Quellobjekts wird an die Adresse des Zielobjekts kopiert.  
  
 Das Verhalten des `cpobj` ist nicht angegeben, wenn Quelle und Ziel-Verweise sind Zeiger auf Instanzen der Klasse, die durch die Klassentoken dargestellt wird-Objekts `classTok` (eine `typeref` oder `typedef`), oder wenn `classTok` stellt keinen dar. ein der Werttyp.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `cpobj` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dividiert zwei Werte und legt das Ergebnis als Gleitkommawert (Typ <see langword="F" />) oder Quotient (Typ <see langword="int32" />) auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|5B|div|Dividiert zwei Werte und gibt Quotient oder Gleitkommaergebnis zurück.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` sind per pop ausgelesen, aus dem Stapel; `value1` wird geteilt durch `value2`.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 `result` = `value1` Div value2 werden die folgenden Bedingungen erfüllt:  
  
 &#124; `result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, and:  
  
 Anmeldung (`result`) = +, wenn signieren (`value1`) = Vorzeichen (`value2`), "oder"-, wenn Anmeldung (`value1`) ~ = Vorzeichen (`value2`)  
  
 Die `div` Anweisung berechnet das Ergebnis und legt es auf den Stapel.  
  
 Ganzzahldivision durch in Richtung 0 abgeschnitten.  
  
 Division einer endlichen Anzahl von 0 (null) erzeugt den ordnungsgemäß signierten unendlichen Wert.  
  
 Division von 0 durch 0 (null) oder unendlich durch unendlich wird den Wert "NaN (Not A Number)". Eine beliebige Anzahl geteilt durch unendlich erzeugt einen Nullwert.  
  
 Ganzzahloperationen lösen <xref:System.ArithmeticException> Wenn das Ergebnis im Ergebnistyp dargestellt werden kann. Dies kann geschehen, wenn `value1` ist der maximale negative Wert und `value2` ist-1.  
  
 Ganzzahloperationen lösen <xref:System.DivideByZeroException> Wenn `value2` 0 (null).  
  
 Beachten Sie, dass auf Intel-Plattformen eine <xref:System.OverflowException> wird ausgelöst, bei der Berechnung (Minint Div-1). Gleitkommaoperationen lösen niemals Ausnahmen (NaNs oder hervorrufen unendlichen stattdessen).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `div` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dividiert zwei Ganzzahlwerte ohne Vorzeichen und legt das Ergebnis (<see langword="int32" />) auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|5C|div.un|Dividiert zwei Werte ohne Vorzeichen und gibt einen Quotienten zurück.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` sind per pop ausgelesen, aus dem Stapel; `value1` wird geteilt durch `value2`.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 Die `div.un` Anweisung berechnet `value1` geteilt durch `value2`, beide als Ganzzahlen ohne Vorzeichen und Push-Vorgänge die `result` auf dem Stapel.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `div.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopiert den obersten Wert auf dem Auswertungsstapel und legt die Kopie dann auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|25|Dup|Den Wert oben im Stapel, um Duplikate.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` der Stapel für die Duplizierung per pop ausgelesen wird.  
  
3.  `value` wird wieder auf dem Stapel abgelegt.  
  
4.  Ein doppelter Wert wird auf dem Stapel abgelegt.  
  
 Die `dup` -Anweisung dupliziert das oberste Element des Stapels und bewirkt, dass zwei identische Werte über ihn.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `dup` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung von der <see langword="filter" />-Klausel einer Ausnahme zurück an den CLI-Ausnahmehandler (Common Language Infrastructure).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 11|endfilter|End-Filterklausel der SEH-Ausnahmebehandlung.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` wird vom Stapel geholt. `endfilter` ausgeführt wird und die Steuerung an den Ausnahmehandler übertragen wird.  
  
 `Value` (die muss vom Typ `int32` und ist von einem bestimmten Satz von Werten) aus der Filterklausel zurückgegeben wird. Es muss eine der:  
  
-   `exception_continue_search` (`value` = 0) die Suche nach einem Ausnahmehandler fortgesetzt  
  
-   `exception_execute_handler` (`value` = 1) starten Sie die zweite Phase der Ausnahmebehandlung an, in dem finally-Blöcke ausgeführt werden, bis diese Filterklausel der Handler zugeordnete, befindet. Bei der Ermittlung wird der Handler ausgeführt.  
  
 Andere ganzzahlige Werte werden führen zu undefinierten Ergebnissen.  
  
 Der Einstiegspunkt eines Filters muss wie gezeigt in die Methodentabelle Ausnahme der ersten Anweisung im Codeblock des Filters. Die `endfilter` Anweisung muss die letzte Anweisung im Codeblock der Filter (daher gibt es nur möglich `endfilter` für jede einzelne Filterblocks). Nach dem Ausführen der `endfilter` -Anweisung, an der CLI-Ausnahmebehandlungsmechanismus logisch Steuerelement übergibt.  
  
 Steuerung kann nicht in eines Filterblocks außer über Ausnahmemechanismus übertragen werden. Steuerelement kann nicht außerhalb eines Filterblocks außer durch die Verwendung der übertragen werden eine `throw` Anweisung oder durch Ausführen der endgültige `endfilter` Anweisung. Sie können nicht eingebettet eine `try` -Block in eine `filter` Block. Wenn eine Ausnahme, in ausgelöst wird der `filter` -Block abgefangen wird und der Wert 0 (`exception_continue_search`) wird zurückgegeben.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `endfilter` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung aus der <see langword="fault" />-Klausel oder <see langword="finally" />-Klausel eines Ausnahmeblockes zurück an den CLI-Ausnahmehandler (Common Language Infrastructure).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|DOMÄNENCONTROLLER|endfinally<br /><br /> Fault|Beendet die `finally` oder `fault` -Klausel einen Ausnahmeblock.|  
  
 Es gibt kein Stapel Übergangsverhalten für diese Anweisung.  
  
 `Endfinally` und `endfault` signalisiert das Ende der `finally` oder `fault` Klausel, damit diese stapelentladung fortgesetzt werden kann, bis der Ausnahmehandler aufgerufen wird. Die `endfinally` oder `endfault` -Anweisung überträgt die Steuerung wieder an die CLI-Ausnahmemechanismus. Der Mechanismus dann sucht das nächste `finally` -Klausel in der Kette, wenn der geschützte Block mit der Anweisung Leave beendet wurde. Wenn der geschützte Block mit einer Ausnahme beendet wurde, sucht die CLI für die nächsten `finally` oder `fault`, oder geben Sie den Ausnahmehandler, der während der ersten Phase der Ausnahmebehandlung ausgewählt wurde.  
  
 Ein `endfinally` Anweisung scheinen nur lexikalisch innerhalb einer `finally` Block. Im Gegensatz zu den `endfilter` -Anweisung, besteht keine Notwendigkeit, das Beenden des Blocks mit einer `endfinally` -Anweisung, und es kann beliebig viele `endfinally` Anweisungen innerhalb des Blocks nach Bedarf. Diese gleichen Einschränkungen gelten für die `endfault` Anweisung und die `fault` Block.  
  
 Steuerelement kann nicht übertragen werden, in einem `finally` (oder `fault`)-block, außer über den Ausnahmemechanismus. Steuerelement kann nicht übertragen werden, der eine `finally` (oder `fault`)-block, außer durch die Verwendung der einen `throw` Anweisung oder in der Ausführung der `endfinally` (oder `endfault`) Anweisung. Insbesondere, Sie können nicht "fallen" der eine `finally` (oder `fault`) Block oder zum Ausführen einer <xref:System.Reflection.Emit.OpCodes.Ret> oder <xref:System.Reflection.Emit.OpCodes.Leave> Anweisung innerhalb einer `finally` (oder `fault`) Block.  
  
 Beachten Sie, dass die `endfault` und `endfinally` Anweisungen sind Aliase – sie der gleichen Opcode entsprechen.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `endfinally` (`endfault`) Opcode, als auch die `ILGenerator` Methode <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.  
  
-   ILGenerator.Emit(OpCode)  
  
-   ILGenerator.EndExceptionBlock()  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Initialisiert einen angegebenen Speicherblock an einer bestimmten Adresse mit einer angegebenen Größe und einem angegebenen Anfangswert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 18|initblk|Legen Sie jeden Standort in einen Speicherblock zu einem angegebenen Wert.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Eine Startadresse ist auf dem Stapel abgelegt.  
  
2.  Ein Initialisierungswert wird auf dem Stapel abgelegt.  
  
3.  Die Anzahl der Bytes, die initialisiert werden, wird auf dem Stapel abgelegt.  
  
4.  Die Anzahl der Bytes, der Initialisierungswert und die Startadresse werden vom Stapel geholt, und die Initialisierung erfolgt gemäß deren Werte.  
  
 Die `initblk` -Anweisung legt die Anzahl (`unsigned int32`) von Bytes beginnend an der angegebenen Adresse (vom Typ `native int`, `&`, oder `*`) auf den Initialisierungswert (des Typs `unsigned int8`). `initblk` wird davon ausgegangen, dass die Startadresse an die Größe des Computers ausgerichtet ist.  
  
 Der Vorgang von der `initblk` Anweisungen können geändert werden, eine sofort abgrenzen, indem Sie <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> unmittelbar vorangestellt wird.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `initblk` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Initialisiert alle Felder des Werttyps an einer angegebenen Adresse mit einem NULL-Verweis oder dem Wert 0 des entsprechenden primitiven Typs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 15 < `T` >|`initobj` `typeTok`|Initialisiert einen Werttyp an.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Die Adresse des Werttyps initialisiert werden, wird auf dem Stapel abgelegt.  
  
2.  Die Adresse wird vom Stapel geholt. der Werttyp an der angegebenen Adresse wird als Typ initialisiert `typeTok`.  
  
 Die `initobj` -Anweisung initialisiert alle Felder des Werttyps, der angegebenen Adresse (vom Typ `native int`, `&`, oder `*`) auf einen null-Verweis oder eine 0 des entsprechenden primitiven Typs. Nachdem diese Methode aufgerufen wird, ist die Instanz kann eine Konstruktormethode aufgerufen werden. Wenn `typeTok` ein Verweistyp handelt, wird diese Anweisung hat dieselbe Wirkung wie das `ldnull` gefolgt von `stind.ref`.  
  
 Im Gegensatz zu <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` die Konstruktormethode wird nicht aufgerufen. `Initobj` wird zum Initialisieren von Werttypen vorgesehen, while `newobj` reservieren und Initialisieren von Objekten verwendet wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `initobj` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überprüft, ob ein Objektverweis (Typ <see langword="O" />) eine Instanz einer bestimmten Klasse ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|75 < `T` >|isinst `class`|Testet, ob ein Objektverweis auf eine Instanz von ist `class`, zurückgeben, ein null-Verweis oder eine Instanz dieser Klasse oder Schnittstelle.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis ist auf dem Stapel abgelegt.  
  
2.  Der Objektverweis wird vom Stapel geholt und getestet, um festzustellen, ob er eine Instanz der Klasse übergeben wird `class`.  
  
3.  Das Ergebnis (einen Objektverweis oder ein null-Verweis) wird auf dem Stapel abgelegt.  
  
 `Class` ist ein Metadatentoken, das die gewünschte Klasse angibt. Wenn die Klasse des Objekts oben im Stapel implementiert `class` (Wenn `class` ist eine Schnittstelle) oder eine abgeleitete Klasse von `class` (Wenn `class` eine normale Klasse ist) und dann diese Typ umgewandelt wird `class` und das Ergebnis wird auf dem Stapel abgelegt genau wie Obwohl <xref:System.Reflection.Emit.OpCodes.Castclass> hatte aufgerufen wurde. Andernfalls wird ein null-Verweis auf dem Stapel abgelegt. Wenn der Objektverweis selbst ein null-Verweis ist `isinst` ebenso einen null-Verweis zurück.  
  
 <xref:System.TypeLoadException> wird ausgelöst, wenn die Klasse nicht gefunden werden kann. Dies ist i. d. r. erkannt, wenn die Microsoft Intermediate Language (MSIL)-Anweisungen in systemeigenen Code anstatt zur Laufzeit konvertiert werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `isinst` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beendet die aktuelle Methode und wechselt zur angegebenen Methode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|27 < `T` >|jmp `method`|Beendet die aktuelle Methode und wechselt zur angegebenen Methode.|  
  
 Es gibt kein Stapel Übergangsverhalten für diese Anweisung.  
  
 Die `jmp` (Sprung)-Anweisung überträgt die Steuerung an die Methode angegeben werden, `method`, also ein Metadatentoken für einen Methodenverweis. Die aktuellen Argumente werden an die Zielmethode übertragen.  
  
 Der Auswertungsstapel muss leer sein, wenn diese Anweisung ausgeführt wird. Die Aufrufkonvention, Anzahl und Typ der Argumente an die Zieladresse müssen mit der aktuellen Methode übereinstimmen.  
  
 Die `jmp` Anweisung kann nicht verwendet werden, um die Steuerung von einer `try`, `filter`, `catch`, oder `finally` Block.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `jmp` Opcode:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt ein Argument, auf das ein angegebener Indexwert verweist, in den Stapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 09 < `unsigned int16` >|ldarg `index`|Lädt das Argument am `index` Stapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Argumentwert am `index` auf dem Stapel abgelegt wird.  
  
 Die `ldarg` -Anweisung legt das Argument am Index `index`, wobei die Argumente von 0 oder höher, auf dem Auswertungsstapel ab Indizierung werden. Die `ldarg` Anweisung kann verwendet werden, um das Kopieren aus einem eingehenden Argument ein Werttyp oder ein primitiver Wert auf den Stapel zu laden. Der Typ des Argumentwerts ist identisch mit dem Typ des Arguments, entsprechend den Angaben von der Signatur der aktuellen Methode.  
  
 Für Prozeduren, die eine Argumentliste mit variabler Länge kann der `ldarg` Anweisung kann nur für den ersten festen Argumente, nicht die in der Variable Teil der Signatur verwendet werden (finden Sie unter der <xref:System.Reflection.Emit.OpCodes.Arglist> Anweisung Weitere Details).  
  
 Argumente, die einen ganzzahligen Wert, der kürzer als 4 Bytes lang werden erweitert, um geben `int32` werden beim Laden in den Stapel. Gleitkommawerte werden auf ihre systemeigene Größe erweitert (Typ `F`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldarg` Opcode:  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Argument am Index 0 in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|02|ldarg.0|Lädt das Argument 0 Stapel|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Argumentwert am Index 0 wird auf dem Stapel abgelegt.  
  
 Die `ldarg.0` -Anweisung ist eine effiziente Codierung für das Laden des Argumentwerts am Index 0.  
  
 Die `ldarg.0` Anweisung legt das Argument mit dem Index 0 in den Auswertungsstapel. Die `ldarg.0` Anweisung kann verwendet werden, um das Kopieren aus einem eingehenden Argument ein Werttyp oder ein primitiver Wert auf den Stapel zu laden. Der Typ des Argumentwerts ist identisch mit dem Typ des Arguments, entsprechend den Angaben von der Signatur der aktuellen Methode.  
  
 Argumente, die einen ganzzahligen Wert, der kürzer als 4 Bytes lang werden erweitert, um geben `int32` werden beim Laden in den Stapel. Gleitkommawerte werden auf ihre systemeigene Größe erweitert (Typ `F`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldarg.0` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Argument am Index 1 in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|03|ldarg. 1|Lädt das Argument 1 Stapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Argumentwert am Index 1 wird auf dem Stapel abgelegt.  
  
 Die `ldarg.1` -Anweisung ist eine effiziente Codierung für das Laden des Argumentwerts am Index 1.  
  
 Die `ldarg.1` Anweisung legt das Argument mit dem Index 1 auf dem Auswertungsstapel ab. Die `ldarg.1` Anweisung kann verwendet werden, um das Kopieren aus einem eingehenden Argument ein Werttyp oder ein primitiver Wert auf den Stapel zu laden. Der Typ des Argumentwerts ist identisch mit dem Typ des Arguments, entsprechend den Angaben von der Signatur der aktuellen Methode.  
  
 Argumente, die einen ganzzahligen Wert, der kürzer als 4 Bytes lang werden erweitert, um geben `int32` werden beim Laden in den Stapel. Gleitkommawerte werden auf ihre systemeigene Größe erweitert (Typ `F`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldarg.1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Argument am Index 2 in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|04|ldarg. 2|Lädt das Argument 2 Stapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Argumentwert am Index 2 wird auf dem Stapel abgelegt.  
  
 Die `ldarg.2` -Anweisung ist eine effiziente Codierung für das Laden des Argumentwerts am Index 2.  
  
 Die `ldarg.2` -Anweisung legt das Argument Index 2 in den Auswertungsstapel. Die `ldarg.2` Anweisung kann verwendet werden, um das Kopieren aus einem eingehenden Argument ein Werttyp oder ein primitiver Wert auf den Stapel zu laden. Der Typ des Argumentwerts ist identisch mit dem Typ des Arguments, entsprechend den Angaben von der Signatur der aktuellen Methode.  
  
 Argumente, die einen ganzzahligen Wert, der kürzer als 4 Bytes lang werden erweitert, um geben `int32` werden beim Laden in den Stapel. Gleitkommawerte werden auf ihre systemeigene Größe erweitert (Typ `F`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldarg.2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Argument am Index 3 in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|05|ldarg. 3|Laden von Argument 3 in den Stapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Argumentwert am Index 3 wird auf dem Stapel abgelegt.  
  
 Die `ldarg.3` -Anweisung ist eine effiziente Codierung für das Laden des Argumentwerts am Index 3.  
  
 Die `ldarg.3` -Anweisung legt das Argument Index 3 in den Auswertungsstapel. Die `ldarg.3` Anweisung kann verwendet werden, um das Kopieren aus einem eingehenden Argument ein Werttyp oder ein primitiver Wert auf den Stapel zu laden. Der Typ des Argumentwerts ist identisch mit dem Typ des Arguments, entsprechend den Angaben von der Signatur der aktuellen Methode.  
  
 Argumente, die einen ganzzahligen Wert, der kürzer als 4 Bytes lang werden erweitert, um geben `int32` werden beim Laden in den Stapel. Gleitkommawerte werden auf ihre systemeigene Größe erweitert (Typ `F`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldarg.3` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Argument, auf das ein angegebener Kurzformindex verweist, in den Stapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|0E < `unsigned int8` >|ldarg.s `index`|Lädt das Argument am `index` Stapel, Kurzform.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Argumentwert am `index` auf dem Stapel abgelegt wird.  
  
 Die `ldarg.s` Anweisung ist eine effiziente Codierung zum Laden der Argumente von 4 bis 255 indiziert.  
  
 Die `ldarg.s` -Anweisung legt das Argument am Index `index`, wobei die Argumente von 0 oder höher, auf dem Auswertungsstapel ab Indizierung werden. Die `ldarg.s` Anweisung kann verwendet werden, um das Kopieren aus einem eingehenden Argument ein Werttyp oder ein primitiver Wert auf den Stapel zu laden. Der Typ des Argumentwerts ist identisch mit dem Typ des Arguments, entsprechend den Angaben von der Signatur der aktuellen Methode.  
  
 Für Prozeduren, die eine Argumentliste mit variabler Länge kann der `ldarg.s` Anweisung kann nur für den ersten festen Argumente, nicht die in der Variable Teil der Signatur verwendet werden (finden Sie unter der <xref:System.Reflection.Emit.OpCodes.Arglist> Anweisung Weitere Details).  
  
 Argumente, die einen ganzzahligen Wert, der kürzer als 4 Bytes lang werden erweitert, um geben `int32` werden beim Laden in den Stapel. Gleitkommawerte werden auf ihre systemeigene Größe erweitert (Typ `F`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldarg.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt eine Argumentadresse in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 0A < `unsigned int16` >|ldarga `index`|Ruft die Adresse des Arguments ab, das von `index`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Die Adresse `addr` des Arguments ab, indem Sie `index` auf dem Stapel abgelegt wird.  
  
 Die `ldarga` -Anweisung ruft die Adresse (des Typs `*`) des Arguments ab, indem Sie `index`, wobei die Argumente von 0 oder höher Indizierung. Die Adresse `addr` ist immer auf dem Zielcomputer eine natürliche Grenze ausgerichtet.  
  
 Für Prozeduren, die eine Argumentliste mit variabler Länge kann der `ldarga` Anweisung kann nur für den ersten festen Argumente, nicht die in der Variable Teil der Signatur verwendet werden.  
  
 `ldarga` wird für übergeben mit Ref-Parameter verwendet. In anderen Fällen <xref:System.Reflection.Emit.OpCodes.Ldarg> und <xref:System.Reflection.Emit.OpCodes.Starg> verwendet werden soll.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldarga` Opcode:  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt eine Argumentadresse in Kurzform in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|0F &LT; `unsigned int8` >|ldarga.s `index`|Ruft die Adresse des Arguments ab, das von `index`, Kurzform.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Die Adresse `addr` des Arguments ab, indem Sie `index` auf dem Stapel abgelegt wird.  
  
 `ldarga.s` (die Kurzform der `ldarga`) sollte verwendet werden, für die Argumente von 0 bis 255 und eine effizientere Codierung ist.  
  
 Die `ldarga.s` -Anweisung ruft die Adresse (des Typs`*`) des Arguments ab, indem Sie `index`, wobei die Argumente von 0 oder höher Indizierung. Die Adresse `addr` ist immer auf dem Zielcomputer eine natürliche Grenze ausgerichtet.  
  
 Für Prozeduren, die eine Argumentliste mit variabler Länge kann der `ldarga.s` Anweisung kann nur für den ersten festen Argumente, nicht die in der Variable Teil der Signatur verwendet werden.  
  
 `ldarga.s` wird für übergeben mit Ref-Parameter verwendet. In anderen Fällen <xref:System.Reflection.Emit.OpCodes.Ldarg_S> und <xref:System.Reflection.Emit.OpCodes.Starg_S> verwendet werden soll.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldarga.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen bereitgestellten Wert vom Typ <see langword="int32" /> als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|20 < `int32` >|ldc. i4 `num`|Legt den Wert `num` im Stapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Wert `num` wird auf dem Stapel abgelegt.  
  
 Beachten Sie, dass spezielle kurze (und daher eine effizientere) Codierungen für die ganze Zahlen-128 bis 127 und insbesondere kurze Codierungen für-1 bis 8. Alle kurze Codierungen push 4 Bytes langen ganzen Zahlen auf dem Stapel an. Längere Codierungen werden verwendet, für die 8 Bytes langen ganzen Zahlen und 4 und 8 Byte-Gleitkommazahlen, sowie 4-Byte-Werten, die die Kurzformen nicht groß genug ist. Es gibt drei Möglichkeiten, um eine 8-Byte-ganzzahlige Konstante im Stapel per Push übertragen  
  
 1. Verwenden der <xref:System.Reflection.Emit.OpCodes.Ldc_I8> -Anweisung für die Konstanten, die mehr als 32 Bits ausgedrückt werden müssen.  
  
 2. Verwenden der <xref:System.Reflection.Emit.OpCodes.Ldc_I4> Anweisung, gefolgt von einem <xref:System.Reflection.Emit.OpCodes.Conv_I8> für Konstanten, 9 bis 32 Bits erforderlich sind.  
  
 3. Verwenden Sie eine Kurzform-Anweisung, gefolgt von einem <xref:System.Reflection.Emit.OpCodes.Conv_I8> für Konstanten, die in 8 oder weniger Bits ausgedrückt werden können.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldc.i4` Opcode:  
  
-   ILGenerator.Emit (OpCode, Int)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert 0 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|16|ldc.i4.0|Schiebt 0 im Stapel an.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Wert 0 wird auf dem Stapel abgelegt.  
  
 Dies ist eine besondere kurze Codierungen für den Push von der ganzzahlige Wert 0. Alle spezielle kurze Codierungen push 4 Bytes langen ganzen Zahlen auf dem Stapel an.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldc.i4.0` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert 1 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|17|ldc.i4.1|Schiebt 1 im Stapel an.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Wert 1 wird auf dem Stapel abgelegt.  
  
 Dies ist eine besondere kurze Codierungen für den Push von der ganzzahlige Wert 0. Alle spezielle kurze Codierungen push 4 Bytes langen ganzen Zahlen auf dem Stapel an.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldc.i4.1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert 2 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|18|ldc.i4.2|Schiebt 2 auf den Stapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Wert 2 wird auf dem Stapel abgelegt.  
  
 Dies ist eine besondere kurze Codierungen für den Push von der ganzzahlige Wert 0. Alle spezielle kurze Codierungen push 4 Bytes langen ganzen Zahlen auf dem Stapel an.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldc.i4.2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert 3 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|19|ldc.i4.3|Schiebt 3 im Stapel an.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Wert 3 ist auf dem Stapel abgelegt.  
  
 Dies ist eine besondere kurze Codierungen für den Push von der ganzzahlige Wert 0. Alle spezielle kurze Codierungen push 4 Bytes langen ganzen Zahlen auf dem Stapel an.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldc.i4.3` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert 4 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|1A|ldc.i4.4|Schiebt 4 im Stapel an.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Wert 4 ist auf dem Stapel abgelegt.  
  
 Dies ist eine besondere kurze Codierungen für den Push von der ganzzahlige Wert 0. Alle spezielle kurze Codierungen push 4 Bytes langen ganzen Zahlen auf dem Stapel an.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldc.i4.4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert 5 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|1B|ldc.i4.5|Schiebt 5 im Stapel an.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Wert 5 wird auf dem Stapel abgelegt.  
  
 Dies ist eine besondere kurze Codierungen für den Push von der ganzzahlige Wert 0. Alle spezielle kurze Codierungen push 4 Bytes langen ganzen Zahlen auf dem Stapel an.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldc.i4.5` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert 6 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|1C|ldc.i4.6|Schiebt 6 im Stapel an.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Wert 6 wird auf dem Stapel abgelegt.  
  
 Dies ist eine besondere kurze Codierungen für den Push von der ganzzahlige Wert 0. Alle spezielle kurze Codierungen push 4 Bytes langen ganzen Zahlen auf dem Stapel an.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldc.i4.6` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert 7 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|1D|ldc.i4.7|Schiebt 7 im Stapel an.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Wert 7 wird auf dem Stapel abgelegt.  
  
 Dies ist eine besondere kurze Codierungen für den Push von der ganzzahlige Wert 0. Alle spezielle kurze Codierungen push 4 Bytes langen ganzen Zahlen auf dem Stapel an.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldc.i4.7` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert 8 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|1E|ldc.i4.8|Schiebt 8 im Stapel an.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Wert 8 ist auf dem Stapel abgelegt.  
  
 Dies ist eine besondere kurze Codierungen für den Push von der ganzzahlige Wert 0. Alle spezielle kurze Codierungen push 4 Bytes langen ganzen Zahlen auf dem Stapel an.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldc.i4.8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert -1 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|15|ldc.i4.m1|Schiebt-1 im Stapel an.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Wert-1 wird auf dem Stapel abgelegt.  
  
 Dies ist eine besondere kurze Codierungen für den Push von der ganzzahlige Wert 0. Alle spezielle kurze Codierungen push 4 Bytes langen ganzen Zahlen auf dem Stapel an.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldc.i4.m1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den bereitgestellten <see langword="int8" />-Wert als <see langword="int32" />, Kurzform, auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|1F &LT; `int8` >|ldc.i4.s `num`|Schiebt `num` im Stapel als `int32`, Kurzform.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Wert `num` wird auf dem Stapel abgelegt.  
  
 `ldc.i4.s` ist eine effizientere Codierung für Push von ganzen Zahlen von-128 bis 127 auf dem Auswertungsstapel ab.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldc.i4.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen bereitgestellten Wert vom Typ <see langword="int64" /> als <see langword="int64" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|21 < `int64` >|ldc. i8 `num`|Schiebt `num` im Stapel als `int64`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Wert `num` wird auf dem Stapel abgelegt.  
  
 Diese Codierung legt ein `int64` Wert im Stapel.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldc.i8` Opcode:  
  
-   ILGenerator.Emit (OpCode, long)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen bereitgestellten Wert vom Typ <see langword="float32" /> als Typ <see langword="F" /> (Gleitkommawert) auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|22 < `float32` >|ldc. r4 `num`|Schiebt `num` im Stapel als `F`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Wert `num` wird auf dem Stapel abgelegt.  
  
 Diese Codierung legt eine `float32` Wert im Stapel.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldc.r4` Opcode:  
  
-   ILGenerator.Emit(OpCode, single)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen bereitgestellten Wert vom Typ <see langword="float64" /> als Typ <see langword="F" /> (Gleitkommawert) auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|23 < `float64` >|r8 `num`|Schiebt `num` im Stapel als `F`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Wert `num` wird auf dem Stapel abgelegt.  
  
 Diese Codierung legt eine `float64` Wert im Stapel.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldc.r8` Opcode:  
  
-   ILGenerator.Emit (OpCode, double)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element an einem angegebenen Arrayindex als der in der Anweisung angegebene Typ auf die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Microsoft intermediate Language (MSIL) Assemblyformat sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|A3 < `T` >|ldelem `typeTok`|Lädt das Element am `index` an die oberste Position des Stapels als Typ `typeTok`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis `array` auf dem Stapel abgelegt wird.  
  
2.  Ein Indexwert `index` auf dem Stapel abgelegt wird.  
  
3.  `index` und `array` sind per pop ausgelesen, aus dem Stapel; der Wert gespeichert, an der Position `index` in `array` gesucht wird.  
  
4.  Der Wert wird auf dem Stapel abgelegt.  
  
 Die `ldelem` Anweisung lädt den Wert des Elements mit dem Index `index` (Typ `native int`) in der nullbasierten, eindimensionalen Array `array` und platziert sie oben im Stapel. Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`.  
  
 Der Typ des Rückgabewerts wird vom Token angegeben `typeTok` in der Anweisung.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die obere Grenze der `array`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldelem` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element mit dem Typ <see langword="native int" /> an einem angegebenen Arrayindex als <see langword="native int" /> auf die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|97|ldelem.i|Lädt das Element mit dem Typ `native int` am `index` an die oberste Position des Stapels als eine `native int`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis `array` auf dem Stapel abgelegt wird.  
  
2.  Ein Indexwert `index` auf dem Stapel abgelegt wird.  
  
3.  `index` und `array` sind per pop ausgelesen, aus dem Stapel; der Wert gespeichert, an der Position `index` in `array` gesucht wird.  
  
4.  Der Wert wird auf dem Stapel abgelegt.  
  
 Die `ldelem.i` Anweisung lädt den Wert des Elements mit dem Index `index` (Typ `native int`) in der nullbasierten, eindimensionalen Array `array` und platziert sie oben im Stapel. Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`.  
  
 Der Rückgabewert für `ldelem.i` ist `native int`.  
  
 Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` (nicht `native int`) werden beim Laden in den Auswertungsstapel.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldelem.i` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element mit dem Typ <see langword="int8" /> an einem angegebenen Arrayindex als <see langword="int32" /> an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|90|i1|Lädt das Element mit dem Typ `int8` am `index` an die oberste Position des Stapels als ein `int32`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis `array` auf dem Stapel abgelegt wird.  
  
2.  Ein Indexwert `index` auf dem Stapel abgelegt wird.  
  
3.  `index` und `array` sind per pop ausgelesen, aus dem Stapel; der Wert gespeichert, an der Position `index` in `array` gesucht wird.  
  
4.  Der Wert wird auf dem Stapel abgelegt.  
  
 Die `ldelem.i1` Anweisung lädt den Wert des Elements mit dem Index `index` (Typ `native int`) in der nullbasierten, eindimensionalen Array `array` und platziert sie oben im Stapel. Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`.  
  
 Der Rückgabewert für `ldelem.i1` ist `int8`.  
  
 Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` (nicht `native int`) werden beim Laden in den Auswertungsstapel.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldelem.i1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element mit dem Typ <see langword="int16" /> an einem angegebenen Arrayindex als <see langword="int32" /> an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|92|i2|Lädt das Element mit dem Typ `int16` am `index` an die oberste Position des Stapels als ein `int32`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis `array` auf dem Stapel abgelegt wird.  
  
2.  Ein Indexwert `index` auf dem Stapel abgelegt wird.  
  
3.  `index` und `array` sind per pop ausgelesen, aus dem Stapel; der Wert gespeichert, an der Position `index` in `array` gesucht wird.  
  
4.  Der Wert wird auf dem Stapel abgelegt.  
  
 Die `ldelem.i2` Anweisung lädt den Wert des Elements mit dem Index `index` (Typ `native int`) in der nullbasierten, eindimensionalen Array `array` und platziert sie oben im Stapel. Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`.  
  
 Der Rückgabewert für `ldelem.i2` ist `int16`.  
  
 Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` (nicht `native int`) werden beim Laden in den Auswertungsstapel.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldelem.i2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element mit dem Typ <see langword="int32" /> an einem angegebenen Arrayindex als <see langword="int32" /> an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|94|i4|Lädt das Element mit dem Typ `int32` am `index` an die oberste Position des Stapels als ein `int32`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis `array` auf dem Stapel abgelegt wird.  
  
2.  Ein Indexwert `index` auf dem Stapel abgelegt wird.  
  
3.  `index` und `array` sind per pop ausgelesen, aus dem Stapel; der Wert gespeichert, an der Position `index` in `array` gesucht wird.  
  
4.  Der Wert wird auf dem Stapel abgelegt.  
  
 Die `ldelem.i4` Anweisung lädt den Wert des Elements mit dem Index `index` (Typ `native int`) in der nullbasierten, eindimensionalen Array `array` und platziert sie oben im Stapel. Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`.  
  
 Der Rückgabewert für `ldelem.i4` ist `int32`.  
  
 Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` (nicht `native int`) werden beim Laden in den Auswertungsstapel.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldelem.i4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element mit dem Typ <see langword="int64" /> an einem angegebenen Arrayindex als <see langword="int64" /> an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|96|i8|Lädt das Element mit dem Typ `int64` am `index` an die oberste Position des Stapels als ein `int64`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis `array` auf dem Stapel abgelegt wird.  
  
2.  Ein Indexwert `index` auf dem Stapel abgelegt wird.  
  
3.  `index` und `array` sind per pop ausgelesen, aus dem Stapel; der Wert gespeichert, an der Position `index` in `array` gesucht wird.  
  
4.  Der Wert wird auf dem Stapel abgelegt.  
  
 Die `ldelem.i8` Anweisung lädt den Wert des Elements mit dem Index `index` (Typ `native int`) in der nullbasierten, eindimensionalen Array `array` und platziert sie oben im Stapel. Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`.  
  
 Der Rückgabewert für `ldelem.i8` ist `int64`.  
  
 Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` (nicht `native int`) werden beim Laden in den Auswertungsstapel.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldelem.i8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element vom Typ <see langword="float32" /> an einem angegebenen Arrayindex als Typ <see langword="F" /> (Gleitkommawert) an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|98|R4|Lädt das Element mit dem Typ `float32` am `index` an die oberste Position des Stapels als Typ `F`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis `array` auf dem Stapel abgelegt wird.  
  
2.  Ein Indexwert `index` auf dem Stapel abgelegt wird.  
  
3.  `index` und `array` sind per pop ausgelesen, aus dem Stapel; der Wert gespeichert, an der Position `index` in `array` gesucht wird.  
  
4.  Der Wert wird auf dem Stapel abgelegt.  
  
 Die `ldelem.r4` Anweisung lädt den Wert des Elements mit dem Index `index` (Typ `native int`) in der nullbasierten, eindimensionalen Array `array` und platziert sie oben im Stapel. Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`.  
  
 Der Rückgabewert für `ldelem.r4` ist `float32`.  
  
 Gleitkommawerte sind in den Typ konvertiert `F` beim Laden in den Auswertungsstapel.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldelem.r4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element vom Typ <see langword="float64" /> an einem angegebenen Arrayindex als Typ <see langword="F" /> (Gleitkommawert) an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|99|r8|Lädt das Element mit dem Typ `float64` am `index` an die oberste Position des Stapels als Typ `F`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis `array` auf dem Stapel abgelegt wird.  
  
2.  Ein Indexwert `index` auf dem Stapel abgelegt wird.  
  
3.  `index` und `array` sind per pop ausgelesen, aus dem Stapel; der Wert gespeichert, an der Position `index` in `array` gesucht wird.  
  
4.  Der Wert wird auf dem Stapel abgelegt.  
  
 Die `ldelem.r8` Anweisung lädt den Wert des Elements mit dem Index `index` (Typ `native int`) in der nullbasierten, eindimensionalen Array `array` und platziert sie oben im Stapel. Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`.  
  
 Der Rückgabewert für `ldelem.r8` ist `float64`.  
  
 Gleitkommawerte sind in den Typ konvertiert `F` beim Laden in den Auswertungsstapel.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldelem.r8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element mit Objektverweis an einem angegebenen Arrayindex als Typ <see langword="O" /> (Objektverweis) an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|9A|ldelem.ref|Lädt einen Objektverweis auf das Element `index` an die oberste Position des Stapels als Typ `O`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis `array` auf dem Stapel abgelegt wird.  
  
2.  Ein Indexwert `index` auf dem Stapel abgelegt wird.  
  
3.  `index` und `array` sind per pop ausgelesen, aus dem Stapel; der Wert gespeichert, an der Position `index` in `array` gesucht wird.  
  
4.  Der Wert wird auf dem Stapel abgelegt.  
  
 Die `ldelem.ref` Anweisung lädt den Wert des Elements mit dem Index `index` (Typ `native int`) in der nullbasierten, eindimensionalen Array `array` und platziert sie oben im Stapel. Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`.  
  
 Der Rückgabewert für `ldelem.ref` Typ `O` (Objektverweis).  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldelem.ref` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element mit dem Typ <see langword="unsigned int8" /> an einem angegebenen Arrayindex als <see langword="int32" /> an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|91|ldelem. U1|Lädt das Element mit dem Typ `unsigned int8` am `index` an die oberste Position des Stapels als ein `int32`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis `array` auf dem Stapel abgelegt wird.  
  
2.  Ein Indexwert `index` auf dem Stapel abgelegt wird.  
  
3.  `index` und `array` sind per pop ausgelesen, aus dem Stapel; der Wert gespeichert, an der Position `index` in `array` gesucht wird.  
  
4.  Der Wert wird auf dem Stapel abgelegt.  
  
 Die `ldelem.u1` Anweisung lädt den Wert des Elements mit dem Index `index` (Typ `native int`) in der nullbasierten, eindimensionalen Array `array` und platziert sie oben im Stapel. Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`.  
  
 Der Rückgabewert für `ldelem.u1` ist `int8`.  
  
 Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` (nicht `native int`) werden beim Laden in den Auswertungsstapel.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldelem.u1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element mit dem Typ <see langword="unsigned int16" /> an einem angegebenen Arrayindex als <see langword="int32" /> an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|93|U2|Lädt das Element mit dem Typ `unsigned int16` am Index in der obersten Position im Stapel als ein `int32`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis `array` auf dem Stapel abgelegt wird.  
  
2.  Ein Indexwert `index` auf dem Stapel abgelegt wird.  
  
3.  `index` und `array` sind per pop ausgelesen, aus dem Stapel; der Wert gespeichert, an der Position `index` in `array` gesucht wird.  
  
4.  Der Wert wird auf dem Stapel abgelegt.  
  
 Die `ldelem.u2` Anweisung lädt den Wert des Elements mit dem Index `index` (Typ `native int`) in der nullbasierten, eindimensionalen Array `array` und platziert sie oben im Stapel. Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`.  
  
 Der Rückgabewert für `ldelem.u2` ist `int16`.  
  
 Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` (nicht `native int`) werden beim Laden in den Auswertungsstapel.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldelem.u2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element mit dem Typ <see langword="unsigned int32" /> an einem angegebenen Arrayindex als <see langword="int32" /> an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|95|U4|Lädt das Element mit dem Typ `unsigned int32` am Index in der obersten Position im Stapel als ein `int32`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis `array` auf dem Stapel abgelegt wird.  
  
2.  Ein Indexwert `index` auf dem Stapel abgelegt wird.  
  
3.  `index` und `array` sind per pop ausgelesen, aus dem Stapel; der Wert gespeichert, an der Position `index` in `array` gesucht wird.  
  
4.  Der Wert wird auf dem Stapel abgelegt.  
  
 Die `ldelem.u4` Anweisung lädt den Wert des Elements mit dem Index `index` (Typ `native int`) in der nullbasierten, eindimensionalen Array `array` und platziert sie oben im Stapel. Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`.  
  
 Der Rückgabewert für `ldelem.u4` ist `int32`.  
  
 Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` (nicht `native int`) werden beim Laden in den Auswertungsstapel.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn Array keine Elemente des erforderlichen Typs enthält.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldelem.u4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt die Adresse des Arrayelements an einem angegebenen Arrayindex als Typ <see langword="&amp;" /> (verwalteter Zeiger) an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|8F &LT; `T` >|ldelema `class`|Lädt die Adresse des Arrayelements an `index` an die oberste Position des Auswertungsstapels als Typ `&` (verwalteter Zeiger).|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis `array` auf dem Stapel abgelegt wird.  
  
2.  Ein Indexwert `index` auf dem Stapel abgelegt wird.  
  
3.  `index` und `array` sind per pop ausgelesen, aus dem Stapel; die Adresse, an der Position gespeichert `index` in `array` gesucht wird.  
  
4.  Die Adresse wird auf dem Stapel abgelegt.  
  
 Die `ldelema` dient zum Abrufen der Adresse eines Objekts an einem bestimmten Index in ein Array von Objekten (des Typs `class`). Die `ldelema` -Anweisung lädt die Adresse des Werts am Index `index` (Typ `native int`) in der nullbasierten, eindimensionalen Array `array` und platziert sie oben im Stapel. Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`. Der Wert muss vom Typ `class` mit der Anweisung übergeben.  
  
 Der Rückgabewert für `ldelema` ist ein verwalteter Zeiger (Typ `&`).  
  
 Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` (nicht `native int`) werden beim Laden in den Auswertungsstapel.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldelema` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sucht den Wert eines Felds in dem Objekt, für das sich derzeit ein Verweis auf dem Auswertungsstapel befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|7B < `T` >|ldfld `field`|Legt den Wert eines Felds in einem angegebenen Objekt im Stapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis (oder Zeiger) wird auf dem Stapel abgelegt.  
  
2.  Der Objektverweis (oder Zeiger) wird vom Stapel geholt. der Wert des angegebenen Felds in dem Objekt wurde gefunden.  
  
3.  Der Wert in das Feld gespeichert wird auf dem Stapel abgelegt.  
  
 Die `ldfld` Anweisung legt den Wert eines Felds in einem Objekt im Stapel befindet. Das Objekt muss auf dem Stapel als ein Objektverweis sein (Typ `O`), einen verwalteten Zeiger (Typ `&`), ein nicht verwalteter Zeiger (Typ `native int`), flüchtiger Zeiger (Typ `*`), oder eine Instanz eines Werttyps. Die Verwendung eines nicht verwalteten Zeigers ist nicht in überprüfbarem Code zulässig. Das Feld des Objekts wird durch ein Metadatentoken angegeben, die auf einen Feldmember verweisen muss. Der Rückgabetyp ist identisch mit dem Feld zugeordnet. Das Feld möglicherweise ein Instanzenfeld (in diesem Fall das Objekt kein null-Verweis sein muss) oder eines statischen Felds.  
  
 Die `ldfld` Anweisung kann vorangestellt werden eine oder beide der <xref:System.Reflection.Emit.OpCodes.Unaligned> und <xref:System.Reflection.Emit.OpCodes.Volatile> Präfixe.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn das Objekt null ist, und das Feld nicht statisch ist.  
  
 <xref:System.MissingFieldException> wird ausgelöst, wenn das angegebene Feld in den Metadaten nicht gefunden wird. Dies wird in der Regel überprüft, wenn Microsoft Intermediate Language (MSIL)-Anweisungen nicht zur Laufzeit in systemeigenen Code konvertiert werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldfld` Opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sucht die Adresse eines Felds in dem Objekt, für das sich derzeit ein Verweis auf dem Auswertungsstapel befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|7C < `T` >|ldflda `field`|Legt die Adresse eines `field` in einem angegebenen Objekt im Stapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis (oder Zeiger) wird auf dem Stapel abgelegt.  
  
2.  Der Objektverweis (oder Zeiger) wird vom Stapel geholt. die Adresse des angegebenen Felds in dem Objekt wurde gefunden.  
  
3.  Die Adresse des angegebenen Felds wird auf dem Stapel abgelegt.  
  
 Die `ldflda` Anweisung legt die Adresse eines Felds in einem Objekt im Stapel befindet. Das Objekt muss auf dem Stapel als ein Objektverweis sein (Typ `O`), einen verwalteten Zeiger (Typ `&`), ein nicht verwalteter Zeiger (Typ `native int`), flüchtiger Zeiger (Typ `*`), oder eine Instanz eines Werttyps. Die Verwendung eines nicht verwalteten Zeigers ist nicht in überprüfbarem Code zulässig. Das Feld des Objekts wird durch ein Metadatentoken angegeben, die auf einen Feldmember verweisen muss.  
  
 Der Rückgabewert von `ldflda` ist ein verwalteter Zeiger (Typ `&`), wenn das Objekt wird als ein nicht verwalteter Zeiger in den Stapel abgelegt, in diesem Fall die Absenderadresse ist auch ein nicht verwalteter Zeiger (Typ `native int`).  
  
 Die `ldflda` Anweisung kann vorangestellt werden eine oder beide der <xref:System.Reflection.Emit.OpCodes.Unaligned> und <xref:System.Reflection.Emit.OpCodes.Volatile> Präfixe.  
  
 <xref:System.InvalidOperationException> wird ausgelöst, wenn das Objekt nicht innerhalb der Anwendungsdomäne ist von dem zugegriffen wird. Die Adresse eines Felds, das nicht in die beim Zugriff auf die Anwendungsdomäne befindet, kann nicht geladen werden.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn das Objekt null ist, und das Feld nicht statisch ist.  
  
 <xref:System.MissingFieldException> wird ausgelöst, wenn das angegebene Feld in den Metadaten nicht gefunden wird. Dies wird in der Regel überprüft, wenn Microsoft Intermediate Language (MSIL)-Anweisungen nicht zur Laufzeit in systemeigenen Code konvertiert werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldflda` Opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen nicht verwalteten Zeiger (Typ <see langword="native int" />) auf dem Auswertungsstapel ab. Dieser Zeiger zeigt auf den systemeigenen Code, der eine bestimmte Methode implementiert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 06 < `T` >|ldftn `method`|Legt einen Zeiger auf eine Methode verweist `method` auf dem Stapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der nicht verwalteten Zeiger auf eine bestimmte Methode wird auf dem Stapel abgelegt.  
  
 Die bestimmte Methode (`method`) kann aufgerufen werden, mithilfe der <xref:System.Reflection.Emit.OpCodes.Calli> Anweisung, wenn er auf einer verwalteten Methode (oder einen Stub, der Übergang von verwaltetem zu nicht verwaltetem Code) verweist.  
  
 Der zurückgegebene Wert zeigt mit der CLR Aufrufkonvention in nativen Code. Diese Methodenzeiger sollten nicht als Rückrufroutine an nicht verwalteten systemeigenen Code übergeben werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldftn` Opcode:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="native int" /> indirekt als <see langword="native int" /> in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|4D|ldind.i|Lädt die `native int` Wert Downloadadresse `addr` im Stapel als eine `native int`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Die Adresse wird vom Stapel geholt. der Wert befindet sich unter der Adresse wird abgerufen.  
  
3.  Der abgerufene Wert wird auf dem Stapel abgelegt.  
  
 Die `ldind.i` -Anweisung lädt indirekt ein `native int` Wert aus der angegebenen Adresse (vom Typ `native int`, `&`, oder *) auf dem Stapel als eine `native int`.  
  
 Alle der `ldind` Anweisungen sind Verknüpfungen für ein <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die den entsprechenden integrierten Wertklasse angibt.  
  
 Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` (nicht `native int`) werden beim Laden in den Auswertungsstapel. In Gleitkommazahlen-Punktwerte konvertiert `F` Geben Sie beim Laden in den Auswertungsstapel.  
  
 Ordnungsgemäß gebildeten Microsoft Intermediate Language (MSIL) wird sichergestellt, dass die `ldind` Anweisungen werden in Übereinstimmung mit dem Typ des Zeigers verwendet.  
  
 Die Adresse, die anfänglich auf den Stapel verschoben muss ausgerichtet sein, um die natürliche Größe der Objekte auf dem Computer oder ein <xref:System.NullReferenceException> auftreten können (finden Sie unter der <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix vorbeugende Maßnahmen-Anweisung). Die Ergebnisse von allen MSIL-Anweisungen, die Adressen zurückgegeben (z. B. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>) sicher ausgerichtet sind. Die Bytereihenfolge wird für Datentypen, die größer als 1 Byte abhängig von der Ziel-CPU. Code, der die Bytereihenfolge hängt möglicherweise nicht auf allen Plattformen ausgeführt werden.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldind.i` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="int8" /> indirekt als <see langword="int32" /> in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|46|ldind. i1|Lädt die `int8` Wert Downloadadresse `addr` im Stapel als ein `int32`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Die Adresse wird vom Stapel geholt. der Wert befindet sich unter der Adresse wird abgerufen.  
  
3.  Der abgerufene Wert wird auf dem Stapel abgelegt...  
  
 Die `ldind.i1` -Anweisung lädt indirekt ein `int8` Wert aus der angegebenen Adresse (vom Typ `native int`, `&`, oder *) auf dem Stapel als ein `int32`.  
  
 Alle der `ldind` Anweisungen sind Verknüpfungen für ein <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die den entsprechenden integrierten Wertklasse angibt.  
  
 Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` (nicht `native int`) werden beim Laden in den Auswertungsstapel. In Gleitkommazahlen-Punktwerte konvertiert `F` Geben Sie beim Laden in den Auswertungsstapel.  
  
 Ordnungsgemäß gebildeten Microsoft Intermediate Language (MSIL) wird sichergestellt, dass die `ldind` Anweisungen werden in Übereinstimmung mit dem Typ des Zeigers verwendet.  
  
 Die Adresse, die anfänglich auf den Stapel verschoben muss ausgerichtet sein, um die natürliche Größe der Objekte auf dem Computer oder ein <xref:System.NullReferenceException> auftreten können (finden Sie unter der <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix vorbeugende Maßnahmen-Anweisung). Die Ergebnisse von allen MSIL-Anweisungen, die Adressen zurückgegeben (z. B. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>) sicher ausgerichtet sind. Die Bytereihenfolge wird für Datentypen, die größer als 1 Byte abhängig von der Ziel-CPU. Code, der die Bytereihenfolge hängt möglicherweise nicht auf allen Plattformen ausgeführt werden.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldind.i1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="int16" /> indirekt als <see langword="int32" /> in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|48|ldind. i2|Lädt die `int16` Wert Downloadadresse `addr` im Stapel als ein `int32`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Die Adresse wird vom Stapel geholt. der Wert befindet sich unter der Adresse wird abgerufen.  
  
3.  Der abgerufene Wert wird auf dem Stapel abgelegt.  
  
 Die `ldind.i2` -Anweisung lädt indirekt ein `int16` Wert aus der angegebenen Adresse (vom Typ `native int`, `&`, oder *) auf dem Stapel als ein `int32`.  
  
 Alle der `ldind` Anweisungen sind Verknüpfungen für ein <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die den entsprechenden integrierten Wertklasse angibt.  
  
 Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` (nicht `native int`) werden beim Laden in den Auswertungsstapel. In Gleitkommazahlen-Punktwerte konvertiert `F` Geben Sie beim Laden in den Auswertungsstapel.  
  
 Ordnungsgemäß gebildeten Microsoft Intermediate Language (MSIL) wird sichergestellt, dass die `ldind` Anweisungen werden in Übereinstimmung mit dem Typ des Zeigers verwendet.  
  
 Die Adresse, die anfänglich auf den Stapel verschoben muss ausgerichtet sein, um die natürliche Größe der Objekte auf dem Computer oder ein <xref:System.NullReferenceException> auftreten können (finden Sie unter der <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix vorbeugende Maßnahmen-Anweisung). Die Ergebnisse von allen MSIL-Anweisungen, die Adressen zurückgegeben (z. B. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>) sicher ausgerichtet sind. Die Bytereihenfolge wird für Datentypen, die größer als 1 Byte abhängig von der Ziel-CPU. Code, der die Bytereihenfolge hängt möglicherweise nicht auf allen Plattformen ausgeführt werden.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldind.i2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="int32" /> indirekt als <see langword="int32" /> in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|4A|i4|Lädt die `int32` Wert Downloadadresse `addr` im Stapel als ein `int32`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Die Adresse wird vom Stapel geholt. der Wert befindet sich unter der Adresse wird abgerufen.  
  
3.  Der abgerufene Wert wird auf dem Stapel abgelegt.  
  
 Die `ldind.i4` -Anweisung lädt indirekt ein `int32` Wert aus der angegebenen Adresse (vom Typ `native int`, `&`, oder *) auf dem Stapel als ein `int32`.  
  
 Alle der `ldind` Anweisungen sind Verknüpfungen für ein <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die den entsprechenden integrierten Wertklasse angibt.  
  
 Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` (nicht `native int`) werden beim Laden in den Auswertungsstapel. In Gleitkommazahlen-Punktwerte konvertiert `F` Geben Sie beim Laden in den Auswertungsstapel.  
  
 Ordnungsgemäß gebildeten Microsoft Intermediate Language (MSIL) wird sichergestellt, dass die `ldind` Anweisungen werden in Übereinstimmung mit dem Typ des Zeigers verwendet.  
  
 Die Adresse, die anfänglich auf den Stapel verschoben muss ausgerichtet sein, um die natürliche Größe der Objekte auf dem Computer oder ein <xref:System.NullReferenceException> auftreten können (finden Sie unter der <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix vorbeugende Maßnahmen-Anweisung). Die Ergebnisse von allen MSIL-Anweisungen, die Adressen zurückgegeben (z. B. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>) sicher ausgerichtet sind. Die Bytereihenfolge wird für Datentypen, die größer als 1 Byte abhängig von der Ziel-CPU. Code, der die Bytereihenfolge hängt möglicherweise nicht auf allen Plattformen ausgeführt werden.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldind.i4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="int64" /> indirekt als <see langword="int64" /> in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|4C|i8|Lädt die `int64` Wert Downloadadresse `addr` im Stapel als ein `int64`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Die Adresse wird vom Stapel geholt. der Wert befindet sich unter der Adresse wird abgerufen.  
  
3.  Der abgerufene Wert wird auf dem Stapel abgelegt.  
  
 Die `ldind.i8` -Anweisung lädt indirekt ein `int64` Wert aus der angegebenen Adresse (vom Typ `native int`, `&`, oder *) auf dem Stapel als ein `int64`.  
  
 Alle der `ldind` Anweisungen sind Verknüpfungen für ein <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die den entsprechenden integrierten Wertklasse angibt.  
  
 Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` (nicht `native int`) werden beim Laden in den Auswertungsstapel. In Gleitkommazahlen-Punktwerte konvertiert `F` Geben Sie beim Laden in den Auswertungsstapel.  
  
 Ordnungsgemäß gebildeten Microsoft Intermediate Language (MSIL) wird sichergestellt, dass die `ldind` Anweisungen werden in Übereinstimmung mit dem Typ des Zeigers verwendet.  
  
 Die Adresse, die anfänglich auf den Stapel verschoben muss ausgerichtet sein, um die natürliche Größe der Objekte auf dem Computer oder ein <xref:System.NullReferenceException> auftreten können (finden Sie unter der <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix vorbeugende Maßnahmen-Anweisung). Die Ergebnisse von allen MSIL-Anweisungen, die Adressen zurückgegeben (z. B. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>) sicher ausgerichtet sind. Die Bytereihenfolge wird für Datentypen, die größer als 1 Byte abhängig von der Ziel-CPU. Code, der die Bytereihenfolge hängt möglicherweise nicht auf allen Plattformen ausgeführt werden.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldind.i8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="float32" /> indirekt als Typ <see langword="F" /> (Gleitkommawert) in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|4E|ldind. r4|Lädt die `float32` Wert Downloadadresse `addr` im Stapel als Typ `F`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Die Adresse wird vom Stapel geholt. der Wert befindet sich unter der Adresse wird abgerufen.  
  
3.  Der abgerufene Wert wird auf dem Stapel abgelegt.  
  
 Die `ldind.r4` -Anweisung lädt indirekt ein `float32` Wert aus der angegebenen Adresse (vom Typ `native int`, `&`, oder *) als einen Typ in den Stapel `F`.  
  
 Alle der `ldind` Anweisungen sind Verknüpfungen für ein <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die den entsprechenden integrierten Wertklasse angibt.  
  
 Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` (nicht `native int`) werden beim Laden in den Auswertungsstapel. In Gleitkommazahlen-Punktwerte konvertiert `F` Geben Sie beim Laden in den Auswertungsstapel.  
  
 Ordnungsgemäß gebildeten Microsoft Intermediate Language (MSIL) wird sichergestellt, dass die `ldind` Anweisungen werden in Übereinstimmung mit dem Typ des Zeigers verwendet.  
  
 Die Adresse, die anfänglich auf den Stapel verschoben muss ausgerichtet sein, um die natürliche Größe der Objekte auf dem Computer oder ein <xref:System.NullReferenceException> auftreten können (finden Sie unter der <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix vorbeugende Maßnahmen-Anweisung). Die Ergebnisse von allen MSIL-Anweisungen, die Adressen zurückgegeben (z. B. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>) sicher ausgerichtet sind. Die Bytereihenfolge wird für Datentypen, die größer als 1 Byte abhängig von der Ziel-CPU. Code, der die Bytereihenfolge hängt möglicherweise nicht auf allen Plattformen ausgeführt werden.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldind.r4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="float64" /> indirekt als Typ <see langword="F" /> (Gleitkommawert) in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|4F|ldind. r8|Lädt die `float64` Wert Downloadadresse `addr` im Stapel als Typ `F`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Die Adresse wird vom Stapel geholt. der Wert befindet sich unter der Adresse wird abgerufen.  
  
3.  Der abgerufene Wert wird auf dem Stapel abgelegt.  
  
 Die `ldind.r8` -Anweisung lädt indirekt ein `float64` Wert aus der angegebenen Adresse (vom Typ `native int`, `&`, oder *) auf dem Stapel als eine `float64`.  
  
 Alle der `ldind` Anweisungen sind Verknüpfungen für ein <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die den entsprechenden integrierten Wertklasse angibt.  
  
 Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` (nicht `native int`) werden beim Laden in den Auswertungsstapel. In Gleitkommazahlen-Punktwerte konvertiert `F` Geben Sie beim Laden in den Auswertungsstapel.  
  
 Ordnungsgemäß gebildeten Microsoft Intermediate Language (MSIL) wird sichergestellt, dass die `ldind` Anweisungen werden in Übereinstimmung mit dem Typ des Zeigers verwendet.  
  
 Die Adresse, die anfänglich auf den Stapel verschoben muss ausgerichtet sein, um die natürliche Größe der Objekte auf dem Computer oder ein <xref:System.NullReferenceException> auftreten können (finden Sie unter der <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix vorbeugende Maßnahmen-Anweisung). Die Ergebnisse von allen MSIL-Anweisungen, die Adressen zurückgegeben (z. B. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>) sicher ausgerichtet sind. Die Bytereihenfolge wird für Datentypen, die größer als 1 Byte abhängig von der Ziel-CPU. Code, der die Bytereihenfolge hängt möglicherweise nicht auf allen Plattformen ausgeführt werden.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldind.r8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Objektverweis indirekt als Typ <see langword="O" /> (Objektverweis) in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|50|ldind.ref|Lädt den Objektverweis Downloadadresse `addr` als einen Typ in den Stapel `O`|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Die Adresse wird vom Stapel geholt. Der Objektverweis finden Sie unter der Adresse wird abgerufen.  
  
3.  Der abgerufene Verweis wird auf dem Stapel abgelegt.  
  
 Die `ldind.ref` -Anweisung lädt indirekt den Objektverweis die angegebene Adresse (des Typs `native int`, `&`, oder *) auf dem Stapel als Typ `O`.  
  
 Alle der `ldind` Anweisungen sind Verknüpfungen für ein <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die den entsprechenden integrierten Wertklasse angibt.  
  
 Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` (nicht `native int`) werden beim Laden in den Auswertungsstapel. In Gleitkommazahlen-Punktwerte konvertiert `F` Geben Sie beim Laden in den Auswertungsstapel.  
  
 Ordnungsgemäß gebildeten Microsoft Intermediate Language (MSIL) wird sichergestellt, dass die `ldind` Anweisungen werden in Übereinstimmung mit dem Typ des Zeigers verwendet.  
  
 Die Adresse, die anfänglich auf den Stapel verschoben muss ausgerichtet sein, um die natürliche Größe der Objekte auf dem Computer oder ein <xref:System.NullReferenceException> auftreten können (finden Sie unter der <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix vorbeugende Maßnahmen-Anweisung). Die Ergebnisse von allen MSIL-Anweisungen, die Adressen zurückgegeben (z. B. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>) sicher ausgerichtet sind. Die Bytereihenfolge wird für Datentypen, die größer als 1 Byte abhängig von der Ziel-CPU. Code, der die Bytereihenfolge hängt möglicherweise nicht auf allen Plattformen ausgeführt werden.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldind.ref` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="unsigned int8" /> indirekt als <see langword="int32" /> in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|47|ldind. U1|Lädt die `unsigned int8` Wert Downloadadresse `addr` im Stapel als ein `int32`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Die Adresse wird vom Stapel geholt. der Wert befindet sich unter der Adresse wird abgerufen.  
  
3.  Der abgerufene Wert wird auf dem Stapel abgelegt.  
  
 Die `ldind.u1` -Anweisung lädt indirekt ein `unsigned int8` Wert aus der angegebenen Adresse (vom Typ`native int`, `&`, oder *) auf dem Stapel als ein `int32`.  
  
 Alle der `ldind` Anweisungen sind Verknüpfungen für ein <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die den entsprechenden integrierten Wertklasse angibt.  
  
 Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` (nicht `native int`) werden beim Laden in den Auswertungsstapel. In Gleitkommazahlen-Punktwerte konvertiert `F` Geben Sie beim Laden in den Auswertungsstapel.  
  
 Ordnungsgemäß gebildeten Microsoft Intermediate Language (MSIL) wird sichergestellt, dass die `ldind` Anweisungen werden in Übereinstimmung mit dem Typ des Zeigers verwendet.  
  
 Die Adresse, die anfänglich auf den Stapel verschoben muss ausgerichtet sein, um die natürliche Größe der Objekte auf dem Computer oder ein <xref:System.NullReferenceException> auftreten können (finden Sie unter der <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix vorbeugende Maßnahmen-Anweisung). Die Ergebnisse von allen MSIL-Anweisungen, die Adressen zurückgegeben (z. B. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>) sicher ausgerichtet sind. Die Bytereihenfolge wird für Datentypen, die größer als 1 Byte abhängig von der Ziel-CPU. Code, der die Bytereihenfolge hängt möglicherweise nicht auf allen Plattformen ausgeführt werden.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldind.u1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="unsigned int16" /> indirekt als <see langword="int32" /> in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|49|ldind. u2|Lädt die `unsigned int16` Wert Downloadadresse `addr` im Stapel als ein `int32`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Die Adresse wird vom Stapel geholt. der Wert befindet sich unter der Adresse wird abgerufen.  
  
3.  Der abgerufene Wert wird auf dem Stapel abgelegt.  
  
 Die `ldind.u2` -Anweisung lädt indirekt ein `unsigned int16` Wert aus der angegebenen Adresse (vom Typ `native int`, `&`, oder *) auf dem Stapel als ein `int32`.  
  
 Alle der `ldind` Anweisungen sind Verknüpfungen für ein <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die den entsprechenden integrierten Wertklasse angibt.  
  
 Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` (nicht `native int`) werden beim Laden in den Auswertungsstapel. In Gleitkommazahlen-Punktwerte konvertiert `F` Geben Sie beim Laden in den Auswertungsstapel.  
  
 Ordnungsgemäß gebildeten Microsoft Intermediate Language (MSIL) wird sichergestellt, dass die `ldind` Anweisungen werden in Übereinstimmung mit dem Typ des Zeigers verwendet.  
  
 Die Adresse, die anfänglich auf den Stapel verschoben muss ausgerichtet sein, um die natürliche Größe der Objekte auf dem Computer oder ein <xref:System.NullReferenceException> auftreten können (finden Sie unter der <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix vorbeugende Maßnahmen-Anweisung). Die Ergebnisse von allen MSIL-Anweisungen, die Adressen zurückgegeben (z. B. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>) sicher ausgerichtet sind. Die Bytereihenfolge wird für Datentypen, die größer als 1 Byte abhängig von der Ziel-CPU. Code, der die Bytereihenfolge hängt möglicherweise nicht auf allen Plattformen ausgeführt werden.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldind.u2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="unsigned int32" /> indirekt als <see langword="int32" /> in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|4 B|U4|Lädt die `unsigned int32` Wert Downloadadresse `addr` im Stapel als ein `int32`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Die Adresse wird vom Stapel geholt. der Wert befindet sich unter der Adresse wird abgerufen.  
  
3.  Der abgerufene Wert wird auf dem Stapel abgelegt.  
  
 Die `ldind.u4` -Anweisung lädt indirekt ein `unsigned int32` Wert aus der angegebenen Adresse (vom Typ `native int`, `&`, oder *) auf dem Stapel als ein `int32`.  
  
 Alle der `ldind` Anweisungen sind Verknüpfungen für ein <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die den entsprechenden integrierten Wertklasse angibt.  
  
 Beachten Sie, dass Ganzzahlwerte von weniger als 4 Bytes auf ausgeweitet werden `int32` (nicht `native int`) werden beim Laden in den Auswertungsstapel. In Gleitkommazahlen-Punktwerte konvertiert `F` Geben Sie beim Laden in den Auswertungsstapel.  
  
 Ordnungsgemäß gebildeten Microsoft Intermediate Language (MSIL) wird sichergestellt, dass die `ldind` Anweisungen werden in Übereinstimmung mit dem Typ des Zeigers verwendet.  
  
 Die Adresse, die anfänglich auf den Stapel verschoben muss ausgerichtet sein, um die natürliche Größe der Objekte auf dem Computer oder ein <xref:System.NullReferenceException> auftreten können (finden Sie unter der <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix vorbeugende Maßnahmen-Anweisung). Die Ergebnisse von allen MSIL-Anweisungen, die Adressen zurückgegeben (z. B. <xref:System.Reflection.Emit.OpCodes.Ldloca> und <xref:System.Reflection.Emit.OpCodes.Ldarga>) sicher ausgerichtet sind. Die Bytereihenfolge wird für Datentypen, die größer als 1 Byte abhängig von der Ziel-CPU. Code, der die Bytereihenfolge hängt möglicherweise nicht auf allen Plattformen ausgeführt werden.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldind.u4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt die Anzahl der Elemente eines nullbasierten, eindimensionalen Arrays auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|8E|ldlen|Legt die Länge (des Typs `natural unsigned int`) eines Arrays auf dem Stapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis auf ein Array ist auf dem Stapel abgelegt.  
  
2.  Der Arrayverweis als aus dem Stapel per pop ausgelesen wird, und die Länge wird berechnet.  
  
3.  Die Länge ist auf dem Stapel abgelegt.  
  
 Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`. Die Länge wird zurückgegeben, als eine `natural unsigned int`.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn der Arrayverweis als null-Verweis ist.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldlen` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt die lokale Variable an einem bestimmten Index in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 0C < `unsigned int16` >|ldloc `index`|Lädt die lokale Variable am Index `index` Stapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Wert der lokale Variable am angegebenen Index ist auf dem Stapel abgelegt.  
  
 Die `ldloc` Anweisung legt den Inhalt der lokalen Variable Anzahl an der übergebene Index in den Auswertungsstapel, in dem die lokalen Variablen 0 nummeriert oder höher. Lokale Variablen werden vor dem Wechsel in der Methodennamens nur, wenn das Initialisierungsflag für die Methode "true" ist auf 0 initialisiert. Es sind 65.535 (2 ^ 16 - 1) lokale Variablen möglich (0-65.534). Index 65.535 ist ungültig, da Sie wahrscheinliche Implementierungen eine 2-Byte-Ganzzahl verwenden werden, um sowohl eine lokale Index zusammen mit der Gesamtanzahl von "lokal" für eine bestimmte Methode nachzuverfolgen. Wenn ein Index von 65535 gültig vorgenommen wurden war, wäre eine umfassendere ganze Zahl zum Nachverfolgen der Anzahl von "lokal" in einer solchen Methode erforderlich.  
  
 Die `ldloc.0`, `ldloc.1`, `ldloc.2`, und `ldloc.3` Anweisungen bieten eine effiziente Codierung für den Zugriff auf die ersten vier lokalen Variablen.  
  
 Der Typ des Werts ist identisch mit dem Typ der lokalen Variablen, die in der Methodenheader angegeben wurde. Finden Sie unter Partition I. lokale Variablen, die kleiner sind als 4 Bytes lang erweitert werden, geben Sie `int32` werden beim Laden in den Stapel. Gleitkommawerte werden auf ihre systemeigene Größe erweitert (Typ `F`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> methodenüberladungen können die `ldloc` Opcode:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt die lokale Variable am Index 0 in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|06|ldloc.0|Lädt die lokale Variable am Index 0 in den Auswertungsstapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Wert der lokale Variable am Index 0 wird auf dem Stapel abgelegt.  
  
 `ldloc.0` ist eine besonders effiziente Codierung für <xref:System.Reflection.Emit.OpCodes.Ldloc>, ermöglicht den Zugriff auf die lokale Variable am Index 0.  
  
 Der Typ des Werts ist identisch mit dem Typ der lokalen Variablen, die in der Methodenheader angegeben wurde. Lokale Variablen, die kleiner als 4 Bytes lang werden erweitert, um geben `int32` werden beim Laden in den Stapel. Gleitkommawerte werden auf ihre systemeigene Größe erweitert (Typ `F`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldloc.0` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt die lokale Variable am Index 1 in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|07|ldloc. 1|Lädt die lokale Variable am Index 1 in den Auswertungsstapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Wert der lokale Variable am Index 1 wird auf dem Stapel abgelegt.  
  
 `ldloc.1` ist eine besonders effiziente Codierung für <xref:System.Reflection.Emit.OpCodes.Ldloc>, ermöglicht den Zugriff auf die lokale Variable am Index 1.  
  
 Der Typ des Werts ist identisch mit dem Typ der lokalen Variablen, die in der Methodenheader angegeben wurde. Lokale Variablen, die kleiner als 4 Bytes lang werden erweitert, um geben `int32` werden beim Laden in den Stapel. Gleitkommawerte werden auf ihre systemeigene Größe erweitert (Typ `F`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldloc.1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt die lokale Variable am Index 2 in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|08|ldloc.2|Lädt die lokale Variable am Index 2 in den Auswertungsstapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Wert der lokale Variable am Index 2 wird auf dem Stapel abgelegt.  
  
 `ldloc.2` ist eine besonders effiziente Codierung für <xref:System.Reflection.Emit.OpCodes.Ldloc>, ermöglicht den Zugriff auf die lokale Variable am Index 2.  
  
 Der Typ des Werts ist identisch mit dem Typ der lokalen Variablen, die in der Methodenheader angegeben wurde. Lokale Variablen, die kleiner als 4 Bytes lang werden erweitert, um geben `int32` werden beim Laden in den Stapel. Gleitkommawerte werden auf ihre systemeigene Größe erweitert (Typ `F`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldloc.2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt die lokale Variable am Index 3 in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|09|ldloc. 3|Lädt die lokale Variable am Index 3 in den Auswertungsstapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Wert der lokale Variable am Index 3 wird auf dem Stapel abgelegt.  
  
 `ldloc.3` ist eine besonders effiziente Codierung für <xref:System.Reflection.Emit.OpCodes.Ldloc>, ermöglicht den Zugriff auf die lokale Variable am Index 3.  
  
 Der Typ des Werts ist identisch mit dem Typ der lokalen Variablen, die in der Methodenheader angegeben wurde. Lokale Variablen, die kleiner als 4 Bytes lang werden erweitert, um geben `int32` werden beim Laden in den Stapel. Gleitkommawerte werden auf ihre systemeigene Größe erweitert (Typ `F`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldloc.3` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt die lokale Variable an einem bestimmten Index in den Auswertungsstapel, Kurzform.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|11 < `unsigned int8` >|ldloc.s `index`|Lädt die lokale Variable am Index `index` Stapel, Kurzform.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Wert der lokale Variable am angegebenen Index ist auf dem Stapel abgelegt.  
  
 Die `ldloc.s` Anweisung legt den Inhalt der lokalen Variable Anzahl an der übergebene Index in den Auswertungsstapel, in dem die lokalen Variablen 0 nummeriert oder höher. Lokale Variablen werden mit 0 initialisiert, bevor Sie die Methode eingeben, ist das Initialisierungsflag für die Methode "true". Es sind 256 (2 ^ 8) lokale Variablen (0-255) in der Kurzform, mögliche also eine effizientere Codierung als `ldloc`.  
  
 Der Typ des Werts ist identisch mit dem Typ der lokalen Variablen, die in der Methodenheader angegeben wurde. Finden Sie unter Partition I. lokale Variablen, die kleiner sind als 4 Bytes lang erweitert werden, geben Sie `int32` werden beim Laden in den Stapel. Gleitkommawerte werden auf ihre systemeigene Größe erweitert (Typ `F`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> methodenüberladungen können die `ldloc.s` Opcode:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt die Adresse der lokalen Variablen am angegebenen Index in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE OD &LT; `unsigned int16` >|ldloca `index`|Lädt die Adresse der lokalen Variablen am `index` auf dem Auswertungsstapel ab.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  In der lokalen Variablen am angegebenen Index gespeicherte Adresse wird auf dem Stapel abgelegt.  
  
 Die `ldloca` Anweisung legt die Adresse der lokalen Variable Anzahl an der übergebene Index im Stapel, in dem lokale Variablen 0 nummeriert oder höher. Der Wert, der auf dem Stapel abgelegt wurde bereits ordnungsgemäß ausgerichtet für die Verwendung mit Anweisungen wie <xref:System.Reflection.Emit.OpCodes.Ldind_I> und <xref:System.Reflection.Emit.OpCodes.Stind_I>. Das Ergebnis ist ein vorübergehender Zeiger (Typ `*`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldloca` Opcode:  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt die Adresse der lokalen Variablen am angegebenen Index in den Auswertungsstapel, Kurzform.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|12 < `unsigned int8` >|ldloca.s `index`|Lädt die Adresse der lokalen Variablen am `index` in den Auswertungsstapel, Kurzform.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  In der lokalen Variablen am angegebenen Index gespeicherte Adresse wird auf dem Stapel abgelegt.  
  
 Die `ldloca.s` Anweisung legt die Adresse der lokalen Variable Anzahl an der übergebene Index im Stapel, in dem lokale Variablen 0 nummeriert oder höher. Der Wert, der auf dem Stapel abgelegt wurde bereits ordnungsgemäß ausgerichtet für die Verwendung mit Anweisungen wie <xref:System.Reflection.Emit.OpCodes.Ldind_I> und <xref:System.Reflection.Emit.OpCodes.Stind_I>. Das Ergebnis ist ein vorübergehender Zeiger (Typ `*`).  
  
 Die `ldloca.s` Anweisung bietet eine effiziente Codierung für die Verwendung mit der lokalen Variablen von 0 bis 255.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldloca.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen NULL-Verweis (Typ <see langword="O" />) auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|14|ldnull|einen null-Verweis auf den Stapel Push|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Verweis auf ein null-Objekt ist auf dem Stapel abgelegt.  
  
 `ldnull` Legt einen null-Verweis (Typ `O`) auf dem Stapel. Dient zur Speicherorte zu initialisieren, bevor sie mit Daten aufgefüllt werden, oder wenn sie veraltet sind.  
  
 `ldnull` enthält einen null-Verweis, der Größe unabhängig ist.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldnull` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopiert das Werttypobjekt, auf das eine Adresse zeigt, an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|71 < `T` >|ldobj `class`|Kopiert eine Instanz eines Werttyps `class` auf den Stapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Die Adresse eines Objekts vom Typ Wert wird auf dem Stapel abgelegt.  
  
2.  Die Adresse wird vom Stapel geholt, und die Instanz an dieser bestimmten Adresse gesucht wird.  
  
3.  Der Wert des Objekts an dieser Adresse gespeichert ist auf dem Stapel abgelegt.  
  
 Die `ldobj` Anweisung wird verwendet, um einen Werttyp als Parameter übergeben.  
  
 Die `ldobj` -Anweisung kopiert den Wert verweist `addrOfValObj` (des Typs `&`, `*`, oder `native int`) am Anfang des Stapels. Die Anzahl der kopierten Bytes hängt von der Größe der Klasse (gemäß der `class` Parameter). Die `class` Parameter ist ein Metadatentoken, das den Werttyp darstellt.  
  
 Der Vorgang von der `ldobj` Anweisung kann geändert werden, eine sofort abgrenzen, indem Sie <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> unmittelbar vorangestellt wird.  
  
 <xref:System.TypeLoadException> wird ausgelöst, wenn die Klasse nicht gefunden werden kann. Dies wird in der Regel erkannt, wenn die Microsoft Intermediate Language (MSIL)-Anweisung in nativen Code anstatt zur Laufzeit konvertiert wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldobj` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Wert eines statischen Felds auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|7E < `T` >|ldsfld `field`|Legt den Wert von `field` auf dem Stapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Wert eines bestimmten Felds wird auf dem Stapel abgelegt.  
  
 Die `ldsfld` Anweisung legt den Wert eines statischen (shared für alle Instanzen einer Klasse) auf dem Stapel Feld. Der Rückgabetyp ist, verknüpft mit dem übergebenen Metadatentoken `field`.  
  
 Die `ldsfld` Anweisung lassen eine <xref:System.Reflection.Emit.OpCodes.Volatile> Präfix.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldsfld` Opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt die Adresse eines statischen Felds auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|7F. &LT; `T` >|ldsflda `field`|Drücken Sie die Adresse des `field` auf dem Stapel|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Die Adresse eines bestimmten Felds wird auf dem Stapel abgelegt.  
  
 Die `ldsflda` Anweisung legt die Adresse eines statischen (shared für alle Instanzen einer Klasse) auf dem Stapel Feld. Die Adresse kann als vorübergehender Zeiger dargestellt werden (Typ `*`) Wenn das Metadatentoken `field` bezieht sich auf einen Typ, dessen Speicher verwaltet wird. Andernfalls entspricht es ein nicht verwalteter Zeiger (Typ `native int`). Beachten Sie, dass `field` möglicherweise ein statischen globalen mit einer zugewiesenen relative virtuelle Adresse (der Offset des Felds aus der Basisadresse, an dem die PE-Datei in den Arbeitsspeicher geladen wird), in dem der Arbeitsspeicher wird nicht verwaltet.  
  
 Die `ldsflda` Anweisung lassen eine <xref:System.Reflection.Emit.OpCodes.Volatile> Präfix.  
  
 <xref:System.MissingFieldException> wird ausgelöst, wenn in den Metadaten nicht gefunden wird. Dies wird in der Regel überprüft, wenn Microsoft Intermediate Language (MSIL)-Anweisungen in systemeigenen Code, nicht zur Laufzeit konvertiert werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldsflda` Opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen neuen Objektverweis auf ein in den Metadaten gespeichertes Zeichenfolgenliteral mittels Push ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|72 < `T` >|ldstr `mdToken`|Legt ein Zeichenfolgenobjekt für das Metadatentoken für die Zeichenfolge `mdToken`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis auf eine Zeichenfolge ist auf dem Stapel abgelegt.  
  
 Die `ldstr` Anweisung legt einen Objektverweis (Typ `O`) auf ein neues String-Objekt, das in den Metadaten gespeicherte Zeichenfolgenliteral darstellt. Die `ldstr` Anweisung belegt die erforderliche Menge an Arbeitsspeicher und führt alle formatkonvertierung erforderlich, um aus dem Formular in der Datei in das Zeichenfolgenformat erforderlich zur Laufzeit verwendet das Zeichenfolgenliteral zu konvertieren.  
  
 Die Common Language Infrastructure (CLI) wird sichergestellt, dass das Ergebnis von zwei `ldstr` Anweisungen verweisen auf zwei Metadatentoken, das über die gleiche Sequenz von Zeichen zurück, genau das gleiche Zeichenfolgenobjekt (dieser Prozess wird als "Internalisierung" bezeichnet).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldstr` Opcode:  
  
-   ILGenerator.Emit(OpCode, string)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert ein Metadatentoken in seine Laufzeitdarstellung und legt es auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|D0 < `T` >|ldtoken `token`|Konvertiert ein Metadatentoken in seine laufzeitdarstellung an.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Das übergebene Token konvertiert eine `RuntimeHandle` und auf dem Stapel abgelegt.  
  
 Die `ldtoken` Anweisung Push-Vorgänge eine `RuntimeHandle` für das angegebene Metadatentoken. Ein `RuntimeHandle` kann eine `fieldref/fielddef`, `methodref/methoddef`, oder ein `typeref/typedef`.  
  
 Der Wert, der auf dem Stapel abgelegt kann verwendet werden, in Aufrufen `Reflection` Methoden in der System-Klassenbibliothek.  
  
 Informationen über Laufzeithandles finden Sie unter den folgenden Klassen: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, und <xref:System.RuntimeMethodHandle>.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> methodenüberladungen können die `ldtoken` Opcode:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen nicht verwalteten Zeiger (Typ <see langword="native int" />) auf systemeigenen Code auf dem Auswertungsstapel ab. Dieser Code implementiert eine bestimmte virtuelle Methode, die einem angegebenen Objekt zugeordnet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 07 < `T` >|ldvirtftn `method`|Legt einen Zeiger auf ein Objekt virtuelle Methode `method` auf dem Stapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis ist auf dem Stapel abgelegt.  
  
2.  Der Objektverweis per pop ausgelesen wird aus dem Stapel und die Adresse des Einstiegspunkts der-Methode (gemäß der Metadatentoken `method`) gesucht wird.  
  
3.  Der Zeiger auf `method` auf dem Stapel abgelegt wird.  
  
 Die resultierende nicht verwaltete Zeiger auf den Stapel von verschoben der `ldvirtftn` Anweisung kann aufgerufen werden, mithilfe der <xref:System.Reflection.Emit.OpCodes.Calli> Anweisung, wenn er auf einer verwalteten Methode (oder einen Stub, der Übergang von verwaltetem zu nicht verwaltetem Code) verweist.  
  
 Der nicht verwalteten Zeiger verweist auf systemeigenen Code mit der CLR-Aufrufkonvention. Diese Methodenzeiger sollten nicht als Rückrufroutine an nicht verwalteten systemeigenen Code übergeben werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ldvirtftn` Opcode:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beendet einen geschützten Codebereich, wobei die Steuerung bedingungslos an eine bestimmte Zielanweisung übertragen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|TT &LT; `int32` >|Lassen Sie `target`|Beendet einen geschützten Codebereich.|  
  
 Es gibt keine Zustandswechsel für diese Anweisung angegeben.  
  
 Die `leave` -Anweisung überträgt die Steuerung bedingungslos an das bestimmte zielanweisung als einen signierten 4-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Die `leave` Anweisung ähnelt der `br` -Anweisung, sondern dienen zum Beenden einer `try`, `filter`, oder `catch` blockieren, während der normalen verzweigungsanweisungen nur in einem solchen Block zum Übertragen des Steuerelements in erfolgen können Es ist. Die `leave` Anweisung leert den Auswertungsstapel und stellt sicher, dass die entsprechenden umgebenden `finally` Blöcke ausgeführt werden.  
  
 Können keine `leave` Anweisung zum Beenden einer `finally` Block. Um die Generierung von Code für Ausnahmehandler zu vereinfachen, innerhalb eines Catch-Blocks verwenden gültig ist, ein `leave` -Anweisung die Steuerung zu übertragen, um jede Anweisung innerhalb der zugeordneten `try` Block.  
  
 Wenn eine Anweisung mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> methodenüberladungen können die `leave` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beendet einen geschützten Codebereich, wobei die Steuerung bedingungslos an eine bestimmte Zielanweisung übertragen wird, Kurzform.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|DE < `int8` >|leave.s `target`|Beendet einen geschützten Codebereich, Kurzform.|  
  
 Es gibt keine Zustandswechsel für diese Anweisung angegeben.  
  
 Die `leave.s` -Anweisung überträgt die Steuerung bedingungslos an die übergebene zielanweisung als einen signierten 1-Byte-Offset vom Anfang der aktuellen Anweisung folgenden dargestellt.  
  
 Die `leave.s` Anweisung ähnelt der `br` -Anweisung, sondern dienen zum Beenden einer `try`, `filter`, oder `catch` blockieren, während der normalen verzweigungsanweisungen nur in einem solchen Block zum Übertragen des Steuerelements in erfolgen können Es ist. Die `leave.s` Anweisung leert den Auswertungsstapel und stellt sicher, dass die entsprechenden umgebenden `finally` Blöcke ausgeführt werden.  
  
 Können keine `leave.s` Anweisung zum Beenden einer `finally` Block. Um die Generierung von Code für Ausnahmehandler zu vereinfachen, innerhalb eines Catch-Blocks verwenden gültig ist, ein `leave.s` -Anweisung die Steuerung zu übertragen, um jede Anweisung innerhalb der zugeordneten `try` Block.  
  
 Wenn eine Anweisung mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `leave.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Belegt eine bestimmte Anzahl von Bytes aus dem lokalen dynamischen Speicherpool und legt die Adresse (einen flüchtigen Zeiger, Typ <see langword="*" />) des ersten reservierten Bytes auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 0F|localloc|Speicherplatz aus dem lokalen Heap reserviert.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Die Anzahl der Bytes, die zugeordnet werden, wird auf dem Stapel abgelegt.  
  
2.  Die Anzahl von Bytes wird vom Stapel geholt. Größe des Arbeitsspeichers, der Größe entspricht, wird vom lokalen Heap zugeordnet.  
  
3.  Ein Zeiger auf das erste Byte der belegte Arbeitsspeicher wird auf dem Stapel abgelegt.  
  
 Die `localloc` Anweisung ordnet `size` (Typ `natural unsigned int`) Bytes aus dem lokalen dynamischen Arbeitsspeicher Anwendungspool und die Adresse zurückgibt (ein vorübergehender Zeiger, der Typ `*`) des ersten reservierten Bytes. Der Speicherblock, der zurückgegeben wird nur dann, wenn das Initialisierungsflag für die Methode wird mit 0 initialisiert `true`. Wenn die aktuelle Methode führt eine <xref:System.Reflection.Emit.OpCodes.Ret>, der lokalen Speicher-Pool für die Wiederverwendung verfügbar gemacht.  
  
 Die resultierende Adresse ist ausgerichtet, sodass alle primitiven Datentyp es gespeichert werden kann, mit der `stind` Anweisungen (z. B. <xref:System.Reflection.Emit.OpCodes.Stind_I4>) und geladen, mit der `ldind` Anweisungen (z. B. <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).  
  
 Die `localloc` Anweisung nicht möglich, innerhalb einer `filter`, `catch`, `finally`, oder `fault` Block.  
  
 <xref:System.StackOverflowException> wird ausgelöst, wenn die Anforderung nicht genügend Arbeitsspeicher vorhanden ist.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `localloc` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen typisierten Verweis auf eine Instanz eines bestimmten Typs auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|C6 < `T` >|mkrefany `class`|Legt einen typisierten Verweis vom Typ `class` im Stapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Zeiger auf Daten auf dem Stapel abgelegt wird.  
  
2.  Der Zeiger wird per pop ausgelesen und in einen typisierten Verweis vom Typ konvertiert `class`.  
  
3.  Die typisierte Verweis wird auf dem Stapel abgelegt.  
  
 Die `mkrefany` -Anweisung unterstützt das Übergeben von dynamisch typisierte Verweise. Der Zeiger muss vom Typ `&`, `*`, oder `native int`, und halten Sie die gültige Adresse eines Datenelements. `Class` ist den Typ der Daten, die der Zeiger verweist, die das Klassentoken beschreiben. `Mkrefany` Legt einen typisierten Verweis auf den Stapel, wobei ein nicht transparenten Deskriptor des Zeigers und der Typ `class`.  
  
 Der einzige zulässige Operation auf einen typisierten Verweis ist das an eine Methode übergeben, die einen typisierten Verweis als Parameter erfordert. Die aufgerufene Methode können Sie dann die <xref:System.Reflection.Emit.OpCodes.Refanytype> und <xref:System.Reflection.Emit.OpCodes.Refanyval> Anweisungen, um den Typ (Klasse) bzw. die Adresse abrufen.  
  
 <xref:System.TypeLoadException> wird ausgelöst, wenn `class` wurde nicht gefunden. Dies ist i. d. r. erkannt, wenn Microsoft Intermediate Language (MSIL)-Anweisungen in systemeigenen Code anstatt zur Laufzeit konvertiert werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `mkrefany` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Multipliziert zwei Werte und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|5A|mul|Multipliziert zwei Werte im Stapel an.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` sind per pop ausgelesen, aus dem Stapel; `value1` multipliziert wird `value2`.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 Die `mul` -Anweisung multipliziert `value1` von `value2` und legt das Ergebnis auf dem Stapel. Ganzzahloperationen abgeschnitten werden, automatisch die höherwertigen Bits bei einem Überlauf.  
  
 Finden Sie unter <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> für eine ganze Zahl-spezifische multiply-Vorgang mit der Bearbeitung von Überlaufdaten.  
  
 Für Gleitkommatypen 0 * unendlich = "NaN".  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `mul` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Multipliziert zwei Ganzzahlwerte, führt eine Überlaufprüfung durch und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|D8|mul.ovf|Multipliziert zwei Ganzzahlwerte auf dem Stapel mit eine überlaufprüfung an.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` sind per pop ausgelesen, aus dem Stapel; `value1` multipliziert wird `value2`, mit der eine überlaufprüfung.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 Die `mul.ovf` -Anweisung multipliziert die ganze Zahl `value1` durch eine ganze Zahl `value2` und legt das Ergebnis auf dem Stapel. Eine Ausnahme wird ausgelöst, wenn das Ergebnis nicht dem Ergebnistyp passen.  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `mul.ovf` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Multipliziert zwei Ganzzahlwerte ohne Vorzeichen, führt eine Überlaufprüfung durch und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|D9|mul.ovf.un|Multipliziert zwei Werte, die auf dem Stapel mit eine überlaufprüfung ohne Vorzeichen.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` sind per pop ausgelesen, aus dem Stapel; `value1` multipliziert wird `value2`, mit der eine überlaufprüfung.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 Die `mul.ovf.un` Anweisung multipliziert Ganzzahl ohne Vorzeichen `value1` von Ganzzahl ohne Vorzeichen `value2` und legt das Ergebnis auf dem Stapel. Eine Ausnahme wird ausgelöst, wenn das Ergebnis nicht dem Ergebnistyp passen.  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `mul.ovf.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Negiert einen Wert und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|65|Neg|Negiert den Wert derzeit an oberster Position im Stapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Wert wird auf dem Stapel abgelegt.  
  
2.  Ein Wert vom Stapel geholt und negiert.  
  
3.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 Die `neg` Anweisung negiert einen Wert und legt das Ergebnis auf dem Stapel. Der Rückgabetyp entspricht dem Operandentyp.  
  
 Negation von ganzzahligen Werten ist standard Zweierkomplement Negation. Insbesondere negieren den kleinsten negative Zahl (die nicht positive Entsprechung verfügt), wird den kleinsten negative Zahl ergibt. Diese Verwendung einen Überlauf erkennen die <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> Anweisung stattdessen (d. h. Subtrahieren von 0).  
  
 Negieren einer Gleitkommazahl kann nicht "Überlauf", und "NaN" negieren wird NaN zurückgegeben.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `neg` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen Objektverweis auf ein neues nullbasiertes, eindimensionales Array auf dem Auswertungsstapel ab, dessen Elemente einen bestimmten Typ aufweisen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|8D < `T` >|newarr `etype`|Erstellt ein neues Array mit Elementen des Typs `etype`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Die Anzahl der Elemente im Array wird auf dem Stapel abgelegt.  
  
2.  Die Anzahl der Elemente aus dem Stapel per pop ausgelesen wird, und das Array erstellt wird.  
  
3.  Ein Objektverweis auf das neue Array wird auf dem Stapel abgelegt.  
  
 Die `newarr` Anweisung legt einen Objektverweis (Typ `O`) in ein neues nullbasiertes, eindimensionales Array, dessen Elemente vom Typ sind `etype` (ein Metadatentoken, das den Typ beschreibt). Die Anzahl der Elemente im neuen Array sollte angegeben werden, als ein `native int`. Gültiges Array Indizes können Werte zwischen 0 (null), um die maximale Anzahl von Elementen, die minus eins.  
  
 Die Elemente eines Arrays können beliebigen Typs, einschließlich Werttypen werden.  
  
 Nullbasierte, eindimensionale Arrays von Zahlen werden mit einem Metadatentoken verweisen auf den entsprechenden Werttyp erstellt (<xref:System.Int32>usw.). Elemente des Arrays werden auf 0 des entsprechenden Typs initialisiert.  
  
 Eindimensionale Arrays, nicht nullbasiert sind und mehrdimensionale Arrays werden mit erstellt <xref:System.Reflection.Emit.OpCodes.Newobj> statt `newarr`. Sie werden in der Regel erstellt, mit den Methoden der der <xref:System.Array> Klasse in .NET Framework.  
  
 <xref:System.OutOfMemoryException> wird ausgelöst, wenn nicht genügend zum Erfüllen der Anforderung Arbeitsspeicher.  
  
 <xref:System.OverflowException> wird ausgelöst, wenn `numElems` ist kleiner als 0.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `newarr` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Erstellt ein neues Objekt oder eine neue Instanz eines Werttyps, wobei ein Objektverweis (Typ <see langword="O" />) auf dem Auswertungsstapel abgelegt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|73 < `T` >|newobj `ctor`|Reserviert ein nicht initialisiertes Objekt oder einen Werttyp und ruft die Konstruktormethode `ctor`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Argumente `arg1` über `argn` auf dem Stapel abgelegt werden, die in der Sequenz.  
  
2.  Argumente `argn` über `arg1` werden vom Stapel geholt und an `ctor` für die objekterstellung.  
  
3.  Ein Verweis auf das neue Objekt wird auf dem Stapel abgelegt.  
  
 Die `newobj` -Anweisung erstellt ein neues Objekt oder eine neue Instanz eines Werttyps. `Ctor` ist ein Metadatentoken (eine `methodref` oder `methoddef` , die als Konstruktor markiert werden muss), der die Namen, die Klasse und die Signatur des aufzurufenden Konstruktors angibt.  
  
 Die `newobj` Anweisung weist eine neue Instanz der zugeordneten Klasse `ctor` und initialisiert alle Felder in der neuen Instanz auf 0 (des erforderlichen Typs) oder null-Verweise nach Bedarf. Er ruft dann den Konstruktor `ctor` mit den angegebenen Argumenten zusammen mit der neu erstellte Instanz. Nachdem der Konstruktor aufgerufen wurde, der nun initialisierte Objektverweis (Typ `O`) auf dem Stapel abgelegt wird.  
  
 Aus Sicht des Konstruktors der nicht initialisierte Objekt Argument 0 ist und andere Newobj übergebenen Argumente führen Sie in der Reihenfolge.  
  
 Alle nullbasierten, eindimensionalen Arrays werden mit erstellt <xref:System.Reflection.Emit.OpCodes.Newarr>, nicht `newobj`. Andererseits, werden alle anderen Arrays (mehr als eine Dimension oder eindimensionale, nicht nullbasiert) mit erstellt `newobj`.  
  
 Werttypen sind nicht in der Regel mit erstellt `newobj`. Sie sind in der Regel zugewiesen, entweder als Argumente oder lokale Variablen mit `newarr` (für nullbasierte, eindimensionale Arrays) oder als Felder von Objekten. Sobald zugeordnet ist, werden sie mithilfe der initialisiert <xref:System.Reflection.Emit.OpCodes.Initobj>. Allerdings die `newobj` Anweisung kann verwendet werden, um eine neue Instanz eines Werttyps auf dem Stapel zu erstellen, die dann als Argument, gespeichert in einer lokalen und so weiter übergeben werden kann.  
  
 <xref:System.OutOfMemoryException> wird ausgelöst, wenn nicht genügend zum Erfüllen der Anforderung Arbeitsspeicher.  
  
 <xref:System.MissingMethodException> wird ausgelöst, wenn eine Konstruktormethode `ctor` mit dem angegebenen Namen, Klasse und die Signatur wurde nicht gefunden. Dies wird in der Regel erkannt, wenn Microsoft Intermediate Language (MSIL)-Anweisungen in systemeigenen Code anstatt zur Laufzeit konvertiert werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `newobj` Opcode:  
  
-   ILGenerator.Emit(OpCode, ConstructorInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Füllt Speicherplatz auf, wenn Opcodes gepatcht werden. Es wird keine sinnvolle Operation ausgeführt, obwohl ein Verarbeitungszyklus ausgeführt werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|00|NOP|Führt eine Operation ohne Verhalten.|  
  
 Es gibt keine Stapel laufen, die für diese Anweisung definiert.  
  
 Die `nop` Vorgang wird keine Aktion ausgeführt. Es ist im Raum zu füllen, wenn Opcodes gepatcht werden soll.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `nop` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Berechnet das bitweise Komplement des Ganzzahlwerts an oberster Position des Stapels und legt das Ergebnis als denselben Typ auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|66|not|Berechnet das bitweise Komplement eines Werts an.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value` wird auf dem Stapel abgelegt.  
  
2.  `value` per pop ausgelesen wird, aus dem Stapel und das bitweise Komplement berechnet.  
  
3.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 Die `not` Anweisung berechnet das bitweise Komplement von einen ganzzahligen Wert und legt das Ergebnis im Stapel. Der Rückgabetyp entspricht dem Operandentyp.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `not` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Berechnet das bitweise Komplement der beiden Ganzzahlwerte an oberster Position des Stapels und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|60|oder|Berechnet die bitweise oder mit zwei ganzzahligen Werten gibt eine Ganzzahl zurück.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` sind per pop ausgelesen, aus dem Stapel und die bitweise OR berechnet.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 Die `or` -Anweisung berechnet die bitweise OR von zwei Werten über den Stapel legt das Ergebnis im Stapel.  
  
 `Or` ist ein Integer-spezifische-Vorgang.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `or` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Entfernt den Wert, der sich derzeit an oberster Position des Auswertungsstapels befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|26|pop|Holt den obersten Wert aus dem Stapel an.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Höchstwert wird vom Stapel geholt.  
  
 Die `pop` -Anweisung entfernt das oberste Element vom Stapel.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `pop` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dies ist eine reservierte Anweisung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dies ist eine reservierte Anweisung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dies ist eine reservierte Anweisung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dies ist eine reservierte Anweisung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dies ist eine reservierte Anweisung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dies ist eine reservierte Anweisung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dies ist eine reservierte Anweisung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dies ist eine reservierte Anweisung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass beim nachfolgenden Vorgang zur Arrayadresse zur Laufzeit keine Typüberprüfung durchgeführt wird und dass ein verwalteter Zeiger zurückgegeben wird, der nur bedingt geändert werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Microsoft intermediate Language (MSIL) Assemblyformat sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 1E|ReadOnly.|Geben Sie, dass die nachfolgenden Vorgang zur Laufzeit keine typüberprüfung durchführt und wird mit eingeschränkten Veränderlichkeit einen verwalteten Zeiger zurückgegeben.|  
  
 Dieses Präfix kann nur unmittelbar vorangehenden stehen die `ldelema` -Anweisung und Aufrufe an die speziellen `Address` Methode für Arrays. Seine Auswirkungen auf den nachfolgenden Vorgang dient einem doppelten Zweck:  
  
1.  Zur Laufzeit wird kein Typ Check-Vorgang ausgeführt. Beachten Sie, dass normalerweise eine implizite typüberprüfung für die `ldelema` und `stelem` Anweisungen auf Verweis geben Arrays. Wird niemals eine Laufzeit-Typinformationen überprüft Wertklassen, also `readonly` kein in diesem Fall ist.  
  
2.  Die Überprüfung behandelt das Ergebnis des Vorgangs Adresse der als ein verwalteter Zeiger mit eingeschränkten Veränderlichkeit.  
  
 Der Zeiger gibt Veränderlichkeit eingeschränkt, da der definierende Typ steuert, ob der Wert geändert werden kann. Für Wertklassen, die verfügbar machen, keine öffentliche Felder oder Methoden, die den Wert direkt aktualisieren, ist der Zeiger schreibgeschützt (daher der Name des Präfixes). Insbesondere die Klassen, die primitive Typen (z. B. System. Int32) machen keine Mutatoren und somit sind schreibgeschützt.  
  
 Ein verwalteter Zeiger beschränkt auf diese Weise kann nur auf folgende Weise verwendet werden:  
  
-   Als die `object` -Parameter für die `ldfld`, `ldflda`, `stfld`, `call`, oder`constrained callvirt` Anweisungen.  
  
-   Als die `pointer` Parameter an die `ldobj` Anweisung oder in eines der `ldind` Anweisungen.  
  
-   Als die `source` Parameter an die `cpobj` Anweisung.  
  
 Alle anderen Vorgänge nicht zulässig ist, einschließlich der `stobj`, `initobj`, oder `mkrefany` Vorgänge oder keines der `stind` Anweisungen.  
  
 Der Zweck der `readonly` Präfix ist, um eine typüberprüfung vermieden werden, wenn ein Element aus einem Array in generischem Code abrufen. Z. B. der Ausdruck `arr[i].m()`, bei dem der Elementtyp des Arrays `arr` ist ein generischer Typ, der auf eine Schnittstelle mit der Methode eingeschränkt `m`, möglicherweise in der folgenden MSIL kompiliert.  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 Ohne die `readonly` Präfix, das `ldelema` Anweisung würde eine typüberprüfung ausführen, in dem Fall, in dem! 0 wurde ein Verweistyp. Nicht nur diese Prüfung ineffizient ist, aber es ist semantisch inkorrekt. Die typüberprüfung für `ldelema` ist eine genaue Übereinstimmung, also zu streng. Wenn das Array des Typs Unterklassen aufrechterhalten! 0, der obige Code würde die typüberprüfung fehlschlagen.  
  
 Die Adresse des Arrayelements wird abgerufen, statt dem Element selbst, um ein Handle für haben `arr[i]` funktioniert für beide Werttypen und Verweistypen, und können daher übergeben werden, um die `constrained callvirt` Anweisung.  
  
 Im Allgemeinen ist es wäre unsicher, die zur Laufzeit Überprüfung übersprungen wird, wenn das Array Elemente eines Verweistyps aufrechterhalten. Um sicher zu sein, ist es erforderlich, um sicherzustellen, dass keine Änderungen an das Array mit diesem Zeiger vorgenommen werden. Die Regeln für die Überprüfung stellen Sie sicher, diese. Beschränkte verwaltete Zeiger kann als Objekt der Instanz von Methodenaufrufen, übergeben werden, damit nicht streng genommen für Werttypen schreibgeschützt, aber es kein Sicherheitsproblem Typ für Werttypen ist.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `readonly` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Typtoken ab, das in einen typisierten Verweis eingebettet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 1D|refanytype|Schiebt das Typtoken in einen typisierten Verweis gespeichert.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Werttyp-Verweis ist auf dem Stapel abgelegt.  
  
2.  Die typisierte Verweis aus dem Stapel per pop ausgelesen wird, und das entsprechende Typtoken abgerufen.  
  
3.  Das Typtoken wird auf dem Stapel abgelegt.  
  
 Ein typisierter Verweis enthält ein Typtoken und eine Adresse einer Objektinstanz.  
  
 Die `refanytype` Anweisung ruft das Typtoken ab in den typisierten Verweis eingebettet. Finden Sie unter der <xref:System.Reflection.Emit.OpCodes.Mkrefany> Anweisung Informationen zum Erstellen von typisierten Verweise.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `refanytype` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Adresse (Typ <see langword="&amp;" />) ab, die in einen typisierten Verweis eingebettet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|C2 < `T` >|refanyval `type`|Legt die Adresse in einen typisierten Verweis gespeichert.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Werttyp-Verweis ist auf dem Stapel abgelegt.  
  
2.  Die typisierte Verweis aus dem Stapel per pop ausgelesen wird, und die entsprechende Adresse abgerufen.  
  
3.  Die Adresse wird auf dem Stapel abgelegt.  
  
 Ein typisierter Verweis enthält ein Typtoken und eine Adresse einer Objektinstanz.  
  
 Die `refanyval` -Anweisung ruft die Adresse in eingebetteten ab, der einen typisierten Verweis. In den auf dem Stapel bereitgestellten Typverweis eingebettete Typ muss den vom angegebenen Typ übereinstimmen `type` (ein Metadatentoken, entweder eine `typedef` oder `typeref`). Finden Sie unter der <xref:System.Reflection.Emit.OpCodes.Mkrefany> -Anweisung.  
  
 <xref:System.InvalidCastException> wird ausgelöst, wenn `type` ist nicht identisch mit dem in den Typverweis gespeicherten Typ (in diesem Fall `type` ist die Klasse angegeben die <xref:System.Reflection.Emit.OpCodes.Mkrefany> -Anweisung, die erstellt said typisierten Verweis).  
  
 <xref:System.TypeLoadException> wird ausgelöst, wenn `type` wurde nicht gefunden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `refanyval` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dividiert zwei Werte und legt den Rest auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|5D|REM|Legt den Rest der Division `value1` von `value2` im Stapel.|  
  
> [!NOTE]
>  ### ReplaceThisText  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein `value1` auf dem Stapel abgelegt wird.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus dem Stapel und die restliche geholt `value1` `div` `value2` berechnet.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 `result` = `value1` `rem` `value2` die folgenden Bedingungen erfüllt:  
  
 `result` = `value1` - `value2` `×` (`value1` `div` `value2`), und:  
  
 0 = &#124; `result` &#124; < &#124; `value2` &#124;, Anmeldung (`result`) = Vorzeichen (`value1`), wobei `div` Division-Anweisung, die in Richtung 0 abgeschnitten wird.  
  
 Wenn `value2` 0 (null) oder `value1` ist das Ergebnis "NaN ist" unendlich. Wenn `value2` unendlich ist, ist das Ergebnis ist `value1` (negiert für `-infinity`).  
  
 Ganzzahloperationen lösen <xref:System.DivideByZeroException> Wenn `value2` 0 (null).  
  
 Beachten Sie, dass auf der Intel-Plattformen eine <xref:System.OverflowException> wird ausgelöst, bei der Berechnung (Minint `rem` -1).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `rem` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dividiert zwei Werte ohne Vorzeichen und legt den Rest auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|5E|rem.un|Legt den Rest der Division ohne Vorzeichen `value1` von nicht signierten `value2` im Stapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` werden aus dem Stapel und die restliche geholt `value1` `div` `value2` berechnet.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 `result` = `value1` `rem.un` `value2` die folgenden Bedingungen erfüllt:  
  
 `result` = `value1` - `value2` X (`value1` `div.un` `value2`), und:  
  
 0 = `result`  <  `value2`, wobei `div.un` wird die Anweisung ohne Vorzeichen dividieren.  
  
 Die `rem.un` Anweisung berechnet `result` und legt es auf den Stapel. `Rem.un` die Argumente als ganze Zahlen ohne Vorzeichen behandelt während <xref:System.Reflection.Emit.OpCodes.Rem> behandelt sie als Ganzzahlen mit Vorzeichen.  
  
 `Rem.un` ist für Gleitkommazahlen nicht angegeben.  
  
 Ganzzahloperationen lösen <xref:System.DivideByZeroException> Wenn `value2` 0 (null).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `rem.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird von der aktuellen Methode zurückgegeben und legt einen Rückgabewert (sofern vorhanden) vom Auswertungsstapel des Aufgerufenen auf dem Auswertungsstapel des Aufrufenden ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|2A|ret|Wird von der Methode, die möglicherweise einen Wert zurückgeben.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der zurückgegebene Wert vom Auswertungsstapel aufgerufenen per pop ausgelesen wird.  
  
2.  Der Rückgabewert, der in Schritt 1 erhaltenen wird in den Auswertungsstapel Aufrufer abgelegt.  
  
 Wenn der Rückgabewert nicht auf dem Auswertungsstapel des aufgerufenen vorhanden ist, wird kein Wert (keine Zustandswechsel für den aufgerufenen oder die Aufrufer-Methode) zurückgegeben.  
  
 Der Typ des Rückgabewerts, bestimmt, ob vorhanden, der aktuellen Methode den Typ des Werts aus dem oberen Ende des Stapels und auf den Stapel der Methode, die die aktuelle Methode aufgerufen kopiert abgerufen werden sollen. Dem Auswertungsstapel ab, für die aktuelle Methode muss mit Ausnahme der zurückzugebende Wert leer sein.  
  
 Die `ret` Anweisung kann nicht verwendet werden, um die Steuerung von einer`try`, `filter`, `catch`, oder `finally` Block. Innerhalb einer `try` oder `catch`, verwenden die <xref:System.Reflection.Emit.OpCodes.Leave> Anweisung mit einem Ziel eine `ret` Anweisung, die außerhalb aller einschließenden Ausnahmeblöcke befindet. Da die `filter` und `finally` Blöcke sind logisch Teil der Behandlung von Ausnahmen und nicht der Methode, die in dem ihr Code eingebettet ist, ordnungsgemäß generierten Microsoft Intermediate Language (MSIL)-Anweisungen führen keine Rückgabe aus innerhalb eine Methode einen `filter` oder `finally`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `ret` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Löst erneut die aktuelle Ausnahme aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 1A|Rethrow|Löst erneut die aktuelle Ausnahme aus.|  
  
 Für diese Anweisung ist keine Zustandswechsel definiert.  
  
 Die `rethrow` Anweisung ist nur zulässig, in den Textkörper einer `catch` Handler. Es wird die gleiche Ausnahme, die von diesem Handler abgefangen wurde ausgelöst.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `rethrow` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Verschiebt einen ganzzahligen Wert um eine angegebene Anzahl von Bits nach links, wobei die frei werdenden Stellen mit 0-Bits aufgefüllt werden, und legt das Ergebnis auf den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|62|shl|Verschiebt eine ganze Zahl auf der linken Seite (nachfolgenden in Nullen).|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Wert wird auf dem Stapel abgelegt.  
  
2.  Die Menge der zu verschiebenden Bits wird auf dem Stapel abgelegt.  
  
3.  Die Anzahl der zu verschiebenden Bits und der Wert werden vom Stapel geholt. der Wert wird durch die angegebene Anzahl von Bits nach links verschoben.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 Die `shl` Anweisung verschiebt den Wert (Typ `int32`, `int64` oder `native int`) um die angegebene Anzahl von Bits nach links. Die Anzahl der Bits ist ein Wert vom Typ `int32` oder `native int`. Der Rückgabewert ist nicht angegeben, wenn die Anzahl der zu verschiebenden Bits größer als oder gleich der Breite (in Bits) des angegebenen Werts ist.  
  
 `Shl` Fügt eine Bit 0 (null) in der niedrigsten Position für jede Schicht an.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `shl` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Verschiebt einen ganzzahligen Wert um eine angegebene Anzahl von Bits nach rechts, wobei das Vorzeichen mitgeführt wird, und legt das Ergebnis auf den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|63|shr|Verschiebt eine ganze Zahl nach rechts (nachfolgenden in Zeichen).|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Wert wird auf dem Stapel abgelegt.  
  
2.  Die Menge der zu verschiebenden Bits wird auf dem Stapel abgelegt.  
  
3.  Die Anzahl der zu verschiebenden Bits und der Wert werden vom Stapel geholt. der Wert wird durch die angegebene Anzahl von Bits nach rechts verschoben.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 Die `shr.un` Anweisung verschiebt den Wert (Typ `int32`, `int64` oder `native int`) um die angegebene Anzahl von Bits nach rechts. Die Anzahl der Bits ist ein Wert vom Typ `int32` oder `native int`. Der Rückgabewert ist nicht angegeben, wenn die Anzahl der zu verschiebenden Bits größer als oder gleich der Breite (in Bits) des angegebenen Werts ist.  
  
 `Shr` repliziert das höchstwertige bit für jede Schicht, die das Vorzeichen des ursprünglichen Werts in der `result`.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `shr` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Verschiebt einen ganzzahligen Wert ohne Vorzeichen um eine angegebene Anzahl von Bits nach rechts, wobei die frei werdenden Stellen mit 0-Bits aufgefüllt werden, und legt das Ergebnis auf den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|64|shr.un|Verschiebt eine ganze Zahl nach rechts (nachfolgenden in Nullen (0)).|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Wert wird auf dem Stapel abgelegt.  
  
2.  Die Menge der zu verschiebenden Bits wird auf dem Stapel abgelegt.  
  
3.  Die Anzahl der zu verschiebenden Bits und der Wert werden vom Stapel geholt. der Wert wird durch die angegebene Anzahl von Bits nach rechts verschoben.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 Die `shr.un` Anweisung verschiebt den Wert (Typ `int32`, `int64` oder `native int`) um die angegebene Anzahl von Bits nach rechts. Die Anzahl der Bits ist ein Wert vom Typ `int32`, `int64` oder `native int`. Der Rückgabewert ist nicht angegeben, wenn die Anzahl der zu verschiebenden Bits größer als oder gleich der Breite (in Bits) des angegebenen Werts ist.  
  
 `Shr.un` Fügt eine Bit 0 (null) in die höchste Position für jede Schicht an.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `shr.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt die Größe eines bereitgestellten Werttyps in Bytes auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 1C < `T` >|"sizeof" `valType`|Drücken Sie die Größe in Bytes, der einen Werttyp als ein `unsigned int32`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Die Größe (in Bytes) des bereitgestellten Werttyps (`valType`) auf dem Stapel abgelegt wird.  
  
 `valType` muss ein Metadatentoken (eine `typeref` oder `typedef`), ein Werttyp, Verweistyp oder generischen Typparameter angibt.  
  
 Für einen Verweistyp handelt ist die zurückgegebene Größe an, die Größe des einen Verweiswert des entsprechenden (4 Bytes auf 32-Bit-Systemen), geben Sie nicht die Größe der Daten in Objekten der Verweiswert verweist auf gespeichert. Ein generischer Typparameter kann verwendet werden, nur im Text des Typs oder der Methode, die ihn definiert. Wenn Sie den Typ oder die Methode instanziiert wird, wird der generische Typparameter von einem Werttyp oder Verweistyp ersetzt.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `sizeof` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert den an der obersten Position des Auswertungsstapels befindlichen Wert im Argumentslot an einem angegebenen Index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 0B < `unsigned int16` >|starg `num`|Holt den obersten Wert aus dem Stapel und speichert ihn im Argumentslot `num`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Wert derzeit an oberster Position im Stapel geholt und im Argumentslot platziert `num`.  
  
 Die `starg` Anweisung holt einen Wert aus dem Stapel und platziert ihn im Argumentslot `num`. Der Typ des Werts muss den Typ des Arguments, entsprechend den Angaben in der aktuellen Methode Signatur übereinstimmen.  
  
 Für Prozeduren, die eine Variable Argumentliste kann die `starg` Anweisung kann nur für den ersten festen Argumente, nicht die in der Variable Teil der Signatur verwendet werden.  
  
 Beim Speichern in Argumenten, die einen ganzzahligen Wert, der kürzer als 4 Bytes lang schneidet den Wert ab, während sie auf das Argument aus dem Stapel verschoben. Gleitkommawerte werden von ihrer systemeigenen Größe gerundet (Typ `F`) auf die Größe, die das Argument zugeordnet.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `starg` Opcode:  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert den an der obersten Position des Auswertungsstapels befindlichen Wert im Argumentslot an einem angegebenen Index, Kurzform.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|10 < `unsigned int8` >|starg.s `num`|Holt den obersten Wert aus dem Stapel und speichert ihn im Argumentslot `num`, Kurzform.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Der Wert derzeit an oberster Position im Stapel geholt und im Argumentslot platziert `num`.  
  
 Die `starg.s` Anweisung holt einen Wert aus dem Stapel und platziert ihn im Argumentslot `num`. Der Typ des Werts muss den Typ des Arguments, entsprechend den Angaben in der aktuellen Methode Signatur übereinstimmen.  
  
 Die `starg.s` Anweisung bietet eine effiziente Codierung für die Verwendung mit den ersten 256 Argumenten.  
  
 Für Prozeduren, die eine Variable Argumentliste kann die `starg.s` Anweisung kann nur für den ersten festen Argumente, nicht die in der Variable Teil der Signatur verwendet werden.  
  
 Beim Speichern in Argumenten, die einen ganzzahligen Wert, der kürzer als 4 Bytes lang schneidet den Wert ab, während sie auf das Argument aus dem Stapel verschoben. Gleitkommawerte werden von ihrer systemeigenen Größe gerundet (Typ `F`) auf die Größe, die das Argument zugeordnet.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `starg.s` Opcode:  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt das Arrayelement am angegebenen Index durch den Wert im Auswertungsstapel, dessen Typ in der Anweisung angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Microsoft intermediate Language (MSIL) Assemblyformat sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|A4 < `T` >|stelem `typeTok`|Ersetzt das Arrayelement am angegebenen Index mit einem Wert vom Typ `typeTok` auf dem Stapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis auf ein Array `array`, auf dem Stapel abgelegt wird.  
  
2.  Der Indexwert `index`, auf ein Element in `array` auf dem Stapel abgelegt wird.  
  
3.  Ein Wert des Typs in der Anweisung angegebene wird auf dem Stapel abgelegt.  
  
4.  Der Wert, der Index und der Arrayverweis als werden vom Stapel geholt. der Wert wird in das Arrayelement am angegebenen Index eingefügt.  
  
 Die `stelem` -Anweisung ersetzt den Wert des Elements am angegebenen nullbasierten Index in die eindimensionalen Array `array` mit dem Wert. Der Wert weist den Typ, der durch das Token angegeben `typeTok` in der Anweisung.  
  
 Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`. Der Index ist Typ `native int`.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `stelem` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt das Arrayelement am angegebenen Index durch den <see langword="native int" />-Wert im Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|9|stelem.i|Ersetzt ein Arrayelement am angegebenen Index mit dem `native int` Wert auf dem Stapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis auf ein Array `array`, auf dem Stapel abgelegt wird.  
  
2.  Ein gültiger Index für ein Element im `array` auf dem Stapel abgelegt wird.  
  
3.  Ein Wert wird auf dem Stapel abgelegt.  
  
4.  Der Wert, der Index und der Arrayverweis als werden vom Stapel geholt. der Wert wird in das Arrayelement am angegebenen Index eingefügt.  
  
 Die `stelem.i` -Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` mit der `native int` Wert auf den Stapel verschoben.  
  
 Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`. Der Index ist Typ `native int`.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `stelem.i` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt das Arrayelement am angegebenen Index durch den <see langword="int8" />-Wert im Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|9C|stelem. i1|Ersetzt ein Arrayelement am angegebenen Index mit dem `int8` Wert auf dem Stapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis auf ein Array `array`, auf dem Stapel abgelegt wird.  
  
2.  Ein gültiger Index für ein Element im `array` auf dem Stapel abgelegt wird.  
  
3.  Ein Wert wird auf dem Stapel abgelegt.  
  
4.  Der Wert, der Index und der Arrayverweis als werden vom Stapel geholt. der Wert wird in das Arrayelement am angegebenen Index eingefügt.  
  
 Die `stelem.i1` -Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` mit der `int8` Wert auf den Stapel verschoben.  
  
 Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`. Der Index ist Typ `native int`.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `stelem.i1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt das Arrayelement am angegebenen Index durch den <see langword="int16" />-Wert im Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|9D|stelem. i2|Ersetzt ein Arrayelement am angegebenen Index mit dem `int16` Wert auf dem Stapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis auf ein Array `array`, auf dem Stapel abgelegt wird.  
  
2.  Ein gültiger Index für ein Element im `array` auf dem Stapel abgelegt wird.  
  
3.  Ein Wert wird auf dem Stapel abgelegt.  
  
4.  Der Wert, der Index und der Arrayverweis als werden vom Stapel geholt. der Wert wird in das Arrayelement am angegebenen Index eingefügt.  
  
 Die `stelem.i2` -Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` mit der `int16` Wert auf den Stapel verschoben.  
  
 Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`. Der Index ist Typ `native int`.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `stelem.i2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt das Arrayelement am angegebenen Index durch den <see langword="int32" />-Wert im Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|9E|stelem. i4|Ersetzt ein Arrayelement am angegebenen Index mit dem `int32` Wert auf dem Stapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis auf ein Array `array`, auf dem Stapel abgelegt wird.  
  
2.  Ein gültiger Index für ein Element im `array` auf dem Stapel abgelegt wird.  
  
3.  Ein Wert wird auf dem Stapel abgelegt.  
  
4.  Der Wert, der Index und der Arrayverweis als werden vom Stapel geholt. der Wert wird in das Arrayelement am angegebenen Index eingefügt.  
  
 Die `stelem.i4` -Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` mit der `int32` Wert auf den Stapel verschoben.  
  
 Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`. Der Index ist Typ `native int`.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `stelem.i4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt das Arrayelement am angegebenen Index durch den <see langword="int64" />-Wert im Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|9F|i8|Ersetzt ein Arrayelement am angegebenen Index mit dem `int64` Wert auf dem Stapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis auf ein Array `array`, auf dem Stapel abgelegt wird.  
  
2.  Ein gültiger Index für ein Element im `array` auf dem Stapel abgelegt wird.  
  
3.  Ein Wert wird auf dem Stapel abgelegt.  
  
4.  Der Wert, der Index und der Arrayverweis als werden vom Stapel geholt. der Wert wird in das Arrayelement am angegebenen Index eingefügt.  
  
 Die `stelem.i8` -Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` mit der `int64` Wert auf den Stapel verschoben.  
  
 Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`. Der Index ist Typ `native int`.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `stelem.i8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt das Arrayelement am angegebenen Index durch den <see langword="float32" />-Wert im Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|A0|stelem. r4|Ersetzt ein Arrayelement am angegebenen Index mit dem `float32` Wert auf dem Stapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis auf ein Array `array`, auf dem Stapel abgelegt wird.  
  
2.  Ein gültiger Index für ein Element im `array` auf dem Stapel abgelegt wird.  
  
3.  Ein Wert wird auf dem Stapel abgelegt.  
  
4.  Der Wert, der Index und der Arrayverweis als werden vom Stapel geholt. der Wert wird in das Arrayelement am angegebenen Index eingefügt.  
  
 Die `stelem.r4` -Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` mit der `float32` Wert auf den Stapel verschoben.  
  
 Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`. Der Index ist Typ `native int`.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `stelem.r4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt das Arrayelement am angegebenen Index durch den <see langword="float64" />-Wert im Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|A1|stelem. r8|Ersetzt ein Arrayelement am angegebenen Index mit dem `float64` Wert auf dem Stapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis auf ein Array `array`, auf dem Stapel abgelegt wird.  
  
2.  Ein gültiger Index für ein Element im `array` auf dem Stapel abgelegt wird.  
  
3.  Ein Wert wird auf dem Stapel abgelegt.  
  
4.  Der Wert, der Index und der Arrayverweis als werden vom Stapel geholt. der Wert wird in das Arrayelement am angegebenen Index eingefügt.  
  
 Die `stelem.r8` -Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` mit der `float64` Wert auf den Stapel verschoben.  
  
 Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`. Der Index ist Typ `native int`.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `stelem.r8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt das Arrayelement am angegebenen Index durch den Wert des Objektverweises (Typ <see langword="O" />) im Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|A2|stelem.ref|Ersetzt ein Arrayelement am angegebenen Index mit dem `ref` Wert (Typ `O`) auf dem Stapel.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis auf ein Array `array`, auf dem Stapel abgelegt wird.  
  
2.  Ein gültiger Index für ein Element im `array` auf dem Stapel abgelegt wird.  
  
3.  Ein Wert wird auf dem Stapel abgelegt.  
  
4.  Der Wert, der Index und der Arrayverweis als werden vom Stapel geholt. der Wert wird in das Arrayelement am angegebenen Index eingefügt.  
  
 Die `stelem.ref` -Anweisung ersetzt den Wert des Elements am angegebenen Index im eindimensionalen Array `array` mit der `ref` (Typ `O`) Wert auf den Stapel verschoben.  
  
 Arrays sind Objekte, und daher ein Wert vom Typ dargestellt `O`. Der Index ist Typ `native int`.  
  
 Beachten Sie, dass `stelem.ref` implizit wandelt den angegebenen Wert in den Elementtyp des `array` vor der Zuweisung des Werts auf das Arrayelement. Dies gilt auch für überprüften Code kann diese Umwandlung fehl. Daher die `stelem.ref` Anweisung auslösen kann <xref:System.InvalidCastException>. Für eindimensionale Arrays, die nicht nullbasiert sind und für mehrdimensionale Arrays der <xref:System.Array> -Klasse bietet eine <xref:System.Array.SetValue%2A> Methode.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ist ein null-Verweis.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst, wenn `index` ist negativ oder größer als die Grenze der `array`.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` errichtet keine Elemente des erforderlichen Typs.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `stelem.ref` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt den im Feld eines Objektsverweises oder Zeigers gespeicherten Wert durch einen neuen Wert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|7D < `T` >|stfld `field`|Ersetzt den Wert des `field` des Objekts mit einem neuen Wert.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Objektsverweises oder Zeigers ist auf dem Stapel abgelegt.  
  
2.  Ein Wert wird auf dem Stapel abgelegt.  
  
3.  Der Wert und Verweis/Objektzeiger werden vom Stapel geholt. der Wert des `field` in das Objekt mit dem angegebenen Wert ersetzt wird.  
  
 Die `stfld` -Anweisung ersetzt den Wert eines Felds eines Objekts (Typ `O`) oder über einen Zeiger (Typ `native int`, `&`, oder `*`) mit einem angegebenen Wert. `Field` ist ein Metadatentoken, das auf ein Verweis auf ein Element verweist. Die `stfld` Anweisung kann ein Präfix für eine oder beide haben <xref:System.Reflection.Emit.OpCodes.Unaligned> und <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn die Objektsverweises oder Zeigers ein null-Verweis ist, und das Feld nicht statisch.  
  
 <xref:System.MissingFieldException> wird ausgelöst, wenn `field` ist nicht in den Metadaten gefunden. Dies wird in der Regel überprüft, wenn die Microsoft Intermediate Language (MSIL)-Anweisung in systemeigenen Code, nicht zur Laufzeit konvertiert wird.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `stfld` Opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert einen Wert vom Typ <see langword="native int" /> an einer angegebenen Adresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|DF|stind.i|Speichert einen `native int` Wert einer angegebenen Adresse.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Ein Wert wird auf dem Stapel abgelegt.  
  
3.  Der Wert und die Adresse werden vom Stapel geholt. der Wert wird an der Adresse gespeichert.  
  
 Die `stind.i` -Anweisung speichert eine `native int` Wert an der angegebenen Adresse (Typ `native int`, `*`, oder `&`).  
  
 Typsichere Operation erfordert, dass die `stind.i` Anweisung auf eine Weise konsistent mit dem Typ des Zeigers verwendet werden. Der Vorgang von der `stind.i` Anweisung kann geändert werden, eine sofort abgrenzen, indem Sie <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> unmittelbar vorangestellt wird.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `addr` ist nicht für den Argumententyp impliziert durch die Anweisungssuffix natürlich ausgerichtet.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `stind.i` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert einen Wert vom Typ <see langword="int8" /> an einer angegebenen Adresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|52|i1|Speichert ein `int8` Wert einer angegebenen Adresse.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Ein Wert wird auf dem Stapel abgelegt.  
  
3.  Der Wert und die Adresse werden vom Stapel geholt. der Wert wird an der Adresse gespeichert.  
  
 Die `stind.i1` -Anweisung speichert eine `int8` Wert an der angegebenen Adresse (Typ `native int`, `*`, oder `&`).  
  
 Typsichere Operation erfordert, dass die `stind.i1` Anweisung auf eine Weise konsistent mit dem Typ des Zeigers verwendet werden. Der Vorgang von der `stind.i1` Anweisung kann geändert werden, eine sofort abgrenzen, indem Sie <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> unmittelbar vorangestellt wird.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `addr` ist nicht für den Argumententyp impliziert durch die Anweisungssuffix natürlich ausgerichtet.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `stind.i1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert einen Wert vom Typ <see langword="int16" /> an einer angegebenen Adresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|53|i2|Speichert ein `int16` Wert einer angegebenen Adresse.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Ein Wert wird auf dem Stapel abgelegt.  
  
3.  Der Wert und die Adresse werden vom Stapel geholt. der Wert wird an der Adresse gespeichert.  
  
 Die `stind.i2` -Anweisung speichert eine `int16` Wert an der angegebenen Adresse (Typ `native int`, `*`, oder `&`).  
  
 Typsichere Operation erfordert, dass die `stind.2i` Anweisung auf eine Weise konsistent mit dem Typ des Zeigers verwendet werden. Der Vorgang von der `stind.i2` Anweisung kann geändert werden, eine sofort abgrenzen, indem Sie <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> unmittelbar vorangestellt wird.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `addr` ist nicht für den Argumententyp impliziert durch die Anweisungssuffix natürlich ausgerichtet.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `stind.i2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert einen Wert vom Typ <see langword="int32" /> an einer angegebenen Adresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|54|i4|Speichert ein `int32` Wert einer angegebenen Adresse.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Ein Wert wird auf dem Stapel abgelegt.  
  
3.  Der Wert und die Adresse werden vom Stapel geholt. der Wert wird an der Adresse gespeichert.  
  
 Die `stind.i4` -Anweisung speichert eine `int32` Wert an der angegebenen Adresse (Typ `native int`, `*`, oder `&`).  
  
 Typsichere Operation erfordert, dass die `stind.i4` Anweisung auf eine Weise konsistent mit dem Typ des Zeigers verwendet werden. Der Vorgang von der `stind.i4` Anweisung kann geändert werden, eine sofort abgrenzen, indem Sie <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> unmittelbar vorangestellt wird.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `addr` ist nicht für den Argumententyp impliziert durch die Anweisungssuffix natürlich ausgerichtet.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `stind.i4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert einen Wert vom Typ <see langword="int64" /> an einer angegebenen Adresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|55|i8|Speichert ein `int64` Wert einer angegebenen Adresse.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Ein Wert wird auf dem Stapel abgelegt.  
  
3.  Der Wert und die Adresse werden vom Stapel geholt. der Wert wird an der Adresse gespeichert.  
  
 Die `stind.i8` -Anweisung speichert eine `int64` Wert an der angegebenen Adresse (Typ `native int`, `*`, oder `&`).  
  
 Typsichere Operation erfordert, dass die `stind.i8` Anweisung auf eine Weise konsistent mit dem Typ des Zeigers verwendet werden. Der Vorgang von der `stind.i` Anweisung kann geändert werden, eine sofort abgrenzen, indem Sie <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> unmittelbar vorangestellt wird.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `addr` ist nicht für den Argumententyp impliziert durch die Anweisungssuffix natürlich ausgerichtet.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `stind.i8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert einen Wert vom Typ <see langword="float32" /> an einer angegebenen Adresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|56|R4|Speichert einen `float32` Wert einer angegebenen Adresse.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Ein Wert wird auf dem Stapel abgelegt.  
  
3.  Der Wert und die Adresse werden vom Stapel geholt. der Wert wird an der Adresse gespeichert.  
  
 Die `stind.r4` -Anweisung speichert eine `float32` Wert an der angegebenen Adresse (Typ `native int`, `*`, oder `&`).  
  
 Typsichere Operation erfordert, dass die `stind.r4` Anweisung auf eine Weise konsistent mit dem Typ des Zeigers verwendet werden. Der Vorgang von der `stind.r4` Anweisung kann geändert werden, eine sofort abgrenzen, indem Sie <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> unmittelbar vorangestellt wird.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `addr` ist nicht für den Argumententyp impliziert durch die Anweisungssuffix natürlich ausgerichtet.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `stind.r4` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert einen Wert vom Typ <see langword="float64" /> an einer angegebenen Adresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|57|r8|Speichert einen `float64` Wert einer angegebenen Adresse.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Ein Wert wird auf dem Stapel abgelegt.  
  
3.  Der Wert und die Adresse werden vom Stapel geholt. der Wert wird an der Adresse gespeichert.  
  
 Die `stind.r8` -Anweisung speichert eine `float64` Wert an der angegebenen Adresse (Typ `native int`, `*`, oder `&`).  
  
 Typsichere Operation erfordert, dass die `stind.r8` Anweisung auf eine Weise konsistent mit dem Typ des Zeigers verwendet werden. Der Vorgang von der `stind.r8` Anweisung kann geändert werden, eine sofort abgrenzen, indem Sie <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> unmittelbar vorangestellt wird.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `addr` ist nicht für den Argumententyp impliziert durch die Anweisungssuffix natürlich ausgerichtet.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `stind.r8` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert einen Objektverweiswert an einer angegebenen Adresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|51|stind.ref|Speichert einen Objektverweiswert (Typ `O`) Wert einer angegebenen Adresse.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Ein Wert wird auf dem Stapel abgelegt.  
  
3.  Der Wert und die Adresse werden vom Stapel geholt. der Wert wird an der Adresse gespeichert.  
  
 Die `stind.ref` -Anweisung speichert einen Objektverweiswert an der angegebenen Adresse (Typ `native int`, `*`, oder `&`).  
  
 Typsichere Operation erfordert, dass die `stind.ref` Anweisung auf eine Weise konsistent mit dem Typ des Zeigers verwendet werden. Der Vorgang von der `stind.ref` Anweisung kann geändert werden, eine sofort abgrenzen, indem Sie <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> unmittelbar vorangestellt wird.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `addr` ist nicht für den Argumententyp impliziert durch die Anweisungssuffix natürlich ausgerichtet.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `stind.ref` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Holt den aktuellen Wert von der obersten Position des Auswertungsstapels und speichert ihn in der Liste der lokalen Variablen am angegebenen Index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 0E < `unsigned int16` >|stloc `index`|Holt einen Wert aus dem Stapel und speichert ihn in der lokalen Variable `index`.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Wert vom Stapel geholt und in der lokalen Variablen platziert `index`.  
  
 Die `stloc` Anweisung holt den obersten Wert vom Auswertungsstapel und verschiebt ihn in die lokale Variable Anzahl `index`, in der lokale Variablen Nummer 0 oder höher. Der Typ des Werts muss dem Typ der lokalen Variablen entsprechend den Angaben in der aktuellen Methode lokale Signatur entsprechen.  
  
 Der Wert Win32_PatchState "lokal", die einen ganzzahligen Wert, der kürzer als 4 Bytes lang verkürzt werden, während sie auf die lokale Variable aus dem Stapel verschoben. Gleitkommawerte werden von ihrer systemeigenen Größe gerundet (Typ `F`) auf die Größe, die das Argument zugeordnet.  
  
 Richtige Microsoft Intermediate Language (MSIL)-Anweisungen wird vorausgesetzt, die `index` ein gültiger lokaler Index sein. Für die `stloc` -Anweisung, `index` muss liegen zwischen 0 und 65534 an inklusiven (65535 ist kein gültiger Wert). Der Grund zum Ausschließen von 65535 ist pragmatisches: wahrscheinliche Implementierungen werden eine 2-Byte-Ganzzahl verwenden, um sowohl einen lokalen Index als auch die Gesamtzahl der "lokal" für eine bestimmte Methode nachzuverfolgen. Wenn ein Index von 65535 gültig vorgenommen wurden war, wäre eine umfassendere ganze Zahl zum Nachverfolgen der Anzahl von "lokal" in einer solchen Methode erforderlich.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> methodenüberladungen können die `stloc` Opcode:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Holt den aktuellen Wert von der obersten Position des Auswertungsstapels und speichert ihn in der Liste der lokalen Variablen am Index 0.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|0A|stloc.0|Ruft einen Wert aus dem Stapel in der lokalen Variablen 0.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Wert vom Stapel geholt und in der lokalen Variable mit dem Index 0 platziert.  
  
 Die `stloc.0` Anweisung holt den obersten Wert vom Auswertungsstapel und verschiebt ihn in die lokale Variable mit dem Index 0. Der Typ des Werts muss dem Typ der lokalen Variablen entsprechend den Angaben in der aktuellen Methode lokale Signatur entsprechen.  
  
 `stloc.0` ist eine besonders effiziente Codierung zum Speichern von Werten in der lokalen Variablen 0.  
  
 Der Wert Win32_PatchState "lokal", die einen ganzzahligen Wert, der kürzer als 4 Bytes lang verkürzt werden, während sie auf die lokale Variable aus dem Stapel verschoben. Gleitkommawerte werden von ihrer systemeigenen Größe gerundet (Typ `F`) auf die Größe, die das Argument zugeordnet.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `stloc.0` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Holt den aktuellen Wert von der obersten Position des Auswertungsstapels und speichert ihn in der Liste der lokalen Variablen am Index 1.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|0 B|stloc. 1|Ruft einen Wert aus dem Stapel in der lokalen Variablen 1 auf.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Wert vom Stapel geholt und in der lokalen Variable mit dem Index 1 platziert.  
  
 Die `stloc.1` Anweisung holt den obersten Wert vom Auswertungsstapel und verschiebt ihn in die lokale Variable mit dem Index 1. Der Typ des Werts muss dem Typ der lokalen Variablen entsprechend den Angaben in der aktuellen Methode lokale Signatur entsprechen.  
  
 `stloc.1` ist eine besonders effiziente Codierung zum Speichern von Werten in der lokalen Variable 1.  
  
 Der Wert Win32_PatchState "lokal", die einen ganzzahligen Wert, der kürzer als 4 Bytes lang verkürzt werden, während sie auf die lokale Variable aus dem Stapel verschoben. Gleitkommawerte werden von ihrer systemeigenen Größe gerundet (Typ `F`) auf die Größe, die das Argument zugeordnet.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `stloc.1` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Holt den aktuellen Wert von der obersten Position des Auswertungsstapels und speichert ihn in der Liste der lokalen Variablen am Index 2.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|0C|stloc. 2|Holt einen Wert aus dem Stapel in der lokalen Variablen 2|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Wert vom Stapel geholt und in der lokalen Variable mit dem Index 2 platziert.  
  
 Die `stloc.2` Anweisung holt den obersten Wert vom Auswertungsstapel und verschiebt ihn in die lokale Variable mit dem Index 2. Der Typ des Werts muss dem Typ der lokalen Variablen entsprechend den Angaben in der aktuellen Methode lokale Signatur entsprechen.  
  
 `stloc.2` ist eine besonders effiziente Codierung zum Speichern von Werten in der lokalen Variable 2.  
  
 Der Wert Win32_PatchState "lokal", die einen ganzzahligen Wert, der kürzer als 4 Bytes lang verkürzt werden, während sie auf die lokale Variable aus dem Stapel verschoben. Gleitkommawerte werden von ihrer systemeigenen Größe gerundet (Typ `F`) auf die Größe, die das Argument zugeordnet.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `stloc.2` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Holt den aktuellen Wert von der obersten Position des Auswertungsstapels und speichert ihn in der Liste der lokalen Variablen am Index 3.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|0D|stloc. 3|Holt einen Wert aus dem Stapel in der lokalen Variablen 3|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Wert vom Stapel geholt und in der lokalen Variablen durch 3 indiziert platziert.  
  
 Die `stloc.3` Anweisung holt den obersten Wert vom Auswertungsstapel und verschiebt ihn in die lokale Variable mit dem Index 3. Der Typ des Werts muss dem Typ der lokalen Variablen entsprechend den Angaben in der aktuellen Methode lokale Signatur entsprechen.  
  
 `stloc.3` ist eine besonders effiziente Codierung zum Speichern von Werten in der lokalen Variable 3.  
  
 Der Wert Win32_PatchState "lokal", die einen ganzzahligen Wert, der kürzer als 4 Bytes lang verkürzt werden, während sie auf die lokale Variable aus dem Stapel verschoben. Gleitkommawerte werden von ihrer systemeigenen Größe gerundet (Typ `F`) auf die Größe, die das Argument zugeordnet.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `stloc.3` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Holt den aktuellen Wert von der obersten Position des Auswertungsstapels und speichert ihn in der Liste der lokalen Variablen am <paramref name="index" /> (Kurzform).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|13 < `unsigned int8` >|stloc.s `index`|Holt einen Wert aus dem Stapel und speichert ihn in der lokalen Variable `index`, Kurzform.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Wert vom Stapel geholt und in der lokalen Variablen platziert `index`.  
  
 Die `stloc.s` Anweisung holt den obersten Wert vom Auswertungsstapel und verschiebt ihn in die lokale Variable Anzahl `index`, in der lokale Variablen Nummer 0 oder höher. Der Typ des Werts muss dem Typ der lokalen Variablen entsprechend den Angaben in der aktuellen Methode lokale Signatur entsprechen.  
  
 Die `stloc.s` -Anweisung bietet eine effiziente Codierung, die mit den lokalen Variablen von 0 bis 255.  
  
 Der Wert Win32_PatchState "lokal", die einen ganzzahligen Wert, der kürzer als 4 Bytes lang verkürzt werden, während sie auf die lokale Variable aus dem Stapel verschoben. Gleitkommawerte werden von ihrer systemeigenen Größe gerundet (Typ `F`) auf die Größe, die das Argument zugeordnet.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> methodenüberladungen können die `stloc.s` Opcode:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopiert einen Wert mit dem angegebenen Typ vom Auswertungsstapel in die angegebene Speicheradresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|81 < `T` >|stobj `class`|Speichert einen Wert vom Typ `class` aus dem Stapel in den Arbeitsspeicher.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
2.  Ein Werttypobjekt vom Typ `class` ist auf dem Stapel abgelegt.  
  
3.  Das Objekt und die Adresse werden vom Stapel geholt. das Wertobjekt für den Typ wird bei der Adresse gespeichert.  
  
 Die `stobj` -Anweisung kopiert das Werttypobjekt in die Adresse, angegeben durch die Adresse (ein Zeiger des Typs `native int`, `*`, oder `&`). Die Anzahl der kopierten Bytes hängt von der Größe der dargestellte Klasse `class`, ein Metadatentoken, das einen Werttyp darstellt.  
  
 Der Vorgang von der `stobj` Anweisung kann geändert werden, eine sofort abgrenzen, indem Sie <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> unmittelbar vorangestellt wird.  
  
 <xref:System.TypeLoadException> wird ausgelöst, wenn die Klasse nicht gefunden werden kann. Dies ist i. d. r. erkannt, wenn Microsoft Intermediate Language (MSIL)-Anweisungen in systemeigenen Code anstatt zur Laufzeit konvertiert werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `stobj` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt den Wert eines statischen Felds durch einen Wert vom Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|80 < `T` >|stsfld `field`|Ersetzt den Wert in `field` mit einem angegebenen Wert.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Wert wird auf dem Stapel abgelegt.  
  
2.  Ein Wert vom Stapel geholt und in gespeicherten `field`.  
  
 Die `stsfld` Anweisung ersetzt den Wert eines statischen Felds durch einen Wert aus dem Stapel. `field` ist ein Metadatentoken, die auf einen statischen Feldmember verweisen muss.  
  
 Die `stsfld` -Anweisung vorangestellt werden möglicherweise <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.MissingFieldException> wird ausgelöst, wenn in den Metadaten nicht gefunden wird. Dies wird in der Regel überprüft, wenn Microsoft Intermediate Language (MSIL)-Anweisungen nicht zur Laufzeit in systemeigenen Code konvertiert werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `stsfld` Opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Subtrahiert einen Wert von einem anderen Wert und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|59|sub|Subtrahiert einen Wert aus einer anderen, einen neuen numerischen Wert zurückgeben.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` sind per pop ausgelesen, aus dem Stapel; `value2` abgezogen `value1`.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 Überlauf für Ganzzahloperationen nicht erkannt wird (ordnungsgemäße überlaufbearbeitung, finden Sie unter <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).  
  
 Ganzzahlige Subtraktion, anstatt das Sättigungsverfahren. Zum Beispiel: 8-Bit-Ganzzahlen, vorausgesetzt, in dem `value1` auf 0 festgelegt ist und `value2` festgelegt ist auf 1, wird das Ergebnis "umschlossene" 255 werden.  
  
 Gleitkommaüberlauf gibt `+inf` (`PositiveInfinity`) oder `-inf` (`NegativeInfinity`).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `sub` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Subtrahiert einen Ganzzahlwert von einem anderen Ganzzahlwert, führt eine Überlaufprüfung durch und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|DA|Sub.ovf|Subtrahiert einen Ganzzahlwert von einem anderen mit eine überlaufprüfung an.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` sind per pop ausgelesen, aus dem Stapel; `value2` abgezogen `value1` mit einem Häkchen auf Überläufe.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Dieser Vorgang wird für Ganzzahlen mit Vorzeichen ausgeführt; Verwenden Sie für Gleitkommawerte, <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `sub.ovf` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Subtrahiert einen Ganzzahlwert ohne Vorzeichen von einem anderen Ganzzahlwert, führt eine Überlaufprüfung durch und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|DB|Sub.ovf.un|Subtrahiert einen Ganzzahlwert ohne Vorzeichen in einen anderen eine überlaufprüfung an.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` sind per pop ausgelesen, aus dem Stapel; `value2` abgezogen `value1` mit einem Häkchen auf Überläufe.  
  
4.  Das Ergebnis wird auf dem Stapel abgelegt.  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Dieser Vorgang wird für Ganzzahlen mit Vorzeichen ausgeführt; Verwenden Sie für Gleitkommawerte, <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `sub.ovf.un` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Implementiert eine Sprungtabelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|45 < `unsigned int32` >< `int32` >... < `int32` >|Wechseln (`N`, `t1`, `t2`... `tN`)|Wechselt zur eines `N` Werte.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Wert wird auf dem Stapel abgelegt.  
  
2.  Der Wert wird vom Stapel geholt und für die Anweisung durch den Wert indizierten Offset Ausführung übertragen wird, wobei der Wert ist kleiner als `N`.  
  
 Die `switch` Anweisung implementiert eine Sprungtabelle. Das Format der Anweisung ist ein `unsigned int32` , der die Anzahl von Zielen `N`, gefolgt von `N` int32-Werte, die angeben, springen Ziele. Diese Ziele werden als (positive oder negative) Offsets vom Anfang der folgenden Anweisung dies dargestellt `switch` Anweisung.  
  
 Die `switch` Anweisung holt einen Wert vom Stapel und vergleicht ihn als ganze Zahl ohne Vorzeichen zu `N`. Wenn der Wert ist kleiner als `N`, Ausführung an das Ziel, die indiziert anhand des Werts übertragen wird, in denen Ziele von 0 nummeriert (z. B. ein Wert von 0 nimmt das erste Ziel, ein Wert von 1 hat, das zweite Ziel usw.). Wenn der Wert größer als oder gleich `N`, die Ausführung wird fortgeführt, bei der nächsten Anweisung (fortfahren).  
  
 Wenn bei der zielinstruktion mindestens ein Präfix Codes verfügt, Steuerelement kann nur übertragen werden mit dem ersten dieser Präfixe.  
  
 Steuern von Übertragungen in und aus `try`, `catch`, `filter`, und `finally` Blöcke können durch diese Anweisung nicht ausgeführt werden. (Solche Übertragungen werden stark eingeschränkt und müssen stattdessen die Anweisung Leave verwenden).  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `switch` Opcode. Die `Label[]` Argument ist ein Array von Bezeichnungen, die 32-Bit-Offsets darstellen.  
  
-   ILGenerator.Emit (OpCode, Label[])  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der `Switch` Opcodes zum Generieren einer Sprungtabelle mithilfe eines Arrays von <xref:System.Reflection.Emit.Label>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Führt eine Postfix-Methodenaufrufanweisung in der Weise aus, dass der Stapelrahmen der aktuellen Methode vor der Ausführung der eigentlichen Aufrufanweisung entfernt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 14|Tail.|Nachfolgende Aufruf beendet die aktuelle Methoden|  
  
 Es gibt keine Zustandswechsel für diese Anweisung definiert.  
  
 Die `tail` Präfix-Anweisung muss unmittelbar voranstehen eine <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, oder <xref:System.Reflection.Emit.OpCodes.Callvirt> Anweisung. Er gibt an, dass die aktuelle Methode Stapelrahmen entfernt werden soll, bevor die Call-Anweisung ausgeführt wird. Es bedeutet auch, dass aus den folgenden Aufruf zurückgegebene Wert auch der Wert, der von der aktuellen Methode zurückgegeben ist, und der Aufruf daher in einen Sprung Cross-Methode konvertiert werden kann.  
  
 Der Stapel darf außer den Argumenten, die durch den folgenden Aufruf übertragenen leer sein. Die Call-Anweisung folgenden muss Ret sein. Der einzige gültige Codesequenz also `tail. call` (oder `calli` oder `callvirt`). Richtige Microsoft Intermediate Language (MSIL)-Anweisungen müssen nicht zur Verzweigen der `call` -Anweisung, doch diese Verzweigung zur nachfolgenden <xref:System.Reflection.Emit.OpCodes.Ret>.  
  
 Der aktuelle Frame kann nicht verworfen werden, wenn die Steuerung wird vor nicht vertrauenswürdigem Code vertrauenswürdigem Code, da dies Code Identität Sicherheit gefährden würde. Die .NET Framework-Sicherheit wird überprüft, kann daher dazu führen, dass die `tail` ignoriert werden soll, einen Standard verlassen <xref:System.Reflection.Emit.OpCodes.Call> Anweisung. Auf ähnliche Weise, in Reihenfolge ermöglichen das Beenden eines synchronisierten Bereichs auftritt, nachdem der Aufruf zurückgegeben, die `tail` Präfix wird ignoriert, wenn verwendet, um eine Methode zu beenden, der als synchronisiert gekennzeichnet ist.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `tail` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">Eine Instanz eines eines Opcodeobjekts.</param>
        <summary>Gibt TRUE oder FALSE zurück, wenn der bereitgestellte Opcode ein Einzelbyte-Argument akzeptiert.</summary>
        <returns>
          <see langword="True" /> oder <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um zu ermitteln, welche MSIL-Opcodes "Kurzform", für die Verwendung in optimiertem Code.  
  
 `TakesSingleByteArgument` Gibt `true` Wenn die <xref:System.Reflection.Emit.OpCode> Instanz akzeptiert ein Einzelbyte-Argument in den folgenden Fällen:  
  
-   Der Opcode führt eine verzweigungsanweisung an eine Adresse Byte-Größe (z. B. <xref:System.Reflection.Emit.OpCodes.Br_S> und <xref:System.Reflection.Emit.OpCodes.Bgt_S>).  
  
-   Der Opcode legt einen Bytewert im Stapel (z. B. <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).  
  
-   Der Opcode verweist auf eine Variable oder ein Argument über die "Kurzform" (z. B. <xref:System.Reflection.Emit.OpCodes.Ldloc_S> und <xref:System.Reflection.Emit.OpCodes.Stloc_S>).  
  
 Andernfalls wird `false` zurückgegeben.  
  
 Das folgende Beispiel veranschaulicht die Verwendung von `TakesSingleByteArgument` durch Reflektion auf die `OpCodes` Klasse und testen, um festzustellen, ob jede `OpCode` Feld übernimmt ein Einzelbyte-Argument.  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Löst das Ausnahmeobjekt aus, das sich momentan auf dem Auswertungsstapel befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|7A|throw|Löst eine Ausnahme aus.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis (auf einer Ausnahme) wird auf dem Stapel abgelegt.  
  
2.  Der Objektverweis wird vom die Ausnahme ausgelöst und im Stapel geholt.  
  
 Die `throw` -Anweisung löst das Ausnahmeobjekt aus (Typ `O`) derzeit auf dem Stapel.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn der Objektverweis null-Verweis ist.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `throw` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass eine Adresse, die sich momentan oben auf dem Stapel befindet, möglicherweise nicht an der eigentlichen Größe der unmittelbar darauf folgenden <see langword="ldind" />-Anweisung, <see langword="stind" />-Anweisung, <see langword="ldfld" />-Anweisung, <see langword="stfld" />-Anweisung, <see langword="ldobj" />-Anweisung, <see langword="stobj" />-Anweisung, <see langword="initblk" />-Anweisung oder <see langword="cpblk" />-Anweisung ausgerichtet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 12 < `unsigned int8` >|nicht ausgerichtete. `alignment`|Gibt an, dass die Zeiger-Anweisung nicht ausgerichteten werden kann.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
 `Unaligned` Gibt an, dass die Adresse (ein nicht verwalteter Zeiger `native int`) auf dem Stapel möglicherweise nicht ausgerichtet sein, die Größe des unmittelbar darauf folgenden `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, oder `cpblk` Anweisung. D. h. für eine <xref:System.Reflection.Emit.OpCodes.Ldind_I4> Anweisung, die die Ausrichtung der Adresse darf nicht mit einer 4-Byte-Grenze sein. Für `initblk` und `cpblk` die standardmäßige Ausrichtung ist abhängige-Architektur (4-Byte für 32-Bit-CPUs, 8 Bytes auf 64-Bit-CPUs). Code-Generatoren, die ihre Ausgabe nicht auf eine Größe von 32-Bit-Wort beschränken müssen verwenden `unaligned` , wenn die Ausrichtung zum Zeitpunkt der Kompilierung nicht bekannt ist, um 8 Bytes sein.  
  
 Der Wert der Ausrichtung muss 1, 2 oder 4 und bedeutet, die der generierte Code, dass die Adresse Byte, Doppelbyte- oder Quad-Byte-, bzw. ausgerichtet annehmen soll. Beachten Sie, dass flüchtige Zeiger (Typ `*`) immer ausgerichtet sind.  
  
 Während die Ausrichtung für eine `cpblk` Anweisung müsste logisch zwei Zahlen (eine für die Quelle) und eine für das Ziel, die ohne merkliche Auswirkungen auf die Leistung vorhanden ist, wenn nur die niedrigere Zahl angegeben wird.  
  
 Die `unaligned` und `volatile` Präfixe können in beliebiger Reihenfolge kombiniert werden. Sie müssen unmittelbar voranstehen eine `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, oder `cpblk` Anweisung. Nur die <xref:System.Reflection.Emit.OpCodes.Volatile> Präfix ist zulässig, für die <xref:System.Reflection.Emit.OpCodes.Ldsfld> und <xref:System.Reflection.Emit.OpCodes.Stsfld> Anweisungen.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> methodenüberladungen können die `unaligned` Opcode:  
  
-   ILGenerator.Emit(OpCode, Label)  
  
-   ILGenerator.Emit(Opcode, Byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert die Darstellung eines mittels Boxing gepackten Werttyps in seine mittels Unboxing entpackte Entsprechung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|79 < `T` >|Unboxing `valType`|Extrahiert die Daten der Wert vom Typ von `obj`, dessen Darstellung geschachtelt.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis ist auf dem Stapel abgelegt.  
  
2.  Der Objektverweis wird vom Stapel geholt und mittels Unboxing zurückkonvertiert, um einen Werttypzeiger.  
  
3.  Zeiger vom Typ "Wert" wird auf dem Stapel abgelegt.  
  
 Ein Werttyp verfügt über zwei separate Darstellungen innerhalb der Common Language Infrastructure (CLI):  
  
-   Eine "rohen" Form verwendet, wenn ein Werttyp innerhalb eines anderen Objekts eingebettet ist.  
  
-   Eine "geschachtelte" Form, in dem die Daten in den Werttyp in ein Objekt umschlossen (geschachtelt) ist, damit es als unabhängige Entität vorhanden ist.  
  
 Die `unbox` Anweisung konvertiert den Objektverweis (Typ `O`), wird die Darstellung eines Werttyps an einen Werttypzeiger geschachtelt (ein verwalteter Zeiger vom Typ `&`), dessen mittels Unboxing zurückkonvertiert Formular. Der angegebene Werttyp (`valType`) ist ein Metadatentoken, das den Typ eines Werttyps innerhalb des geschachtelten Objekts angibt.  
  
 Im Gegensatz zu <xref:System.Reflection.Emit.OpCodes.Box>, das ist erforderlich, um eine Kopie eines Werttyps für die Verwendung in dem Objekt `unbox` ist nicht erforderlich, kopieren Sie den Werttyp aus dem Objekt. In der Regel berechnet es einfach die Adresse des Werttyps, der bereits innerhalb des geschachtelten Objekts vorhanden ist.  
  
 <xref:System.InvalidCastException> wird ausgelöst, wenn das Objekt nicht als geschachtelt ist `valType`.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn der Objektverweis null-Verweis ist.  
  
 <xref:System.TypeLoadException> wird ausgelöst, wenn der Werttyp `valType` kann nicht gefunden werden. Dies wird in der Regel erkannt, wenn Microsoft Intermediate Language (MSIL)-Anweisungen in systemeigenen Code anstatt zur Laufzeit konvertiert werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `unbox` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert die geschachtelte Darstellung eines n der Anweisung angegebenen Typs in seine nicht geschachtelte Form.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Microsoft intermediate Language (MSIL) Assemblyformat sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|A5 < `T` >|unbox.Any `typeTok`|Extrahieren Sie die Daten aus `obj`, dessen Darstellung geschachtelt.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Ein Objektverweis `obj` auf dem Stapel abgelegt wird.  
  
2.  Der Objektverweis wird vom Stapel geholt und in den angegebenen Typ in der Anweisung nicht geschachtelt.  
  
3.  Der resultierende Verweis- oder Werttyp Objekttyp wird auf dem Stapel abgelegt.  
  
 Bei Anwendung auf die geschachtelte Form eines Werttyps, der `unbox.any` Anweisung extrahiert den Wert, der in enthaltenen `obj` (des Typs `O`), und ist daher äquivalent zu `unbox` gefolgt von `ldobj`.  
  
 Bei Anwendung auf einen Referenztyp darstellt, die `unbox.any` Anweisung hat dieselbe Wirkung wie das `castclass` `typeTok`.  
  
 Wenn der Operand `typeTok` ein generischer Typparameter ist, und klicken Sie dann das Laufzeitverhalten vom Typ bestimmt wird, die für den generischen Typparameter angegeben wird.  
  
 <xref:System.InvalidCastException> wird ausgelöst, wenn `obj` ist kein geschachtelter Typ.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `obj` ist ein null-Verweis.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `unbox.any` Opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass es sich bei einer Adresse, die sich momentan oben auf dem Auswertungsstapel befindet, möglicherweise um eine flüchtige Adresse handelt und daher die aus diesem Speicherort gelesenen Ergebnisse nicht zwischengespeichert werden können oder mehrere für diesen Speicherort ausgeführte Speichervorgänge nicht unterdrückt werden können.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|FE 13|flüchtige.|Gibt an, dass der Zeigerverweis flüchtig ist.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  Eine Adresse wird auf dem Stapel abgelegt.  
  
 `volatile` Gibt an, dass die Adresse eine flüchtige Adresse handelt (d. h., es kann von außen für den aktuellen Thread der Ausführung verwiesen werden) und die Ergebnisse nicht zwischengespeichert werden können oder mehrere Geschäfte an diesen Speicherort nicht unterdrückt werden können. Markieren eines Zugriffs als `volatile` beeinflusst nur das einzelne Zugriff; andere Zugriffe auf den gleichen Speicherort müssen separat markiert werden. Zugriff auf flüchtige Speicherorte muss nicht atomar ausgeführt werden.  
  
 Die <xref:System.Reflection.Emit.OpCodes.Unaligned> und `volatile` Präfixe können in beliebiger Reihenfolge kombiniert werden. Sie müssen unmittelbar voranstehen eine `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, oder `cpblk` Anweisung. Nur die `volatile` Präfix ist zulässig, für die <xref:System.Reflection.Emit.OpCodes.Ldsfld> und <xref:System.Reflection.Emit.OpCodes.Stsfld> Anweisungen.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `volatile` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Berechnet das bitweise XOR der beidem auf dem Stapel an oberster Position befindlichen Werte und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Anweisung Hexadezimal und Assemblyformat von Microsoft Intermediate Language (MSIL) sowie eine kurze Referenz Zusammenfassung:  
  
|Format|Assemblyformat|Beschreibung |  
|------------|---------------------|-----------------|  
|61|xor|Berechnet das bitweise XOR mit zwei ganzzahligen Werten aus, und gibt eine ganze Zahl zurück.|  
  
 Im Stapel laufen, wird in sequenzieller Reihenfolge auf:  
  
1.  `value1` wird auf dem Stapel abgelegt.  
  
2.  `value2` wird auf dem Stapel abgelegt.  
  
3.  `value2` und `value1` sind per pop ausgelesen, aus dem Stapel und deren bitweise XOR berechnet.  
  
4.  Der bitweise XOR der `value2` und `value1` auf dem Stapel abgelegt wird.  
  
 Die `xor` -Anweisung berechnet das bitweise XOR für die oberen beiden Werte im Stapel, und das Ergebnis auf dem Stapel verbleibt.  
  
 `Xor` ist ein Integer-spezifische-Vorgang.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> -methodenüberladung können die `xor` Opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>