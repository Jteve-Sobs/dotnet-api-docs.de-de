<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4b7f4e71cf18c74551468efdfe7e06391da1bc4c" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86808932" /></Metadata><TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Reflection.Primitives" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Reflection.Primitives" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt Felddarstellungen der MSIL (Microsoft Intermediate Language)-Anweisungen für die Ausgabe durch die <see cref="T:System.Reflection.Emit.ILGenerator" />-Klassenmember bereit, beispielsweise <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine ausführliche Beschreibung der Member-Opcodes finden Sie in der Common Language Infrastructure (CLI)-Dokumentation, insbesondere "Partition III: CIL Instruction Set" und "Partition II: Metadata Definition and Semantics". Die Dokumentation ist online verfügbar. Sie finden sie unter [ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)](https://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))](https://go.microsoft.com/fwlink/?LinkID=65552) auf der Ecma International-Website.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Erstellung einer dynamischen Methode veranschaulicht, mit der <xref:System.Reflection.Emit.ILGenerator> in eine ausgegeben wird `OpCodes` <xref:System.Reflection.Emit.MethodBuilder> .  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Addiert zwei Werte und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|58|add|Fügt zwei numerische Werte hinzu und gibt einen neuen numerischen Wert zurück.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt; `value1` wird zu hinzugefügt `value2` .  
  
4.  Das Ergebnis wird auf den Stapel verschoben.  
  
 Ein Überlauf für ganzzahlige Vorgänge wird nicht erkannt (für eine ordnungsgemäße Überlauf Behandlung finden Sie unter <xref:System.Reflection.Emit.OpCodes.Add_Ovf> ).  
  
 Ganzzahlige Addition umbrochen und nicht als ganze Zahl. Bei 8-Bit-Ganzzahlen, bei denen `value1` auf 255 und auf 1 festgelegt ist `value2` , ist das umschließende Ergebnis z. b. 0 (null) und nicht 256.  
  
 Gleit Komma Überlauf gibt `+inf` ( `PositiveInfinity` ) oder `-inf` () zurück `NegativeInfinity` .  
  
 Die zulässigen Operanden Typen und deren zugehöriger Ergebnis Datentyp sind in der folgenden Tabelle aufgeführt. Wenn kein Eintrag für eine bestimmte Typkombination (z `int32` . b. und, `float` und) vorhanden ist `int32` `int64` , handelt es sich um eine ungültige MSIL (Microsoft Intermediate Language) und generiert einen Fehler.  
  
|Operand|value1-Typ|Value2-Typ|Ergebnistyp|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `add` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Addiert zwei ganze Zahlen, führt eine Überlaufprüfung durch und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|D6|OVF hinzufügen|Fügt mit einer Überlauf Überprüfung zwei ganzzahlige Werte mit Vorzeichen hinzu.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt `value1` `value2` . wird mit einer Überprüfung auf einen Überlauf hinzugefügt.  
  
4.  Das Ergebnis wird auf den Stapel verschoben.  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt wird.  
  
 Sie können diesen Vorgang für ganze Zahlen mit Vorzeichen ausführen. Verwenden Sie für Gleit Komma Werte <xref:System.Reflection.Emit.OpCodes.Add> .  
  
 Die zulässigen Operanden Typen und deren zugehöriger Ergebnis Datentyp sind in der folgenden Tabelle aufgeführt. Wenn kein Eintrag für eine bestimmte Typkombination (z `int32` . b. und, `float` und) vorhanden ist `int32` `int64` , handelt es sich um eine ungültige MSIL-Anweisung (Microsoft Intermediate Language), die einen Fehler generiert.  
  
|Operand|value1-Typ|Value2-Typ|Ergebnistyp|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `add.ovf` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Addiert zwei Ganzzahlwerte ohne Vorzeichen, führt eine Überlaufprüfung durch und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|Handelte|Add. ovf. UN|Fügt zwei ganzzahlige Werte ohne Vorzeichen mit einer Überlauf Überprüfung hinzu.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt `value1` `value2` . wird mit einer Überprüfung auf einen Überlauf hinzugefügt.  
  
4.  Das Ergebnis wird auf den Stapel verschoben.  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt wird.  
  
 Sie können diesen Vorgang für ganze Zahlen mit Vorzeichen ausführen. Verwenden Sie für Gleit Komma Werte <xref:System.Reflection.Emit.OpCodes.Add> .  
  
 Die zulässigen Operanden Typen und deren zugehöriger Ergebnis Datentyp sind in der folgenden Tabelle aufgeführt. Wenn kein Eintrag für eine bestimmte Typkombination (z `int32` . b. und, `float` und) vorhanden ist `int32` `int64` , handelt es sich um eine ungültige MSIL-Anweisung (Microsoft Intermediate Language), die einen Fehler generiert.  
  
|Operand|value1-Typ|Value2-Typ|Ergebnistyp|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `add.ovf.un` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Berechnet das bitweise AND für zwei Werte und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|Anweisung|BESCHREIBUNG|  
|------------|-----------------|-----------------|  
|5F|and|Bestimmt das bitweise and von zwei ganzzahligen Werten.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value1` und `value2` werden aus dem Stapel entfernt; das bitweise and der beiden Werte wird berechnet.  
  
4.  Das Ergebnis wird auf den Stapel verschoben.  
  
 Die `and` -Anweisung berechnet das bitweise and der obersten beiden Werte im Stapel und verlässt das Ergebnis auf dem Stapel.  
  
 `And` ist ein ganzzahliger spezifischer Vorgang.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `and` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt einen nicht verwalteten Zeiger auf die Argumentliste der aktuellen Methode zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|FE 00|Arglist|Gibt ein Argumentlisten Handle für die aktuelle Methode zurück.|  
  
 Von diesem Vorgang werden keine Bewertungs Stapel Verhalten ausgeführt.  
  
 Die- `arglist` Anweisung gibt ein undurchsichtiges handle (ein nicht verwalteter Zeiger vom Typ `native int` ) zurück, der die Argumentliste der aktuellen Methode darstellt. Dieses Handle ist nur während der Lebensdauer der aktuellen Methode gültig. Sie können das Handle jedoch an andere Methoden übergeben, solange sich die aktuelle Methode im Steuerungs Thread befindet. Sie können die Anweisung nur `arglist` innerhalb einer Methode ausführen, die eine Variable Anzahl von Argumenten annimmt.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `arglist` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn zwei Werte übereinstimmen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|3B-< `int32` >|beq `target`|Verzweigt die Ziel Anweisung bei Offset, `target` Wenn die beiden Werte gleich sind.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt `value1` . wenn gleich ist `value2` , wird der Verzweigungs Vorgang ausgeführt.  
  
 Die- `beq` Anweisung überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value1` gleich ist `value2` . Der Effekt ist derselbe wie das Ausführen einer `ceq` Anweisung, gefolgt von einer `brtrue` Verzweigung zur spezifischen Ziel Anweisung. Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.  
  
 Die zulässigen Operanden Typen werden im folgenden dargestellt:  
  
 Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.  
  
 Steuerelement Übertragungen in und aus- `try` , `catch` -, `filter` -und- `finally` Blöcken können nicht von dieser Anweisung ausgeführt werden (solche Übertragungen sind stark eingeschränkt und müssen stattdessen die- <xref:System.Reflection.Emit.OpCodes.Leave> Anweisung verwenden).  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `beq` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn zwei Werte übereinstimmen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|2E-< `int8` >|beq. s `target`|Verzweigung zur Ziel Anweisung bei Offset `target` , wenn gleich, Kurzform|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt `value1` . wenn gleich ist `value2` , wird der Verzweigungs Vorgang ausgeführt.  
  
 Die- `beq.s` Anweisung überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value1` gleich ist `value2` . Der Effekt ist derselbe wie das Ausführen einer `ceq` Anweisung, gefolgt von einer `brtrue` Verzweigung zur spezifischen Ziel Anweisung. Die Ziel Anweisung wird als 1-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.  
  
 Die zulässigen Operanden Typen werden im folgenden dargestellt:  
  
 Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.  
  
 Steuerelement Übertragungen in und aus- `try` , `catch` -, `filter` -und- `finally` Blöcken können nicht von dieser Anweisung ausgeführt werden (solche Übertragungen sind stark eingeschränkt und müssen stattdessen die- <xref:System.Reflection.Emit.OpCodes.Leave> Anweisung verwenden).  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `beq.s` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn der erste Wert größer oder gleich dem zweiten Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|3C `<int32>`|BGE `target`|Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert größer oder gleich dem zweiten Wert ist.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt `value1` . wenn größer als oder gleich ist `value2` , wird der Verzweigungs Vorgang ausgeführt.  
  
 Die- `bge` Anweisung überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value1` größer als oder gleich ist `value2` . Der Effekt ist identisch mit dem Ausführen einer- `clt` Anweisung (für Gleit Komma Zahlen `clt.un` ), gefolgt von einer `brfalse` Verzweigung zur spezifischen Ziel Anweisung. Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.  
  
 Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden. Steuerelement Übertragungen in und aus- `try` , `catch` -, `filter` -und- `finally` Blöcken können von dieser Anweisung nicht ausgeführt werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `bge` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn der erste Wert größer oder gleich dem zweiten Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|2F `<int8>`|BGE. s `target`|Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert größer oder gleich dem zweiten Wert (Kurzform) ist.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt `value1` . wenn größer als oder gleich ist `value2` , wird der Verzweigungs Vorgang ausgeführt.  
  
 Die- `bge.s` Anweisung überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value1` größer als oder gleich ist `value2` . Der Effekt ist identisch mit dem Ausführen einer- `clt` Anweisung (für Gleit Komma Zahlen `clt.un` ), gefolgt von einer `brfalse` Verzweigung zur spezifischen Ziel Anweisung. Die Ziel Anweisung wird als 1-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.  
  
 Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden. Steuerelement Übertragungen in und aus- `try` , `catch` -, `filter` -und- `finally` Blöcken können von dieser Anweisung nicht ausgeführt werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `bge.s` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert größer als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|41 `<int32>`|BGE. UN `target`|Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert größer oder gleich dem zweiten Wert (ohne Vorzeichen) ist.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt `value1` . wenn größer als oder gleich ist `value2` , wird der Verzweigungs Vorgang ausgeführt.  
  
 Mit der- `bge.un` Anweisung wird die Steuerung an die angegebene Ziel Anweisung übertragen `value1` , wenn größer oder gleich ist `value2` , wenn Sie mit einer Ganzzahl ohne Vorzeichen oder ungeordnete Gleit Komma Werte verglichen werden. Der Effekt ist identisch mit dem Ausführen einer- `clt.un` Anweisung (für Gleit Komma Zahlen `clt` ), gefolgt von einer `brfalse` Verzweigung zur spezifischen Ziel Anweisung. Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.  
  
 Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden. Steuerelement Übertragungen in und aus- `try` , `catch` -, `filter` -und- `finally` Blöcken können von dieser Anweisung nicht ausgeführt werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `bge.un` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert größer als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|34 < `int8` >|BGE. un. s `target`|Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert größer oder gleich dem zweiten Wert (ohne Vorzeichen), Kurzform ist.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt `value1` . wenn größer als oder gleich ist `value2` , wird der Verzweigungs Vorgang ausgeführt.  
  
 Mit der- `bge.un.s` Anweisung wird die Steuerung an die angegebene Ziel Anweisung übertragen `value1` , wenn größer oder gleich ist `value2` , wenn Sie mit einer Ganzzahl ohne Vorzeichen oder ungeordnete Gleit Komma Werte verglichen werden. Der Effekt ist identisch mit dem Ausführen einer- `clt.un` Anweisung (für Gleit Komma Zahlen `clt` ), gefolgt von einer `brfalse` Verzweigung zur spezifischen Ziel Anweisung. Die Ziel Anweisung wird als 1-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.  
  
 Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden. Steuerelement Übertragungen in und aus- `try` , `catch` -, `filter` -und- `finally` Blöcken können von dieser Anweisung nicht ausgeführt werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `bge.un.s` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn der erste Wert größer als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|3D-< `int32` >|BGT `target`|Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert größer als der zweite Wert ist.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt `value1` . wenn größer als ist `value2` , wird der Verzweigungs Vorgang ausgeführt.  
  
 Die- `bgt` Anweisung überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value1` größer als ist `value2` . Der Effekt ist identisch mit der Ausführung einer- `cgt` Anweisung, gefolgt von einer `brtrue` Verzweigung zur bestimmten Ziel Anweisung. Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.  
  
 Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden. Steuerelement Übertragungen in und aus- `try` , `catch` -, `filter` -und- `finally` Blöcken können von dieser Anweisung nicht ausgeführt werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `bgt` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn der erste Wert größer als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|30 < `int8` >|BGT. s `target`|Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert größer als der zweite Wert (Kurzform) ist.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt `value1` . wenn größer als ist `value2` , wird der Verzweigungs Vorgang ausgeführt.  
  
 Die- `bgt.s` Anweisung überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value1` größer als ist `value2` . Der Effekt ist identisch mit der Ausführung einer- `cgt` Anweisung, gefolgt von einer `brtrue` Verzweigung zur bestimmten Ziel Anweisung. Die Ziel Anweisung wird als 1-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.  
  
 Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden. Steuerelement Übertragungen in und aus- `try` , `catch` -, `filter` -und- `finally` Blöcken können von dieser Anweisung nicht ausgeführt werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `bgt.s` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert größer als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|42 < `int32` >|BGT. UN `target`|Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert größer als der zweite Wert (ohne Vorzeichen) ist.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt `value1` . wenn größer als ist `value2` , wird der Verzweigungs Vorgang ausgeführt.  
  
 Mit der- `bgt.un` Anweisung wird die Steuerung an die angegebene Ziel Anweisung übertragen `value1` , wenn größer als ist `value2` , wenn eine ganze Zahl ohne Vorzeichen oder ungeordnete Gleit Komma Werte verglichen werden. Der Effekt ist identisch mit der Ausführung einer- `cgt.un` Anweisung, gefolgt von einer `brtrue` Verzweigung zur bestimmten Ziel Anweisung. Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.  
  
 Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden. Steuerelement Übertragungen in und aus- `try` , `catch` -, `filter` -und- `finally` Blöcken können von dieser Anweisung nicht ausgeführt werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `bgt.un` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert größer als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|35 < `int8` >|BGT. un. s `target`|Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert größer als der zweite Wert (ohne Vorzeichen), Kurzform ist.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt `value1` . wenn größer als ist `value2` , wird der Verzweigungs Vorgang ausgeführt.  
  
 Mit der- `bgt.un.s` Anweisung wird die Steuerung an die angegebene Ziel Anweisung übertragen `value1` , wenn größer als ist `value2` , wenn eine ganze Zahl ohne Vorzeichen oder ungeordnete Gleit Komma Werte verglichen werden. Der Effekt ist identisch mit der Ausführung einer- `cgt.un` Anweisung, gefolgt von einer `brtrue` Verzweigung zur bestimmten Ziel Anweisung. Die Ziel Anweisung wird als 1-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.  
  
 Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden. Steuerelement Übertragungen in und aus- `try` , `catch` -, `filter` -und- `finally` Blöcken können von dieser Anweisung nicht ausgeführt werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `bgt.un.s` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn der erste Wert kleiner oder gleich dem zweiten Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|3e `<int32>`|Erbar `target`|Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert kleiner oder gleich dem zweiten Wert ist.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt `value1` . wenn kleiner oder gleich ist `value2` , wird der Verzweigungs Vorgang ausgeführt.  
  
 Die- `ble` Anweisung überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value1` kleiner als oder gleich ist `value2` . Der Effekt ist identisch mit dem Ausführen einer- `cgt` Anweisung (für Gleit Komma Zahlen `cgt.un` ), gefolgt von einer `brfalse` Verzweigung zur spezifischen Ziel Anweisung. Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.  
  
 Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden. Steuerelement Übertragungen in und aus- `try` , `catch` -, `filter` -und- `finally` Blöcken können von dieser Anweisung nicht ausgeführt werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ble` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn der erste Wert kleiner oder gleich dem zweiten Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|31 `<int8>`|BLE. s `target`|Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert kleiner oder gleich dem zweiten Wert ist, Kurzform.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt `value1` . wenn kleiner oder gleich ist `value2` , wird der Verzweigungs Vorgang ausgeführt.  
  
 Die- `ble.s` Anweisung überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value1` kleiner als oder gleich ist `value2` . Der Effekt ist identisch mit der Ausführung einer `cgt` Anweisung (für Gleit Komma Zahlen `cgt.un` ), gefolgt von einer `brfalse` Verzweigung zur spezifischen Ziel Anweisung. Die Ziel Anweisung wird als 1-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.  
  
 Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden. Steuerelement Übertragungen in und aus- `try` , `catch` -, `filter` -und- `finally` Blöcken können von dieser Anweisung nicht ausgeführt werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ble.s` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert kleiner oder gleich dem zweiten Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|43 `<int32>`|BLE. UN `target`|Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert kleiner oder gleich dem zweiten Wert (ohne Vorzeichen) ist.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt `value1` . wenn kleiner oder gleich ist `value2` , wird der Verzweigungs Vorgang ausgeführt.  
  
 Mit der- `ble.un` Anweisung wird die Steuerung an die angegebene Ziel Anweisung übertragen `value1` , wenn kleiner oder gleich ist `value2` , wenn Sie mit einer Ganzzahl ohne Vorzeichen oder ungeordnete Gleit Komma Werte verglichen werden. Der Effekt ist identisch mit dem Ausführen einer- `cgt.un` Anweisung (für Gleit Komma Zahlen `cgt` ), gefolgt von einer `brfalse` Verzweigung zur spezifischen Ziel Anweisung. Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.  
  
 Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden. Steuerelement Übertragungen in und aus- `try` , `catch` -, `filter` -und- `finally` Blöcken können von dieser Anweisung nicht ausgeführt werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ble.un` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert kleiner oder gleich dem zweiten Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|36 `<int8>`|BLE. un. s `target`|Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert kleiner oder gleich dem zweiten Wert (nicht signierte Werte), Kurzform ist.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt `value1` . wenn kleiner oder gleich ist `value2` , wird der Verzweigungs Vorgang ausgeführt.  
  
 Mit der- `ble.un.s` Anweisung wird die Steuerung an die angegebene Ziel Anweisung übertragen `value1` , wenn kleiner oder gleich ist `value2` , wenn Sie mit einer Ganzzahl ohne Vorzeichen oder ungeordnete Gleit Komma Werte verglichen werden. Der Effekt ist identisch mit dem Ausführen einer- `cgt.un` Anweisung (für Gleit Komma Zahlen `cgt` ), gefolgt von einer `brfalse` Verzweigung zur spezifischen Ziel Anweisung. Die Ziel Anweisung wird als 1-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.  
  
 Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden. Steuerelement Übertragungen in und aus- `try` , `catch` -, `filter` -und- `finally` Blöcken können von dieser Anweisung nicht ausgeführt werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ble.un.s` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn der erste Wert kleiner als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|3F-< `int32` >|BLT `target`|Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert kleiner als der zweite Wert ist.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt `value1` . wenn kleiner als ist `value2` , wird der Verzweigungs Vorgang ausgeführt.  
  
 Die- `blt` Anweisung überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value1` kleiner als oder gleich ist `value2` . Der Effekt ist identisch mit der Ausführung einer- `clt` Anweisung, gefolgt von einer `brtrue` Verzweigung zur bestimmten Ziel Anweisung. Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.  
  
 Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden. Steuerelement Übertragungen in und aus- `try` , `catch` -, `filter` -und- `finally` Blöcken können von dieser Anweisung nicht ausgeführt werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `blt` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn der erste Wert kleiner als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|32 < `int8` >|BLT. s `target`|Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert kleiner als der zweite Wert (Kurzform) ist.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt `value1` . wenn kleiner als ist `value2` , wird der Verzweigungs Vorgang ausgeführt.  
  
 Die- `blt.s` Anweisung überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value1` kleiner als ist `value2` . Der Effekt ist identisch mit der Ausführung einer- `clt` Anweisung, gefolgt von einer `brtrue` Verzweigung zur bestimmten Ziel Anweisung. Die Ziel Anweisung wird als 1-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.  
  
 Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden. Steuerelement Übertragungen in und aus- `try` , `catch` -, `filter` -und- `finally` Blöcken können von dieser Anweisung nicht ausgeführt werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `blt.s` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert kleiner als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|44 < `int32` >|BLT. UN `target`|Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert kleiner als der zweite Wert (ohne Vorzeichen) ist.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt `value1` . wenn kleiner als ist `value2` , wird der Verzweigungs Vorgang ausgeführt.  
  
 Mit der- `blt.un` Anweisung wird die Steuerung an die angegebene Ziel Anweisung übertragen `value1` , wenn kleiner als ist `value2` , wenn eine Ganzzahl ohne Vorzeichen oder ungeordnete Gleit Komma Werte verglichen werden. Der Effekt ist identisch mit der Ausführung einer- `clt.un` Anweisung, gefolgt von einer `brtrue` Verzweigung zur bestimmten Ziel Anweisung. Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.  
  
 Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden. Steuerelement Übertragungen in und aus- `try` , `catch` -, `filter` -und- `finally` Blöcken können von dieser Anweisung nicht ausgeführt werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `blt.un` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte verglichen werden und der erste Wert kleiner als der zweite Wert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|37 < `int8` >|BLT. un. s `target`|Verzweigt die Ziel Anweisung am angegebenen Offset, wenn der erste Wert kleiner als der zweite Wert (ohne Vorzeichen), Kurzform ist.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt `value1` . wenn kleiner als ist `value2` , wird der Verzweigungs Vorgang ausgeführt.  
  
 Mit der- `blt.un` Anweisung wird die Steuerung an die angegebene Ziel Anweisung übertragen `value1` , wenn kleiner als ist `value2` , wenn eine Ganzzahl ohne Vorzeichen oder ungeordnete Gleit Komma Werte verglichen werden. Der Effekt ist identisch mit der Ausführung einer- `clt.un` Anweisung, gefolgt von einer `brtrue` Verzweigung zur bestimmten Ziel Anweisung. Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.  
  
 Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden. Steuerelement Übertragungen in und aus- `try` , `catch` -, `filter` -und- `finally` Blöcken können von dieser Anweisung nicht ausgeführt werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `blt.un.s` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn zwei Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte ungleich sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|40 < `int32` >|BNE. UN `target`|Verzweigt die Ziel Anweisung am angegebenen Offset, wenn zwei ganzzahlige Werte ohne Vorzeichen nicht gleich sind (Werte ohne Vorzeichen).|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt `value1` . wenn nicht gleich ist `value2` , wird der Verzweigungs Vorgang ausgeführt.  
  
 Mit der- `bne.un` Anweisung wird die Steuerung an die angegebene Ziel Anweisung übertragen `value1` , wenn `value2` ungleich ist, wenn die Verwendung einer Ganzzahl ohne Vorzeichen oder ungeordnete Gleit Komma Werte verglichen wird. Der Effekt ist identisch mit der Ausführung einer- `ceq` Anweisung, gefolgt von einer `brfalse` Verzweigung zur bestimmten Ziel Anweisung. Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.  
  
 Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden. Steuerelement Übertragungen in und aus- `try` , `catch` -, `filter` -und- `finally` Blöcken können von dieser Anweisung nicht ausgeführt werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `bne.un` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn zwei Ganzzahlwerte ohne Vorzeichen oder ungeordnete Gleitkommawerte ungleich sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|33 < `int8` >|BNE. un. s `target`|Verzweigt die Ziel Anweisung am angegebenen Offset, wenn zwei ganzzahlige Werte ohne Vorzeichen nicht gleich sind (unsignierte Werte), Kurzform.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt `value1` . wenn nicht gleich ist `value2` , wird der Verzweigungs Vorgang ausgeführt.  
  
 Mit der- `bne.un` Anweisung wird die Steuerung an die angegebene Ziel Anweisung übertragen `value1` , wenn `value2` ungleich ist, wenn die Verwendung einer Ganzzahl ohne Vorzeichen oder ungeordnete Gleit Komma Werte verglichen wird. Der Effekt ist identisch mit der Ausführung einer- `ceq` Anweisung, gefolgt von einer `brfalse` Verzweigung zur bestimmten Ziel Anweisung. Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.  
  
 Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden. Steuerelement Übertragungen in und aus- `try` , `catch` -, `filter` -und- `finally` Blöcken können von dieser Anweisung nicht ausgeführt werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `bne.un.s` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert einen Werttyp in einen Objektverweis (Typ <see langword="O" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|8c-< `T` >|Chens `valTypeToken`|Konvertiert einen Werttyp (von dem in angegebenen Typ `valTypeToken` ) in einen echten Objekt Verweis.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Werttyp wird auf den Stapel verschoben.  
  
2.  Der Werttyp wird aus dem Stapel ausgeblendet. der `box` Vorgang wird ausgeführt.  
  
3.  Ein Objekt Verweis auf den resultierenden "Boxed"-Werttyp wird auf den Stapel verschoben.  
  
 Ein Werttyp verfügt über zwei separate Darstellungen innerhalb der Common Language Infrastructure (CLI):  
  
-   Ein RAW-Formular, das verwendet wird, wenn ein Werttyp in ein anderes Objekt oder auf dem Stapel eingebettet ist.  
  
-   Ein geschachteltes Formular, in dem die Daten im Werttyp in ein Objekt umwickelt (geschachtelt) werden, damit es als unabhängige Entität vorhanden sein kann.  
  
 Die `box` Anweisung konvertiert den "RAW"-Werttyp (Unboxing) in einen Objekt Verweis (Typ `O` ). Dies wird erreicht, indem ein neues-Objekt erstellt und die Daten aus dem Werttyp in das neu zugewiesene-Objekt kopiert werden. `valTypeToken` ein Metadatentoken, das den Typ des Werttyps auf dem Stapel angibt.  
  
 <xref:System.OutOfMemoryException> wird ausgelöst, wenn nicht genügend Arbeitsspeicher vorhanden ist, um die Anforderung zu erfüllen.  
  
 <xref:System.TypeLoadException> wird ausgelöst, wenn die Klasse nicht gefunden werden kann. Dies wird in der Regel erkannt, wenn MSIL (Microsoft Intermediate Language) in nativen Code konvertiert wird, anstatt zur Laufzeit.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `box` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung bedingungslos an eine Zielanweisung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|38 < `int32` >|BR `target`|Verzweigt am angegebenen Offset in eine Ziel Anweisung.|  
  
 Von diesem Vorgang werden keine Bewertungs Stapel Verhalten ausgeführt.  
  
 Die `br` Anweisung überträgt die Steuerung bedingungslos an eine Ziel Anweisung. Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.  
  
 Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden. Steuerelement Übertragungen in und aus- `try` , `catch` -, `filter` -und- `finally` Blöcken können von dieser Anweisung nicht ausgeführt werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `br` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung bedingungslos an eine Zielanweisung (Kurzform).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|2B-< `int8` >|Br. s `target`|Verzweigt in eine Ziel Anweisung am angegebenen Offset, Kurzform.|  
  
 Von diesem Vorgang werden keine Bewertungs Stapel Verhalten ausgeführt.  
  
 Die `br.s` Anweisung überträgt die Steuerung bedingungslos an eine Ziel Anweisung. Die Ziel Anweisung wird als 1-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.  
  
 Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden. Steuerelement Übertragungen in und aus- `try` , `catch` -, `filter` -und- `finally` Blöcken können von dieser Anweisung nicht ausgeführt werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `br.s` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Signalisiert CLI (Common Language Infrastructure), den Debugger darüber zu informieren, dass ein Haltepunkt erreicht wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|01|break|informieren Sie einen Debugger, dass ein Haltepunkt erreicht wurde.|  
  
 Von diesem Vorgang werden keine Bewertungs Stapel Verhalten ausgeführt.  
  
 Die `break` Anweisung dient der Debugunterstützung. Es signalisiert der CLI, den Debugger darüber zu informieren, dass ein Haltepunkt erreicht wurde. Er wirkt sich nicht auf den Interpreterzustand aus.  
  
 Die `break` Anweisung verfügt über die kleinste mögliche Anweisungs Größe, die das Patchen von Code mit einem Breakpoint ermöglicht und den umgebenden Code nur minimal stören kann.  
  
 Die `break` Anweisung kann an einen Debugger Trap, keine Aktion durchführen oder eine Sicherheits Ausnahme auslöst. Das genaue Verhalten ist von der Implementierung definiert.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `break` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn <paramref name="value" /> entweder <see langword="false" />, ein NULL-Verweis (<see langword="Nothing" /> in Visual Basic) oder 0 (null) ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|39 < `int32` >|brfalse `target`<br /><br /> brnull `target`<br /><br /> brzero `target`|Verzweigt in eine Ziel Anweisung am angegebenen Offset, wenn `false` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird von einem vorherigen Vorgang auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt. Wenn `value` ist `false` , verzweigen Sie in `target` .  
  
 Die `brfalse` -Anweisung (und ihre Aliase `brnull` und `brzero` ) überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value` (vom Typ `int32` , `int64` , Objekt Verweis `O` , verwalteter Zeiger `&` , vorübergehender Zeiger `*` , `native int` ) 0 (null) ist `false` . Wenn `value` nicht 0 (null) () ist, wird `true` die Ausführung bei der nächsten Anweisung fortgesetzt.  
  
 Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.  
  
 Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden. Steuerelement Übertragungen in und aus- `try` , `catch` -, `filter` -und- `finally` Blöcken können von dieser Anweisung nicht ausgeführt werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `brfalse` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn <paramref name="value" /> entweder <see langword="false" />, ein NULL-Verweis oder 0 (null) ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|2C-<`int8` >|brfalse. s `target`<br /><br /> brnull. s `target`<br /><br /> brzero. s `target`|Verzweigt in einer Ziel Anweisung am angegebenen Offset `false` , wenn, Kurzform.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird von einem vorherigen Vorgang auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt. Wenn `value` ist `false` , verzweigen Sie in `target` .  
  
 Die `brfalse.s` -Anweisung (und ihre Aliase `brnull` und `brzero` ) überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value` (vom Typ `int32` , `int64` , Objekt Verweis `O` , verwalteter Zeiger `&` , vorübergehender Zeiger `*` , `native int` ) 0 (null) ist `false` . Wenn `value` nicht 0 (null) () ist, wird `true` die Ausführung bei der nächsten Anweisung fortgesetzt.  
  
 Die Ziel Anweisung wird als 1-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.  
  
 Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden. Steuerelement Übertragungen in und aus- `try` , `catch` -, `filter` -und- `finally` Blöcken können von dieser Anweisung nicht ausgeführt werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `brfalse.s` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung, wenn <paramref name="value" /> entweder <see langword="true" />, nicht NULL oder ungleich 0 (null) ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|3a-< `int32` >|brtrue `target`<br /><br /> brinst `target`|Verzweigt beim angegebenen Offset in eine Ziel Anweisung, wenn Sie nicht NULL ( `true` ) ist.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird von einem vorherigen Vorgang auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt. Wenn `value` ist `true` , verzweigen Sie in `target` .  
  
 Die- `brtrue` Anweisung überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value` (Type `native int` ) ungleich 0 (NULL `true` ) () ist. Wenn `value` 0 (null) ist, wird `false` die Ausführung bei der nächsten Anweisung fortgesetzt.  
  
 Wenn `value` ein Objekt Verweis (Typ `O` ) ist `brinst` , überträgt (ein Alias für `brtrue` ) die Steuerung, wenn Sie eine Instanz eines Objekts darstellt (z. b., wenn es sich nicht um den NULL-Objekt Verweis handelt; Weitere Informationen finden Sie unter <xref:System.Reflection.Emit.OpCodes.Ldnull> ).  
  
 Die Ziel Anweisung wird als 4-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.  
  
 Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden. Steuerelement Übertragungen in und aus- `try` , `catch` -, `filter` -und- `finally` Blöcken können von dieser Anweisung nicht ausgeführt werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `brtrue` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung an eine Zielanweisung (Kurzform), wenn <paramref name="value" /> entweder <see langword="true" />, nicht NULL oder ungleich 0 (null) ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|2D-< `int8` >|brtrue. s `target`<br /><br /> brinst. s `target`|Verzweigt beim angegebenen Offset in eine Ziel Anweisung, wenn Sie nicht NULL ( `true` ), Kurzform ist.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird von einem vorherigen Vorgang auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt. Wenn `value` ist `true` , verzweigen Sie in `target` .  
  
 Die- `brtrue.s` Anweisung überträgt die Steuerung an die angegebene Ziel Anweisung, wenn `value` (Type `native int` ) ungleich 0 (NULL `true` ) () ist. Wenn `value` 0 (null) ist, wird `false` die Ausführung bei der nächsten Anweisung fortgesetzt.  
  
 Wenn `value` ein Objekt Verweis (Typ `O` ) ist `brinst` , überträgt (ein Alias für `brtrue` ) die Steuerung, wenn Sie eine Instanz eines Objekts darstellt (z. b., wenn es sich nicht um den NULL-Objekt Verweis handelt; Weitere Informationen finden Sie unter <xref:System.Reflection.Emit.OpCodes.Ldnull> ).  
  
 Die Ziel Anweisung wird als 1-Byte-Offset vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt.  
  
 Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden. Steuerelement Übertragungen in und aus- `try` , `catch` -, `filter` -und- `finally` Blöcken können von dieser Anweisung nicht ausgeführt werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `brtrue.s` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Methode auf, die der übergebene Methodendeskriptor angibt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|28 < `T` >|call `methodDesc` („555-555-5555“ anrufen)|Ruft die von beschriebene Methode auf `methodDesc` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Methodenargumente `arg1` durch `argN` werden auf den Stapel verschoben.  
  
2.  Methodenargumente `arg1` durch `argN` werden aus dem Stapel abgerufen. der Methodenaufrufe wird mit diesen Argumenten durchgeführt, und die Steuerung wird an die Methode übertragen, auf die vom Methoden Deskriptor verwiesen wird. Nach Abschluss des Vorgangs wird ein Rückgabewert von der aufgerufenen Methode generiert und an den Aufrufer gesendet.  
  
3.  Der Rückgabewert wird auf den Stapel verschoben.  
  
 Die- `call` Anweisung ruft die Methode auf, die durch den mit der-Anweisung bestandenen Methoden Deskriptor angegeben wird. Der Methoden Deskriptor ist ein Metadatentoken, das die aufzurufende Methode angibt, sowie die Anzahl, den Typ und die Reihenfolge der Argumente, die auf dem Stapel abgelegt wurden und die an diese Methode und die zu verwendende Aufruf Konvention übermittelt werden. Der `call` Anweisung kann unmittelbar eine `tail` <xref:System.Reflection.Emit.OpCodes.Tailcall> Präfix Anweisung () vorangestellt werden, um anzugeben, dass der aktuelle Methoden Zustand vor dem übertragen der Steuerung freigegeben werden soll. Wenn der-Befehl die Steuerung an eine Methode mit höherer Vertrauenswürdigkeit überträgt, als die Ursprungs Methode, wird der Stapel Rahmen nicht freigegeben. Stattdessen wird die Ausführung im Hintergrund fortgesetzt, als wäre der `tail` nicht angegeben worden. Das Metadatentoken enthält ausreichende Informationen, um zu bestimmen, ob es sich um eine statische Methode, eine Instanzmethode, eine virtuelle Methode oder eine globale Funktion handelt. In all diesen Fällen wird die Zieladresse vollständig vom Methoden Deskriptor bestimmt (vergleichen Sie dies mit der <xref:System.Reflection.Emit.OpCodes.Callvirt> Anweisung zum Aufrufen von virtuellen Methoden, wobei die Zieladresse auch vom Lauf Zeittyp des instanzverweises abhängt, der vor dem verschoben wurde <xref:System.Reflection.Emit.OpCodes.Callvirt> ).  
  
 Die Argumente werden in der Reihenfolge von links nach rechts auf dem Stapel abgelegt. Das heißt, das erste Argument wird berechnet und auf dem Stapel abgelegt, dann das zweite Argument, dann das dritte, bis alle erforderlichen Argumente in absteigender Reihenfolge auf dem Stapel liegen. Es gibt drei wichtige Sonderfälle:  
  
 1. Aufrufe einer Instanz-(oder virtuellen) Methode müssen diesen Instanzverweis vor allen Benutzer sichtbaren Argumenten übersetzen. Der Instanzverweis darf kein NULL-Verweis sein. Die in den Metadaten getragene Signatur enthält keinen Eintrag in der Parameterliste für den `this` Zeiger; stattdessen wird ein Bit verwendet, um anzugeben, ob die Methode den Zeiger übergeben muss `this` .  
  
 2. Es ist zulässig, eine virtuelle Methode mithilfe `call` von (anstelle von `callvirt` ) aufzurufen. Dies deutet darauf hin, dass die Methode mithilfe der Klasse aufgelöst werden soll, die von der-Methode angegeben wird, anstatt wie von dem aufgerufenen Objekt dynamisch angegeben zu werden.  
  
 3. Beachten Sie, dass die-Methode eines Delegaten `Invoke` entweder mit der-oder der-Anweisung aufgerufen werden kann `call` `callvirt` .  
  
 <xref:System.Security.SecurityException> kann ausgelöst werden, wenn die Systemsicherheit dem Aufrufer nicht den Zugriff auf die aufgerufene Methode gewährt. Die Sicherheitsüberprüfung kann auftreten, wenn die MSIL-Anweisungen (Microsoft Intermediate Language) nicht zur Laufzeit, sondern in systemeigenen Code konvertiert werden.  
  
> [!NOTE]
>  Wenn Sie Methoden von "System. Object" für Werttypen aufrufen, sollten Sie das `constrained` Präfix mit der Anweisung verwenden, `callvirt` anstatt eine Anweisung auszuwerten `call` . Dadurch entfällt die Notwendigkeit, eine andere Il auszugeben, je nachdem, ob der Werttyp die Methode überschreibt, sodass ein mögliches Versions Problem vermieden wird. Verwenden Sie das `constrained` Präfix beim Aufrufen von Schnittstellen Methoden für Werttypen, da die Werttyp Methode, die die Schnittstellen Methode implementiert, mit einem geändert werden kann `MethodImpl` . Diese Probleme werden im <xref:System.Reflection.Emit.OpCodes.Constrained> Opcode ausführlicher beschrieben.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladungen können den `call` Opcode verwenden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.EmitCall%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%2CSystem.Type%5B%5D%29?displayProperty=nameWithType>  
  
> [!NOTE]
>  Die- <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> Methode wird für-Aufrufe bereitgestellt `varargs` . Verwenden Sie die- <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methode für normale Aufrufe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die angegebene Methode auf dem Auswertungsstapel (als Zeiger auf einen Einstiegspunkt) mit Argumenten auf, die durch eine Aufrufkonvention beschrieben sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|29 < `T` >|Calli `callSiteDescr`|Ruft die Methode auf, auf die mit den von der Aufruf Konvention beschriebenen Argumenten verwiesen wird.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Methodenargumente `arg1` durch `argN` werden auf den Stapel verschoben.  
  
2.  Der Methoden Eingabe Zeiger wird auf den Stapel verschoben.  
  
3.  Methodenargumente `arg1` durch `argN` und der Methoden Eintrags Zeiger werden aus dem Stapel entfernt. der Aufrufvorgang der-Methode wird ausgeführt. Nach Abschluss des Vorgangs wird ein Rückgabewert von der aufgerufenen Methode generiert und an den Aufrufer gesendet.  
  
4.  Der Rückgabewert wird auf den Stapel verschoben.  
  
 Die- `calli` Anweisung ruft den Methoden Eingabe Zeiger mit den Argumenten `arg1` über auf `argN` . Die Typen dieser Argumente werden von der spezifischen Aufruf Konvention () beschrieben `callSiteDesc` . Der `calli` Anweisung kann unmittelbar ein `tail` Präfix () vorangestellt werden, <xref:System.Reflection.Emit.OpCodes.Tailcall> um anzugeben, dass der aktuelle Methoden Zustand vor dem übertragen der Steuerung freigegeben werden soll. Wenn der-Befehl die Steuerung an eine Methode mit höherer Vertrauenswürdigkeit überträgt, als die Ursprungs Methode, wird der Stapel Rahmen nicht freigegeben. Stattdessen wird die Ausführung im Hintergrund fortgesetzt, als wäre der `tail` nicht angegeben worden.  
  
 Es wird davon ausgegangen, dass es sich um einen bestimmten Zeiger auf systemeigenen Code (des Ziel Computers) handelt, der mit den durch die Aufruf Konvention beschriebenen Argumenten (ein Metadatentoken für eine eigenständige Signatur) rechtmäßig aufgerufen werden kann. Ein solcher Zeiger kann mit der-oder der- <xref:System.Reflection.Emit.OpCodes.Ldftn> <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> Anweisung erstellt oder aus nativem Code übermittelt werden.  
  
 Die Aufruf Konvention wird nicht dynamisch überprüft, sodass Code, der eine `calli` Anweisung verwendet, nicht ordnungsgemäß funktioniert, wenn das Ziel nicht die angegebene Aufruf Konvention tatsächlich verwendet.  
  
 Die Argumente werden in der Reihenfolge von links nach rechts auf dem Stapel abgelegt. Das heißt, das erste Argument wird berechnet und auf dem Stapel abgelegt, dann das zweite Argument, dann das dritte, bis alle erforderlichen Argumente in absteigender Reihenfolge auf dem Stapel liegen. Die Argument Erstellungs Code Sequenz für eine Instanz oder eine virtuelle Methode muss diesen Instanzverweis (der kein NULL-Verweis sein darf) vor einem der Benutzer sichtbaren Argumente per Push übersetzen.  
  
 <xref:System.Security.SecurityException> kann ausgelöst werden, wenn die Systemsicherheit dem Aufrufer nicht den Zugriff auf die aufgerufene Methode gewährt. Die Sicherheitsüberprüfung kann auftreten, wenn die MSIL-Anweisungen (Microsoft Intermediate Language) in nativen Code anstatt zur Laufzeit konvertiert werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> Methoden können verwendet werden, um eine `calli` Anweisung auf dem Stapel auszuführen. Beachten Sie, dass `calli` durch die folgenden Methoden aufgerufen werden sollte, anstatt die- <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Klasse zum direkten platzieren der Anweisung auf dem Stapel zu verwenden.  
  
-   <xref:System.Reflection.Emit.ILGenerator.EmitCalli%28System.Reflection.Emit.OpCode%2CSystem.Reflection.CallingConventions%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType> bei aufrufen, die eine verwaltete Aufruf Konvention verwenden.  
  
-   <xref:System.Reflection.Emit.ILGenerator.EmitCalli%28System.Reflection.Emit.OpCode%2CSystem.Runtime.InteropServices.CallingConvention%2CSystem.Type%2CSystem.Type%5B%5D%29?displayProperty=nameWithType> bei aufrufen, die eine nicht verwaltete Aufruf Konvention verwenden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine spät gebundene Methode für ein Objekt auf und legt den Rückgabewert auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|6f-< `T` >|"callvirt" `method`|Ruft eine bestimmte Methode auf, die zugeordnet ist `obj` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis `obj` wird auf den Stapel verschoben.  
  
2.  Methodenargumente `arg1` durch `argN` werden auf den Stapel verschoben.  
  
3.  Methodenargumente `arg1` durch `argN` und der Objekt Verweis `obj` werden aus dem Stapel entfernt. der Methodenaufrufe wird mit diesen Argumenten ausgeführt, und die Steuerung wird an die-Methode übertragen, auf die `obj` durch das Metadatentoken der Methode verwiesen wird. Nach Abschluss des Vorgangs wird ein Rückgabewert von der aufgerufenen Methode generiert und an den Aufrufer gesendet.  
  
4.  Der Rückgabewert wird auf den Stapel verschoben.  
  
 Die `callvirt` -Anweisung ruft eine spät gebundene Methode für ein-Objekt auf. Das heißt, die Methode wird basierend auf dem Lauf Zeittyp von `obj` und nicht mit der im Methoden Zeiger sichtbaren Kompilierzeit Klasse ausgewählt. `Callvirt` kann verwendet werden, um sowohl virtuelle als auch Instanzmethoden aufzurufen. Der `callvirt` Anweisung kann unmittelbar ein `tail` Präfix () vorangestellt werden, <xref:System.Reflection.Emit.OpCodes.Tailcall> um anzugeben, dass der aktuelle Stapel Rahmen vor dem übertragen der Steuerung freigegeben werden soll. Wenn der-Befehl die Steuerung an eine Methode mit höherer Vertrauenswürdigkeit überträgt, als die ursprüngliche Methode, wird der Stapel Rahmen nicht freigegeben.  
  
 Das Metadatentoken der Methode stellt den Namen, die Klasse und die Signatur der aufzurufenden Methode bereit. Die zugeordnete Klasse `obj` ist die Klasse, von der es sich um eine-Instanz handelt. Wenn die Klasse eine nicht statische Methode definiert, die mit dem festgelegten Methodennamen und der Signatur übereinstimmt, wird diese Methode aufgerufen. Andernfalls werden alle Klassen in der Basisklassen Kette dieser Klasse in der richtigen Reihenfolge geprüft. Wenn keine Methode gefunden wird, ist dies ein Fehler.  
  
 `Callvirt` Ruft das-Objekt und die zugehörigen Argumente aus dem Auswertungs Stapel ab, bevor die-Methode aufgerufen wird. Wenn die Methode über einen Rückgabewert verfügt, wird Sie nach Abschluss der Methode auf dem Stapel abgelegt. Auf der `obj` aufgerufenen Seite wird auf den Parameter als Argument 0, `arg1` als Argument 1 usw. zugegriffen.  
  
 Die Argumente werden in der Reihenfolge von links nach rechts auf dem Stapel abgelegt. Das heißt, das erste Argument wird berechnet und auf dem Stapel abgelegt, dann das zweite Argument, dann das dritte, bis alle erforderlichen Argumente in absteigender Reihenfolge auf dem Stapel liegen. Der Instanzverweis `obj` (immer erforderlich für `callvirt` ) muss vor allen Benutzer sichtbaren Argumenten gepusht werden. Die Signatur (die im Metadatentoken enthalten ist) muss keinen Eintrag in der Parameterliste für den this-Zeiger enthalten.  
  
 Beachten Sie, dass eine virtuelle Methode auch mit der-Anweisung aufgerufen werden kann <xref:System.Reflection.Emit.OpCodes.Call> .  
  
 <xref:System.MissingMethodException> wird ausgelöst, wenn eine nicht statische Methode mit dem festgelegten Namen und der Signatur in der Klasse, die mit `obj` oder einer der zugehörigen Basisklassen verknüpft ist, nicht gefunden werden konnte. Dies wird in der Regel erkannt, wenn MSIL-Anweisungen (Microsoft Intermediate Language) in systemeigenen Code konvertiert werden, anstatt zur Laufzeit.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn obj null ist.  
  
 <xref:System.Security.SecurityException> wird ausgelöst, wenn die Systemsicherheit dem Aufrufer nicht den Zugriff auf die aufgerufene Methode gewährt. Die Sicherheitsüberprüfung kann auftreten, wenn die cil anstelle der Laufzeit in nativen Code konvertiert wird.  
  
> [!NOTE]
>  Wenn Sie Methoden von System. Object für Werttypen aufrufen, sollten Sie das `constrained` Präfix mit der- `callvirt` Anweisung verwenden. Dadurch entfällt die Notwendigkeit, eine andere Il auszugeben, je nachdem, ob der Werttyp die Methode überschreibt, sodass ein mögliches Versions Problem vermieden wird. Verwenden Sie das `constrained` Präfix beim Aufrufen von Schnittstellen Methoden für Werttypen, da die Werttyp Methode, die die Schnittstellen Methode implementiert, mit einem geändert werden kann `MethodImpl` . Diese Probleme werden im <xref:System.Reflection.Emit.OpCodes.Constrained> Opcode ausführlicher beschrieben.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `callvirt` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.EmitCall%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%2CSystem.Type%5B%5D%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wandelt ein als Verweis übergebenes Objekt in die angegebene Klasse um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|74 < `T` >|castclass `class`|Wandelt ein Objekt in ein neues Objekt vom Typ um `class` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis wird auf den Stapel verschoben.  
  
2.  Der Objekt Verweis wird aus dem Stapel entfernt. das Objekt, auf das verwiesen wird, wird in den angegebenen umgewandelt `class` .  
  
3.  Bei erfolgreicher Ausführung wird ein neuer Objekt Verweis auf den Stapel verschoben.  
  
 Die- `castclass` Anweisung versucht, den Objekt Verweis (Typ `O` ) oberhalb des Stapels in eine angegebene Klasse umzuwandeln. Die neue Klasse wird durch ein Metadatentoken angegeben, das die gewünschte Klasse angibt. Wenn die Klasse des Objekts am Anfang des Stapels die neue Klasse nicht implementiert (vorausgesetzt, die neue Klasse ist eine Schnittstelle) und keine abgeleitete Klasse der neuen Klasse ist, wird eine ausgelöst <xref:System.InvalidCastException> . Wenn der Objekt Verweis ein NULL-Verweis ist, wird erfolgreich ausgeführt, `castclass` und das neue-Objekt wird als NULL-Verweis zurückgegeben.  
  
 <xref:System.InvalidCastException> wird ausgelöst, wenn obj nicht in Class umgewandelt werden kann.  
  
 <xref:System.TypeLoadException> wird ausgelöst, wenn die Klasse nicht gefunden werden kann. Dies wird in der Regel erkannt, wenn eine MSIL-Anweisung (Microsoft Intermediate Language) in nativen Code anstatt zur Laufzeit konvertiert wird.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `castclass` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Vergleicht zwei Werte. Wenn sie gleich sind, wird der Ganzzahlwert 1 <see langword="(int32" />) auf dem Auswertungsstapel abgelegt, andernfalls wird 0 (<see langword="int32" />) auf dem Auswertungsstapel abgelegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|FE 01|ceq|Überträgt 1, wenn ist, andernfalls wird `value1` `value2` 0 gedrückt.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt; `value1` wird mit verglichen `value2` .  
  
4.  Wenn `value1` gleich ist `value2` , wird 1 auf dem Stapel abgelegt, andernfalls wird 0 auf den Stapel verschoben.  
  
 Die `ceq` Anweisung vergleicht `value1` und `value2` . Wenn `value1` gleich ist `value2` , wird 1 (vom Typ `int32` ) auf dem Stapel abgelegt. Andernfalls wird 0 (vom Typ `int32` ) auf dem Stapel abgelegt.  
  
 Gibt für Gleit Komma Zahlen `ceq` den Wert 0 zurück, wenn die Zahlen nicht geordnet sind (entweder oder beide sind NaN). Die unendlichen Werte sind gleich.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ceq` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Vergleicht zwei Werte. Wenn der erste Wert größer als der zweite Wert ist, wird der Ganzzahlwert 1 <see langword="(int32" />) auf dem Auswertungsstapel abgelegt, andernfalls wird 0 (<see langword="int32" />) auf dem Auswertungsstapel abgelegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|FE 02|CGT|Überträgt 1 `value1` , wenn größer als ist, andernfalls wird `value2` 0 gedrückt.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt. `cgt` testet, ob `value1` größer als ist `value2` .  
  
4.  Wenn `value1` größer als ist `value2` , wird 1 auf den Stapel verschoben; andernfalls wird 0 auf den Stapel verschoben.  
  
 Die `cgt` Anweisung vergleicht `value1` und `value2` . Wenn `value1` streng größer als ist `value2` , `int32` wird der Wert 1 auf dem Stapel abgelegt. Andernfalls `int32` wird der Wert 0 auf den Stapel verschoben.  
  
-   Gibt für Gleit Komma Zahlen `cgt` den Wert 0 zurück, wenn die Zahlen nicht geordnet sind (d. h., wenn eines oder beide der Argumente Nan sind).  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `cgt` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Vergleicht zwei Werte ohne Vorzeichen oder zwei ungeordnete Werte. Wenn der erste Wert größer als der zweite Wert ist, wird der Ganzzahlwert 1 <see langword="(int32" />) auf dem Auswertungsstapel abgelegt, andernfalls wird 0 (<see langword="int32" />) auf dem Auswertungsstapel abgelegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|FE 03|CGT. UN|Überträgt 1 `value1` , wenn größer als ist, andernfalls wird `value2` 0 (nicht signierte Werte) übertragen.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt. `cgt.un` testet, ob `value1` größer als ist `value2` .  
  
4.  Wenn `value1` größer als ist `value2` , wird 1 auf den Stapel verschoben; andernfalls wird 0 auf den Stapel verschoben.  
  
 Der `int32` Wert 1 wird auf dem Stapel abgelegt, wenn Folgendes gilt `true` :  
  
 Für Gleit Komma Zahlen ist in `value1` Bezug auf nicht geordnet `value2` .  
  
 Bei ganzzahligen Werten `value1` ist streng größer als, `value2` Wenn es als nicht signierte Zahlen angesehen wird.  
  
 Andernfalls `int32` wird der Wert 0 auf den Stapel verschoben.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `cgt.un` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Löst <see cref="T:System.ArithmeticException" /> aus, wenn der Wert keine endliche Zahl ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|C3|ckfinite|Throw, <xref:System.ArithmeticException> Wenn der Wert keine endliche Zahl ist.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben. 
  
2.  `value` wird aus dem Stapel entfernt, und die `ckfinite` Anweisung wird darauf ausgeführt.  
  
3.  `value` wird zurück auf den Stapel verschoben, wenn keine Ausnahme ausgelöst wird.  
  
 Das löst aus, `ckfinite instruction` <xref:System.ArithmeticException> Wenn `value` (eine Gleit Komma Zahl) entweder ein "not a Number"-Wert (NaN) oder ein `+-` Unendlichkeits Wert ist. `Ckfinite` behält den Wert im Stapel bei, wenn keine Ausnahme ausgelöst wird. Die Ausführung ist nicht angegeben, wenn `value` keine Gleit Komma Zahl ist.  
  
 <xref:System.ArithmeticException> wird ausgelöst, wenn `value` keine "normale" Zahl ist.  
  
 Beachten Sie, dass eine besondere Ausnahme oder eine abgeleitete Klasse von <xref:System.ArithmeticException> möglicherweise besser geeignet ist, indem Sie den falschen Wert an den Ausnahmehandler übergibt.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ckfinite` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Vergleicht zwei Werte. Wenn der erste Wert kleiner als der zweite Wert ist, wird der Ganzzahlwert 1 <see langword="(int32" />) auf dem Auswertungsstapel abgelegt, andernfalls wird 0 (<see langword="int32" />) auf dem Auswertungsstapel abgelegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|FE 04|CLT|Überträgt 1 `value1` , wenn kleiner als ist, andernfalls wird `value2` 0 gedrückt.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge: 

1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt. `clt` testet, ob `value1` kleiner als ist `value2` .  
  
4.  Wenn `value1` kleiner als ist `value2` , wird 1 auf den Stapel verschoben; andernfalls wird 0 auf den Stapel verschoben.  
  
 Die `clt` Anweisung vergleicht `value1` und `value2` . Wenn `value1` streng kleiner als ist `value2` , `int32` wird der Wert 1 auf dem Stapel abgelegt. Andernfalls `int32` wird der Wert 0 auf den Stapel verschoben.  
  
-   Gibt für Gleit Komma Zahlen `clt` den Wert 0 zurück, wenn die Zahlen nicht geordnet sind (d. h., wenn eines oder beide der Argumente Nan sind).  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `clt` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Vergleicht die Werte ohne Vorzeichen oder die ungeordneten Werte <paramref name="value1" /> und <paramref name="value2" />. Wenn <paramref name="value1" /> kleiner als <paramref name="value2" /> ist, wird der Ganzzahlwert 1 <see langword="(int32" />) auf dem Auswertungsstapel abgelegt, andernfalls wird 0 (<see langword="int32" />) auf dem Auswertungsstapel abgelegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|FE 05|CLT. UN|Überträgt 1 `value1` , wenn kleiner als ist; andernfalls wird `value2` 0 (nicht signierte Werte) übertragen.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt. `clt.un` testet, ob `value1` kleiner als ist `value2` .  
  
4.  Wenn `value1` kleiner als ist `value2` , wird 1 auf den Stapel verschoben; andernfalls wird 0 auf den Stapel verschoben.  
  
 Die `clt.un` Anweisung vergleicht `value1` und `value2` . Der `int32` Wert 1 wird auf dem Stapel abgelegt, wenn Folgendes zutrifft:  
  
-   `value1` ist streng kleiner als `value2` (wie für `clt` ).  
  
-   Für Gleit Komma Zahlen ist in `value1` Bezug auf nicht geordnet `value2` .  
  
-   Bei ganzzahligen Werten `value1` ist streng kleiner als, `value2` Wenn als nicht signierte Zahlen angesehen werden.  
  
 Andernfalls `int32` wird der Wert 0 auf den Stapel verschoben.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `clt.un` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Schränkt den Typ ein, für den eine virtuelle Methode aufgerufen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|FE 16 < `T` >|schwierige. `thisType`|Ruft eine virtuelle Methode für einen Typ auf, der auf Typ beschränkt ist `T` .|  
  
 Das- `constrained` Präfix ist nur für eine- `callvirt` Anweisung zulässig.  
  
 An diesem Punkt muss der Status des MSIL-Stapels lauten:  
  
1.  Ein verwalteter Zeiger, `ptr` , wird auf den Stapel verschoben. Der Typ von `ptr` muss ein verwalteter Zeiger ( `&` ) für sein `thisType` . Beachten Sie, dass sich dies von der Groß-/Kleinschreibung einer unvorhersehenden Anweisung unterscheidet `callvirt` , die einen Verweis von erwartet `thisType` .  
  
2.  Methodenargumente `arg1` bis `argN` werden wie bei einer unfixed-Anweisung auf den Stapel verschoben `callvirt` .  
  
 Das `constrained` Präfix ist so konzipiert, dass `callvirt` Anweisungen auf einheitliche Weise erstellt werden können, unabhängig davon, ob `thisType` ein Werttyp oder ein Verweistyp ist.  
  
 Wenn einer `callvirt` `method` Anweisung ein Präfix `constrained` `thisType` vorangestellt ist, wird die Anweisung wie folgt ausgeführt:  
  
-   Wenn `thisType` ein Verweistyp ist (im Gegensatz zu einem Werttyp) `ptr` , wird dereferenziert und als this-Zeiger an den von weiter `callvirt` gegeben `method` .  
  
-   Wenn `thisType` ein Werttyp ist `thisType` und `method` implementiert `ptr` , wird nicht geändert als ' this '-Zeiger an eine- `call` `method` Anweisung für die Implementierung von `method` durch weitergegeben `thisType` .  
  
-   Wenn `thisType` ein Werttyp ist und `thisType` nicht implementiert `method` `ptr` , wird dereferenziert, gekapselt und als this-Zeiger an die Anweisung weitergeleitet `callvirt` `method` .  
  
 Der letzte Fall kann nur auftreten `method` , wenn für <xref:System.Object> , oder definiert <xref:System.ValueType> <xref:System.Enum> und nicht von überschrieben wurde `thisType` . In diesem Fall bewirkt das Boxing, dass eine Kopie des ursprünglichen Objekts erstellt wird. Da jedoch keine der Methoden von <xref:System.Object> , <xref:System.ValueType> und <xref:System.Enum> den Status des Objekts ändert, kann dieser Fakt nicht erkannt werden.  
  
 Das `constrained` Präfix unterstützt Il-Generatoren, die generischen Code erstellen. Normalerweise `callvirt` ist die Anweisung für Werttypen ungültig. Stattdessen ist es erforderlich, dass Il-Compiler die oben beschriebene "This"-Transformation zum Zeitpunkt der Kompilierung ausführen, je nach Typ von `ptr` und der aufgerufenen Methode. Wenn jedoch `ptr` ein generischer Typ ist, der zur Kompilierzeit nicht bekannt ist, ist es nicht möglich, diese Transformation zur Kompilierzeit vorzunehmen.  
  
 Der `constrained` Opcode ermöglicht es Il-Compilern, eine virtuelle Funktion auf einheitliche Weise aufzurufen, unabhängig davon, ob `ptr` ein Werttyp oder ein Verweistyp ist. Obwohl es für den Fall vorgesehen ist `thisType` , dass eine generische Typvariable ist, `constrained` kann das Präfix auch für nicht generische Typen verwendet werden und die Komplexität beim Erstellen virtueller Aufrufe in Sprachen verringern, die den Unterschied zwischen Werttypen und Verweis Typen ausblenden.  
  
 Mit dem `constrained` Präfix werden auch potenzielle Versions Probleme mit Werttypen vermieden. Wenn das `constrained` Präfix nicht verwendet wird, müssen verschiedene Il ausgegeben werden, abhängig davon, ob ein Werttyp eine Methode von System. Object überschreibt. Wenn ein Werttyp z `V` . b. die Object. destring ()-Methode überschreibt, wird eine- `call` `V.ToString()` Anweisung ausgegeben; andernfalls `box` werden eine-Anweisung und eine-Anweisung `callvirt` `Object.ToString()` ausgegeben. Im ersten Fall kann ein Versions Problem auftreten, wenn die außer Kraft Setzung später entfernt wird, und im letzteren Fall, wenn eine außer Kraft Setzung später hinzugefügt wird.  
  
 Das `constrained` Präfix kann auch für den Aufruf von Schnittstellen Methoden für Werttypen verwendet werden, da die Werttyp Methode, die die Schnittstellen Methode implementiert, mit einem geändert werden kann `MethodImpl` . Wenn das `constrained` Präfix nicht verwendet wird, wird der Compiler gezwungen, auszuwählen, an welche Methode des Werttyps zur Kompilierzeit gebunden werden soll. Mit dem `constrained` Präfix kann die MSIL an die Methode binden, die die Schnittstellen Methode zur Laufzeit implementiert, anstatt zur Kompilierzeit.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `constrained` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|D3|. i|Konvertieren in `native int` , übertragen per Push `native int` auf den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.i` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und belassen den konvertierten Wert am Anfang des Stapels. Ganzzahlige Werte von weniger als 4 Bytes werden auf erweitert `int32` , wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.i` `conv.u` , oder wird verwendet. in diesem Fall ist das Ergebnis ebenfalls `native int` ). Gleit Komma Werte werden in den- `F` Typ konvertiert.  
  
 Durch die Konvertierung von Gleit Komma Zahlen in ganzzahlige Werte wird die Zahl in Richtung NULL abgeschnitten. Beim `float64` Umrechnen von einem in einen `float32` kann die Genauigkeit verloren gehen. Wenn zu `value` groß ist, um in einen zu passen `float32 (F)` , wird positiv unendlich (wenn `value` positiv ist) oder minus unendlich (wenn `value` negativ ist) zurückgegeben. Wenn beim Umrechnen eines ganzzahligen Typs in einen anderen ein Überlauf auftritt, werden die hohen Bestell Bits abgeschnitten. Wenn das Ergebnis kleiner als ein ist `int32` , ist der Wert "Sign-Extended", um den Slot auszufüllen.  
  
 Wenn beim Umrechnen eines Gleit Komma Typs in eine ganze Zahl ein Überlauf auftritt, wird der zurückgegebene Wert nicht angegeben.  
  
 Wenn dieses Feld verwendet wird, werden keine Ausnahmen ausgelöst. <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> Entsprechende Anweisungen, die eine Ausnahme auslösen, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann, finden Sie unter und.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.i` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="int8" /> und erweitert ihn dann zu <see langword="int32" /> (durch Auffüllen).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|67|"vs. I1"|Konvertieren in `int8` , übertragen per Push `int32` auf den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.i1` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und belassen den konvertierten Wert am Anfang des Stapels. Ganzzahlige Werte von weniger als 4 Bytes werden auf erweitert `int32` , wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.i` `conv.u` , oder wird verwendet. in diesem Fall ist das Ergebnis ebenfalls `native int` ). Gleit Komma Werte werden in den- `F` Typ konvertiert.  
  
 Durch die Konvertierung von Gleit Komma Zahlen in ganzzahlige Werte wird die Zahl in Richtung NULL abgeschnitten. Beim `float64` Umrechnen von einem in einen `float32` kann die Genauigkeit verloren gehen. Wenn zu `value` groß ist, um in einen zu passen `float32 (F)` , wird positiv unendlich (wenn `value` positiv ist) oder minus unendlich (wenn `value` negativ ist) zurückgegeben. Wenn beim Umrechnen eines ganzzahligen Typs in einen anderen ein Überlauf auftritt, werden die hohen Bestell Bits abgeschnitten. Wenn das Ergebnis kleiner als ein ist `int32` , ist der Wert "Sign-Extended", um den Slot auszufüllen.  
  
 Wenn beim Umrechnen eines Gleit Komma Typs in eine ganze Zahl ein Überlauf auftritt, wird der zurückgegebene Wert nicht angegeben.  
  
 Wenn dieses Feld verwendet wird, werden keine Ausnahmen ausgelöst. <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> Entsprechende Anweisungen, die eine Ausnahme auslösen, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann, finden Sie unter und.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.i1` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="int16" /> und erweitert ihn dann zu <see langword="int32" /> (durch Auffüllen).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|68|"vs. I2"|Konvertieren in `int16` , übertragen per Push `int32` auf den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.i2` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und belassen den konvertierten Wert am Anfang des Stapels. Ganzzahlige Werte von weniger als 4 Bytes werden auf erweitert `int32` , wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.i` `conv.u` , oder wird verwendet. in diesem Fall ist das Ergebnis ebenfalls `native int` ). Gleit Komma Werte werden in den- `F` Typ konvertiert.  
  
 Durch die Konvertierung von Gleit Komma Zahlen in ganzzahlige Werte wird die Zahl in Richtung NULL abgeschnitten. Beim `float64` Umrechnen von einem in einen `float32` kann die Genauigkeit verloren gehen. Wenn zu `value` groß ist, um in einen zu passen `float32 (F)` , wird positiv unendlich (wenn `value` positiv ist) oder minus unendlich (wenn `value` negativ ist) zurückgegeben. Wenn beim Umrechnen eines ganzzahligen Typs in einen anderen ein Überlauf auftritt, werden die hohen Bestell Bits abgeschnitten. Wenn das Ergebnis kleiner als ein ist `int32` , ist der Wert "Sign-Extended", um den Slot auszufüllen.  
  
 Wenn beim Umrechnen eines Gleit Komma Typs in eine ganze Zahl ein Überlauf auftritt, wird der zurückgegebene Wert nicht angegeben.  
  
 Wenn dieses Feld verwendet wird, werden keine Ausnahmen ausgelöst. <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> Entsprechende Anweisungen, die eine Ausnahme auslösen, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann, finden Sie unter und.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.i2` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|69|I4|Konvertieren in `int32` , übertragen per Push `int32` auf den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.i4` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und belassen den konvertierten Wert am Anfang des Stapels. Ganzzahlige Werte von weniger als 4 Bytes werden auf erweitert `int32` , wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.i` `conv.u` , oder wird verwendet. in diesem Fall ist das Ergebnis ebenfalls `native int` ). Gleit Komma Werte werden in den- `F` Typ konvertiert.  
  
 Durch die Konvertierung von Gleit Komma Zahlen in ganzzahlige Werte wird die Zahl in Richtung NULL abgeschnitten. Beim `float64` Umrechnen von einem in einen `float32` kann die Genauigkeit verloren gehen. Wenn zu `value` groß ist, um in einen zu passen `float32 (F)` , wird positiv unendlich (wenn `value` positiv ist) oder minus unendlich (wenn `value` negativ ist) zurückgegeben. Wenn beim Umrechnen eines ganzzahligen Typs in einen anderen ein Überlauf auftritt, werden die hohen Bestell Bits abgeschnitten. Wenn das Ergebnis kleiner als ein ist `int32` , ist der Wert "Sign-Extended", um den Slot auszufüllen.  
  
 Wenn beim Umrechnen eines Gleit Komma Typs in eine ganze Zahl ein Überlauf auftritt, wird der zurückgegebene Wert nicht angegeben.  
  
 Wenn dieses Feld verwendet wird, werden keine Ausnahmen ausgelöst. <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> Entsprechende Anweisungen, die eine Ausnahme auslösen, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann, finden Sie unter und.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.i4` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|6a|"vs. I8"|Konvertieren in `int64` , übertragen per Push `int64` auf den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.i8` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und belassen den konvertierten Wert am Anfang des Stapels. Ganzzahlige Werte von weniger als 4 Bytes werden auf erweitert `int32` , wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.i` `conv.u` , oder wird verwendet. in diesem Fall ist das Ergebnis ebenfalls `native int` ). Gleit Komma Werte werden in den- `F` Typ konvertiert.  
  
 Durch die Konvertierung von Gleit Komma Zahlen in ganzzahlige Werte wird die Zahl in Richtung NULL abgeschnitten. Beim `float64` Umrechnen von einem in einen `float32` kann die Genauigkeit verloren gehen. Wenn zu `value` groß ist, um in einen zu passen `float32 (F)` , wird positiv unendlich (wenn `value` positiv ist) oder minus unendlich (wenn `value` negativ ist) zurückgegeben. Wenn beim Umrechnen eines ganzzahligen Typs in einen anderen ein Überlauf auftritt, werden die hohen Bestell Bits abgeschnitten. Wenn das Ergebnis kleiner als ein ist `int32` , ist der Wert "Sign-Extended", um den Slot auszufüllen.  
  
 Wenn beim Umrechnen eines Gleit Komma Typs in eine ganze Zahl ein Überlauf auftritt, wird der zurückgegebene Wert nicht angegeben.  
  
 Wenn dieses Feld verwendet wird, werden keine Ausnahmen ausgelöst. <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> Entsprechende Anweisungen, die eine Ausnahme auslösen, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann, finden Sie unter und.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.i8` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="native int" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|D4|"". ovf. i|Konvertieren Sie in einen `native int` (auf dem Stapel als), und lösen Sie `native int` bei einem Überlauf eine Ausnahme aus.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.ovf.i` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels. Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null). Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf erweitert werden, `int32` Wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.ovf.i` `conv.ovf.u` , oder werden verwendet, in diesem Fall ist das Ergebnis ebenfalls `native int` ).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.ovf.i` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="native int" /> mit Vorzeichen und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|8a|". ovf. i. un"|Konvertiert einen Wert ohne Vorzeichen in einen `native int` (auf dem Stapel als `native int` ) und löst bei einem Überlauf eine Ausnahme aus.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.ovf.i.un` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels. Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null). Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf erweitert werden, `int32` Wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.ovf.i` `conv.ovf.u` , oder werden verwendet, in diesem Fall ist das Ergebnis ebenfalls `native int` ).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.ovf.i.un` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int8" /> mit Vorzeichen und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|B3|"c. ovf. I1"|Konvertieren Sie in einen `int8` (auf dem Stapel als), und lösen Sie `int32` bei einem Überlauf eine Ausnahme aus.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.ovf.i1` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels. Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null). Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf erweitert werden, `int32` Wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.ovf.i` `conv.ovf.u` , oder werden verwendet, in diesem Fall ist das Ergebnis ebenfalls `native int` ).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.ovf.i1` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int8" /> mit Vorzeichen und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|82|"c. ovf. I1. un"|Konvertiert einen Wert ohne Vorzeichen in einen `int8` (auf dem Stapel als `int32` ) und löst bei einem Überlauf eine Ausnahme aus.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.ovf.i1.un` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels. Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null). Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf erweitert werden, `int32` Wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.ovf.i` `conv.ovf.u` , oder werden verwendet, in diesem Fall ist das Ergebnis ebenfalls `native int` ).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.ovf.i1.un` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int16" /> mit Vorzeichen und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|B5|"c. ovf. I2"|Konvertieren Sie in einen `int16` (auf dem Stapel als), und lösen Sie `int32` bei einem Überlauf eine Ausnahme aus.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.ovf.i2` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels. Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null). Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf erweitert werden, `int32` Wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.ovf.i` `conv.ovf.u` , oder werden verwendet, in diesem Fall ist das Ergebnis ebenfalls `native int` ).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.ovf.i2` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int16" /> mit Vorzeichen und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|83|"c. ovf. I2. un"|Konvertiert einen Wert ohne Vorzeichen in einen `int16` (auf dem Stapel als `int32` ) und löst bei einem Überlauf eine Ausnahme aus.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.ovf.i2.un` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels. Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null). Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf erweitert werden, `int32` Wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.ovf.i` `conv.ovf.u` , oder werden verwendet, in diesem Fall ist das Ergebnis ebenfalls `native int` ).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.ovf.i2.un` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|B7|"c. ovf. I4"|Konvertieren Sie in einen `int32` (auf dem Stapel als), und lösen Sie `int32` bei einem Überlauf eine Ausnahme aus.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.ovf.i4` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels. Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null). Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf erweitert werden, `int32` Wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.ovf.i` `conv.ovf.u` , oder werden verwendet, in diesem Fall ist das Ergebnis ebenfalls `native int` ).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.ovf.i4` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int32" /> mit Vorzeichen und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|84|"c. ovf. I4. un"|Konvertiert einen Wert ohne Vorzeichen in einen `int32` (auf dem Stapel als `int32` ) und löst bei einem Überlauf eine Ausnahme aus.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.ovf.i4.un` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels. Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null). Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf erweitert werden, `int32` Wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.ovf.i` `conv.ovf.u` , oder werden verwendet, in diesem Fall ist das Ergebnis ebenfalls `native int` ).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.ovf.i4.un` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int64" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|B9|"c. ovf. I8"|Konvertieren Sie in einen `int64` (auf dem Stapel als), und lösen Sie `int64` bei einem Überlauf eine Ausnahme aus.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.ovf.i8` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels. Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null). Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf erweitert werden, `int32` Wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.ovf.i` `conv.ovf.u` , oder werden verwendet, in diesem Fall ist das Ergebnis ebenfalls `native int` ).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.ovf.i8` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="int64" /> mit Vorzeichen und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|85|"c. ovf. I8. un"|Konvertiert einen Wert ohne Vorzeichen in einen `int64` (auf dem Stapel als `int64` ) und löst bei einem Überlauf eine Ausnahme aus.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.ovf.i8.un` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels. Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null). Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf erweitert werden, `int32` Wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.ovf.i` `conv.ovf.u` , oder werden verwendet, in diesem Fall ist das Ergebnis ebenfalls `native int` ).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.ovf.i8.un` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned native int" /> und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|D5|"c. ovf. u"|Konvertieren Sie in einen `unsigned native int` (auf dem Stapel als), und lösen Sie `native int` bei einem Überlauf eine Ausnahme aus.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.ovf.u` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels. Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null). Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf erweitert werden, `int32` Wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.ovf.i` `conv.ovf.u` , oder werden verwendet, in diesem Fall ist das Ergebnis ebenfalls `native int` ).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.ovf.u` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned native int" /> und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|8B|"c. ovf. u. un"|Konvertiert den nicht signierten Wert in einen-Wert `unsigned native int` (auf dem Stapel als `native int` ) und löst bei einem Überlauf eine Ausnahme aus.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.ovf.u.un` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels. Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null). Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf erweitert werden, `int32` Wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.ovf.i` `conv.ovf.u` , oder werden verwendet, in diesem Fall ist das Ergebnis ebenfalls `native int` ).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.uvf.u.un` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int8" /> und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|B4|"c. ovf. U1"|Konvertieren Sie in einen `unsigned int8` (auf dem Stapel als), und lösen Sie `int32` bei einem Überlauf eine Ausnahme aus.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.ovf.u1` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels. Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null). Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf erweitert werden, `int32` Wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.ovf.i` `conv.ovf.u` , oder werden verwendet, in diesem Fall ist das Ergebnis ebenfalls `native int` ).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.ovf.u1` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int8" /> und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|86|"c. ovf. U1. un"|Konvertiert einen Wert ohne Vorzeichen in einen `unsigned int8` (auf dem Stapel als `int32` ) und löst bei einem Überlauf eine Ausnahme aus.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.ovf.u1.un` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels. Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null). Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf erweitert werden, `int32` Wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.ovf.i` `conv.ovf.u` , oder werden verwendet, in diesem Fall ist das Ergebnis ebenfalls `native int` ).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.ovf.u1.un` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int16" /> und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|B6|"c. ovf. U2"|Konvertieren Sie in einen `unsigned int16` (auf dem Stapel als), und lösen Sie `int32` bei einem Überlauf eine Ausnahme aus.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.ovf.u2` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels. Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null). Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf erweitert werden, `int32` Wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.ovf.i` `conv.ovf.u` , oder werden verwendet, in diesem Fall ist das Ergebnis ebenfalls `native int` ).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.ovf.u2` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int16" /> und erweitert ihn auf <see langword="int32" />. Bei einem Überlauf wird eine <see cref="T:System.OverflowException" /> ausgelöst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|87|"c. ovf. U2. un"|Konvertiert einen Wert ohne Vorzeichen in einen `unsigned int16` (auf dem Stapel als `int32` ) und löst bei einem Überlauf eine Ausnahme aus.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.ovf.u2.un` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels. Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null). Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf erweitert werden, `int32` Wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.ovf.i` `conv.ovf.u` , oder werden verwendet, in diesem Fall ist das Ergebnis ebenfalls `native int` ).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.ovf.u2.un` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int32" /> und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|B8|"c. ovf. U4"|Konvertieren Sie in einen `unsigned int32` (auf dem Stapel als), und lösen Sie `int32` bei einem Überlauf eine Ausnahme aus.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.ovf.u4` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels. Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null). Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf erweitert werden, `int32` Wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.ovf.i` `conv.ovf.u` , oder werden verwendet, in diesem Fall ist das Ergebnis ebenfalls `native int` ).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.ovf.u4` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int32" /> und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|88|"c. ovf. U4. un"|Konvertiert einen Wert ohne Vorzeichen in einen `unsigned int32` (auf dem Stapel als `int32` ) und löst bei einem Überlauf eine Ausnahme aus.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.ovf.u4.un` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels. Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null). Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf erweitert werden, `int32` Wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.ovf.i` `conv.ovf.u` , oder werden verwendet, in diesem Fall ist das Ergebnis ebenfalls `native int` ).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.ovf.u4.un` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert mit Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int64" /> und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|BA|"c. ovf. U8"|Konvertieren Sie in einen `unsigned int64` (auf dem Stapel als), und lösen Sie `int64` bei einem Überlauf eine Ausnahme aus.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.ovf.u8` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels. Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null). Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf erweitert werden, `int32` Wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.ovf.i` `conv.ovf.u` , oder werden verwendet, in diesem Fall ist das Ergebnis ebenfalls `native int` ).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.ovf.u8` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="unsigned int64" /> und löst bei einem Überlauf eine <see cref="T:System.OverflowException" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|89|"" "".|Konvertiert einen Wert ohne Vorzeichen in einen `unsigned int64` (auf dem Stapel als `int64` ) und löst bei einem Überlauf eine Ausnahme aus.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht. Wenn ein Überlauf auftritt, wird eine Ausnahme ausgelöst.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.ovf.u8.un` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und platziert den konvertierten Wert am Anfang des Stapels. Wenn der Wert zu groß oder zu klein ist, um durch den Zieltyp dargestellt zu werden, wird eine Ausnahme ausgelöst.  
  
 Konvertierungen von Gleit Komma Zahlen in ganzzahlige Werte kürzen die Zahl in Richtung 0 (null). Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf erweitert werden, `int32` Wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.ovf.i` `conv.ovf.u` , oder werden verwendet, in diesem Fall ist das Ergebnis ebenfalls `native int` ).  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.ovf.u8.un` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Ganzzahlwert ohne Vorzeichen an oberster Position des Auswertungsstapels in <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|76|". r. un"|Konvertiert eine Ganzzahl ohne Vorzeichen in einen Gleit Komma Wert, wobei auf dem Stapel abgelegt wird `F` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.r.un` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und belassen den konvertierten Wert am Anfang des Stapels. Ganzzahlige Werte von weniger als 4 Bytes werden auf erweitert `int32` , wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.i` `conv.u` , oder wird verwendet. in diesem Fall ist das Ergebnis ebenfalls `native int` ). Gleit Komma Werte werden in den- `F` Typ konvertiert.  
  
 Durch die Konvertierung von Gleit Komma Zahlen in ganzzahlige Werte wird die Zahl in Richtung NULL abgeschnitten. Beim `float64` Umrechnen von einem in einen `float32` kann die Genauigkeit verloren gehen. Wenn zu `value` groß ist, um in einen zu passen `float32 (F)` , wird positiv unendlich (wenn `value` positiv ist) oder minus unendlich (wenn `value` negativ ist) zurückgegeben. Wenn beim Umrechnen eines ganzzahligen Typs in einen anderen ein Überlauf auftritt, werden die hohen Bestell Bits abgeschnitten. Wenn das Ergebnis kleiner als ein ist `int32` , ist der Wert "Sign-Extended", um den Slot auszufüllen.  
  
 Wenn beim Umrechnen eines Gleit Komma Typs in eine ganze Zahl ein Überlauf auftritt, `result` wird der zurückgegebene nicht angegeben. Der `conv.r.un` Vorgang nimmt eine Ganzzahl aus dem Stapel, interpretiert sie als unsigned und ersetzt Sie durch eine Gleit Komma Zahl, die die ganze Zahl darstellt: entweder eine `float32` , wenn diese breit genug ist, um die ganze Zahl ohne Genauigkeits Verlust darzustellen, oder else a `float64` .  
  
 Wenn dieses Feld verwendet wird, werden keine Ausnahmen ausgelöst.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.r.un` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|6B|Configuration Manager|Konvertieren in `float32` , übertragen per Push `F` auf den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.r4` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und belassen den konvertierten Wert am Anfang des Stapels. Ganzzahlige Werte von weniger als 4 Bytes werden auf erweitert `int32` , wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.i` `conv.u` , oder wird verwendet. in diesem Fall ist das Ergebnis ebenfalls `native int` ). Gleit Komma Werte werden in den- `F` Typ konvertiert.  
  
 Durch die Konvertierung von Gleit Komma Zahlen in ganzzahlige Werte wird die Zahl in Richtung NULL abgeschnitten. Beim Umstellen von einem `float64` in einen `float32` kann die Genauigkeit verloren gehen. Wenn zu `value` groß ist, um in einen zu passen `float32 (F)` , wird positiv unendlich (wenn `value` positiv ist) oder minus unendlich (wenn `value` negativ ist) zurückgegeben. Wenn beim Umrechnen eines ganzzahligen Typs in einen anderen ein Überlauf auftritt, werden die hohen Bestell Bits abgeschnitten. Wenn das Ergebnis kleiner als ein ist `int32` , ist der Wert "Sign-Extended", um den Slot auszufüllen.  
  
 Wenn beim Umrechnen eines Gleit Komma Typs in eine ganze Zahl ein Überlauf auftritt, wird der zurückgegebene Wert nicht angegeben.  
  
 Wenn dieses Feld verwendet wird, werden keine Ausnahmen ausgelöst.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.r4` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="float64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|6C|"vs. R8"|Konvertieren in `float64` , übertragen per Push `F` auf den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.r8` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und belassen den konvertierten Wert am Anfang des Stapels. Ganzzahlige Werte von weniger als 4 Bytes werden auf erweitert `int32` , wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.i` `conv.u` , oder wird verwendet. in diesem Fall ist das Ergebnis ebenfalls `native int` ). Gleit Komma Werte werden in den- `F` Typ konvertiert.  
  
 Durch die Konvertierung von Gleit Komma Zahlen in ganzzahlige Werte wird die Zahl in Richtung NULL abgeschnitten. Beim Umstellen von einem `float64` in einen `float32` kann die Genauigkeit verloren gehen. Wenn zu `value` groß ist, um in einen zu passen `float32 (F)` , wird positiv unendlich (wenn `value` positiv ist) oder minus unendlich (wenn `value` negativ ist) zurückgegeben. Wenn beim Umrechnen eines ganzzahligen Typs in einen anderen ein Überlauf auftritt, werden die hohen Bestell Bits abgeschnitten. Wenn das Ergebnis kleiner als ein ist `int32` , ist der Wert "Sign-Extended", um den Slot auszufüllen.  
  
 Wenn beim Umrechnen eines Gleit Komma Typs in eine ganze Zahl ein Überlauf auftritt, wird der zurückgegebene Wert nicht angegeben.  
  
 Wenn dieses Feld verwendet wird, werden keine Ausnahmen ausgelöst.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.r8` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="unsigned native int" /> und erweitert ihn dann zu <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|E0|. u|Konvertieren in `unsigned native int` , übertragen per Push `native int` auf den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.u` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und belassen den konvertierten Wert am Anfang des Stapels. Ganzzahlige Werte von weniger als 4 Bytes werden auf erweitert `int32` , wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.i` `conv.u` , oder wird verwendet. in diesem Fall ist das Ergebnis ebenfalls `native int` ). Gleit Komma Werte werden in den- `F` Typ konvertiert.  
  
 Durch die Konvertierung von Gleit Komma Zahlen in ganzzahlige Werte wird die Zahl in Richtung NULL abgeschnitten. Beim Umstellen von einem `float64` in einen `float32` kann die Genauigkeit verloren gehen. Wenn zu `value` groß ist, um in einen zu passen `float32 (F)` , wird positiv unendlich (wenn `value` positiv ist) oder minus unendlich (wenn `value` negativ ist) zurückgegeben. Wenn beim Umrechnen eines ganzzahligen Typs in einen anderen ein Überlauf auftritt, werden die hohen Bestell Bits abgeschnitten. Wenn das Ergebnis kleiner als ein ist `int32` , ist der Wert "Sign-Extended", um den Slot auszufüllen.  
  
 Wenn beim Umrechnen eines Gleit Komma Typs in eine ganze Zahl ein Überlauf auftritt, wird der zurückgegebene Wert nicht angegeben.  
  
 Wenn dieses Feld verwendet wird, werden keine Ausnahmen ausgelöst. <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> Entsprechende Anweisungen, die eine Ausnahme auslösen, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann, finden Sie unter und.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.u` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="unsigned int8" /> und erweitert ihn dann zu <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|D2|"vs. U1"|Konvertieren in `int8` , übertragen per Push `int32` auf den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.u1` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und belassen den konvertierten Wert am Anfang des Stapels. Ganzzahlige Werte von weniger als 4 Bytes werden auf erweitert `int32` , wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.i` `conv.u` , oder wird verwendet. in diesem Fall ist das Ergebnis ebenfalls `native int` ). Gleit Komma Werte werden in den- `F` Typ konvertiert.  
  
 Durch die Konvertierung von Gleit Komma Zahlen in ganzzahlige Werte wird die Zahl in Richtung NULL abgeschnitten. Beim Umstellen von einem `float64` in einen `float32` kann die Genauigkeit verloren gehen. Wenn zu `value` groß ist, um in einen zu passen `float32 (F)` , wird positiv unendlich (wenn `value` positiv ist) oder minus unendlich (wenn `value` negativ ist) zurückgegeben. Wenn beim Umrechnen eines ganzzahligen Typs in einen anderen ein Überlauf auftritt, werden die hohen Bestell Bits abgeschnitten. Wenn das Ergebnis kleiner als ein ist `int32` , ist der Wert "Sign-Extended", um den Slot auszufüllen.  
  
 Wenn beim Umrechnen eines Gleit Komma Typs in eine ganze Zahl ein Überlauf auftritt, wird der zurückgegebene Wert nicht angegeben.  
  
 Wenn dieses Feld verwendet wird, werden keine Ausnahmen ausgelöst. <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> Entsprechende Anweisungen, die eine Ausnahme auslösen, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann, finden Sie unter und.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.u1` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="unsigned int16" /> und erweitert ihn dann zu <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|D1|"vs. U2"|Konvertieren in `int16` , übertragen per Push `int32` auf den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.u2` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und belassen den konvertierten Wert am Anfang des Stapels. Ganzzahlige Werte von weniger als 4 Bytes werden auf erweitert `int32` , wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.i` `conv.u` , oder wird verwendet. in diesem Fall ist das Ergebnis ebenfalls `native int` ). Gleit Komma Werte werden in den- `F` Typ konvertiert.  
  
 Durch die Konvertierung von Gleit Komma Zahlen in ganzzahlige Werte wird die Zahl in Richtung NULL abgeschnitten. Beim Umstellen von einem `float64` in einen `float32` kann die Genauigkeit verloren gehen. Wenn zu `value` groß ist, um in einen zu passen `float32 (F)` , wird positiv unendlich (wenn `value` positiv ist) oder minus unendlich (wenn `value` negativ ist) zurückgegeben. Wenn beim Umrechnen eines ganzzahligen Typs in einen anderen ein Überlauf auftritt, werden die hohen Bestell Bits abgeschnitten. Wenn das Ergebnis kleiner als ein ist `int32` , ist der Wert "Sign-Extended", um den Slot auszufüllen.  
  
 Wenn beim Umrechnen eines Gleit Komma Typs in eine ganze Zahl ein Überlauf auftritt, wird der zurückgegebene Wert nicht angegeben.  
  
 Wenn dieses Feld verwendet wird, werden keine Ausnahmen ausgelöst. <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> Entsprechende Anweisungen, die eine Ausnahme auslösen, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann, finden Sie unter und.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.u2` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="unsigned int32" /> und erweitert ihn dann zu <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|6d|"vs. U4"|Konvertieren in `unsigned int32` , übertragen per Push `int32` auf den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.u4` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und belassen den konvertierten Wert am Anfang des Stapels. Ganzzahlige Werte von weniger als 4 Bytes werden auf erweitert `int32` , wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.i` `conv.u` , oder wird verwendet. in diesem Fall ist das Ergebnis ebenfalls `native int` ). Gleit Komma Werte werden in den- `F` Typ konvertiert.  
  
 Durch die Konvertierung von Gleit Komma Zahlen in ganzzahlige Werte wird die Zahl in Richtung NULL abgeschnitten. Beim Umstellen von einem `float64` in einen `float32` kann die Genauigkeit verloren gehen. Wenn zu `value` groß ist, um in einen zu passen `float32 (F)` , wird positiv unendlich (wenn `value` positiv ist) oder minus unendlich (wenn `value` negativ ist) zurückgegeben. Wenn beim Umrechnen eines ganzzahligen Typs in einen anderen ein Überlauf auftritt, werden die hohen Bestell Bits abgeschnitten. Wenn das Ergebnis kleiner als ein ist `int32` , ist der Wert "Sign-Extended", um den Slot auszufüllen.  
  
 Wenn beim Umrechnen eines Gleit Komma Typs in eine ganze Zahl ein Überlauf auftritt, wird der zurückgegebene Wert nicht angegeben.  
  
 Wenn dieses Feld verwendet wird, werden keine Ausnahmen ausgelöst. <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> Entsprechende Anweisungen, die eine Ausnahme auslösen, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann, finden Sie unter und.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.u4` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert den Wert an oberster Position des Auswertungsstapels in <see langword="unsigned int64" /> und erweitert ihn dann zu <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|6E|"".|Konvertieren in `int64` , übertragen per Push `int64` auf den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt, und der Konvertierungs Vorgang wird versucht.  
  
3.  Wenn die Konvertierung erfolgreich ist, wird der resultierende Wert auf den Stapel verschoben.  
  
 Der `conv.u8` Opcode konvertiert das `value` an oberster Position des Stapels in den Typ, der im Opcode angegeben ist, und belassen den konvertierten Wert am Anfang des Stapels. Ganzzahlige Werte von weniger als 4 Bytes werden auf erweitert `int32` , wenn Sie auf den Auswertungs Stapel geladen werden (es sei denn `conv.i` `conv.u` , oder wird verwendet. in diesem Fall ist das Ergebnis ebenfalls `native int` ). Gleit Komma Werte werden in den- `F` Typ konvertiert.  
  
 Durch die Konvertierung von Gleit Komma Zahlen in ganzzahlige Werte wird die Zahl in Richtung NULL abgeschnitten. Beim Umstellen von einem `float64` in einen `float32` kann die Genauigkeit verloren gehen. Wenn zu `value` groß ist, um in einen zu passen `float32 (F)` , wird positiv unendlich (wenn `value` positiv ist) oder minus unendlich (wenn `value` negativ ist) zurückgegeben. Wenn beim Umrechnen eines ganzzahligen Typs in einen anderen ein Überlauf auftritt, werden die hohen Bestell Bits abgeschnitten. Wenn das Ergebnis kleiner als ein ist `int32` , ist der Wert "Sign-Extended", um den Slot auszufüllen.  
  
 Wenn beim Umrechnen eines Gleit Komma Typs in eine ganze Zahl ein Überlauf auftritt, wird der zurückgegebene Wert nicht angegeben.  
  
 Wenn dieses Feld verwendet wird, werden keine Ausnahmen ausgelöst. <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> Entsprechende Anweisungen, die eine Ausnahme auslösen, wenn der Ergebnistyp den Ergebniswert nicht ordnungsgemäß darstellen kann, finden Sie unter und.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `conv.u8` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopiert eine angegebene Anzahl von Bytes von einer Quelladresse an eine Zieladresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|FE 17|cpblk nicht vorhanden|Kopieren von Daten aus einem Speicherblock in einen anderen.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Die Zieladresse wird auf den Stapel verschoben.  
  
2.  Die Quelladresse wird auf den Stapel verschoben.  
  
3.  Die Anzahl der zu kopierenden Bytes wird auf den Stapel verschoben.  
  
4.  Die Anzahl von Bytes, die Quelladresse und die Zieladresse werden aus dem Stapel entfernt. die angegebene Anzahl von Bytes wird von der Quelladresse zur Zieladresse kopiert.  
  
 Die `cpblk` Anweisung kopiert eine Zahl (Typ `unsigned int32` ) von Bytes von einer Quelladresse (vom Typ `*` , `native int` oder `&` ) in eine Zieladresse (vom Typ `*` , `native int` oder `&` ). Das Verhalten von `cpblk` ist nicht angegeben, wenn sich die Quell-und Zielbereiche überlappen.  
  
 `cpblk` geht davon aus, dass sowohl Quell-als auch Ziel adressiert an der natürlichen Größe des Computers ausgerichtet sind. Der `cpblk` Anweisung kann unmittelbar die-Anweisung voranstehen `unaligned.<prefix>` , um anzugeben, dass entweder die Quelle oder das Ziel nicht ausgerichtet ist.  
  
 Der Vorgang der `cpblk` Anweisung kann durch eine unmittelbar vorangehende <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung geändert werden.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `cpblk` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopiert den Werttyp, der an der Adresse eines Objekts gespeichert ist (Typ <see langword="&amp;" />, <see langword="*" /> oder <see langword="native int" />), an die Adresse des Zielobjekts (Typ <see langword="&amp;" />, <see langword="*" /> oder <see langword="native int" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|70 < `T` >|cpobj `classTok`|Kopiert einen Werttyp aus einem Quell Objekt in ein Zielobjekt.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der Zielobjekt Verweis wird auf den Stapel verschoben.  
  
2.  Der Quell Objekt Verweis wird auf den Stapel verschoben.  
  
3.  Die zwei Objekt Verweise werden aus dem Stapel entfernt. der Werttyp an der Adresse des Quell Objekts wird in die Adresse des Zielobjekts kopiert.  
  
 Das Verhalten von `cpobj` ist nicht angegeben, wenn die Quell-und Zielobjekt Verweise keine Zeiger auf Instanzen der Klasse sind, die durch das-Klassen Token `classTok` ( `typeref` oder) dargestellt werden `typedef` , oder wenn keinen `classTok` Werttyp darstellt.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `cpobj` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dividiert zwei Werte und legt das Ergebnis als Gleitkommawert (Typ <see langword="F" />) oder Quotient (Typ <see langword="int32" />) auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|5B|div|Dividiert zwei Werte, um einen Quotienten oder Gleit Komma Ergebnis zurückzugeben.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt; `value1` wird durch dividiert `value2` .  
  
4.  Das Ergebnis wird auf den Stapel verschoben.  
  
 `result` = `value1` div Value2 erfüllt die folgenden Bedingungen:  
  
 &#124; `result` &#124; = &#124; `value1` &#124;/&#124; `value2` &#124; und:  
  
 Sign ( `result` ) = +, if Sign ( `value1` ) = Sign ( `value2` ) oder-, if Sign ( `value1` ) ~ = Sign ( `value2` )  
  
 Die `div` -Anweisung berechnet das Ergebnis und legt es auf dem Stapel ab.  
  
 Die ganzzahlige Division wird in Richtung NULL abgeschnitten.  
  
 Die Division einer endlichen Zahl durch null erzeugt den ordnungsgemäß signierten unendlichen Wert.  
  
 Die Division von NULL durch Null oder unendlich durch unendlich erzeugt den NaN-Wert (Not-A-Number). Eine Zahl, die durch unendlich dividiert wird, erzeugt einen Nullwert.  
  
 Ganzzahlige Vorgänge werden ausgelöst, <xref:System.ArithmeticException> Wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann. Dies kann vorkommen `value1` , wenn der maximale negative Wert ist und `value2` -1 ist.  
  
 Ganzzahlige Vorgänge lösen aus, <xref:System.DivideByZeroException> Wenn `value2` NULL ist.  
  
 Beachten Sie, dass auf Intel-basierten Plattformen eine <xref:System.OverflowException> bei der Berechnung von (minint div-1) ausgelöst wird. Gleit Komma Operationen lösen nie eine Ausnahme aus (Sie führen stattdessen Nane oder Unendlichkeiten aus).  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `div` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dividiert zwei Ganzzahlwerte ohne Vorzeichen und legt das Ergebnis (<see langword="int32" />) auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|5C|div. UN|Dividiert zwei Werte ohne Vorzeichen und gibt einen Quotienten zurück.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt; `value1` wird durch dividiert `value2` .  
  
4.  Das Ergebnis wird auf den Stapel verschoben.  
  
 Die `div.un` -Anweisung berechnet `value1` dividiert durch `value2` , wobei beide als ganze Zahlen ohne Vorzeichen verwendet werden, und legt den `result` auf dem Stapel ab.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `div.un` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopiert den obersten Wert auf dem Auswertungsstapel und legt die Kopie dann auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|25|dup|Dupliziert den Wert am Anfang des Stapels.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird für die Duplizierung aus dem Stapel entfernt.  
  
3.  `value` wird zurück auf den Stapel verschoben.  
  
4.  Ein doppelter Wert wird auf den Stapel verschoben.  
  
 Die `dup` Anweisung dupliziert das oberste Element des Stapels und lässt zwei identische Werte darüber aus.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `dup` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung von der <see langword="filter" />-Klausel einer Ausnahme zurück an den CLI-Ausnahmehandler (Common Language Infrastructure).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|FE 11|"endfilter"|End Filter-Klausel der Seh-Ausnahmebehandlung.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel entfernt. `endfilter` wird ausgeführt, und die Steuerung wird an den Ausnahmehandler übertragen.  
  
 `Value` (dieser Typ muss vom Typ sein `int32` und ist einer von einem bestimmten Satz von Werten) wird von der Filter Klausel zurückgegeben. Dies sollte einer der folgenden sein:  
  
-   `exception_continue_search` ( `value` = 0), um die Suche nach einem Ausnahmehandler fortzusetzen  
  
-   `exception_execute_handler` ( `value` = 1) zum Starten der zweiten Phase der Ausnahmebehandlung, bei der schließlich Blöcke ausgeführt werden, bis der Handler gefunden wird, der dieser Filter Klausel zugeordnet ist. Bei der Ermittlung wird der Handler ausgeführt.  
  
 Andere ganzzahlige Werte verursachen nicht angegebene Ergebnisse.  
  
 Der Einstiegspunkt eines Filters, wie in der Ausnahme Tabelle der Methode gezeigt, muss die erste Anweisung im Codeblock des Filters sein. Die `endfilter` Anweisung muss die letzte Anweisung im Codeblock des Filters sein (daher kann nur eine `endfilter` für einen einzelnen Filter Block vorhanden sein). Nachdem die `endfilter` Anweisung ausgeführt wurde, wird die Steuerung logisch zurück zum CLI-Mechanismus für die Ausnahmebehandlung.  
  
 Das Steuerelement kann nur über den Ausnahme Mechanismus in einen Filter Block übertragen werden. Das Steuerelement kann nicht aus einem Filter Block übertragen werden, es sei denn, es wird eine-Anweisung verwendet, `throw` oder die letzte-Anweisung wird ausgeführt `endfilter` . Ein-Block kann nicht `try` in einen-Block eingebettet werden `filter` . Wenn eine Ausnahme im-Block ausgelöst wird `filter` , wird Sie abgefangen, und der Wert 0 ( `exception_continue_search` ) wird zurückgegeben.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `endfilter` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überträgt die Steuerung aus der <see langword="fault" />-Klausel oder <see langword="finally" />-Klausel eines Ausnahmeblockes zurück an den CLI-Ausnahmehandler (Common Language Infrastructure).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|DC|"endfinally"<br /><br /> endfault|Beendet die- `finally` oder- `fault` Klausel eines Ausnahme Blocks.|  
  
 Es gibt keine Stapel Übergangs Verhaltensweisen für diese Anweisung.  
  
 `Endfinally` und `endfault` signalisieren das Ende der- `finally` oder- `fault` Klausel, sodass die Stapel Auflösung fortgesetzt werden kann, bis der Ausnahmehandler aufgerufen wird. Die- `endfinally` oder- `endfault` Anweisung überträgt die Steuerung zurück an den CLI-Ausnahme Mechanismus. Der Mechanismus sucht dann nach der nächsten `finally` Klausel in der Kette, wenn der geschützte Block mit einer LEAVE-Anweisung beendet wurde. Wenn der geschützte Block mit einer Ausnahme beendet wurde, sucht die CLI nach dem nächsten oder oder `finally` gibt `fault` den Ausnahmehandler ein, der beim ersten Durchlauf der Ausnahmebehandlung ausgewählt wurde.  
  
 Eine `endfinally` Anweisung kann nur lexikalisch innerhalb eines- `finally` Blocks vorkommen. Anders als bei der- `endfilter` Anweisung ist es nicht erforderlich, dass der-Block mit einer `endfinally` -Anweisung endet, und es können beliebig viele `endfinally` Anweisungen im Block vorhanden sein. Diese Einschränkungen gelten für die `endfault` -Anweisung und den- `fault` Block.  
  
 Das Steuerelement kann `finally` `fault` nur über den Ausnahme Mechanismus in einen-oder-Block übertragen werden. Das Steuerelement kann nicht aus einem-oder-Block übertragen werden, `finally` `fault` es sei denn, es wird eine- `throw` Anweisung verwendet oder die- `endfinally` Anweisung (oder `endfault` ) ausgeführt. Insbesondere ist es nicht möglich, einen `finally` (oder)-Block zu "ziehen" `fault` oder eine- <xref:System.Reflection.Emit.OpCodes.Ret> oder- <xref:System.Reflection.Emit.OpCodes.Leave> Anweisung innerhalb eines- `finally` oder-Blocks auszuführen `fault` .  
  
 Beachten Sie, dass die `endfault` `endfinally` Anweisungen und Aliase sind, die dem gleichen Opcode entsprechen.  
  
 Die folgende <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann den `endfinally` ( `endfault` )-Opcode und die- `ILGenerator` Methode verwenden <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A> .  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Initialisiert einen angegebenen Speicherblock an einer bestimmten Adresse mit einer angegebenen Größe und einem angegebenen Anfangswert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|FE 18|initblk|Legen Sie jeden Speicherort in einem Speicherblock auf einen angegebenen Wert fest.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Eine Startadresse wird auf den Stapel verschoben.  
  
2.  Ein Initialisierungs Wert wird auf den Stapel verschoben.  
  
3.  Die Anzahl der zu initialisierenden Bytes wird auf den Stapel verschoben.  
  
4.  Die Anzahl von Bytes, der Initialisierungs Wert und die Startadresse werden aus dem Stapel entfernt, und die Initialisierung erfolgt gemäß ihren Werten.  
  
 Mit der- `initblk` Anweisung wird die Anzahl ( `unsigned int32` ) von Bytes, beginnend bei der angegebenen Adresse (vom Typ `native int` , `&` oder `*` ), auf den Initialisierungs Wert (vom Typ `unsigned int8` ) festgelegt. `initblk` geht davon aus, dass die Anfangsadresse an der natürlichen Größe des Computers ausgerichtet ist.  
  
 Der Vorgang der `initblk` Anweisungen kann durch eine unmittelbar vorangehende <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung geändert werden.  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `initblk` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Initialisiert alle Felder des Werttyps an einer angegebenen Adresse mit einem NULL-Verweis oder dem Wert 0 des entsprechenden primitiven Typs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|FE 15 < `T` >|`initobj` `typeTok`|Initialisiert einen Werttyp.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Die Adresse des zu initialisierenden Werttyps wird auf den Stapel verschoben.  
  
2.  Die Adresse wird aus dem Stapel entfernt. der Werttyp bei der angegebenen Adresse wird als Typ initialisiert `typeTok` .  
  
 Die- `initobj` Anweisung initialisiert jedes Feld des Werttyps, der durch die übersetzte Adresse (vom Typ `native int` , `&` oder) angegeben wird `*` , mit einem NULL-Verweis oder 0 des entsprechenden primitiven Typs. Nachdem diese Methode aufgerufen wurde, kann die-Instanz aufgerufen werden, um eine Konstruktormethode aufzurufen. Wenn `typeTok` ein Verweistyp ist, hat diese Anweisung denselben Effekt wie `ldnull` gefolgt von `stind.ref` .  
  
 Im Gegensatz zu <xref:System.Reflection.Emit.OpCodes.Newobj> `initobj` ruft nicht die-Konstruktormethode auf. `Initobj` ist für die Initialisierung von Werttypen vorgesehen, während `newobj` zum Zuordnen und Initialisieren von-Objekten verwendet wird.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `initobj` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überprüft, ob ein Objektverweis (Typ <see langword="O" />) eine Instanz einer bestimmten Klasse ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|75 < `T` >|Isinst `class`|Testet, ob ein Objekt Verweis eine Instanz von ist `class` , wobei entweder ein NULL-Verweis oder eine Instanz dieser Klasse oder Schnittstelle zurückgegeben wird.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis wird auf den Stapel verschoben.  
  
2.  Der Objekt Verweis wird aus dem Stapel entfernt und getestet, um zu ermitteln, ob es sich um eine Instanz der Klasse handelt, die übergeben wird `class` .  
  
3.  Das Ergebnis (entweder ein Objekt Verweis oder ein NULL-Verweis) wird auf den Stapel verschoben.  
  
 `Class` ein Metadatentoken, das die gewünschte Klasse angibt. Wenn die-Klasse des-Objekts am Anfang des Stapels implementiert `class` (wenn `class` eine-Schnittstelle ist) oder eine abgeleitete Klasse von `class` (wenn `class` eine reguläre Klasse ist), wird Sie in den-Typ umgewandelt `class` , und das Ergebnis wird auf dem Stapel abgelegt, genau so, als ob <xref:System.Reflection.Emit.OpCodes.Castclass> aufgerufen wurde. Andernfalls wird ein NULL-Verweis auf dem Stapel abgelegt. Wenn der Objekt Verweis selbst ein NULL-Verweis ist, `isinst` gibt ebenfalls einen NULL-Verweis zurück.  
  
 <xref:System.TypeLoadException> wird ausgelöst, wenn die Klasse nicht gefunden werden kann. Dies wird in der Regel erkannt, wenn die MSIL-Anweisungen (Microsoft Intermediate Language) in systemeigenen Code anstatt zur Laufzeit konvertiert werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `isinst` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beendet die aktuelle Methode und wechselt zur angegebenen Methode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|27 < `T` >|"jmp" `method`|Aktuelle Methode beenden und zur angegebenen Methode springen.|  
  
 Es gibt keine Stapel Übergangs Verhaltensweisen für diese Anweisung.  
  
 Die `jmp` Anweisung (Jump) überträgt die Steuerung an die durch angegebene Methode `method` , die ein Metadatentoken für einen Methoden Verweis ist. Die aktuellen Argumente werden an die Ziel Methode übertragen.  
  
 Der Auswertungs Stapel muss leer sein, wenn diese Anweisung ausgeführt wird. Die Aufruf Konvention, die Anzahl und der Typ der Argumente an der Zieladresse müssen mit der der aktuellen Methode übereinstimmen.  
  
 Die `jmp` Anweisung kann nicht verwendet werden, um die Steuerung von einem-,-,-oder-Block zu übertragen `try` `filter` `catch` `finally` .  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `jmp` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt ein Argument, auf das ein angegebener Indexwert verweist, in den Stapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|< FE 09 `unsigned int16` >|ldarg `index`|Argument an auf `index` Stapel laden.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der Argument Wert at `index` wird auf den Stapel verschoben.  
  
 Mit der- `ldarg` Anweisung wird das Argument, das bei indiziert `index` ist, von 0 (null) auf den Auswertungs Stapel gedrückt. Die- `ldarg` Anweisung kann verwendet werden, um einen Werttyp oder einen primitiven Wert auf den Stapel zu laden, indem Sie ihn aus einem eingehenden Argument kopiert. Der Typ des Argument Werts ist mit dem Typ des Arguments identisch, wie in der Signatur der aktuellen Methode angegeben.  
  
 Für Prozeduren, die eine Argumentliste mit variabler Länge `ldarg` verwenden, kann die Anweisung nur für die anfänglichen Fixed-Argumente verwendet werden, nicht für die Argumente im Variablen Teil der Signatur (Weitere Informationen finden Sie in der <xref:System.Reflection.Emit.OpCodes.Arglist> Anweisung).  
  
 Argumente, die einen ganzzahligen Wert enthalten, der kleiner als 4 Bytes ist, werden auf den Typ erweitert, `int32` Wenn Sie auf dem Stapel geladen werden. Gleit Komma Werte werden auf Ihre systemeigene Größe (Typ `F` ) erweitert.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldarg` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Int16%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Argument am Index 0 in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|02|ldarg. 0|Argument 0 auf Stapel laden|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der Argument Wert bei Index 0 wird auf den Stapel verschoben.  
  
 Die- `ldarg.0` Anweisung ist eine effiziente Codierung zum Laden des Argument Werts bei Index 0.  
  
 Die- `ldarg.0` Anweisung legt das an 0 indizierte Argument auf dem Auswertungs Stapel ab. Die- `ldarg.0` Anweisung kann verwendet werden, um einen Werttyp oder einen primitiven Wert auf den Stapel zu laden, indem Sie ihn aus einem eingehenden Argument kopiert. Der Typ des Argument Werts ist mit dem Typ des Arguments identisch, wie in der Signatur der aktuellen Methode angegeben.  
  
 Argumente, die einen ganzzahligen Wert enthalten, der kleiner als 4 Bytes ist, werden auf den Typ erweitert, `int32` Wenn Sie auf dem Stapel geladen werden. Gleit Komma Werte werden auf Ihre systemeigene Größe (Typ `F` ) erweitert.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldarg.0` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Argument am Index 1 in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|03|ldarg. 1|Argument 1 auf Stapel laden.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der Argument Wert bei Index 1 wird auf den Stapel verschoben.  
  
 Die- `ldarg.1` Anweisung ist eine effiziente Codierung zum Laden des Argument Werts an Index 1.  
  
 Die- `ldarg.1` Anweisung legt das an 1 indizierte Argument auf dem Auswertungs Stapel ab. Die- `ldarg.1` Anweisung kann verwendet werden, um einen Werttyp oder einen primitiven Wert auf den Stapel zu laden, indem Sie ihn aus einem eingehenden Argument kopiert. Der Typ des Argument Werts ist mit dem Typ des Arguments identisch, wie in der Signatur der aktuellen Methode angegeben.  
  
 Argumente, die einen ganzzahligen Wert enthalten, der kleiner als 4 Bytes ist, werden auf den Typ erweitert, `int32` Wenn Sie auf dem Stapel geladen werden. Gleit Komma Werte werden auf Ihre systemeigene Größe (Typ `F` ) erweitert.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldarg.1` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Argument am Index 2 in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|04|ldarg. 2|Argument 2 auf Stapel laden.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der Argument Wert am Index 2 wird auf den Stapel verschoben.  
  
 Die- `ldarg.2` Anweisung ist eine effiziente Codierung zum Laden des Argument Werts am Index 2.  
  
 Die- `ldarg.2` Anweisung legt das an 2 indizierte Argument auf dem Auswertungs Stapel ab. Die- `ldarg.2` Anweisung kann verwendet werden, um einen Werttyp oder einen primitiven Wert auf den Stapel zu laden, indem Sie ihn aus einem eingehenden Argument kopiert. Der Typ des Argument Werts ist mit dem Typ des Arguments identisch, wie in der Signatur der aktuellen Methode angegeben.  
  
 Argumente, die einen ganzzahligen Wert enthalten, der kleiner als 4 Bytes ist, werden auf den Typ erweitert, `int32` Wenn Sie auf dem Stapel geladen werden. Gleit Komma Werte werden auf Ihre systemeigene Größe (Typ `F` ) erweitert.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldarg.2` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Argument am Index 3 in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|05|ldarg. 3|Argument 3 auf Stapel laden.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der Argument Wert am Index 3 wird auf den Stapel verschoben.  
  
 Die- `ldarg.3` Anweisung ist eine effiziente Codierung zum Laden des Argument Werts am Index 3.  
  
 Die- `ldarg.3` Anweisung legt das an 3 indizierte Argument auf dem Auswertungs Stapel ab. Die- `ldarg.3` Anweisung kann verwendet werden, um einen Werttyp oder einen primitiven Wert auf den Stapel zu laden, indem Sie ihn aus einem eingehenden Argument kopiert. Der Typ des Argument Werts ist mit dem Typ des Arguments identisch, wie in der Signatur der aktuellen Methode angegeben.  
  
 Argumente, die einen ganzzahligen Wert enthalten, der kleiner als 4 Bytes ist, werden auf den Typ erweitert, `int32` Wenn Sie auf dem Stapel geladen werden. Gleit Komma Werte werden auf Ihre systemeigene Größe (Typ `F` ) erweitert.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldarg.3` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Argument, auf das ein angegebener Kurzformindex verweist, in den Stapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|0E < `unsigned int8` >|ldarg. s `index`|Load-Argument an einem `index` Stapel, Kurzform.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der Argument Wert at `index` wird auf den Stapel verschoben.  
  
 Die- `ldarg.s` Anweisung ist eine effiziente Codierung zum Laden von Argumenten, die von 4 bis 255 indiziert werden.  
  
 Mit der- `ldarg.s` Anweisung wird das Argument, das bei indiziert `index` ist, von 0 (null) auf den Auswertungs Stapel gedrückt. Die- `ldarg.s` Anweisung kann verwendet werden, um einen Werttyp oder einen primitiven Wert auf den Stapel zu laden, indem Sie ihn aus einem eingehenden Argument kopiert. Der Typ des Argument Werts ist mit dem Typ des Arguments identisch, wie in der Signatur der aktuellen Methode angegeben.  
  
 Für Prozeduren, die eine Argumentliste mit variabler Länge `ldarg.s` verwenden, kann die Anweisung nur für die anfänglichen Fixed-Argumente verwendet werden, nicht für die Argumente im Variablen Teil der Signatur (Weitere Informationen finden Sie in der <xref:System.Reflection.Emit.OpCodes.Arglist> Anweisung).  
  
 Argumente, die einen ganzzahligen Wert enthalten, der kleiner als 4 Bytes ist, werden auf den Typ erweitert, `int32` Wenn Sie auf dem Stapel geladen werden. Gleit Komma Werte werden auf Ihre systemeigene Größe (Typ `F` ) erweitert.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldarg.s` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Byte%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt eine Argumentadresse in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|FE 0A < `unsigned int16` >|ldarga `index`|Ruft die Adresse des Arguments ab, das von indiziert wurde `index` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Die Adresse `addr` des Arguments, das von indiziert `index` wird, wird auf den Stapel verschoben.  
  
 Die- `ldarga` Anweisung ruft die Adresse (vom Typ `*` ) des Arguments ab, das von indiziert `index` wird, wobei Argumente von 0 oder höher indiziert werden. Die Adresse `addr` wird immer an einer natürlichen Grenze auf dem Zielcomputer ausgerichtet.  
  
 Für Prozeduren, die eine Argumentliste mit variabler Länge `ldarga` verwenden, kann die Anweisung nur für die anfänglichen Fixed-Argumente verwendet werden, nicht für die Argumente im Variablen Teil der Signatur.  
  
 `ldarga` wird für die Übergabe des by-ref-Parameters verwendet. In anderen Fällen <xref:System.Reflection.Emit.OpCodes.Ldarg> sollten und <xref:System.Reflection.Emit.OpCodes.Starg> verwendet werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldarga` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Int16%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt eine Argumentadresse in Kurzform in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|0F < `unsigned int8` >|ldarga. s `index`|Rufen Sie die Adresse des Arguments ab `index` , das in Kurzform indiziert ist.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Die Adresse `addr` des Arguments, das von indiziert `index` wird, wird auf den Stapel verschoben.  
  
 `ldarga.s` (die Kurzform von `ldarga` ) sollte für Argument Nummern 0 bis 255 verwendet werden und ist eine effizientere Codierung.  
  
 Die- `ldarga.s` Anweisung ruft die Adresse (vom Typ `*` ) des Arguments ab, das von indiziert `index` wird, wobei Argumente von 0 oder höher indiziert werden. Die Adresse `addr` wird immer an einer natürlichen Grenze auf dem Zielcomputer ausgerichtet.  
  
 Für Prozeduren, die eine Argumentliste mit variabler Länge `ldarga.s` verwenden, kann die Anweisung nur für die anfänglichen Fixed-Argumente verwendet werden, nicht für die Argumente im Variablen Teil der Signatur.  
  
 `ldarga.s` wird für die Übergabe des by-ref-Parameters verwendet. In anderen Fällen <xref:System.Reflection.Emit.OpCodes.Ldarg_S> sollten und <xref:System.Reflection.Emit.OpCodes.Starg_S> verwendet werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldarga.s` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Byte%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen bereitgestellten Wert vom Typ <see langword="int32" /> als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|20 < `int32` >|LDC. I4 `num`|Überträgt den Wert `num` auf den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der Wert `num` wird auf den Stapel verschoben.  
  
 Beachten Sie, dass es besondere kurze (und somit effizientere) Codierungen für die ganzen Zahlen (128 bis 127) und insbesondere für kurze Codierungen für-1 bis 8 gibt. Alle kurzen Codierungen schieben 4 Byte-Ganzzahlen auf dem Stapel. Längere Codierungen werden für 8-Byte-Ganzzahlen und 4-und 8-Byte-Gleit Komma Zahlen sowie für 4-Byte-Werte verwendet, die nicht in die Kurzform passen. Es gibt drei Möglichkeiten, eine ganzzahlige 8-Byte-Konstante auf den Stapel zu verschieben.  
  
 1. Verwenden Sie die <xref:System.Reflection.Emit.OpCodes.Ldc_I8> Anweisung für Konstanten, die in mehr als 32 Bits ausgedrückt werden muss.  
  
 2. Verwenden Sie die <xref:System.Reflection.Emit.OpCodes.Ldc_I4> Anweisung, gefolgt von einer <xref:System.Reflection.Emit.OpCodes.Conv_I8> für Konstanten, die 9 bis 32 Bits benötigen.  
  
 3. Verwenden Sie eine kurze Formular Anweisung gefolgt von einer <xref:System.Reflection.Emit.OpCodes.Conv_I8> für Konstanten, die in 8 oder weniger Bits ausgedrückt werden kann.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldc.i4` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Int32%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert 0 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|16|LDC. i 4.0|Überträgt 0 auf den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der Wert 0 wird auf den Stapel verschoben.  
  
 Dies ist eine spezielle kurze Codierung für den Push des ganzzahligen Werts 0. Alle speziellen kurzen Codierungen pushen 4 Byte-Ganzzahlen auf dem Stapel.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldc.i4.0` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert 1 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|17|LDC. i 4.1|Überträgt 1 auf den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der Wert 1 wird auf den Stapel verschoben.  
  
 Dies ist eine spezielle kurze Codierung für den Push des ganzzahligen Werts 1. Alle speziellen kurzen Codierungen pushen 4 Byte-Ganzzahlen auf dem Stapel.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldc.i4.1` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert 2 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|18|LDC. i 4.2|Überträgt 2 auf den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der Wert 2 wird auf den Stapel verschoben.  
  
 Dies ist eine spezielle kurze Codierung für den Push des ganzzahligen Werts 2. Alle speziellen kurzen Codierungen pushen 4 Byte-Ganzzahlen auf dem Stapel.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldc.i4.2` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert 3 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|19|LDC. i 4.3|Überträgt 3 auf den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der Wert 3 wird auf den Stapel verschoben.  
  
 Dies ist eine spezielle kurze Codierung für den Push des ganzzahligen Werts 3. Alle speziellen kurzen Codierungen pushen 4 Byte-Ganzzahlen auf dem Stapel.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldc.i4.3` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert 4 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|1A|LDC. i 4.4|Überträgt 4 auf den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der Wert 4 wird auf den Stapel verschoben.  
  
 Dies ist eine spezielle kurze Codierung für den Push des ganzzahligen Werts 4. Alle speziellen kurzen Codierungen pushen 4 Byte-Ganzzahlen auf dem Stapel.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldc.i4.4` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert 5 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|1B|LDC. i 4.5|Überträgt 5 auf den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der Wert 5 wird auf den Stapel verschoben.  
  
 Dies ist eine spezielle kurze Codierung für den Push des ganzzahligen Werts 5. Alle speziellen kurzen Codierungen pushen 4 Byte-Ganzzahlen auf dem Stapel.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldc.i4.5` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert 6 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|1C|LDC. i 4.6|Überträgt 6 auf den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der Wert 6 wird auf den Stapel verschoben.  
  
 Dies ist eine spezielle kurze Codierung für den Push des ganzzahligen Werts 6. Alle speziellen kurzen Codierungen pushen 4 Byte-Ganzzahlen auf dem Stapel.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldc.i4.6` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert 7 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|1D|LDC. i 4.7|Überträgt 7 auf den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der Wert 7 wird auf den Stapel verschoben.  
  
 Dies ist eine spezielle kurze Codierung für den Push des ganzzahligen Werts 7. Alle speziellen kurzen Codierungen pushen 4 Byte-Ganzzahlen auf dem Stapel.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldc.i4.7` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert 8 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|1E|LDC. i 4.8|Überträgt 8 auf den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der Wert 8 wird auf den Stapel verschoben.  
  
 Dies ist eine spezielle kurze Codierung für den Push des ganzzahligen Werts 8. Alle speziellen kurzen Codierungen pushen 4 Byte-Ganzzahlen auf dem Stapel.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldc.i4.8` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Ganzzahlwert -1 als <see langword="int32" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|15|LDC. I4. M1|Überträgt-1 auf den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der Wert-1 wird auf den Stapel verschoben.  
  
 Dies ist eine spezielle kurze Codierung für den Push des ganzzahligen Werts-1. Alle speziellen kurzen Codierungen pushen 4 Byte-Ganzzahlen auf dem Stapel.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldc.i4.m1` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den bereitgestellten <see langword="int8" />-Wert als <see langword="int32" />, Kurzform, auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|1F-< `int8` >|LDC. I4. s `num`|Überträgt `num` auf den Stapel als `int32` Kurzform.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der Wert `num` wird auf den Stapel verschoben.  
  
 `ldc.i4.s` ist eine effizientere Codierung, um die ganzen Zahlen zwischen-128 und 127 auf dem Auswertungs Stapel zu pushen.  
  
Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladungen können den `ldc.i4.s` Opcode verwenden:
  
- <xref:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Byte)?displayProperty=nameWithType>
- <xref:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.SByte)?displayProperty=nameWithType>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen bereitgestellten Wert vom Typ <see langword="int64" /> als <see langword="int64" /> auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|21 < `int64` >|LDC. I8 `num`|Überträgt `num` auf den Stapel als `int64` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der Wert `num` wird auf den Stapel verschoben.  
  
 Diese Codierung überträgt einen- `int64` Wert auf den Stapel.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldc.i8` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Int64%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen bereitgestellten Wert vom Typ <see langword="float32" /> als Typ <see langword="F" /> (Gleitkommawert) auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|22 < `float32` >|LDC. R4 `num`|Überträgt `num` auf den Stapel als `F` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der Wert `num` wird auf den Stapel verschoben.  
  
 Diese Codierung überträgt einen `float32` Wert auf den Stapel.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldc.r4` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Single%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen bereitgestellten Wert vom Typ <see langword="float64" /> als Typ <see langword="F" /> (Gleitkommawert) auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|23 < `float64` >|LDC. R8 `num`|Überträgt `num` auf den Stapel als `F` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der Wert `num` wird auf den Stapel verschoben.  
  
 Diese Codierung überträgt einen `float64` Wert auf den Stapel.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldc.r8` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Double%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element an einem angegebenen Arrayindex als der in der Anweisung angegebene Typ auf die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|A3-< `T` >|ldelta EM `typeTok`|Lädt das Element am `index` Anfang des Stapels als Typ `typeTok` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis `array` wird auf den Stapel verschoben.  
  
2.  Ein Indexwert `index` wird auf den Stapel verschoben.  
  
3.  `index` und `array` werden aus dem Stapel entfernt. der Wert, der an der Position `index` in gespeichert `array` wird, wird gesucht.  
  
4.  Der Wert wird auf den Stapel verschoben.  
  
 Die `ldelem` -Anweisung lädt den Wert des-Elements mit Index `index` (Type `native int` ) in das null basierte eindimensionale Array `array` und platziert Sie am Anfang des Stapels. Arrays sind Objekte und werden daher durch einen Wert des Typs dargestellt `O` .  
  
 Der Typ des Rückgabewerts wird durch das Token `typeTok` in der Anweisung angegeben.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst `index` , wenn negativ oder größer als die obere Grenze von ist `array` .  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldelem` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element mit dem Typ <see langword="native int" /> an einem angegebenen Arrayindex als <see langword="native int" /> auf die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|97|ldelta em. i|Lädt das Element mit dem Typ `native int` auf `index` dem Stapel Rand als `native int` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis `array` wird auf den Stapel verschoben.  
  
2.  Ein Indexwert `index` wird auf den Stapel verschoben.  
  
3.  `index` und `array` werden aus dem Stapel entfernt. der Wert, der an der Position `index` in gespeichert `array` wird, wird gesucht.  
  
4.  Der Wert wird auf den Stapel verschoben.  
  
 Die `ldelem.i` -Anweisung lädt den Wert des-Elements mit Index `index` (Type `native int` ) in das null basierte eindimensionale Array `array` und platziert Sie am Anfang des Stapels. Arrays sind Objekte und werden daher durch einen Wert des Typs dargestellt `O` .  
  
 Der Rückgabewert für `ldelem.i` ist `native int` .  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht) erweitert werden, `native int` Wenn Sie auf dem Auswertungs Stapel geladen werden.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst `index` , wenn negativ oder größer als die gebundene von ist `array` .  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldelem.i` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element mit dem Typ <see langword="int8" /> an einem angegebenen Arrayindex als <see langword="int32" /> an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|90|ldelta em. I1|Lädt das Element mit dem Typ `int8` auf `index` dem Stapel Rand als `int32` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis `array` wird auf den Stapel verschoben.  
  
2.  Ein Indexwert `index` wird auf den Stapel verschoben.  
  
3.  `index` und `array` werden aus dem Stapel entfernt. der Wert, der an der Position `index` in gespeichert `array` wird, wird gesucht.  
  
4.  Der Wert wird auf den Stapel verschoben.  
  
 Die `ldelem.i1` -Anweisung lädt den Wert des-Elements mit Index `index` (Type `native int` ) in das null basierte eindimensionale Array `array` und platziert Sie am Anfang des Stapels. Arrays sind Objekte und werden daher durch einen Wert des Typs dargestellt `O` .  
  
 Der Rückgabewert für `ldelem.i1` ist `int8` .  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht) erweitert werden, `native int` Wenn Sie auf dem Auswertungs Stapel geladen werden.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst `index` , wenn negativ oder größer als die gebundene von ist `array` .  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldelem.i1` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element mit dem Typ <see langword="int16" /> an einem angegebenen Arrayindex als <see langword="int32" /> an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|92|ldelta em. I2|Lädt das Element mit dem Typ `int16` auf `index` dem Stapel Rand als `int32` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis `array` wird auf den Stapel verschoben.  
  
2.  Ein Indexwert `index` wird auf den Stapel verschoben.  
  
3.  `index` und `array` werden aus dem Stapel entfernt. der Wert, der an der Position `index` in gespeichert `array` wird, wird gesucht.  
  
4.  Der Wert wird auf den Stapel verschoben.  
  
 Die `ldelem.i2` -Anweisung lädt den Wert des-Elements mit Index `index` (Type `native int` ) in das null basierte eindimensionale Array `array` und platziert Sie am Anfang des Stapels. Arrays sind Objekte und werden daher durch einen Wert des Typs dargestellt `O` .  
  
 Der Rückgabewert für `ldelem.i2` ist `int16` .  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht) erweitert werden, `native int` Wenn Sie auf dem Auswertungs Stapel geladen werden.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst `index` , wenn negativ oder größer als die gebundene von ist `array` .  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldelem.i2` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element mit dem Typ <see langword="int32" /> an einem angegebenen Arrayindex als <see langword="int32" /> an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|94|ldelta em. I4|Lädt das Element mit dem Typ `int32` auf `index` dem Stapel Rand als `int32` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis `array` wird auf den Stapel verschoben.  
  
2.  Ein Indexwert `index` wird auf den Stapel verschoben.  
  
3.  `index` und `array` werden aus dem Stapel entfernt. der Wert, der an der Position `index` in gespeichert `array` wird, wird gesucht.  
  
4.  Der Wert wird auf den Stapel verschoben.  
  
 Die `ldelem.i4` -Anweisung lädt den Wert des-Elements mit Index `index` (Type `native int` ) in das null basierte eindimensionale Array `array` und platziert Sie am Anfang des Stapels. Arrays sind Objekte und werden daher durch einen Wert des Typs dargestellt `O` .  
  
 Der Rückgabewert für `ldelem.i4` ist `int32` .  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht) erweitert werden, `native int` Wenn Sie auf dem Auswertungs Stapel geladen werden.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst `index` , wenn negativ oder größer als die gebundene von ist `array` .  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldelem.i4` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element mit dem Typ <see langword="int64" /> an einem angegebenen Arrayindex als <see langword="int64" /> an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|96|ldelta em. I8|Lädt das Element mit dem Typ `int64` auf `index` dem Stapel Rand als `int64` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis `array` wird auf den Stapel verschoben.  
  
2.  Ein Indexwert `index` wird auf den Stapel verschoben.  
  
3.  `index` und `array` werden aus dem Stapel entfernt. der Wert, der an der Position `index` in gespeichert `array` wird, wird gesucht.  
  
4.  Der Wert wird auf den Stapel verschoben.  
  
 Die `ldelem.i8` -Anweisung lädt den Wert des-Elements mit Index `index` (Type `native int` ) in das null basierte eindimensionale Array `array` und platziert Sie am Anfang des Stapels. Arrays sind Objekte und werden daher durch einen Wert des Typs dargestellt `O` .  
  
 Der Rückgabewert für `ldelem.i8` ist `int64` .  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht) erweitert werden, `native int` Wenn Sie auf dem Auswertungs Stapel geladen werden.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst `index` , wenn negativ oder größer als die gebundene von ist `array` .  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldelem.i8` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element vom Typ <see langword="float32" /> an einem angegebenen Arrayindex als Typ <see langword="F" /> (Gleitkommawert) an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|98|ldelta em. R4|Lädt das Element mit dem Typ `float32` an `index` der obersten Position des Stapels als Typ `F` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis `array` wird auf den Stapel verschoben.  
  
2.  Ein Indexwert `index` wird auf den Stapel verschoben.  
  
3.  `index` und `array` werden aus dem Stapel entfernt. der Wert, der an der Position `index` in gespeichert `array` wird, wird gesucht.  
  
4.  Der Wert wird auf den Stapel verschoben.  
  
 Die `ldelem.r4` -Anweisung lädt den Wert des-Elements mit Index `index` (Type `native int` ) in das null basierte eindimensionale Array `array` und platziert Sie am Anfang des Stapels. Arrays sind Objekte und werden daher durch einen Wert des Typs dargestellt `O` .  
  
 Der Rückgabewert für `ldelem.r4` ist `float32` .  
  
 Gleit Komma Werte werden `F` beim Laden in den Auswertungs Stapel in den Typ konvertiert.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst `index` , wenn negativ oder größer als die gebundene von ist `array` .  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldelem.r4` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element vom Typ <see langword="float64" /> an einem angegebenen Arrayindex als Typ <see langword="F" /> (Gleitkommawert) an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|99|ldelta em. R8|Lädt das Element mit dem Typ `float64` an `index` der obersten Position des Stapels als Typ `F` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis `array` wird auf den Stapel verschoben.  
  
2.  Ein Indexwert `index` wird auf den Stapel verschoben.  
  
3.  `index` und `array` werden aus dem Stapel entfernt. der Wert, der an der Position `index` in gespeichert `array` wird, wird gesucht.  
  
4.  Der Wert wird auf den Stapel verschoben.  
  
 Die `ldelem.r8` -Anweisung lädt den Wert des-Elements mit Index `index` (Type `native int` ) in das null basierte eindimensionale Array `array` und platziert Sie am Anfang des Stapels. Arrays sind Objekte und werden daher durch einen Wert des Typs dargestellt `O` .  
  
 Der Rückgabewert für `ldelem.r8` ist `float64` .  
  
 Gleit Komma Werte werden `F` beim Laden in den Auswertungs Stapel in den Typ konvertiert.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst `index` , wenn negativ oder größer als die gebundene von ist `array` .  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldelem.r8` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element mit Objektverweis an einem angegebenen Arrayindex als Typ <see langword="O" /> (Objektverweis) an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|9a|ldelta em. Ref|Lädt das Element mit einem Objekt Verweis an `index` der obersten Position des Stapels als Typ `O` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis `array` wird auf den Stapel verschoben.  
  
2.  Ein Indexwert `index` wird auf den Stapel verschoben.  
  
3.  `index` und `array` werden aus dem Stapel entfernt. der Wert, der an der Position `index` in gespeichert `array` wird, wird gesucht.  
  
4.  Der Wert wird auf den Stapel verschoben.  
  
 Die `ldelem.ref` -Anweisung lädt den Wert des-Elements mit Index `index` (Type `native int` ) in das null basierte eindimensionale Array `array` und platziert Sie am Anfang des Stapels. Arrays sind Objekte und werden daher durch einen Wert des Typs dargestellt `O` .  
  
 Der Rückgabewert für `ldelem.ref` ist vom Typ `O` (Objekt Verweis).  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst `index` , wenn negativ oder größer als die gebundene von ist `array` .  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldelem.ref` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element mit dem Typ <see langword="unsigned int8" /> an einem angegebenen Arrayindex als <see langword="int32" /> an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|91|ldelta em. U1|Lädt das Element mit dem Typ `unsigned int8` auf `index` dem Stapel Rand als `int32` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis `array` wird auf den Stapel verschoben.  
  
2.  Ein Indexwert `index` wird auf den Stapel verschoben.  
  
3.  `index` und `array` werden aus dem Stapel entfernt. der Wert, der an der Position `index` in gespeichert `array` wird, wird gesucht.  
  
4.  Der Wert wird auf den Stapel verschoben.  
  
 Die `ldelem.u1` -Anweisung lädt den Wert des-Elements mit Index `index` (Type `native int` ) in das null basierte eindimensionale Array `array` und platziert Sie am Anfang des Stapels. Arrays sind Objekte und werden daher durch einen Wert des Typs dargestellt `O` .  
  
 Der Rückgabewert für `ldelem.u1` ist `int8` .  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht) erweitert werden, `native int` Wenn Sie auf dem Auswertungs Stapel geladen werden.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst `index` , wenn negativ oder größer als die gebundene von ist `array` .  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldelem.u1` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element mit dem Typ <see langword="unsigned int16" /> an einem angegebenen Arrayindex als <see langword="int32" /> an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|93|ldelta em. U2|Lädt das Element mit dem Typ `unsigned int16` am Index als in den oberen Bereich des Stapels `int32` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis `array` wird auf den Stapel verschoben.  
  
2.  Ein Indexwert `index` wird auf den Stapel verschoben.  
  
3.  `index` und `array` werden aus dem Stapel entfernt. der Wert, der an der Position `index` in gespeichert `array` wird, wird gesucht.  
  
4.  Der Wert wird auf den Stapel verschoben.  
  
 Die `ldelem.u2` -Anweisung lädt den Wert des-Elements mit Index `index` (Type `native int` ) in das null basierte eindimensionale Array `array` und platziert Sie am Anfang des Stapels. Arrays sind Objekte und werden daher durch einen Wert des Typs dargestellt `O` .  
  
 Der Rückgabewert für `ldelem.u2` ist `int16` .  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht) erweitert werden, `native int` Wenn Sie auf dem Auswertungs Stapel geladen werden.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst `index` , wenn negativ oder größer als die gebundene von ist `array` .  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldelem.u2` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt das Element mit dem Typ <see langword="unsigned int32" /> an einem angegebenen Arrayindex als <see langword="int32" /> an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|95|ldelta em. U4|Lädt das Element mit dem Typ `unsigned int32` am Index als in den oberen Bereich des Stapels `int32` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis `array` wird auf den Stapel verschoben.  
  
2.  Ein Indexwert `index` wird auf den Stapel verschoben.  
  
3.  `index` und `array` werden aus dem Stapel entfernt. der Wert, der an der Position `index` in gespeichert `array` wird, wird gesucht.  
  
4.  Der Wert wird auf den Stapel verschoben.  
  
 Die `ldelem.u4` -Anweisung lädt den Wert des-Elements mit Index `index` (Type `native int` ) in das null basierte eindimensionale Array `array` und platziert Sie am Anfang des Stapels. Arrays sind Objekte und werden daher durch einen Wert des Typs dargestellt `O` .  
  
 Der Rückgabewert für `ldelem.u4` ist `int32` .  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht) erweitert werden, `native int` Wenn Sie auf dem Auswertungs Stapel geladen werden.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn Array keine Elemente des erforderlichen Typs enthält.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst `index` , wenn negativ oder größer als die gebundene von ist `array` .  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldelem.u4` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt die Adresse des Arrayelements an einem angegebenen Arrayindex als Typ <see langword="&amp;" /> (verwalteter Zeiger) an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|8f < `T` >|ldelta- `class`|Lädt die Adresse des Array Elements an `index` der obersten Position des Auswertungs Stapels als Typ `&` (verwalteter Zeiger).|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis `array` wird auf den Stapel verschoben.  
  
2.  Ein Indexwert `index` wird auf den Stapel verschoben.  
  
3.  `index` und `array` werden aus dem Stapel entfernt. die Adresse, die an der Position `index` in gespeichert `array` wird, wird gesucht.  
  
4.  Die Adresse wird auf den Stapel verschoben.  
  
 `ldelema`Wird verwendet, um die Adresse eines Objekts an einem bestimmten Index in einem Array von-Objekten (vom Typ `class` ) abzurufen. Die `ldelema` -Anweisung lädt die Adresse des Werts bei Index `index` (Type `native int` ) im Null basierten eindimensionalen Array `array` und platziert Sie am Anfang des Stapels. Arrays sind Objekte und werden daher durch einen Wert des Typs dargestellt `O` . Der Wert muss vom Typ sein, der `class` mit der-Anweisung übermittelt wurde.  
  
 Der Rückgabewert für `ldelema` ist ein verwalteter Zeiger (Typ `&` ).  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht) erweitert werden, `native int` Wenn Sie auf dem Auswertungs Stapel geladen werden.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst `index` , wenn negativ oder größer als die gebundene von ist `array` .  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldelema` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sucht den Wert eines Felds in dem Objekt, für das sich derzeit ein Verweis auf dem Auswertungsstapel befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|7B-< `T` >|ldfld `field`|Überträgt den Wert eines Felds in einem angegebenen-Objekt auf den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis (oder Zeiger) wird auf den Stapel verschoben.  
  
2.  Der Objekt Verweis (oder Zeiger) wird aus dem Stapel entfernt. der Wert des angegebenen Felds im-Objekt wurde gefunden.  
  
3.  Der im Feld gespeicherte Wert wird auf den Stapel verschoben.  
  
 Die- `ldfld` Anweisung legt den Wert eines Felds, das sich in einem-Objekt befindet, auf den Stapel. Das Objekt muss sich auf dem Stapel als Objekt Verweis (Typ `O` ), ein verwalteter Zeiger (Typ `&` ), ein nicht verwalteter Zeiger (Typ `native int` ), ein vorübergehender Zeiger (Typ `*` ) oder eine Instanz eines Werttyps befinden. Die Verwendung eines nicht verwalteten Zeigers ist in überprüfbarem Code nicht zulässig. Das-Feld des Objekts wird durch ein Metadatentoken angegeben, das auf einen Feldmember verweisen muss. Der Rückgabetyp ist der gleiche wie der, der dem Feld zugeordnet ist. Bei dem Feld kann es sich entweder um ein Instanzfeld (in diesem Fall darf es sich nicht um einen NULL-Verweis handeln) oder um ein statisches Feld handeln.  
  
 Der `ldfld` -Anweisung können entweder oder beide <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfixe und vorangestellt werden <xref:System.Reflection.Emit.OpCodes.Volatile> .  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn das Objekt NULL ist und das Feld nicht statisch ist.  
  
 <xref:System.MissingFieldException> wird ausgelöst, wenn das angegebene Feld in den Metadaten nicht gefunden wurde. Dies wird in der Regel geprüft, wenn MSIL-Anweisungen (Microsoft Intermediate Language) in systemeigenen Code konvertiert werden, nicht zur Laufzeit.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldfld` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.FieldInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sucht die Adresse eines Felds in dem Objekt, für das sich derzeit ein Verweis auf dem Auswertungsstapel befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|7C-< `T` >|ldflda `field`|Überträgt die Adresse von `field` in einem angegebenen-Objekt auf den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis (oder Zeiger) wird auf den Stapel verschoben.  
  
2.  Der Objekt Verweis (oder Zeiger) wird aus dem Stapel entfernt. die Adresse des angegebenen Felds im-Objekt wurde gefunden.  
  
3.  Die Adresse des angegebenen Felds wird auf den Stapel verschoben.  
  
 Die- `ldflda` Anweisung legt die Adresse eines Felds, das sich in einem-Objekt befindet, auf den Stapel. Das Objekt muss sich auf dem Stapel als Objekt Verweis (Typ `O` ), ein verwalteter Zeiger (Typ `&` ), ein nicht verwalteter Zeiger (Typ `native int` ), ein vorübergehender Zeiger (Typ `*` ) oder eine Instanz eines Werttyps befinden. Die Verwendung eines nicht verwalteten Zeigers ist in überprüfbarem Code nicht zulässig. Das-Feld des Objekts wird durch ein Metadatentoken angegeben, das auf einen Feldmember verweisen muss.  
  
 Der von zurückgegebene Wert `ldflda` ist ein verwalteter Zeiger (Typ `&` ), es sei denn, das Objekt wird als nicht verwalteter Zeiger auf den Stapel verschoben. in diesem Fall ist die Rückgabeadresse auch ein nicht verwalteter Zeiger (Typ `native int` ).  
  
 Der `ldflda` -Anweisung können entweder oder beide <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfixe und vorangestellt werden <xref:System.Reflection.Emit.OpCodes.Volatile> .  
  
 <xref:System.InvalidOperationException> wird ausgelöst, wenn sich das Objekt nicht innerhalb der Anwendungsdomäne befindet, von der aus auf das Objekt zugegriffen wird. Die Adresse eines Felds, das nicht in der Zugriffs Anwendungsdomäne ist, kann nicht geladen werden.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn das Objekt NULL ist und das Feld nicht statisch ist.  
  
 <xref:System.MissingFieldException> wird ausgelöst, wenn das angegebene Feld in den Metadaten nicht gefunden wurde. Dies wird in der Regel geprüft, wenn MSIL-Anweisungen (Microsoft Intermediate Language) in systemeigenen Code konvertiert werden, nicht zur Laufzeit.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldflda` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.FieldInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen nicht verwalteten Zeiger (Typ <see langword="native int" />) auf dem Auswertungsstapel ab. Dieser Zeiger zeigt auf den systemeigenen Code, der eine bestimmte Methode implementiert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|< FE 06 `T` >|ldftn `method`|Überträgt einen Zeiger auf eine Methode, `method` auf die von im Stapel verwiesen wird.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der nicht verwaltete Zeiger auf eine bestimmte Methode wird auf den Stapel verschoben.  
  
 Die jeweilige Methode ( `method` ) kann mithilfe der-Anweisung aufgerufen werden <xref:System.Reflection.Emit.OpCodes.Calli> , wenn Sie auf eine verwaltete Methode (oder einen Stub, der von verwaltetem zu nicht verwaltetem Code übergeht) verweist.  
  
 Der zurückgegebene Wert zeigt mithilfe der CLR-Aufruf Konvention auf nativen Code. Dieser Methoden Zeiger sollte nicht als Rückruf Routine an den nicht verwalteten nativen Code übergeben werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldftn` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="native int" /> indirekt als <see langword="native int" /> in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|4D|ldind. i|Lädt den `native int` Wert an `addr` der Adresse als in den Stapel `native int` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Eine Adresse wird auf den Stapel verschoben.  
  
2.  Die Adresse wird aus dem Stapel entfernt. der an der Adresse befindliche Wert wird abgerufen.  
  
3.  Der abgerufene Wert wird auf den Stapel verschoben.  
  
 Die `ldind.i` Anweisung lädt indirekt einen `native int` Wert aus der angegebenen Adresse (vom Typ `native int` , `&` oder *) als in den Stapel `native int` .  
  
 Alle `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende integrierte Wert Klasse angibt.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht) erweitert werden, `native int` Wenn Sie auf dem Auswertungs Stapel geladen werden. Gleit Komma Werte werden `F` beim Laden in den Auswertungs Stapel in den Typ konvertiert.  
  
 Die ordnungsgemäße Formatierung von Microsoft Intermediate Language (MSIL) stellt sicher, dass die `ldind` Anweisungen in Übereinstimmung mit dem Typ des Zeigers verwendet werden.  
  
 Die Adresse, die anfänglich auf den Stapel verschoben wird, muss an der natürlichen Größe von Objekten auf dem Computer ausgerichtet sein, oder es <xref:System.NullReferenceException> kann ein Vorkommen (siehe <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung für vorbeugende Measures). Die Ergebnisse aller MSIL-Anweisungen, die Adressen zurückgeben (z <xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga> . b. und), werden sicher ausgerichtet. Für Datentypen, die größer als 1 Byte sind, ist die Byte-Reihenfolge von der Ziel-CPU abhängig. Code, der von Byte Reihenfolge abhängt, kann möglicherweise nicht auf allen Plattformen ausgeführt werden  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldind.i` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="int8" /> indirekt als <see langword="int32" /> in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|46|ldind. I1|Lädt den `int8` Wert an `addr` der Adresse als in den Stapel `int32` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Eine Adresse wird auf den Stapel verschoben.  
  
2.  Die Adresse wird aus dem Stapel entfernt. der an der Adresse befindliche Wert wird abgerufen.  
  
3.  Der abgerufene Wert wird auf den Stapel verschoben. 
  
 Die `ldind.i1` Anweisung lädt indirekt einen `int8` Wert aus der angegebenen Adresse (vom Typ `native int` , `&` oder *) als in den Stapel `int32` .  
  
 Alle `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende integrierte Wert Klasse angibt.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht) erweitert werden, `native int` Wenn Sie auf dem Auswertungs Stapel geladen werden. Gleit Komma Werte werden `F` beim Laden in den Auswertungs Stapel in den Typ konvertiert.  
  
 Die ordnungsgemäße Formatierung von Microsoft Intermediate Language (MSIL) stellt sicher, dass die `ldind` Anweisungen in Übereinstimmung mit dem Typ des Zeigers verwendet werden.  
  
 Die Adresse, die anfänglich auf den Stapel verschoben wird, muss an der natürlichen Größe von Objekten auf dem Computer ausgerichtet sein, oder es <xref:System.NullReferenceException> kann ein Vorkommen (siehe <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung für vorbeugende Measures). Die Ergebnisse aller MSIL-Anweisungen, die Adressen zurückgeben (z <xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga> . b. und), werden sicher ausgerichtet. Für Datentypen, die größer als 1 Byte sind, ist die Byte-Reihenfolge von der Ziel-CPU abhängig. Code, der von Byte Reihenfolge abhängt, kann möglicherweise nicht auf allen Plattformen ausgeführt werden  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldind.i1` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="int16" /> indirekt als <see langword="int32" /> in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|48|ldind. I2|Lädt den `int16` Wert an `addr` der Adresse als in den Stapel `int32` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Eine Adresse wird auf den Stapel verschoben.  
  
2.  Die Adresse wird aus dem Stapel entfernt. der an der Adresse befindliche Wert wird abgerufen.  
  
3.  Der abgerufene Wert wird auf den Stapel verschoben.  
  
 Die `ldind.i2` Anweisung lädt indirekt einen `int16` Wert aus der angegebenen Adresse (vom Typ `native int` , `&` oder *) als in den Stapel `int32` .  
  
 Alle `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende integrierte Wert Klasse angibt.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht) erweitert werden, `native int` Wenn Sie auf dem Auswertungs Stapel geladen werden. Gleit Komma Werte werden `F` beim Laden in den Auswertungs Stapel in den Typ konvertiert.  
  
 Die ordnungsgemäße Formatierung von Microsoft Intermediate Language (MSIL) stellt sicher, dass die `ldind` Anweisungen in Übereinstimmung mit dem Typ des Zeigers verwendet werden.  
  
 Die Adresse, die anfänglich auf den Stapel verschoben wird, muss an der natürlichen Größe von Objekten auf dem Computer ausgerichtet sein, oder es <xref:System.NullReferenceException> kann ein Vorkommen (siehe <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung für vorbeugende Measures). Die Ergebnisse aller MSIL-Anweisungen, die Adressen zurückgeben (z <xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga> . b. und), werden sicher ausgerichtet. Für Datentypen, die größer als 1 Byte sind, ist die Byte-Reihenfolge von der Ziel-CPU abhängig. Code, der von Byte Reihenfolge abhängt, kann möglicherweise nicht auf allen Plattformen ausgeführt werden  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldind.i2` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="int32" /> indirekt als <see langword="int32" /> in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|4a|ldind. I4|Lädt den `int32` Wert an `addr` der Adresse als in den Stapel `int32` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Eine Adresse wird auf den Stapel verschoben.  
  
2.  Die Adresse wird aus dem Stapel entfernt. der an der Adresse befindliche Wert wird abgerufen.  
  
3.  Der abgerufene Wert wird auf den Stapel verschoben.  
  
 Die `ldind.i4` Anweisung lädt indirekt einen `int32` Wert aus der angegebenen Adresse (vom Typ `native int` , `&` oder *) als in den Stapel `int32` .  
  
 Alle `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende integrierte Wert Klasse angibt.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht) erweitert werden, `native int` Wenn Sie auf dem Auswertungs Stapel geladen werden. Gleit Komma Werte werden `F` beim Laden in den Auswertungs Stapel in den Typ konvertiert.  
  
 Die ordnungsgemäße Formatierung von Microsoft Intermediate Language (MSIL) stellt sicher, dass die `ldind` Anweisungen in Übereinstimmung mit dem Typ des Zeigers verwendet werden.  
  
 Die Adresse, die anfänglich auf den Stapel verschoben wird, muss an der natürlichen Größe von Objekten auf dem Computer ausgerichtet sein, oder es <xref:System.NullReferenceException> kann ein Vorkommen (siehe <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung für vorbeugende Measures). Die Ergebnisse aller MSIL-Anweisungen, die Adressen zurückgeben (z <xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga> . b. und), werden sicher ausgerichtet. Für Datentypen, die größer als 1 Byte sind, ist die Byte-Reihenfolge von der Ziel-CPU abhängig. Code, der von Byte Reihenfolge abhängt, kann möglicherweise nicht auf allen Plattformen ausgeführt werden  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldind.i4` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="int64" /> indirekt als <see langword="int64" /> in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|4C|ldind. I8|Lädt den `int64` Wert an `addr` der Adresse als in den Stapel `int64` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Eine Adresse wird auf den Stapel verschoben.  
  
2.  Die Adresse wird aus dem Stapel entfernt. der an der Adresse befindliche Wert wird abgerufen.  
  
3.  Der abgerufene Wert wird auf den Stapel verschoben.  
  
 Die `ldind.i8` Anweisung lädt indirekt einen `int64` Wert aus der angegebenen Adresse (vom Typ `native int` , `&` oder *) als in den Stapel `int64` .  
  
 Alle `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende integrierte Wert Klasse angibt.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht) erweitert werden, `native int` Wenn Sie auf dem Auswertungs Stapel geladen werden. Gleit Komma Werte werden `F` beim Laden in den Auswertungs Stapel in den Typ konvertiert.  
  
 Die ordnungsgemäße Formatierung von Microsoft Intermediate Language (MSIL) stellt sicher, dass die `ldind` Anweisungen in Übereinstimmung mit dem Typ des Zeigers verwendet werden.  
  
 Die Adresse, die anfänglich auf den Stapel verschoben wird, muss an der natürlichen Größe von Objekten auf dem Computer ausgerichtet sein, oder es <xref:System.NullReferenceException> kann ein Vorkommen (siehe <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung für vorbeugende Measures). Die Ergebnisse aller MSIL-Anweisungen, die Adressen zurückgeben (z <xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga> . b. und), werden sicher ausgerichtet. Für Datentypen, die größer als 1 Byte sind, ist die Byte-Reihenfolge von der Ziel-CPU abhängig. Code, der von Byte Reihenfolge abhängt, kann möglicherweise nicht auf allen Plattformen ausgeführt werden  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldind.i8` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="float32" /> indirekt als Typ <see langword="F" /> (Gleitkommawert) in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|4E|ldind. R4|Lädt den `float32` Wert an `addr` der Adresse als Typ auf den Stapel `F` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Eine Adresse wird auf den Stapel verschoben.  
  
2.  Die Adresse wird aus dem Stapel entfernt. der an der Adresse befindliche Wert wird abgerufen.  
  
3.  Der abgerufene Wert wird auf den Stapel verschoben.  
  
 Die `ldind.r4` Anweisung lädt indirekt einen `float32` Wert aus der angegebenen Adresse (vom Typ `native int` , `&` oder *) als Typ auf den Stapel `F` .  
  
 Alle `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende integrierte Wert Klasse angibt.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht) erweitert werden, `native int` Wenn Sie auf dem Auswertungs Stapel geladen werden. Gleit Komma Werte werden `F` beim Laden in den Auswertungs Stapel in den Typ konvertiert.  
  
 Die ordnungsgemäße Formatierung von Microsoft Intermediate Language (MSIL) stellt sicher, dass die `ldind` Anweisungen in Übereinstimmung mit dem Typ des Zeigers verwendet werden.  
  
 Die Adresse, die anfänglich auf den Stapel verschoben wird, muss an der natürlichen Größe von Objekten auf dem Computer ausgerichtet sein, oder es <xref:System.NullReferenceException> kann ein Vorkommen (siehe <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung für vorbeugende Measures). Die Ergebnisse aller MSIL-Anweisungen, die Adressen zurückgeben (z <xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga> . b. und), werden sicher ausgerichtet. Für Datentypen, die größer als 1 Byte sind, ist die Byte-Reihenfolge von der Ziel-CPU abhängig. Code, der von Byte Reihenfolge abhängt, kann möglicherweise nicht auf allen Plattformen ausgeführt werden  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldind.r4` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="float64" /> indirekt als Typ <see langword="F" /> (Gleitkommawert) in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|4f|ldind. R8|Lädt den `float64` Wert an `addr` der Adresse als Typ auf den Stapel `F` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Eine Adresse wird auf den Stapel verschoben.  
  
2.  Die Adresse wird aus dem Stapel entfernt. der an der Adresse befindliche Wert wird abgerufen.  
  
3.  Der abgerufene Wert wird auf den Stapel verschoben.  
  
 Die `ldind.r8` Anweisung lädt indirekt einen `float64` Wert aus der angegebenen Adresse (vom Typ `native int` , `&` oder *) als in den Stapel `float64` .  
  
 Alle `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende integrierte Wert Klasse angibt.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht) erweitert werden, `native int` Wenn Sie auf dem Auswertungs Stapel geladen werden. Gleit Komma Werte werden `F` beim Laden in den Auswertungs Stapel in den Typ konvertiert.  
  
 Die ordnungsgemäße Formatierung von Microsoft Intermediate Language (MSIL) stellt sicher, dass die `ldind` Anweisungen in Übereinstimmung mit dem Typ des Zeigers verwendet werden.  
  
 Die Adresse, die anfänglich auf den Stapel verschoben wird, muss an der natürlichen Größe von Objekten auf dem Computer ausgerichtet sein, oder es <xref:System.NullReferenceException> kann ein Vorkommen (siehe <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung für vorbeugende Measures). Die Ergebnisse aller MSIL-Anweisungen, die Adressen zurückgeben (z <xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga> . b. und), werden sicher ausgerichtet. Für Datentypen, die größer als 1 Byte sind, ist die Byte-Reihenfolge von der Ziel-CPU abhängig. Code, der von Byte Reihenfolge abhängt, kann möglicherweise nicht auf allen Plattformen ausgeführt werden  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldind.r8` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Objektverweis indirekt als Typ <see langword="O" /> (Objektverweis) in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|50|ldind. Ref|Lädt den Objekt Verweis an `addr` der Adresse als Typ auf den Stapel. `O`|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Eine Adresse wird auf den Stapel verschoben.  
  
2.  Die Adresse wird aus dem Stapel entfernt. der Objekt Verweis an der Adresse wird abgerufen.  
  
3.  Der abgerufene Verweis wird auf den Stapel verschoben.  
  
 Die `ldind.ref` Anweisung lädt das Objekt, auf das die angegebene Adresse (vom Typ `native int` , `&` oder *) verweist, indirekt als Typ in den Stapel `O` .  
  
 Alle `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende integrierte Wert Klasse angibt.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht) erweitert werden, `native int` Wenn Sie auf dem Auswertungs Stapel geladen werden. Gleit Komma Werte werden `F` beim Laden in den Auswertungs Stapel in den Typ konvertiert.  
  
 Die ordnungsgemäße Formatierung von Microsoft Intermediate Language (MSIL) stellt sicher, dass die `ldind` Anweisungen in Übereinstimmung mit dem Typ des Zeigers verwendet werden.  
  
 Die Adresse, die anfänglich auf den Stapel verschoben wird, muss an der natürlichen Größe von Objekten auf dem Computer ausgerichtet sein, oder es <xref:System.NullReferenceException> kann ein Vorkommen (siehe <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung für vorbeugende Measures). Die Ergebnisse aller MSIL-Anweisungen, die Adressen zurückgeben (z <xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga> . b. und), werden sicher ausgerichtet. Für Datentypen, die größer als 1 Byte sind, ist die Byte-Reihenfolge von der Ziel-CPU abhängig. Code, der von Byte Reihenfolge abhängt, kann möglicherweise nicht auf allen Plattformen ausgeführt werden  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldind.ref` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="unsigned int8" /> indirekt als <see langword="int32" /> in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|47|ldind. U1|Lädt den `unsigned int8` Wert an `addr` der Adresse als in den Stapel `int32` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Eine Adresse wird auf den Stapel verschoben.  
  
2.  Die Adresse wird aus dem Stapel entfernt. der an der Adresse befindliche Wert wird abgerufen.  
  
3.  Der abgerufene Wert wird auf den Stapel verschoben.  
  
 Die `ldind.u1` Anweisung lädt indirekt einen `unsigned int8` Wert aus der angegebenen Adresse (vom Typ `native int` , `&` oder *) als in den Stapel `int32` .  
  
 Alle `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende integrierte Wert Klasse angibt.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht) erweitert werden, `native int` Wenn Sie auf dem Auswertungs Stapel geladen werden. Gleit Komma Werte werden `F` beim Laden in den Auswertungs Stapel in den Typ konvertiert.  
  
 Die ordnungsgemäße Formatierung von Microsoft Intermediate Language (MSIL) stellt sicher, dass die `ldind` Anweisungen in Übereinstimmung mit dem Typ des Zeigers verwendet werden.  
  
 Die Adresse, die anfänglich auf den Stapel verschoben wird, muss an der natürlichen Größe von Objekten auf dem Computer ausgerichtet sein, oder es <xref:System.NullReferenceException> kann ein Vorkommen (siehe <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung für vorbeugende Measures). Die Ergebnisse aller MSIL-Anweisungen, die Adressen zurückgeben (z <xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga> . b. und), werden sicher ausgerichtet. Für Datentypen, die größer als 1 Byte sind, ist die Byte-Reihenfolge von der Ziel-CPU abhängig. Code, der von Byte Reihenfolge abhängt, kann möglicherweise nicht auf allen Plattformen ausgeführt werden  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldind.u1` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="unsigned int16" /> indirekt als <see langword="int32" /> in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|49|ldind. U2|Lädt den `unsigned int16` Wert an `addr` der Adresse als in den Stapel `int32` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Eine Adresse wird auf den Stapel verschoben.  
  
2.  Die Adresse wird aus dem Stapel entfernt. der an der Adresse befindliche Wert wird abgerufen.  
  
3.  Der abgerufene Wert wird auf den Stapel verschoben.  
  
 Die `ldind.u2` Anweisung lädt indirekt einen `unsigned int16` Wert aus der angegebenen Adresse (vom Typ `native int` , `&` oder *) als in den Stapel `int32` .  
  
 Alle `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende integrierte Wert Klasse angibt.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht) erweitert werden, `native int` Wenn Sie auf dem Auswertungs Stapel geladen werden. Gleit Komma Werte werden `F` beim Laden in den Auswertungs Stapel in den Typ konvertiert.  
  
 Die ordnungsgemäße Formatierung von Microsoft Intermediate Language (MSIL) stellt sicher, dass die `ldind` Anweisungen in Übereinstimmung mit dem Typ des Zeigers verwendet werden.  
  
 Die Adresse, die anfänglich auf den Stapel verschoben wird, muss an der natürlichen Größe von Objekten auf dem Computer ausgerichtet sein, oder es <xref:System.NullReferenceException> kann ein Vorkommen (siehe <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung für vorbeugende Measures). Die Ergebnisse aller MSIL-Anweisungen, die Adressen zurückgeben (z <xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga> . b. und), werden sicher ausgerichtet. Für Datentypen, die größer als 1 Byte sind, ist die Byte-Reihenfolge von der Ziel-CPU abhängig. Code, der von Byte Reihenfolge abhängt, kann möglicherweise nicht auf allen Plattformen ausgeführt werden  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldind.u2` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt einen Wert vom Typ <see langword="unsigned int32" /> indirekt als <see langword="int32" /> in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|4B|ldind. U4|Lädt den `unsigned int32` Wert an `addr` der Adresse als in den Stapel `int32` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Eine Adresse wird auf den Stapel verschoben.  
  
2.  Die Adresse wird aus dem Stapel entfernt. der an der Adresse befindliche Wert wird abgerufen.  
  
3.  Der abgerufene Wert wird auf den Stapel verschoben.  
  
 Die `ldind.u4` Anweisung lädt indirekt einen `unsigned int32` Wert aus der angegebenen Adresse (vom Typ `native int` , `&` oder *) als in den Stapel `int32` .  
  
 Alle `ldind` Anweisungen sind Verknüpfungen für eine <xref:System.Reflection.Emit.OpCodes.Ldobj> Anweisung, die die entsprechende integrierte Wert Klasse angibt.  
  
 Beachten Sie, dass ganzzahlige Werte von weniger als 4 Bytes auf `int32` (nicht) erweitert werden, `native int` Wenn Sie auf dem Auswertungs Stapel geladen werden. Gleit Komma Werte werden `F` beim Laden in den Auswertungs Stapel in den Typ konvertiert.  
  
 Die ordnungsgemäße Formatierung von Microsoft Intermediate Language (MSIL) stellt sicher, dass die `ldind` Anweisungen in Übereinstimmung mit dem Typ des Zeigers verwendet werden.  
  
 Die Adresse, die anfänglich auf den Stapel verschoben wird, muss an der natürlichen Größe von Objekten auf dem Computer ausgerichtet sein, oder es <xref:System.NullReferenceException> kann ein Vorkommen (siehe <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung für vorbeugende Measures). Die Ergebnisse aller MSIL-Anweisungen, die Adressen zurückgeben (z <xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga> . b. und), werden sicher ausgerichtet. Für Datentypen, die größer als 1 Byte sind, ist die Byte-Reihenfolge von der Ziel-CPU abhängig. Code, der von Byte Reihenfolge abhängt, kann möglicherweise nicht auf allen Plattformen ausgeführt werden  
  
 <xref:System.NullReferenceException> kann ausgelöst werden, wenn eine ungültige Adresse erkannt wird.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldind.u4` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt die Anzahl der Elemente eines nullbasierten, eindimensionalen Arrays auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|8E|Ldlen|Legt die Länge (vom Typ `natural unsigned int` ) eines Arrays auf dem Stapel ab.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis auf ein Array wird auf dem Stapel abgelegt.  
  
2.  Der Array Verweis wird aus dem Stapel entfernt, und die Länge wird berechnet.  
  
3.  Die Länge wird auf den Stapel verschoben.  
  
 Arrays sind Objekte und werden daher durch einen Wert des Typs dargestellt `O` . Die Länge wird als zurückgegeben `natural unsigned int` .  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn der Array Verweis ein NULL-Verweis ist.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldlen` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt die lokale Variable an einem bestimmten Index in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|< FE 0C `unsigned int16` >|ldloc `index`|Lädt die lokale Variable am Index in den `index` Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der lokale Variablen Wert am angegebenen Index wird auf den Stapel verschoben.  
  
 Die- `ldloc` Anweisung überträgt den Inhalt der lokalen Variablen Nummer am bestandenen Index in den Auswertungs Stapel, bei dem die lokalen Variablen auf 0 (null) nummeriert sind. Lokale Variablen werden auf 0 initialisiert, bevor die-Methode nur dann eingegeben wird, wenn das Initialisieren-Flag für die-Methode den Wert true hat. Es sind 65.535 (2 ^ 16-1) lokale Variablen möglich (0-65534). Der Index 65.535 ist ungültig, da wahrscheinliche Implementierungen eine 2-Byte-Ganzzahl verwenden, um sowohl den Index eines lokalen als auch die Gesamtzahl der lokalen Variablen für eine bestimmte Methode zu verfolgen. Wenn ein Index von 65535 als gültig fest gegeben wurde, wäre eine breitere Ganzzahl erforderlich, um die Anzahl der lokalen Variablen in einer solchen Methode zu verfolgen.  
  
 Die `ldloc.0` `ldloc.1` Anweisungen,, `ldloc.2` und `ldloc.3` bieten eine effiziente Codierung für den Zugriff auf die ersten vier lokalen Variablen.  
  
 Der Typ des Werts ist mit dem Typ der lokalen Variablen identisch, der im Methoden Header angegeben ist. Weitere Informationen finden Sie unter Partition I. lokale Variablen, die kleiner als 4 Bytes sind, werden auf den Typ erweitert, `int32` Wenn Sie auf dem Stapel geladen werden. Gleit Komma Werte werden auf Ihre systemeigene Größe (Typ `F` ) erweitert.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladungen können den `ldloc` Opcode verwenden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.LocalBuilder%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Int16%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt die lokale Variable am Index 0 in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|06|ldloc. 0|Lädt die lokale Variable am Index 0 in den Auswertungsstapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der lokale Variablen Wert am Index 0 wird auf den Stapel verschoben.  
  
 `ldloc.0` ist eine besonders effiziente Codierung für <xref:System.Reflection.Emit.OpCodes.Ldloc> und ermöglicht den Zugriff auf die lokale Variable am Index 0.  
  
 Der Typ des Werts ist mit dem Typ der lokalen Variablen identisch, der im Methoden Header angegeben ist. Lokale Variablen, die kleiner als 4 Bytes sind, werden auf den Typ erweitert, `int32` Wenn Sie auf dem Stapel geladen werden. Gleit Komma Werte werden auf Ihre systemeigene Größe (Typ `F` ) erweitert.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldloc.0` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt die lokale Variable am Index 1 in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|07|ldloc. 1|Lädt die lokale Variable am Index 1 in den Auswertungsstapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der lokale Variablen Wert am Index 1 wird auf den Stapel verschoben.  
  
 `ldloc.1` ist eine besonders effiziente Codierung für <xref:System.Reflection.Emit.OpCodes.Ldloc> und ermöglicht den Zugriff auf die lokale Variable am Index 1.  
  
 Der Typ des Werts ist mit dem Typ der lokalen Variablen identisch, der im Methoden Header angegeben ist. Lokale Variablen, die kleiner als 4 Bytes sind, werden auf den Typ erweitert, `int32` Wenn Sie auf dem Stapel geladen werden. Gleit Komma Werte werden auf Ihre systemeigene Größe (Typ `F` ) erweitert.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldloc.1` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt die lokale Variable am Index 2 in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|08|ldloc. 2|Lädt die lokale Variable am Index 2 in den Auswertungsstapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der lokale Variablen Wert am Index 2 wird auf den Stapel verschoben.  
  
 `ldloc.2` ist eine besonders effiziente Codierung für <xref:System.Reflection.Emit.OpCodes.Ldloc> und ermöglicht den Zugriff auf die lokale Variable am Index 2.  
  
 Der Typ des Werts ist mit dem Typ der lokalen Variablen identisch, der im Methoden Header angegeben ist. Lokale Variablen, die kleiner als 4 Bytes sind, werden auf den Typ erweitert, `int32` Wenn Sie auf dem Stapel geladen werden. Gleit Komma Werte werden auf Ihre systemeigene Größe (Typ `F` ) erweitert.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldloc.2` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt die lokale Variable am Index 3 in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|09|ldloc. 3|Lädt die lokale Variable am Index 3 in den Auswertungsstapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der lokale Variablen Wert am Index 3 wird auf den Stapel verschoben.  
  
 `ldloc.3` ist eine besonders effiziente Codierung für <xref:System.Reflection.Emit.OpCodes.Ldloc> und ermöglicht den Zugriff auf die lokale Variable am Index 3.  
  
 Der Typ des Werts ist mit dem Typ der lokalen Variablen identisch, der im Methoden Header angegeben ist. Lokale Variablen, die kleiner als 4 Bytes sind, werden auf den Typ erweitert, `int32` Wenn Sie auf dem Stapel geladen werden. Gleit Komma Werte werden auf Ihre systemeigene Größe (Typ `F` ) erweitert.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldloc.3` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt die lokale Variable an einem bestimmten Index in den Auswertungsstapel, Kurzform.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|11 < `unsigned int8` >|ldloc. s `index`|Lädt die lokale Variable am Index `index` auf den Stapel, Kurzform.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der lokale Variablen Wert am angegebenen Index wird auf den Stapel verschoben.  
  
 Die- `ldloc.s` Anweisung überträgt den Inhalt der lokalen Variablen Nummer am bestandenen Index in den Auswertungs Stapel, bei dem die lokalen Variablen auf 0 (null) nummeriert sind. Lokale Variablen werden vor dem Eingeben der Methode mit 0 initialisiert, wenn das Initialisieren-Flag für die Methode den Wert true hat. In Kurzform sind 256 (2 ^ 8) lokale Variablen möglich (0-255). Dies ist eine effizientere Codierung als `ldloc` .  
  
 Der Typ des Werts ist mit dem Typ der lokalen Variablen identisch, der im Methoden Header angegeben ist. Weitere Informationen finden Sie unter Partition I. lokale Variablen, die kleiner als 4 Bytes sind, werden auf den Typ erweitert, `int32` Wenn Sie auf dem Stapel geladen werden. Gleit Komma Werte werden auf Ihre systemeigene Größe (Typ `F` ) erweitert.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladungen können den `ldloc.s` Opcode verwenden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.LocalBuilder%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Byte%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt die Adresse der lokalen Variablen am angegebenen Index in den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|FE od-< `unsigned int16` >|ldloca `index`|Lädt die Adresse der lokalen Variablen auf in `index` den Auswertungs Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Die Adresse, die in der lokalen Variablen am angegebenen Index gespeichert ist, wird auf den Stapel verschoben.  
  
 Mit der- `ldloca` Anweisung wird die Adresse der lokalen Variablen Nummer am bestandenen Index auf den Stapel gepusht, wobei lokale Variablen auf 0 (null) nummeriert werden. Der Wert, der auf dem Stapel abgelegt wurde, ist bereits ordnungsgemäß für die Verwendung mit Anweisungen wie <xref:System.Reflection.Emit.OpCodes.Ldind_I> und ausgerichtet <xref:System.Reflection.Emit.OpCodes.Stind_I> . Das Ergebnis ist ein vorübergehender Zeiger (Typ `*` ).  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldloca` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Int16%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lädt die Adresse der lokalen Variablen am angegebenen Index in den Auswertungsstapel, Kurzform.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|12 < `unsigned int8` >|ldloca. s `index`|Lädt die Adresse der lokalen Variablen an in `index` den Auswertungs Stapel, Kurzform.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Die Adresse, die in der lokalen Variablen am angegebenen Index gespeichert ist, wird auf den Stapel verschoben.  
  
 Mit der- `ldloca.s` Anweisung wird die Adresse der lokalen Variablen Nummer am bestandenen Index auf den Stapel gepusht, wobei lokale Variablen auf 0 (null) nummeriert werden. Der Wert, der auf dem Stapel abgelegt wurde, ist bereits ordnungsgemäß für die Verwendung mit Anweisungen wie <xref:System.Reflection.Emit.OpCodes.Ldind_I> und ausgerichtet <xref:System.Reflection.Emit.OpCodes.Stind_I> . Das Ergebnis ist ein vorübergehender Zeiger (Typ `*` ).  
  
 Die- `ldloca.s` Anweisung bietet eine effiziente Codierung für die Verwendung mit den lokalen Variablen 0 bis 255.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldloca.s` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Byte%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen NULL-Verweis (Typ <see langword="O" />) auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|14|ldnull|einen NULL-Verweis auf den Stapel verschieben|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein NULL-Objekt Verweis wird auf den Stapel verschoben.  
  
 `ldnull` legt einen NULL-Verweis (Typ `O` ) auf dem Stapel ab. Wird verwendet, um Speicherorte zu initialisieren, bevor Sie mit Daten aufgefüllt werden, oder wenn Sie als veraltet markiert werden.  
  
 `ldnull` stellt einen Größen unabhängigen NULL-Verweis bereit.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldnull` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopiert das Werttypobjekt, auf das eine Adresse zeigt, an die oberste Position des Auswertungsstapels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|71 < `T` >|ldobj `class`|Kopieren Sie die Instanz des Werttyps `class` in den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Die Adresse eines Werttyp Objekts wird auf den Stapel verschoben.  
  
2.  Die Adresse wird aus dem Stapel entfernt, und die Instanz an dieser bestimmten Adresse wird gesucht.  
  
3.  Der Wert des-Objekts, das an dieser Adresse gespeichert wird, wird auf den Stapel verschoben.  
  
 Die- `ldobj` Anweisung wird verwendet, um einen Werttyp als Parameter zu übergeben.  
  
 Die `ldobj` Anweisung kopiert den Wert, auf den durch `addrOfValObj` (vom Typ `&` , oder) gezeigt wird `*` `native int` , an den oberen Rand des Stapels. Die Anzahl der kopierten Bytes hängt von der Größe der-Klasse ab (wie vom- `class` Parameter angegeben). Der- `class` Parameter ist ein Metadatentoken, das den Werttyp darstellt.  
  
 Der Vorgang der `ldobj` Anweisung kann durch eine unmittelbar vorangehende <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung geändert werden.  
  
 <xref:System.TypeLoadException> wird ausgelöst, wenn die Klasse nicht gefunden werden kann. Dies wird in der Regel erkannt, wenn die MSIL-Anweisung (Microsoft Intermediate Language) nicht zur Laufzeit in nativen Code konvertiert wird.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldobj` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den Wert eines statischen Felds auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|7e < `T` >|ldsfld `field`|Übersetzen Sie den Wert von `field` auf dem Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der Wert des jeweiligen Felds wird auf den Stapel verschoben.  
  
 Die- `ldsfld` Anweisung legt den Wert einer statischen (für alle Instanzen einer Klasse freigegebenen) Felder auf dem Stapel ab. Der Rückgabetyp ist der, der dem übergebenen Metadatentoken zugeordnet ist `field` .  
  
 Die `ldsfld` Anweisung kann ein <xref:System.Reflection.Emit.OpCodes.Volatile> Präfix aufweisen.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldsfld` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.FieldInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt die Adresse eines statischen Felds auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|7F < `T` >|ldsflda `field`|Verschieben Sie die Adresse von `field` auf dem Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Die Adresse eines bestimmten Felds wird auf den Stapel verschoben.  
  
 Die- `ldsflda` Anweisung legt die Adresse eines statischen (von allen Instanzen einer Klasse gemeinsam genutzten) Felds auf dem Stapel ab. Die Adresse kann als vorübergehender Zeiger (Typ) dargestellt werden `*` , wenn das Metadatentoken `field` auf einen Typ verweist, dessen Speicher verwaltet wird. Andernfalls entspricht Sie einem nicht verwalteten Zeiger (Typ `native int` ). Beachten Sie, dass ggf `field` . ein statischer globaler Wert mit einer zugewiesenen relativen virtuellen Adresse (der Offset des Felds von der Basisadresse, an der die enthaltende PE-Datei in den Arbeitsspeicher geladen wird) sein kann, in der der Speicher nicht verwaltet wird.  
  
 Die `ldsflda` Anweisung kann ein <xref:System.Reflection.Emit.OpCodes.Volatile> Präfix aufweisen.  
  
 <xref:System.MissingFieldException> wird ausgelöst, wenn das Feld in den Metadaten nicht gefunden wurde. Dies wird in der Regel geprüft, wenn MSIL-Anweisungen (Microsoft Intermediate Language) in systemeigenen Code konvertiert werden, nicht zur Laufzeit.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldsflda` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.FieldInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen neuen Objektverweis auf ein in den Metadaten gespeichertes Zeichenfolgenliteral mittels Push ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|72 < `T` >|ldstr `mdToken`|Überträgt ein Zeichen folgen Objekt für das Token der Metadatenzeichenfolge `mdToken` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis auf eine Zeichenfolge wird auf den Stapel verschoben.  
  
 Die `ldstr` Anweisung überträgt einen Objekt Verweis (Typ `O` ) auf ein neues Zeichen folgen Objekt, das die in den Metadaten gespeicherte spezifische Zeichenfolgenliterale darstellt. Die `ldstr` -Anweisung ordnet die erforderliche Menge an Arbeitsspeicher zu und führt jede Formatkonvertierung aus, die zum Konvertieren des Zeichenfolgenliterals aus dem in der Datei verwendeten Formular in das zur Laufzeit erforderliche Zeichen folgen Format erforderlich ist.  
  
 Der Common Language Infrastructure (CLI) garantiert, dass das Ergebnis von zwei Anweisungen, die `ldstr` auf zwei Metadatentoken mit derselben Zeichenfolge verweisen, genau dasselbe Zeichen folgen Objekt zurückgibt (ein Prozess, der als "Zeichen folgen Interning" bezeichnet wird).  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldstr` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.String%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert ein Metadatentoken in seine Laufzeitdarstellung und legt es auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|D0-< `T` >|ldtoken `token`|Konvertiert ein Metadatentoken in seine Lauf Zeit Darstellung.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Das übergebenen Token wird in eine konvertiert `RuntimeHandle` und auf den Stapel verschoben.  
  
 Die- `ldtoken` Anweisung schiebt einen `RuntimeHandle` für das angegebene Metadatentoken. Ein `RuntimeHandle` kann ein `fieldref/fielddef` , ein `methodref/methoddef` oder ein sein `typeref/typedef` .  
  
 Der Wert, der auf dem Stapel abgelegt wird, kann in Aufrufen von `Reflection` Methoden in der System Klassenbibliothek verwendet werden.  
  
 Weitere Informationen zu Lauf Zeit Handles finden Sie in den folgenden Klassen: <xref:System.RuntimeFieldHandle> , <xref:System.RuntimeTypeHandle> und <xref:System.RuntimeMethodHandle> .  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladungen können den `ldtoken` Opcode verwenden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.FieldInfo%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen nicht verwalteten Zeiger (Typ <see langword="native int" />) auf systemeigenen Code auf dem Auswertungsstapel ab. Dieser Code implementiert eine bestimmte virtuelle Methode, die einem angegebenen Objekt zugeordnet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|FE 07 < `T` >|ldvirtftn `method`|Überträgt den Zeiger auf die virtuelle Methode eines Objekts `method` auf dem Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis wird auf den Stapel verschoben.  
  
2.  Der Objekt Verweis wird aus dem Stapel entfernt, und die Adresse des Einstiegs Punkts zur Methode (wie vom Metadatentoken angegeben `method` ) wird gesucht.  
  
3.  Der Zeiger auf `method` wird auf den Stapel verschoben.  
  
 Der resultierende nicht verwaltete Zeiger, der von der Anweisung auf den Stapel verschoben `ldvirtftn` wird, kann mithilfe der-Anweisung aufgerufen werden <xref:System.Reflection.Emit.OpCodes.Calli> , wenn er auf eine verwaltete Methode (oder einen Stub, der von verwaltetem zu nicht verwaltetem Code übergeht) verweist.  
  
 Der nicht verwaltete Zeiger verweist mithilfe der CLR-Aufruf Konvention auf nativen Code. Dieser Methoden Zeiger sollte nicht als Rückruf Routine an den nicht verwalteten nativen Code übergeben werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ldvirtftn` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beendet einen geschützten Codebereich, wobei die Steuerung bedingungslos an eine bestimmte Zielanweisung übertragen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|DD-< `int32` >|lassen Sie `target`|Beendet einen geschützten Code Bereich.|  
  
 Für diese Anweisung wurde kein Stapel Übergangs Verhalten angegeben.  
  
 Die `leave` Anweisung überträgt die Steuerung bedingungslos an die bestimmte Ziel Anweisung, die als 4-Byte-signierte Abweichung von dem Anfang der Anweisung nach der aktuellen Anweisung dargestellt wird.  
  
 Die- `leave` Anweisung ähnelt der- `br` Anweisung, kann jedoch verwendet werden, um einen-,-oder-Block zu beenden, `try` `filter` `catch` wohingegen die normalen Verzweigungs Anweisungen nur in einem solchen Block verwendet werden können, um die Steuerung darin zu übertragen. Die `leave` Anweisung leert den Auswertungs Stapel und stellt sicher, dass die entsprechenden umgebenden `finally` Blöcke ausgeführt werden.  
  
 Eine-Anweisung kann nicht `leave` zum Beenden eines-Blocks verwendet werden `finally` . Um die Codegenerierung für Ausnahmehandler zu vereinfachen, ist es innerhalb eines catch-Blocks gültig, eine `leave` Anweisung zum Übertragen der Steuerung an eine beliebige Anweisung innerhalb des zugeordneten Blocks zu verwenden `try` .  
  
 Wenn eine Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladungen können den `leave` Opcode verwenden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Beendet einen geschützten Codebereich, wobei die Steuerung bedingungslos an eine bestimmte Zielanweisung übertragen wird, Kurzform.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|DE < `int8` >|lassen Sie. s `target`|Beendet einen geschützten Code Bereich, Kurzform.|  
  
 Für diese Anweisung wurde kein Stapel Übergangs Verhalten angegeben.  
  
 Die `leave.s` Anweisung überträgt die Steuerung bedingungslos an die übergebenen Ziel Anweisung, die als 1-Byte-signierte Abweichung vom Anfang der Anweisung nach der aktuellen Anweisung dargestellt wird.  
  
 Die- `leave.s` Anweisung ähnelt der- `br` Anweisung, kann jedoch verwendet werden, um einen-,-oder-Block zu beenden, `try` `filter` `catch` wohingegen die normalen Verzweigungs Anweisungen nur in einem solchen Block verwendet werden können, um die Steuerung darin zu übertragen. Die `leave.s` Anweisung leert den Auswertungs Stapel und stellt sicher, dass die entsprechenden umgebenden `finally` Blöcke ausgeführt werden.  
  
 Eine-Anweisung kann nicht `leave.s` zum Beenden eines-Blocks verwendet werden `finally` . Um die Codegenerierung für Ausnahmehandler zu vereinfachen, ist es innerhalb eines catch-Blocks gültig, eine `leave.s` Anweisung zum Übertragen der Steuerung an eine beliebige Anweisung innerhalb des zugeordneten Blocks zu verwenden `try` .  
  
 Wenn eine Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `leave.s` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Belegt eine bestimmte Anzahl von Bytes aus dem lokalen dynamischen Speicherpool und legt die Adresse (einen flüchtigen Zeiger, Typ <see langword="*" />) des ersten reservierten Bytes auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|FE 0F|loczuweisung|Zuweisen von Speicherplatz aus dem lokalen Heap|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Die Anzahl der zugeordneten Bytes wird auf den Stapel verschoben.  
  
2.  Die Anzahl der Bytes, die aus dem Stapel entfernt werden. eine Menge an Arbeitsspeicher, die der Größe entspricht, wird vom lokalen Heap zugeordnet.  
  
3.  Ein Zeiger auf das erste Byte des zugeordneten Speichers wird auf den Stapel verschoben.  
  
 Die `localloc` Anweisung ordnet `size` (Type `natural unsigned int` ) Bytes aus dem lokalen dynamischen Speicherpool zu und gibt die Adresse (einen flüchtigen Zeiger, Typ `*` ) des ersten zugeordneten Bytes zurück. Der zurückgegebene Speicherblock wird nur dann auf 0 initialisiert, wenn das Initialisieren-Flag für die Methode ist `true` . Wenn die aktuelle Methode einen ausführt <xref:System.Reflection.Emit.OpCodes.Ret> , wird der lokale Speicherpool für die Wiederverwendung verfügbar gemacht.  
  
 Die resultierende Adresse wird so ausgerichtet, dass alle primitiven Datentypen dort mithilfe der `stind` Anweisungen (z. b. <xref:System.Reflection.Emit.OpCodes.Stind_I4> ) gespeichert und mithilfe der `ldind` Anweisungen (z <xref:System.Reflection.Emit.OpCodes.Ldind_I4> . b.) geladen werden können.  
  
 Die `localloc` Anweisung kann nicht innerhalb eines-,-,- `filter` `catch` oder-Blocks auftreten `finally` `fault` .  
  
 <xref:System.StackOverflowException> wird ausgelöst, wenn nicht genügend Arbeitsspeicher vorhanden ist, um die Anforderung zu bedienen.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `localloc` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen typisierten Verweis auf eine Instanz eines bestimmten Typs auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|C6-< `T` >|mkrefany `class`|Legt einen typisierten Verweis vom Typ `class` auf den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Zeiger auf ein Datenelement wird auf den Stapel verschoben.  
  
2.  Der Zeiger wird per Pop und in einen typisierten Verweis vom Typ konvertiert `class` .  
  
3.  Der typisierte Verweis wird auf den Stapel verschoben.  
  
 Die `mkrefany` Anweisung unterstützt das übergeben dynamisch typisierter Verweise. Der Zeiger muss vom Typ `&` , `*` oder sein `native int` und die gültige Adresse eines Daten Abschnitts enthalten. `Class` ist das Klassen Token, das den Typ der Daten beschreibt, auf die der Zeiger verweist. `Mkrefany` legt einen typisierten Verweis auf den Stapel ab und stellt einen nicht transparenten Deskriptor des Zeigers und des Typs bereit `class` .  
  
 Der einzige gültige Vorgang, der auf einem typisierten Verweis zulässig ist, besteht darin, ihn an eine Methode zu übergeben, die einen typisierten Verweis als Parameter erfordert. Der aufgerufene kann dann die <xref:System.Reflection.Emit.OpCodes.Refanytype> -und- <xref:System.Reflection.Emit.OpCodes.Refanyval> Anweisungen verwenden, um den Typ (Klasse) bzw. die Adresse abzurufen.  
  
 <xref:System.TypeLoadException> wird ausgelöst, wenn `class` nicht gefunden werden kann. Dies wird in der Regel erkannt, wenn MSIL-Anweisungen (Microsoft Intermediate Language) in nativen Code anstatt zur Laufzeit konvertiert werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `mkrefany` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Multipliziert zwei Werte und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|5a|mul|Multipliziert zwei Werte im Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt. `value1` wird mit multipliziert `value2` .  
  
4.  Das Ergebnis wird auf den Stapel verschoben.  
  
 Die `mul` -Anweisung multipliziert `value1` mit `value2` und legt das Ergebnis auf dem Stapel ab. Ganzzahlige Vorgänge kürzen die oberen Bits bei einem Überlauf automatisch.  
  
 <xref:System.Reflection.Emit.OpCodes.Mul_Ovf>Einen ganzzahligen spezifischen Multiplikations Vorgang mit Überlauf Behandlung finden Sie unter.  
  
 Für Gleit Komma Typen lautet der Wert 0 * unendlich = Nan.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `mul` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Multipliziert zwei Ganzzahlwerte, führt eine Überlaufprüfung durch und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|D8|mul. ovf|Multipliziert zwei ganzzahlige Werte auf dem Stapel mit einer Überlauf Überprüfung.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt; `value1` wird `value2` mit einer Überlauf Überprüfung multipliziert.  
  
4.  Das Ergebnis wird auf den Stapel verschoben.  
  
 Die `mul.ovf` -Anweisung multipliziert Integer `value1` mit Integer `value2` und legt das Ergebnis auf dem Stapel ab. Eine Ausnahme wird ausgelöst, wenn das Ergebnis nicht in den Ergebnistyp passt.  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `mul.ovf` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Multipliziert zwei Ganzzahlwerte ohne Vorzeichen, führt eine Überlaufprüfung durch und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|D9|mul. ovf. UN|Multipliziert zwei nicht signierte Werte auf dem Stapel mit einer Überlauf Überprüfung.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt; `value1` wird `value2` mit einer Überlauf Überprüfung multipliziert.  
  
4.  Das Ergebnis wird auf den Stapel verschoben.  
  
 Die `mul.ovf.un` -Anweisung multipliziert eine Ganzzahl ohne Vorzeichen `value1` mit einer Ganzzahl ohne Vorzeichen `value2` und legt das Ergebnis auf dem Stapel ab. Eine Ausnahme wird ausgelöst, wenn das Ergebnis nicht in den Ergebnistyp passt.  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `mul.ovf.un` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Negiert einen Wert und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|65|Neg|Negiert den derzeit auf dem Stapel oberen Wert.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Wert wird auf den Stapel verschoben.  
  
2.  Ein Wert wird aus dem Stapel entfernt und negiert.  
  
3.  Das Ergebnis wird auf den Stapel verschoben.  
  
 Die `neg` Anweisung negiert den Wert und legt das Ergebnis auf dem Stapel ab. Der Rückgabetyp ist der gleiche wie der Operanden-Typ.  
  
 Die Negation von ganzzahligen Werten ist die standardmäßige zwei Komplement Negation. Insbesondere die Negation der negatischsten Zahl (die keine positive Entsprechung hat) ergibt die negativste Zahl. Verwenden Sie stattdessen die-Anweisung, um diesen Überlauf zu erkennen <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> (d. h. Subtrahieren von 0).  
  
 Das neinieren einer Gleit Komma Zahl kann keinen Überlauf verursachen, und die Negation von Nan gibt NaN zurück.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `neg` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt einen Objektverweis auf ein neues nullbasiertes, eindimensionales Array auf dem Auswertungsstapel ab, dessen Elemente einen bestimmten Typ aufweisen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|8d < `T` >|netzerr `etype`|Erstellt ein neues Array mit Elementen vom Typ `etype` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Die Anzahl der Elemente im Array wird auf dem Stapel abgelegt.  
  
2.  Die Anzahl der Elemente wird aus dem Stapel entfernt, und das Array wird erstellt.  
  
3.  Ein Objekt Verweis auf das neue Array wird auf dem Stapel abgelegt.  
  
 Die `newarr` Anweisung überträgt einen Objekt Verweis (Typ `O` ) auf ein neues NULL basiertes, eindimensionales Array, dessen Elemente vom Typ sind `etype` (ein Metadatentoken, das den Typ beschreibt). Die Anzahl der Elemente im neuen Array muss als angegeben werden `native int` . Gültige Array Indizes reichen von Null bis zur maximalen Anzahl von Elementen minus 1.  
  
 Die Elemente eines Arrays können ein beliebiger Typ sein, einschließlich Werttypen.  
  
 Null basierte, eindimensionale Arrays von Zahlen werden mithilfe eines Metadatentokens erstellt, das auf den entsprechenden Werttyp verweist ( <xref:System.Int32> usw.). Elemente des Arrays werden mit 0 des entsprechenden Typs initialisiert.  
  
 Nicht null basierte eindimensionale Arrays und mehrdimensionale Arrays werden mit anstelle von erstellt <xref:System.Reflection.Emit.OpCodes.Newobj> `newarr` . Üblicherweise werden Sie mithilfe der Methoden der- <xref:System.Array> Klasse in der .NET Framework erstellt.  
  
 <xref:System.OutOfMemoryException> wird ausgelöst, wenn nicht genügend Arbeitsspeicher vorhanden ist, um die Anforderung zu erfüllen.  
  
 <xref:System.OverflowException> wird ausgelöst, wenn `numElems` kleiner als 0 (null) ist.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `newarr` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Erstellt ein neues Objekt oder eine neue Instanz eines Werttyps, wobei ein Objektverweis (Typ <see langword="O" />) auf dem Auswertungsstapel abgelegt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|73 < `T` >|newobj `ctor`|Ordnet ein nicht initialisiertes Objekt oder einen Werttyp zu und ruft die Konstruktormethode auf `ctor` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Argumente `arg1` durch `argn` werden nacheinander in den Stapel verschoben.  
  
2.  Argumente `argn` durch `arg1` werden aus dem Stapel entfernt und `ctor` für die Objekt Erstellung an übergeben.  
  
3.  Ein Verweis auf das neue-Objekt wird auf den Stapel verschoben.  
  
 Die- `newobj` Anweisung erstellt ein neues-Objekt oder eine neue Instanz eines Werttyps. `Ctor` ein Metadatentoken ( `methodref` oder `methoddef` , das als Konstruktor gekennzeichnet werden muss), das den Namen, die Klasse und die Signatur des aufzurufenden Konstruktors angibt.  
  
 `newobj`Mit der-Anweisung wird eine neue Instanz der-Klasse zugeordnet, die zugeordnet ist `ctor` , und alle Felder in der neuen-Instanz werden auf 0 (des richtigen Typs) oder NULL-Verweise nach Bedarf initialisiert. Anschließend wird der Konstruktor `ctor` mit den angegebenen Argumenten zusammen mit der neu erstellten Instanz aufgerufen. Nachdem der Konstruktor aufgerufen wurde, wird der jetzt initialisierte Objekt Verweis (Typ `O` ) auf dem Stapel abgelegt.  
  
 Aus Sicht des Konstruktors lautet das nicht initialisierte Objekt Argument 0, und die anderen Argumente, die an newobj übergeben werden, folgen in der angegebenen Reihenfolge.  
  
 Alle NULL basierten, eindimensionalen Arrays werden mithilfe von erstellt <xref:System.Reflection.Emit.OpCodes.Newarr> , nicht `newobj` . Andererseits werden alle anderen Arrays (mehr als eine Dimension oder eindimensional, aber nicht NULL basiert) mithilfe von erstellt `newobj` .  
  
 Werttypen werden in der Regel nicht mithilfe von erstellt `newobj` . Sie werden in der Regel entweder als Argumente oder lokale Variablen zugewiesen, wobei `newarr` (bei Null-basierten, eindimensionalen Arrays) oder als Felder von Objekten verwendet wird. Nachdem Sie zugeordnet wurden, werden Sie mit initialisiert <xref:System.Reflection.Emit.OpCodes.Initobj> . Allerdings `newobj` kann die-Anweisung verwendet werden, um eine neue Instanz eines Werttyps auf dem Stapel zu erstellen, die dann als Argument, in einem lokalen gespeichert usw., weitergegeben werden kann.  
  
 <xref:System.OutOfMemoryException> wird ausgelöst, wenn nicht genügend Arbeitsspeicher vorhanden ist, um die Anforderung zu erfüllen.  
  
 <xref:System.MissingMethodException> wird ausgelöst, wenn eine Konstruktormethode `ctor` mit dem angegeben Namen, der Klasse und der Signatur nicht gefunden werden konnte. Dies wird in der Regel erkannt, wenn MSIL-Anweisungen (Microsoft Intermediate Language) in systemeigenen Code konvertiert werden, anstatt zur Laufzeit.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `newobj` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.ConstructorInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Füllt Speicherplatz auf, wenn Opcodes gepatcht werden. Es wird keine sinnvolle Operation ausgeführt, obwohl ein Verarbeitungszyklus ausgeführt werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|00|NOP|Führt einen Vorgang ohne Verhalten aus.|  
  
 Für diese Anweisung ist kein Stapel Übergangs Verhalten definiert.  
  
 Der `nop` Vorgang bewirkt nichts. Wenn Opcodes gepatcht werden, soll der Speicherplatz ausgefüllt werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `nop` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Berechnet das bitweise Komplement des Ganzzahlwerts an oberster Position des Stapels und legt das Ergebnis als denselben Typ auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|66|not|Berechnet das bitweise Komplement eines-Werts.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value` wird auf den Stapel verschoben.  
  
2.  `value` wird aus dem Stapel und dem bitweisen Komplement berechnet.  
  
3.  Das Ergebnis wird auf den Stapel verschoben.  
  
 Die `not` -Anweisung berechnet das bitweise Komplement eines ganzzahligen Werts und legt das Ergebnis auf dem Stapel ab. Der Rückgabetyp ist der gleiche wie der Operanden-Typ.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `not` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Berechnet das bitweise Komplement der beiden Ganzzahlwerte an oberster Position des Stapels und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|60|oder|Berechnet das bitweise OR von zwei ganzzahligen Werten und gibt eine ganze Zahl zurück.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel und ihrer bitweisen OR-Berechnung aus dem Stapel entfernt.  
  
4.  Das Ergebnis wird auf den Stapel verschoben.  
  
 Die- `or` Anweisung berechnet das bitweise OR von zwei Werten oberhalb des Stapels und überträgt das Ergebnis auf den Stapel.  
  
 `Or` ist ein ganzzahliger spezifischer Vorgang.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `or` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Entfernt den Wert, der sich derzeit an oberster Position des Auswertungsstapels befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|26|pop|Holt den obersten Wert aus dem Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der oberste Wert wird aus dem Stapel entfernt.  
  
 Die `pop` Anweisung entfernt das oberste Element aus dem Stapel.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `pop` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dies ist eine reservierte Anweisung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dies ist eine reservierte Anweisung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dies ist eine reservierte Anweisung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dies ist eine reservierte Anweisung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dies ist eine reservierte Anweisung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dies ist eine reservierte Anweisung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dies ist eine reservierte Anweisung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dies ist eine reservierte Anweisung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass beim nachfolgenden Vorgang zur Arrayadresse zur Laufzeit keine Typüberprüfung durchgeführt wird und dass ein verwalteter Zeiger zurückgegeben wird, der nur bedingt geändert werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|FE 1E|readonly.|Gibt an, dass der nachfolgende Array Adress Vorgang zur Laufzeit keine Typüberprüfung ausführt und einen verwalteten Zeiger mit eingeschränkter Veränderbarkeit zurückgibt.|  
  
 Dieses Präfix kann nur unmittelbar vor der `ldelema` Anweisung und Aufrufen der speziellen `Address` Methode für Arrays angezeigt werden. Die Auswirkung auf den nachfolgenden Vorgang ist zweierlei:  
  
1.  Zur Laufzeit wird kein Vorgang zur Typüberprüfung durchgeführt. Beachten Sie, dass es normalerweise eine implizite Typüberprüfung für die `ldelema` -und-Anweisungen gibt, wenn Sie für `stelem` Verweistyp Arrays verwendet werden. Es gibt nie eine Lauf Zeittyp Überprüfung für Wert Klassen, daher `readonly` ist in diesem Fall kein op.  
  
2.  Der Verifier behandelt das Ergebnis des address-of-Vorgangs als verwalteten Zeiger mit eingeschränkter Veränderbarkeit.  
  
 Der Zeiger hat eine eingeschränkte Veränderlichkeit, da der definierende Typ steuert, ob der Wert mutiert werden kann. Für Wert Klassen, die keine öffentlichen Felder oder Methoden verfügbar machen, die den Wert direkt aktualisieren, ist der Zeiger schreibgeschützt (daher der Name des Präfixes). Insbesondere die Klassen, die primitive Typen darstellen (z. b. System. Int32), machen keine Mutatoren verfügbar und sind daher schreibgeschützt.  
  
 Ein auf diese Weise beschränkte verwalteter Zeiger kann nur auf folgende Weise verwendet werden:  
  
-   Als `object` Parameter für die `ldfld` Anweisungen, `ldflda` , `stfld` , `call` oder `constrained callvirt` .  
  
-   Als `pointer` Parameter für die `ldobj` Anweisung oder eine der `ldind` Anweisungen.  
  
-   Als `source` Parameter für die `cpobj` Anweisung.  
  
 Alle anderen Vorgänge sind nicht zulässig, einschließlich `stobj` der `initobj` Vorgänge,, oder `mkrefany` oder einer der `stind` Anweisungen.  
  
 Der Zweck des `readonly` Präfixes besteht darin, eine Typüberprüfung zu vermeiden, wenn ein Element aus einem Array in generischem Code abgerufen wird. Beispielsweise kann der Ausdruck, `arr[i].m()` bei dem der Elementtyp des Arrays `arr` ein generischer Typ ist, der auf eine Schnittstelle mit der-Methode beschränkt wurde `m` , möglicherweise mit der folgenden MSIL kompiliert werden.  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 Ohne das `readonly` Präfix `ldelema` führt die Anweisung eine Typüberprüfung in dem Fall aus, dass! 0 ein Verweistyp war. Diese Typüberprüfung ist nicht nur ineffizient, sondern ist semantisch falsch. Die Typüberprüfung für `ldelema` ist eine genaue Entsprechung, die zu stark ist. Wenn das Array Unterklassen vom Typ! 0 enthielt, würde der obige Code die Typüberprüfung nicht durchführen.  
  
 Die Adresse des Array Elements wird anstelle des-Elements selbst abgerufen, damit ein Handle für verwendet `arr[i]` werden kann, das sowohl für Werttypen als auch für Verweis Typen geeignet ist und daher an die Anweisung übermittelt werden kann `constrained callvirt` .  
  
 Im allgemeinen wäre es unsicher, die Lauf Zeit Überprüfung zu überspringen, wenn das Array Elemente eines Verweis Typs enthielt. Um sicher zu sein, muss sichergestellt werden, dass keine Änderungen am Array über diesen Zeiger vorgenommen werden. Dies wird von den verifiziererregeln sichergestellt. Der eingeschränkte verwaltete Zeiger kann als Objekt von Instanzmethodenaufrufen weitergegeben werden, sodass er für Werttypen nicht streng schreibgeschützt ist, aber es gibt kein typsicherheits Problem für Werttypen.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `readonly` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Typtoken ab, das in einen typisierten Verweis eingebettet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|FE 1D|refanytype|Überträgt das Typtoken, das in einem typisierten Verweis gespeichert ist.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Werttyp Verweis wird auf den Stapel verschoben.  
  
2.  Der typisierte Verweis wird aus dem Stapel abgerufen, und das zugehörige Typtoken wird abgerufen.  
  
3.  Das Typtoken wird auf den Stapel verschoben.  
  
 Ein typisierter Verweis enthält ein Typtoken und eine Adresse für eine Objektinstanz.  
  
 Die- `refanytype` Anweisung ruft das Typtoken ab, das in den typisierten Verweis eingebettet ist. Weitere <xref:System.Reflection.Emit.OpCodes.Mkrefany> Informationen zum Erstellen von typisierten verweisen finden Sie in der-Anweisung.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `refanytype` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Adresse (Typ <see langword="&amp;" />) ab, die in einen typisierten Verweis eingebettet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|C2-< `T` >|refanyval `type`|Legt die in einem typisierten Verweis gespeicherte Adresse ab.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Werttyp Verweis wird auf den Stapel verschoben.  
  
2.  Der typisierte Verweis wird aus dem Stapel abgerufen, und die entsprechende Adresse wird abgerufen.  
  
3.  Die Adresse wird auf den Stapel verschoben.  
  
 Ein typisierter Verweis enthält ein Typtoken und eine Adresse für eine Objektinstanz.  
  
 Die- `refanyval` Anweisung ruft die Adresse ab, die in einen typisierten Verweis eingebettet ist. Der Typ, der in den typisierten Verweis auf dem Stapel eingebettet ist, muss mit dem durch angegebenen Typ `type` (einem Metadatentoken, entweder `typedef` oder) identisch sein `typeref` . Weitere Informationen finden Sie in der- <xref:System.Reflection.Emit.OpCodes.Mkrefany> Anweisung für verwandte Inhalte.  
  
 <xref:System.InvalidCastException> wird ausgelöst, wenn `type` nicht mit dem im Typverweis gespeicherten Typ identisch ist (in diesem Fall `type` ist die Klasse, die der Anweisung bereitgestellt wird <xref:System.Reflection.Emit.OpCodes.Mkrefany> , die den genannten typisierten Verweis erstellt hat).  
  
 <xref:System.TypeLoadException> wird ausgelöst, wenn `type` nicht gefunden werden kann.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `refanyval` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dividiert zwei Werte und legt den Rest auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|5D|rem|Überträgt den Rest der Division `value1` durch `value2` auf den Stapel.|  
  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel und dem restlichen `value1` `div` `value2` berechnet.  
  
4.  Das Ergebnis wird auf den Stapel verschoben.  
  
 `result` = `value1``rem` `value2` erfüllt die folgenden Bedingungen:  
  
 `result` = `value1` - `value2``×`( `value1` `div` `value2` ), und:  
  
 0 = &#124; `result` &#124; < &#124; `value2` &#124;, Sign ( `result` ) = Sign ( `value1` ), wobei `div` die Divisions Anweisung ist, die in Richtung NULL abgeschnitten wird.  
  
 Wenn `value2` 0 (null) ist oder unendlich ist, `value1` ist das Ergebnis NaN. Wenn `value2` unendlich ist, ist das Ergebnis `value1` (negiert für `-infinity` ).  
  
 Ganzzahlige Vorgänge lösen aus, <xref:System.DivideByZeroException> Wenn `value2` NULL ist.  
  
 Beachten Sie, dass auf den Intel-basierten Plattformen eine <xref:System.OverflowException> bei der Berechnung von (minint `rem` -1) ausgelöst wird.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `rem` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dividiert zwei Werte ohne Vorzeichen und legt den Rest auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|5e|REM. UN|Überträgt den Rest der Division ohne Vorzeichen `value1` durch Ganzzahl ohne Vorzeichen `value2` auf den Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel und dem restlichen `value1` `div` `value2` berechnet.  
  
4.  Das Ergebnis wird auf den Stapel verschoben.  
  
 `result` = `value1``rem.un` `value2` erfüllt die folgenden Bedingungen:  
  
 `result` = `value1` - `value2` x ( `value1` `div.un` `value2` ), und:  
  
 0 = `result`  <  `value2` , wobei `div.un` die Anweisung ohne signierte Division ist.  
  
 Die `rem.un` Anweisung berechnet `result` und überträgt Sie auf dem Stapel. `Rem.un` behandelt die Argumente als ganze Zahlen ohne Vorzeichen, während <xref:System.Reflection.Emit.OpCodes.Rem> Sie als ganze Zahlen mit Vorzeichen behandelt werden.  
  
 `Rem.un` ist für Gleit Komma Zahlen nicht angegeben.  
  
 Ganzzahlige Vorgänge lösen aus, <xref:System.DivideByZeroException> Wenn `value2` NULL ist.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `rem.un` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird von der aktuellen Methode zurückgegeben und legt einen Rückgabewert (sofern vorhanden) vom Auswertungsstapel des Aufgerufenen auf dem Auswertungsstapel des Aufrufenden ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|2a|TZI|Gibt die von der-Methode zurück und gibt möglicherweise einen Wert zurück|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der Rückgabewert wird vom aufgerufener Auswertungs Stapel ausgeblendet.  
  
2.  Der in Schritt 1 abgelegte Rückgabewert wird auf den Auswertungs Stapel des Aufrufers übermittelt.  
  
 Wenn der Rückgabewert nicht auf dem Auswertungs Stapel des aufgerufenen vorhanden ist, wird kein Wert zurückgegeben (kein Stapel Übergangs Verhalten für die aufgerufene Methode oder die aufrufermethode).  
  
 Der Typ des Rückgabewerts der aktuellen Methode bestimmt den Typ des Werts, der vom oberen Rand des Stapels abgerufen und auf den Stapel der Methode kopiert wird, der die aktuelle Methode aufgerufen hat. Der Auswertungs Stapel für die aktuelle Methode muss leer sein, es sei denn, der Wert wird zurückgegeben.  
  
 Die `ret` Anweisung kann nicht verwendet werden, um die Steuerung von einem-,-,-oder-Block zu übertragen `try` `filter` `catch` `finally` . Verwenden Sie innerhalb von `try` oder `catch` die- <xref:System.Reflection.Emit.OpCodes.Leave> Anweisung mit dem Ziel einer `ret` Anweisung außerhalb aller einschließenden Ausnahme Blöcke. Da die `filter` -und- `finally` Blöcke logisch Teil der Ausnahmebehandlung sind und nicht die Methode, in der Ihr Code eingebettet ist, führen ordnungsgemäß generierte MSIL-Anweisungen (Microsoft Intermediate Language) nicht in einer-oder-Methode aus `filter` `finally` .  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `ret` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Löst erneut die aktuelle Ausnahme aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|FE 1a|erneut auslösen|Löst die aktuelle Ausnahme erneut aus.|  
  
 Für diese Anweisung ist kein Stapel Übergangs Verhalten definiert.  
  
 Die `rethrow` Anweisung ist nur innerhalb des Texts eines `catch` Handlers zulässig. Sie löst dieselbe Ausnahme aus, die von diesem Handler abgefangen wurde.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `rethrow` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Verschiebt einen ganzzahligen Wert um eine angegebene Anzahl von Bits nach links, wobei die frei werdenden Stellen mit 0-Bits aufgefüllt werden, und legt das Ergebnis auf den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|62|SHL|Verschiebt eine Ganzzahl nach links (Verschiebung in Nullen).|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Wert wird auf den Stapel verschoben.  
  
2.  Die Menge der zu Verschiebe Bits wird auf den Stapel verschoben.  
  
3.  Die Anzahl der zu Verschiebe enden Bits und der Wert aus dem Stapel. der Wert wird um die angegebene Anzahl von Bits nach links verschoben.  
  
4.  Das Ergebnis wird auf den Stapel verschoben.  
  
 Die- `shl` Anweisung verschiebt den Wert (Typ `int32` , `int64` oder `native int` ) um die angegebene Anzahl von Bits nach links. Die Anzahl der Bits ist ein Wert vom Datentyp `int32` oder `native int` . Der Rückgabewert ist nicht angegeben, wenn die Anzahl von Bits, die verschoben werden sollen, größer oder gleich der Breite (in Bits) des angegebenen Werts ist.  
  
 `Shl` Fügt für jede Schicht ein NULL-Bit an der niedrigsten Position ein.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `shl` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Verschiebt einen ganzzahligen Wert um eine angegebene Anzahl von Bits nach rechts, wobei das Vorzeichen mitgeführt wird, und legt das Ergebnis auf den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|63|SHR|Verschiebt eine Ganzzahl nach rechts (verschiebt das Vorzeichen).|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Wert wird auf den Stapel verschoben.  
  
2.  Die Menge der zu Verschiebe Bits wird auf den Stapel verschoben.  
  
3.  Die Anzahl der zu Verschiebe enden Bits und der Wert aus dem Stapel. der Wert wird um die angegebene Anzahl von Bits nach rechts verschoben.  
  
4.  Das Ergebnis wird auf den Stapel verschoben.  
  
 Die- `shr.un` Anweisung verschiebt den Wert (Typ `int32` , `int64` oder `native int` ) nach rechts um die angegebene Anzahl von Bits. Die Anzahl der Bits ist ein Wert vom Datentyp `int32` oder `native int` . Der Rückgabewert ist nicht angegeben, wenn die Anzahl von Bits, die verschoben werden sollen, größer oder gleich der Breite (in Bits) des angegebenen Werts ist.  
  
 `Shr` repliziert das hohe Bestell Bit auf jeder Schicht, wobei das Vorzeichen des ursprünglichen Werts in beibehalten wird `result` .  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `shr` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Verschiebt einen ganzzahligen Wert ohne Vorzeichen um eine angegebene Anzahl von Bits nach rechts, wobei die frei werdenden Stellen mit 0-Bits aufgefüllt werden, und legt das Ergebnis auf den Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|64|shr. UN|Verschiebt eine Ganzzahl nach rechts (Verschiebung in Nullen).|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Wert wird auf den Stapel verschoben.  
  
2.  Die Menge der zu Verschiebe Bits wird auf den Stapel verschoben.  
  
3.  Die Anzahl der zu Verschiebe enden Bits und der Wert aus dem Stapel. der Wert wird um die angegebene Anzahl von Bits nach rechts verschoben.  
  
4.  Das Ergebnis wird auf den Stapel verschoben.  
  
 Die- `shr.un` Anweisung verschiebt den Wert (Typ `int32` , `int64` oder `native int` ) nach rechts um die angegebene Anzahl von Bits. Die Anzahl der Bits ist ein Wert vom Typ `int32` , `int64` oder `native int` . Der Rückgabewert ist nicht angegeben, wenn die Anzahl von Bits, die verschoben werden sollen, größer oder gleich der Breite (in Bits) des angegebenen Werts ist.  
  
 `Shr.un` Fügt bei jeder Schicht ein NULL-Bit an der höchsten Position ein.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `shr.un` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt die Größe eines bereitgestellten Werttyps in Bytes auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|FE 1C-< `T` >|sizeof `valType`|Übersetzen Sie die Größe eines Werttyps in Bytes als `unsigned int32` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Die Größe (in Bytes) des bereitgestellten Werttyps ( `valType` ) wird auf den Stapel verschoben.  
  
 `valType` muss ein Metadatentoken ( `typeref` oder) sein, `typedef` das einen Werttyp, Verweistyp oder einen generischen Typparameter angibt.  
  
 Bei einem Verweistyp ist die zurückgegebene Größe die Größe eines Verweis Werts des entsprechenden Typs (4 Bytes auf 32-Bit-Systemen), nicht die Größe der Daten, die in Objekten gespeichert werden, auf die durch den Verweis Wert verwiesen wird. Ein generischer Typparameter kann nur im Text des Typs oder der Methode verwendet werden, der ihn definiert. Wenn dieser Typ oder diese Methode instanziiert wird, wird der generische Typparameter durch einen Werttyp oder Verweistyp ersetzt.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `sizeof` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert den an der obersten Position des Auswertungsstapels befindlichen Wert im Argumentslot an einem angegebenen Index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|< FE 0B `unsigned int16` >|starg `num`|Holt den obersten Wert aus dem Stapel und speichert ihn im Argument Slot `num` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der Wert, der sich derzeit oberhalb des Stapels befindet, wird per Pop und in den Argument Slot eingefügt `num` .  
  
 Die `starg` Anweisung holt einen Wert aus dem Stapel und platziert Sie in Argument Slot `num` . Der Typ des Werts muss mit dem Typ des Arguments identisch sein, wie in der Signatur der aktuellen Methode angegeben.  
  
 Für Prozeduren, die eine Variable Argumentliste akzeptieren, `starg` kann die Anweisung nur für die anfänglichen Fixed-Argumente verwendet werden, nicht für die Argumente im Variablen Teil der Signatur.  
  
 Durch das Ausführen eines Stores in Argumenten mit einem ganzzahligen Wert, der kleiner als 4 Bytes ist, wird der Wert abgeschnitten, wenn er vom Stapel zum-Argument verschoben wird. Gleit Komma Werte werden von ihrer nativen Größe (Typ `F` ) auf die Größe gerundet, die dem Argument zugeordnet ist.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `starg` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Int16%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert den an der obersten Position des Auswertungsstapels befindlichen Wert im Argumentslot an einem angegebenen Index, Kurzform.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|10 < `unsigned int8` >|starg. s `num`|Holt den obersten Wert aus dem Stapel und speichert ihn im Argument Slot ( `num` Kurzform).|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Der Wert, der sich derzeit oberhalb des Stapels befindet, wird per Pop und in den Argument Slot eingefügt `num` .  
  
 Die `starg.s` Anweisung holt einen Wert aus dem Stapel und platziert Sie in Argument Slot `num` . Der Typ des Werts muss mit dem Typ des Arguments identisch sein, wie in der Signatur der aktuellen Methode angegeben.  
  
 Die- `starg.s` Anweisung bietet eine effiziente Codierung für die Verwendung mit den ersten 256-Argumenten.  
  
 Für Prozeduren, die eine Variable Argumentliste akzeptieren, `starg.s` kann die Anweisung nur für die anfänglichen Fixed-Argumente verwendet werden, nicht für die Argumente im Variablen Teil der Signatur.  
  
 Durch das Ausführen eines Stores in Argumenten mit einem ganzzahligen Wert, der kleiner als 4 Bytes ist, wird der Wert abgeschnitten, wenn er vom Stapel zum-Argument verschoben wird. Gleit Komma Werte werden von ihrer nativen Größe (Typ `F` ) auf die Größe gerundet, die dem Argument zugeordnet ist.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `starg.s` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Byte%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt das Arrayelement am angegebenen Index durch den Wert im Auswertungsstapel, dessen Typ in der Anweisung angegeben ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|A4-< `T` >|stelem `typeTok`|Ersetzt das Array Element am angegebenen Index durch einen Wert vom Typ `typeTok` im Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis auf ein Array, `array` , wird auf den Stapel verschoben.  
  
2.  Ein Indexwert, `index` , für ein Element in `array` wird auf den Stapel verschoben.  
  
3.  Ein Wert des in der Anweisung angegebenen Typs wird auf den Stapel verschoben.  
  
4.  Der Wert, der Index und der Array Verweis werden aus dem Stapel entfernt. der Wert wird in das Array Element am angegebenen Index eingefügt.  
  
 Die- `stelem` Anweisung ersetzt den Wert des-Elements am angegebenen Null basierten Index im eindimensionalen Array `array` durch den-Wert. Der-Wert weist den Typ auf, der durch das Token `typeTok` in der Anweisung angegeben wird.  
  
 Arrays sind Objekte und werden daher durch einen Wert des Typs dargestellt `O` . Der Index ist vom Typ `native int` .  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst `index` , wenn negativ oder größer als die gebundene von ist `array` .  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `stelem` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt das Arrayelement am angegebenen Index durch den <see langword="native int" />-Wert im Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|9B|stelem. i|Ersetzt ein Array Element am angegebenen Index durch den `native int` Wert auf dem Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis auf ein Array, `array` , wird auf den Stapel verschoben.  
  
2.  Ein gültiger Index für ein Element in `array` wird auf den Stapel verschoben.  
  
3.  Ein Wert wird auf den Stapel verschoben.  
  
4.  Der Wert, der Index und der Array Verweis werden aus dem Stapel entfernt. der Wert wird in das Array Element am angegebenen Index eingefügt.  
  
 Die `stelem.i` Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` durch den Wert, der `native int` auf den Stapel verschoben wird.  
  
 Arrays sind Objekte und werden daher durch einen Wert des Typs dargestellt `O` . Der Index ist vom Typ `native int` .  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst `index` , wenn negativ oder größer als die gebundene von ist `array` .  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `stelem.i` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt das Arrayelement am angegebenen Index durch den <see langword="int8" />-Wert im Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|9C|"stelem. I1"|Ersetzt ein Array Element am angegebenen Index durch den `int8` Wert auf dem Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis auf ein Array, `array` , wird auf den Stapel verschoben.  
  
2.  Ein gültiger Index für ein Element in `array` wird auf den Stapel verschoben.  
  
3.  Ein Wert wird auf den Stapel verschoben.  
  
4.  Der Wert, der Index und der Array Verweis werden aus dem Stapel entfernt. der Wert wird in das Array Element am angegebenen Index eingefügt.  
  
 Die `stelem.i1` Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` durch den Wert, der `int8` auf den Stapel verschoben wird.  
  
 Arrays sind Objekte und werden daher durch einen Wert des Typs dargestellt `O` . Der Index ist vom Typ `native int` .  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst `index` , wenn negativ oder größer als die gebundene von ist `array` .  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `stelem.i1` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt das Arrayelement am angegebenen Index durch den <see langword="int16" />-Wert im Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|9d|stelem. I2|Ersetzt ein Array Element am angegebenen Index durch den `int16` Wert auf dem Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis auf ein Array, `array` , wird auf den Stapel verschoben.  
  
2.  Ein gültiger Index für ein Element in `array` wird auf den Stapel verschoben.  
  
3.  Ein Wert wird auf den Stapel verschoben.  
  
4.  Der Wert, der Index und der Array Verweis werden aus dem Stapel entfernt. der Wert wird in das Array Element am angegebenen Index eingefügt.  
  
 Die `stelem.i2` Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` durch den Wert, der `int16` auf den Stapel verschoben wird.  
  
 Arrays sind Objekte und werden daher durch einen Wert des Typs dargestellt `O` . Der Index ist vom Typ `native int` .  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst `index` , wenn negativ oder größer als die gebundene von ist `array` .  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `stelem.i2` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt das Arrayelement am angegebenen Index durch den <see langword="int32" />-Wert im Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|9E|stelem. I4|Ersetzt ein Array Element am angegebenen Index durch den `int32` Wert auf dem Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis auf ein Array, `array` , wird auf den Stapel verschoben.  
  
2.  Ein gültiger Index für ein Element in `array` wird auf den Stapel verschoben.  
  
3.  Ein Wert wird auf den Stapel verschoben.  
  
4.  Der Wert, der Index und der Array Verweis werden aus dem Stapel entfernt. der Wert wird in das Array Element am angegebenen Index eingefügt.  
  
 Die `stelem.i4` Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` durch den Wert, der `int32` auf den Stapel verschoben wird.  
  
 Arrays sind Objekte und werden daher durch einen Wert des Typs dargestellt `O` . Der Index ist vom Typ `native int` .  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst `index` , wenn negativ oder größer als die gebundene von ist `array` .  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `stelem.i4` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt das Arrayelement am angegebenen Index durch den <see langword="int64" />-Wert im Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|9F|stelem. I8|Ersetzt ein Array Element am angegebenen Index durch den `int64` Wert auf dem Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis auf ein Array, `array` , wird auf den Stapel verschoben.  
  
2.  Ein gültiger Index für ein Element in `array` wird auf den Stapel verschoben.  
  
3.  Ein Wert wird auf den Stapel verschoben.  
  
4.  Der Wert, der Index und der Array Verweis werden aus dem Stapel entfernt. der Wert wird in das Array Element am angegebenen Index eingefügt.  
  
 Die `stelem.i8` Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` durch den Wert, der `int64` auf den Stapel verschoben wird.  
  
 Arrays sind Objekte und werden daher durch einen Wert des Typs dargestellt `O` . Der Index ist vom Typ `native int` .  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst `index` , wenn negativ oder größer als die gebundene von ist `array` .  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `stelem.i8` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt das Arrayelement am angegebenen Index durch den <see langword="float32" />-Wert im Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|A0|stelem. R4|Ersetzt ein Array Element am angegebenen Index durch den `float32` Wert auf dem Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis auf ein Array, `array` , wird auf den Stapel verschoben.  
  
2.  Ein gültiger Index für ein Element in `array` wird auf den Stapel verschoben.  
  
3.  Ein Wert wird auf den Stapel verschoben.  
  
4.  Der Wert, der Index und der Array Verweis werden aus dem Stapel entfernt. der Wert wird in das Array Element am angegebenen Index eingefügt.  
  
 Die `stelem.r4` Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` durch den Wert, der `float32` auf den Stapel verschoben wird.  
  
 Arrays sind Objekte und werden daher durch einen Wert des Typs dargestellt `O` . Der Index ist vom Typ `native int` .  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst `index` , wenn negativ oder größer als die gebundene von ist `array` .  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `stelem.r4` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt das Arrayelement am angegebenen Index durch den <see langword="float64" />-Wert im Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|A1|stelem. R8|Ersetzt ein Array Element am angegebenen Index durch den `float64` Wert auf dem Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis auf ein Array, `array` , wird auf den Stapel verschoben.  
  
2.  Ein gültiger Index für ein Element in `array` wird auf den Stapel verschoben.  
  
3.  Ein Wert wird auf den Stapel verschoben.  
  
4.  Der Wert, der Index und der Array Verweis werden aus dem Stapel entfernt. der Wert wird in das Array Element am angegebenen Index eingefügt.  
  
 Die `stelem.r8` Anweisung ersetzt den Wert des Elements `index` im eindimensionalen Array `array` durch den Wert, der `float64` auf den Stapel verschoben wird.  
  
 Arrays sind Objekte und werden daher durch einen Wert des Typs dargestellt `O` . Der Index ist vom Typ `native int` .  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst `index` , wenn negativ oder größer als die gebundene von ist `array` .  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `stelem.r8` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt das Arrayelement am angegebenen Index durch den Wert des Objektverweises (Typ <see langword="O" />) im Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|A2|stelem. Ref|Ersetzt ein Array Element am angegebenen Index durch den `ref` Wert (Typ `O` ) auf dem Stapel.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis auf ein Array, `array` , wird auf den Stapel verschoben.  
  
2.  Ein gültiger Index für ein Element in `array` wird auf den Stapel verschoben.  
  
3.  Ein Wert wird auf den Stapel verschoben.  
  
4.  Der Wert, der Index und der Array Verweis werden aus dem Stapel entfernt. der Wert wird in das Array Element am angegebenen Index eingefügt.  
  
 Die- `stelem.ref` Anweisung ersetzt den Wert des-Elements am angegebenen Index im eindimensionalen Array `array` durch den `ref` (Type)- `O` Wert, der auf den Stapel verschoben wird.  
  
 Arrays sind Objekte und werden daher durch einen Wert des Typs dargestellt `O` . Der Index ist vom Typ `native int` .  
  
 Beachten Sie, dass `stelem.ref` den angegebenen Wert implizit in den Elementtyp von umwandelt, `array` bevor der Wert dem Array Element zugewiesen wird. Diese Umwandlung kann auch für verifizierten Code fehlschlagen. Daher `stelem.ref` kann die Anweisung auslösen <xref:System.InvalidCastException> . Bei eindimensionalen Arrays, die nicht NULL basiert sind, und bei mehrdimensionalen Arrays <xref:System.Array> stellt die-Klasse eine- <xref:System.Array.SetValue%2A> Methode bereit.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `array` ein NULL-Verweis ist.  
  
 <xref:System.IndexOutOfRangeException> wird ausgelöst `index` , wenn negativ oder größer als die gebundene von ist `array` .  
  
 <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn `array` keine Elemente des erforderlichen Typs enthält.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `stelem.ref` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt den im Feld eines Objektsverweises oder Zeigers gespeicherten Wert durch einen neuen Wert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|7D-< `T` >|stfld `field`|Ersetzt den Wert des- `field` Objekts durch einen neuen Wert.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis oder-Zeiger wird auf den Stapel verschoben.  
  
2.  Ein Wert wird auf den Stapel verschoben.  
  
3.  Der Wert und der Objekt Verweis/-Zeiger werden aus dem Stapel entfernt. der Wert von `field` im-Objekt wird durch den angegebenen Wert ersetzt.  
  
 Die `stfld` Anweisung ersetzt den Wert eines Felds eines Objekts (Type `O` ) oder über einen Zeiger (Typ `native int` , `&` oder `*` ) durch einen angegebenen Wert. `Field` ein Metadatentoken, das auf einen Feldmember Verweis verweist. Die `stfld` -Anweisung kann ein Präfix von oder sowohl von als auch von haben <xref:System.Reflection.Emit.OpCodes.Unaligned> <xref:System.Reflection.Emit.OpCodes.Volatile> .  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn der Objekt Verweis oder-Zeiger ein NULL-Verweis ist und das Feld nicht statisch ist.  
  
 <xref:System.MissingFieldException> wird ausgelöst, wenn `field` in den Metadaten nicht gefunden wurde. Dies wird in der Regel geprüft, wenn die MSIL-Anweisung (Microsoft Intermediate Language) in nativen Code konvertiert wird, nicht zur Laufzeit.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `stfld` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.FieldInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert einen Wert vom Typ <see langword="native int" /> an einer angegebenen Adresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|DF|stind. i|Speichert einen `native int` Wert an einer angegebenen Adresse.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Eine Adresse wird auf den Stapel verschoben.  
  
2.  Ein Wert wird auf den Stapel verschoben.  
  
3.  Der Wert und die Adresse werden aus dem Stapel entfernt. der Wert wird bei der Adresse gespeichert.  
  
 Die `stind.i` Anweisung speichert einen `native int` Wert an der angegebenen Adresse (Typ `native int` , `*` oder `&` ).  
  
 Der typsichere Vorgang erfordert, dass die `stind.i` Anweisung in Übereinstimmung mit dem Typ des Zeigers verwendet wird. Der Vorgang der `stind.i` Anweisung kann durch eine unmittelbar vorangehende <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung geändert werden.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `addr` nicht auf natürliche Weise für den Argumenttyp ausgerichtet ist, der durch das Anweisungs Suffix impliziert wird.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `stind.i` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert einen Wert vom Typ <see langword="int8" /> an einer angegebenen Adresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|52|stind. I1|Speichert einen- `int8` Wert an einer angegebenen Adresse.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Eine Adresse wird auf den Stapel verschoben.  
  
2.  Ein Wert wird auf den Stapel verschoben.  
  
3.  Der Wert und die Adresse werden aus dem Stapel entfernt. der Wert wird bei der Adresse gespeichert.  
  
 Die `stind.i1` Anweisung speichert einen- `int8` Wert an der angegebenen Adresse (Typ `native int` , `*` oder `&` ).  
  
 Der typsichere Vorgang erfordert, dass die `stind.i1` Anweisung in Übereinstimmung mit dem Typ des Zeigers verwendet wird. Der Vorgang der `stind.i1` Anweisung kann durch eine unmittelbar vorangehende <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung geändert werden.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `addr` nicht auf natürliche Weise für den Argumenttyp ausgerichtet ist, der durch das Anweisungs Suffix impliziert wird.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `stind.i1` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert einen Wert vom Typ <see langword="int16" /> an einer angegebenen Adresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|53|stind. I2|Speichert einen- `int16` Wert an einer angegebenen Adresse.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Eine Adresse wird auf den Stapel verschoben.  
  
2.  Ein Wert wird auf den Stapel verschoben.  
  
3.  Der Wert und die Adresse werden aus dem Stapel entfernt. der Wert wird bei der Adresse gespeichert.  
  
 Die `stind.i2` Anweisung speichert einen- `int16` Wert an der angegebenen Adresse (Typ `native int` , `*` oder `&` ).  
  
 Der typsichere Vorgang erfordert, dass die `stind.2i` Anweisung in Übereinstimmung mit dem Typ des Zeigers verwendet wird. Der Vorgang der `stind.i2` Anweisung kann durch eine unmittelbar vorangehende <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung geändert werden.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `addr` nicht auf natürliche Weise für den Argumenttyp ausgerichtet ist, der durch das Anweisungs Suffix impliziert wird.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `stind.i2` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert einen Wert vom Typ <see langword="int32" /> an einer angegebenen Adresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|54|stind. I4|Speichert einen- `int32` Wert an einer angegebenen Adresse.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Eine Adresse wird auf den Stapel verschoben.  
  
2.  Ein Wert wird auf den Stapel verschoben.  
  
3.  Der Wert und die Adresse werden aus dem Stapel entfernt. der Wert wird bei der Adresse gespeichert.  
  
 Die `stind.i4` Anweisung speichert einen- `int32` Wert an der angegebenen Adresse (Typ `native int` , `*` oder `&` ).  
  
 Der typsichere Vorgang erfordert, dass die `stind.i4` Anweisung in Übereinstimmung mit dem Typ des Zeigers verwendet wird. Der Vorgang der `stind.i4` Anweisung kann durch eine unmittelbar vorangehende <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung geändert werden.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `addr` nicht auf natürliche Weise für den Argumenttyp ausgerichtet ist, der durch das Anweisungs Suffix impliziert wird.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `stind.i4` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert einen Wert vom Typ <see langword="int64" /> an einer angegebenen Adresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|55|stind. I8|Speichert einen- `int64` Wert an einer angegebenen Adresse.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Eine Adresse wird auf den Stapel verschoben.  
  
2.  Ein Wert wird auf den Stapel verschoben.  
  
3.  Der Wert und die Adresse werden aus dem Stapel entfernt. der Wert wird bei der Adresse gespeichert.  
  
 Die `stind.i8` Anweisung speichert einen- `int64` Wert an der angegebenen Adresse (Typ `native int` , `*` oder `&` ).  
  
 Der typsichere Vorgang erfordert, dass die `stind.i8` Anweisung in Übereinstimmung mit dem Typ des Zeigers verwendet wird. Der Vorgang der `stind.i` Anweisung kann durch eine unmittelbar vorangehende <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung geändert werden.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `addr` nicht auf natürliche Weise für den Argumenttyp ausgerichtet ist, der durch das Anweisungs Suffix impliziert wird.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `stind.i8` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert einen Wert vom Typ <see langword="float32" /> an einer angegebenen Adresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|56|stind. R4|Speichert einen `float32` Wert an einer angegebenen Adresse.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Eine Adresse wird auf den Stapel verschoben.  
  
2.  Ein Wert wird auf den Stapel verschoben.  
  
3.  Der Wert und die Adresse werden aus dem Stapel entfernt. der Wert wird bei der Adresse gespeichert.  
  
 Die `stind.r4` Anweisung speichert einen `float32` Wert an der angegebenen Adresse (Typ `native int` , `*` oder `&` ).  
  
 Der typsichere Vorgang erfordert, dass die `stind.r4` Anweisung in Übereinstimmung mit dem Typ des Zeigers verwendet wird. Der Vorgang der `stind.r4` Anweisung kann durch eine unmittelbar vorangehende <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung geändert werden.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `addr` nicht auf natürliche Weise für den Argumenttyp ausgerichtet ist, der durch das Anweisungs Suffix impliziert wird.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `stind.r4` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert einen Wert vom Typ <see langword="float64" /> an einer angegebenen Adresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|57|stind. R8|Speichert einen `float64` Wert an einer angegebenen Adresse.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Eine Adresse wird auf den Stapel verschoben.  
  
2.  Ein Wert wird auf den Stapel verschoben.  
  
3.  Der Wert und die Adresse werden aus dem Stapel entfernt. der Wert wird bei der Adresse gespeichert.  
  
 Die `stind.r8` Anweisung speichert einen `float64` Wert an der angegebenen Adresse (Typ `native int` , `*` oder `&` ).  
  
 Der typsichere Vorgang erfordert, dass die `stind.r8` Anweisung in Übereinstimmung mit dem Typ des Zeigers verwendet wird. Der Vorgang der `stind.r8` Anweisung kann durch eine unmittelbar vorangehende <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung geändert werden.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `addr` nicht auf natürliche Weise für den Argumenttyp ausgerichtet ist, der durch das Anweisungs Suffix impliziert wird.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `stind.r8` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert einen Objektverweiswert an einer angegebenen Adresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|51|stind. Ref|Speichert einen Objekt Verweis (Type `O` )-Wert an einer angegebenen Adresse.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Eine Adresse wird auf den Stapel verschoben.  
  
2.  Ein Wert wird auf den Stapel verschoben.  
  
3.  Der Wert und die Adresse werden aus dem Stapel entfernt. der Wert wird bei der Adresse gespeichert.  
  
 Die `stind.ref` Anweisung speichert einen Objekt Verweis Wert an der angegebenen Adresse (Typ `native int` , `*` oder `&` ).  
  
 Der typsichere Vorgang erfordert, dass die `stind.ref` Anweisung in Übereinstimmung mit dem Typ des Zeigers verwendet wird. Der Vorgang der `stind.ref` Anweisung kann durch eine unmittelbar vorangehende <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung geändert werden.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `addr` nicht auf natürliche Weise für den Argumenttyp ausgerichtet ist, der durch das Anweisungs Suffix impliziert wird.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `stind.ref` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Holt den aktuellen Wert von der obersten Position des Auswertungsstapels und speichert ihn in der Liste der lokalen Variablen am angegebenen Index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|FE 0E < `unsigned int16` >|stloc `index`|Holt einen Wert aus dem Stapel und speichert ihn in der lokalen Variablen `index` .|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Wert wird aus dem Stapel entfernt und in der lokalen Variablen abgelegt `index` .  
  
 Die `stloc` Anweisung holt den obersten Wert aus dem Auswertungs Stapel und verschiebt ihn in die Nummer der lokalen Variablen `index` , wobei lokale Variablen auf 0 (null) nummeriert werden. Der Typ des Werts muss mit dem Typ der lokalen Variablen identisch sein, wie in der lokalen Signatur der aktuellen Methode angegeben.  
  
 Beim Speichern in lokale Variablen, die einen ganzzahligen Wert kleiner als 4 Bytes enthalten, wird der Wert abgeschnitten, wenn er vom Stapel zur lokalen Variablen verschoben wird. Gleit Komma Werte werden von ihrer nativen Größe (Typ `F` ) auf die Größe gerundet, die dem Argument zugeordnet ist.  
  
 Zum Korrigieren von MSIL-Anweisungen (Microsoft Intermediate Language) ist `index` ein gültiger lokaler Index erforderlich. Für die- `stloc` Anweisung `index` muss im Bereich von 0 bis 65534 einschließlich liegen (insbesondere 65535 ist ungültig). Der Grund für das Ausschließen von 65535 ist pragmatisch: wahrscheinliche Implementierungen verwenden eine 2-Byte-Ganzzahl, um sowohl den Index eines lokalen als auch die Gesamtzahl der lokalen Variablen für eine bestimmte Methode zu verfolgen. Wenn ein Index von 65535 als gültig fest gegeben wurde, wäre eine breitere Ganzzahl erforderlich, um die Anzahl der lokalen Variablen in einer solchen Methode zu verfolgen.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladungen können den `stloc` Opcode verwenden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.LocalBuilder%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Int16%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Holt den aktuellen Wert von der obersten Position des Auswertungsstapels und speichert ihn in der Liste der lokalen Variablen am Index 0.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|0a|stloc. 0|Holt einen Wert aus dem Stapel in die lokale Variable 0.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Wert wird aus dem Stapel entfernt und in der lokalen, von 0 indizierten Variablen platziert.  
  
 Die `stloc.0` Anweisung holt den obersten Wert vom Auswertungs Stapel und verschiebt ihn in die von 0 indizierte lokale Variable. Der Typ des Werts muss mit dem Typ der lokalen Variablen identisch sein, wie in der lokalen Signatur der aktuellen Methode angegeben.  
  
 `stloc.0` ist eine besonders effiziente Codierung zum Speichern von Werten in der lokalen Variablen 0.  
  
 Beim Speichern in lokale Variablen, die einen ganzzahligen Wert kleiner als 4 Bytes enthalten, wird der Wert abgeschnitten, wenn er vom Stapel zur lokalen Variablen verschoben wird. Gleit Komma Werte werden von ihrer nativen Größe (Typ `F` ) auf die Größe gerundet, die dem Argument zugeordnet ist.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `stloc.0` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Holt den aktuellen Wert von der obersten Position des Auswertungsstapels und speichert ihn in der Liste der lokalen Variablen am Index 1.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|0 B|stloc. 1|Holt einen Wert aus dem Stapel in die lokale Variable 1.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Wert wird aus dem Stapel entfernt und in der lokalen, von 1 indizierten Variablen platziert.  
  
 Die `stloc.1` Anweisung holt den obersten Wert aus dem Auswertungs Stapel und verschiebt ihn in die von 1 indizierte lokale Variable. Der Typ des Werts muss mit dem Typ der lokalen Variablen identisch sein, wie in der lokalen Signatur der aktuellen Methode angegeben.  
  
 `stloc.1` ist eine besonders effiziente Codierung zum Speichern von Werten in der lokalen Variablen 1.  
  
 Beim Speichern in lokale Variablen, die einen ganzzahligen Wert kleiner als 4 Bytes enthalten, wird der Wert abgeschnitten, wenn er vom Stapel zur lokalen Variablen verschoben wird. Gleit Komma Werte werden von ihrer nativen Größe (Typ `F` ) auf die Größe gerundet, die dem Argument zugeordnet ist.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `stloc.1` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Holt den aktuellen Wert von der obersten Position des Auswertungsstapels und speichert ihn in der Liste der lokalen Variablen am Index 2.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|0C|stloc. 2|Holt einen Wert aus dem Stapel in die lokale Variable 2.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Wert wird aus dem Stapel entfernt und in der lokalen, von 2 indizierten Variablen platziert.  
  
 Die `stloc.2` Anweisung holt den obersten Wert vom Auswertungs Stapel und verschiebt ihn in die von 2 indizierte lokale Variable. Der Typ des Werts muss mit dem Typ der lokalen Variablen identisch sein, wie in der lokalen Signatur der aktuellen Methode angegeben.  
  
 `stloc.2` ist eine besonders effiziente Codierung zum Speichern von Werten in der lokalen Variablen 2.  
  
 Beim Speichern in lokale Variablen, die einen ganzzahligen Wert kleiner als 4 Bytes enthalten, wird der Wert abgeschnitten, wenn er vom Stapel zur lokalen Variablen verschoben wird. Gleit Komma Werte werden von ihrer nativen Größe (Typ `F` ) auf die Größe gerundet, die dem Argument zugeordnet ist.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `stloc.2` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Holt den aktuellen Wert von der obersten Position des Auswertungsstapels und speichert ihn in der Liste der lokalen Variablen am Index 3.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|0d|stloc. 3|Holt einen Wert aus dem Stapel in die lokale Variable 3.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Wert wird aus dem Stapel entfernt und in der lokalen, von 3 indizierten Variablen platziert.  
  
 Die `stloc.3` Anweisung holt den obersten Wert vom Auswertungs Stapel und verschiebt ihn in die von 3 indizierte lokale Variable. Der Typ des Werts muss mit dem Typ der lokalen Variablen identisch sein, wie in der lokalen Signatur der aktuellen Methode angegeben.  
  
 `stloc.3` ist eine besonders effiziente Codierung zum Speichern von Werten in der lokalen Variablen 3.  
  
 Beim Speichern in lokale Variablen, die einen ganzzahligen Wert kleiner als 4 Bytes enthalten, wird der Wert abgeschnitten, wenn er vom Stapel zur lokalen Variablen verschoben wird. Gleit Komma Werte werden von ihrer nativen Größe (Typ `F` ) auf die Größe gerundet, die dem Argument zugeordnet ist.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `stloc.3` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Holt den aktuellen Wert von der obersten Position des Auswertungsstapels und speichert ihn in der Liste der lokalen Variablen am <paramref name="index" /> (Kurzform).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|13 < `unsigned int8` >|stloc. s `index`|Holt einen Wert aus dem Stapel und speichert ihn in der lokalen Variablen `index` Kurzform.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Wert wird aus dem Stapel entfernt und in der lokalen Variablen abgelegt `index` .  
  
 Die `stloc.s` Anweisung holt den obersten Wert aus dem Auswertungs Stapel und verschiebt ihn in die Nummer der lokalen Variablen `index` , wobei lokale Variablen auf 0 (null) nummeriert werden. Der Typ des Werts muss mit dem Typ der lokalen Variablen identisch sein, wie in der lokalen Signatur der aktuellen Methode angegeben.  
  
 Die- `stloc.s` Anweisung bietet eine effiziente Codierung für lokale Variablen 0 bis 255.  
  
 Beim Speichern in lokale Variablen, die einen ganzzahligen Wert kleiner als 4 Bytes enthalten, wird der Wert abgeschnitten, wenn er vom Stapel zur lokalen Variablen verschoben wird. Gleit Komma Werte werden von ihrer nativen Größe (Typ `F` ) auf die Größe gerundet, die dem Argument zugeordnet ist.  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladungen können den `stloc.s` Opcode verwenden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.LocalBuilder%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Byte%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Kopiert einen Wert mit dem angegebenen Typ vom Auswertungsstapel in die angegebene Speicheradresse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|81 < `T` >|stobj `class`|Speichert einen Wert vom Typ `class` aus dem Stapel in den Arbeitsspeicher.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Eine Adresse wird auf den Stapel verschoben.  
  
2.  Ein Werttyp Objekt vom Typ `class` wird auf den Stapel verschoben.  
  
3.  Das-Objekt und die-Adresse werden aus dem Stapel entfernt. Das Werttyp Objekt wird an der Adresse gespeichert.  
  
 Die `stobj` Anweisung kopiert das Werttyp Objekt in die von der Adresse angegebene Adresse (ein Zeiger vom Typ `native int` , `*` oder `&` ). Die Anzahl der kopierten Bytes hängt von der Größe der durch dargestellten Klasse ab `class` , einem Metadatentoken, das einen Werttyp darstellt.  
  
 Der Vorgang der `stobj` Anweisung kann durch eine unmittelbar vorangehende <xref:System.Reflection.Emit.OpCodes.Volatile> oder <xref:System.Reflection.Emit.OpCodes.Unaligned> Präfix Anweisung geändert werden.  
  
 <xref:System.TypeLoadException> wird ausgelöst, wenn die Klasse nicht gefunden werden kann. Dies wird in der Regel erkannt, wenn MSIL-Anweisungen (Microsoft Intermediate Language) in systemeigenen Code anstatt zur Laufzeit konvertiert werden.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `stobj` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ersetzt den Wert eines statischen Felds durch einen Wert vom Auswertungsstapel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|80 < `T` >|stsfld `field`|Ersetzt den Wert in `field` durch einen angegebenen Wert.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Wert wird auf den Stapel verschoben.  
  
2.  Ein Wert wird aus dem Stapel entfernt und in gespeichert `field` .  
  
 Die `stsfld` Anweisung ersetzt den Wert eines statischen Felds durch einen Wert aus dem Stapel. `field` ein Metadatentoken, das auf einen statischen Feldmember verweisen muss.  
  
 Der `stsfld` Anweisung kann ein Präfix vorangestellt werden <xref:System.Reflection.Emit.OpCodes.Volatile> .  
  
 <xref:System.MissingFieldException> wird ausgelöst, wenn das Feld in den Metadaten nicht gefunden wurde. Dies wird in der Regel geprüft, wenn MSIL-Anweisungen (Microsoft Intermediate Language) in systemeigenen Code konvertiert werden, nicht zur Laufzeit.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `stsfld` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.FieldInfo%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Subtrahiert einen Wert von einem anderen Wert und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|59|sub|Subtrahiert einen Wert von einem anderen und gibt einen neuen numerischen Wert zurück.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt; `value2` wird von subtrahiert `value1` .  
  
4.  Das Ergebnis wird auf den Stapel verschoben.  
  
 Ein Überlauf für ganzzahlige Vorgänge wird nicht erkannt (für eine ordnungsgemäße Überlauf Behandlung finden Sie unter <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> ).  
  
 Ganzzahlige Subtraktion umschlossen und nicht als ganze Zahl. Beispiel: bei 8-Bit-Ganzzahlen, wobei `value1` auf 0 festgelegt und `value2` auf 1 festgelegt wird, ist das "umschließende" Ergebnis 255.  
  
 Gleit Komma Überlauf gibt `+inf` ( `PositiveInfinity` ) oder `-inf` () zurück `NegativeInfinity` .  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `sub` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Subtrahiert einen Ganzzahlwert von einem anderen Ganzzahlwert, führt eine Überlaufprüfung durch und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|De|Sub. ovf|Subtrahiert einen ganzzahligen Wert von einem anderen mit einer Überlauf Überprüfung.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt; `value2` wird von `value1` mit einer Überprüfung auf einen Überlauf subtrahiert.  
  
4.  Das Ergebnis wird auf den Stapel verschoben.  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Dieser Vorgang wird für ganze Zahlen mit Vorzeichen ausgeführt. Verwenden Sie für Gleit Komma Werte <xref:System.Reflection.Emit.OpCodes.Sub> .  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `sub.ovf` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Subtrahiert einen Ganzzahlwert ohne Vorzeichen von einem anderen Ganzzahlwert, führt eine Überlaufprüfung durch und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|DB|Sub. ovf. UN|Subtrahiert einen ganzzahligen Wert ohne Vorzeichen von einem anderen mit einer Überlauf Überprüfung.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel entfernt; `value2` wird von `value1` mit einer Überprüfung auf einen Überlauf subtrahiert.  
  
4.  Das Ergebnis wird auf den Stapel verschoben.  
  
 <xref:System.OverflowException> wird ausgelöst, wenn das Ergebnis nicht im Ergebnistyp dargestellt werden kann.  
  
 Dieser Vorgang wird für ganze Zahlen mit Vorzeichen ausgeführt. Verwenden Sie für Gleit Komma Werte <xref:System.Reflection.Emit.OpCodes.Sub> .  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `sub.ovf.un` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Implementiert eine Sprungtabelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|45 < `unsigned int32` > < `int32` >... < `int32` >|Switch ( `N` , `t1` , `t2` ... `tN` )|Springt zu einem der- `N` Werte.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Wert wird auf den Stapel verschoben.  
  
2.  Der Wert wird aus dem Stapel entfernt, und die Ausführung wird an die Anweisung an dem Offset übertragen, der durch den-Wert indiziert wird, wobei der Wert kleiner als ist `N` .  
  
 Die `switch` Anweisung implementiert eine Sprung Tabelle. Das Format der Anweisung ist eine `unsigned int32` , die die Anzahl von Zielen darstellt `N` , gefolgt von Int32-Werten, die `N` Sprung Ziele angeben. Diese Ziele werden als Offsets (positiv oder negativ) ab dem Anfang der Anweisung dargestellt, die dieser `switch` Anweisung folgt.  
  
 Die `switch` Anweisung holt einen Wert aus dem Stapel und vergleicht ihn als ganze Zahl ohne Vorzeichen mit `N` . Wenn value kleiner als ist `N` , wird die Ausführung an das Ziel übertragen, das durch den Wert indiziert wird, wobei Ziele von 0 nummeriert werden (z. b. der Wert 0 nimmt das erste Ziel, der Wert 1 das zweite Ziel, usw.). Wenn der Wert größer oder gleich ist, wird `N` die Ausführung bei der nächsten Anweisung (durchlaufen) fortgesetzt.  
  
 Wenn die Ziel Anweisung mindestens einen Präfix Code aufweist, kann die Steuerung nur an das erste dieser Präfixe übertragen werden.  
  
 Steuerelement Übertragungen in und aus- `try` , `catch` -, `filter` -und- `finally` Blöcken können von dieser Anweisung nicht ausgeführt werden. (Solche Übertragungen sind stark eingeschränkt und müssen stattdessen die Leave-Anweisung verwenden).  
  
 Mit der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `switch` Opcode verwendet werden. Das- `Label[]` Argument ist ein Array von Bezeichnungen, das 32-Bit-Offsets darstellt.  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%5B%5D%29?displayProperty=nameWithType>  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie der `Switch` Opcode verwendet wird, um mithilfe eines Arrays von eine Sprung Tabelle zu generieren <xref:System.Reflection.Emit.Label> .  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Führt eine Postfix-Methodenaufrufanweisung in der Weise aus, dass der Stapelrahmen der aktuellen Methode vor der Ausführung der eigentlichen Aufrufanweisung entfernt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|FE 14|Rohr.|Der nachfolgende-Rückruf beendet aktuelle Methoden|  
  
 Es ist kein Stapel Übergangs Verhalten für diese Anweisung definiert.  
  
 Die `tail` Präfix Anweisung muss unmittelbar vor einer- <xref:System.Reflection.Emit.OpCodes.Call> ,-oder-Anweisung stehen <xref:System.Reflection.Emit.OpCodes.Calli> <xref:System.Reflection.Emit.OpCodes.Callvirt> . Gibt an, dass der Stapel Rahmen der aktuellen Methode entfernt werden soll, bevor die-Anweisung ausgeführt wird. Außerdem impliziert dies, dass der Wert, der vom folgenden-Befehl zurückgegeben wird, auch der von der aktuellen Methode zurückgegebene Wert ist, und der-Befehl kann daher in einen Methoden übergreifenden Sprung konvertiert werden.  
  
 Der Stapel muss leer sein, mit Ausnahme der Argumente, die durch den folgenden-Befehl übertragen werden. Die Anweisung, die auf die-Anweisung folgt, muss ein ret sein. Daher ist die einzige gültige Code Sequenz `tail. call` (oder `calli` oder `callvirt` ). Korrekte MSIL-Anweisungen (Microsoft Intermediate Language) dürfen nicht mit der `call` Anweisung verzweigt werden, Sie können jedoch mit der folgenden Verzweigung verzweigen <xref:System.Reflection.Emit.OpCodes.Ret> .  
  
 Der aktuelle Frame kann nicht verworfen werden, wenn die Steuerung von nicht vertrauenswürdigem Code zu vertrauenswürdigem Code übertragen wird, da dadurch die Code Identitäts Sicherheit gefährdet wird. Die .NET Framework Sicherheitsüberprüfungen können daher bewirken `tail` , dass ignoriert wird und eine Standard <xref:System.Reflection.Emit.OpCodes.Call> Anweisung verlässt. Entsprechend `tail` wird das Präfix ignoriert, wenn es verwendet wird, um eine als synchronisiert markierte Methode zu beenden, damit das Beenden eines synchronisierten Bereichs nach der Rückgabe des Aufrufes zugelassen wird.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `tail` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">Eine Instanz eines eines Opcodeobjekts.</param>
        <summary>Gibt TRUE oder FALSE zurück, wenn der bereitgestellte Opcode ein Einzelbyte-Argument akzeptiert.</summary>
        <returns><see langword="true" /> oder <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um zu ermitteln, welche MSIL-Opcodes "Kurzform" sind, um Sie in optimiertem Code zu verwenden.  
  
 `TakesSingleByteArgument` Gibt zurück, `true` Wenn die- <xref:System.Reflection.Emit.OpCode> Instanz in den folgenden Fällen ein einzelnes Byte Argument annimmt:  
  
-   Der Opcode führt eine Verzweigungs Anweisung für eine Adresse mit Byte Größe aus (z <xref:System.Reflection.Emit.OpCodes.Br_S> <xref:System.Reflection.Emit.OpCodes.Bgt_S> . b. und).  
  
-   Der Opcode überträgt einen Bytewert auf den Stapel (z <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S> . b.).  
  
-   Der Opcode verweist auf eine Variable oder ein Argument über das Byte-Format "Kurzform" (z <xref:System.Reflection.Emit.OpCodes.Ldloc_S> <xref:System.Reflection.Emit.OpCodes.Stloc_S> . b. und).  
  
 Andernfalls wird `false`zurückgegeben.  
  
 Im folgenden Beispiel wird die Verwendung von veranschaulicht `TakesSingleByteArgument` , indem die `OpCodes` -Klasse reflektiert und getestet wird, ob jedes `OpCode` Feld ein Single-Byte-Argument annimmt.  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Löst das Ausnahmeobjekt aus, das sich momentan auf dem Auswertungsstapel befindet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|7a|throw|Löst eine Ausnahme aus.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis (auf eine Ausnahme) wird auf dem Stapel abgelegt.  
  
2.  Der Objekt Verweis wird aus dem Stapel entfernt, und die Ausnahme wird ausgelöst.  
  
 Die- `throw` Anweisung löst das Ausnahme Objekt (Typ) aus, das sich `O` derzeit auf dem Stapel befinden.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn der Objekt Verweis ein NULL-Verweis ist.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `throw` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass eine Adresse, die sich momentan oben auf dem Stapel befindet, möglicherweise nicht an der eigentlichen Größe der unmittelbar darauf folgenden <see langword="ldind" />-Anweisung, <see langword="stind" />-Anweisung, <see langword="ldfld" />-Anweisung, <see langword="stfld" />-Anweisung, <see langword="ldobj" />-Anweisung, <see langword="stobj" />-Anweisung, <see langword="initblk" />-Anweisung oder <see langword="cpblk" />-Anweisung ausgerichtet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|< FE 12 `unsigned int8` >|nicht ausgerichtete. `alignment`|Gibt an, dass die nachfolgende Zeiger Anweisung möglicherweise nicht ausgerichtet ist.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Eine Adresse wird auf den Stapel verschoben.  
  
 `Unaligned` Gibt an, dass die Adresse (ein nicht verwalteter Zeiger `native int` ) im Stapel möglicherweise nicht an der natürlichen Größe der unmittelbar folgenden,,,,,, oder-Anweisung ausgerichtet ist `ldind` `stind` `ldfld` `stfld` `ldobj` `stobj` `initblk` `cpblk` . Das heißt, für eine- <xref:System.Reflection.Emit.OpCodes.Ldind_I4> Anweisung ist die Ausrichtung der Adresse möglicherweise nicht auf eine 4-Byte-Grenze fest. Für `initblk` und `cpblk` ist die Standardausrichtung Architektur abhängig (4-Byte auf 32-Bit-CPUs, 8 Bytes auf 64-Bit-CPUs). Code-Generatoren, die ihre Ausgabe nicht auf eine 32-Bit-Wort Größe beschränken, müssen verwenden, `unaligned` Wenn die Ausrichtung beim Kompilieren nicht als 8-Byte-Wert bekannt ist.  
  
 Der Wert von Alignment muss 1, 2 oder 4 lauten und bedeutet, dass der generierte Code davon ausgehen soll, dass die Adresse Byte, Doppelbyte bzw. vier Byte ausgerichtet ist. Beachten Sie, dass vorübergehende Zeiger (Typ `*` ) immer ausgerichtet sind.  
  
 Obwohl die Ausrichtung für eine `cpblk` Anweisung logisch zwei Zahlen erfordert (eine für die Quelle und eine für das Ziel), gibt es keine merkliche Auswirkung auf die Leistung, wenn nur die niedrigere Zahl angegeben wird.  
  
 Die `unaligned` `volatile` Präfixe und können in einer der beiden Reihen folgen kombiniert werden. Sie müssen unmittelbar vor einer-,-,-,-,-,- `ldind` `stind` oder-Anweisung stehen `ldfld` `stfld` `ldobj` `stobj` `initblk` `cpblk` . Nur das <xref:System.Reflection.Emit.OpCodes.Volatile> Präfix ist für die <xref:System.Reflection.Emit.OpCodes.Ldsfld> Anweisungen und zulässig <xref:System.Reflection.Emit.OpCodes.Stsfld> .  
  
 Die folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladungen können den `unaligned` Opcode verwenden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.Emit.Label%29?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Byte%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert die Darstellung eines mittels Boxing gepackten Werttyps in seine mittels Unboxing entpackte Entsprechung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|79 < `T` >|Unboxing `valType`|Extrahiert die Werttyp Daten aus der zugehörigen Kasten `obj` Darstellung.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis wird auf den Stapel verschoben.  
  
2.  Der Objekt Verweis wird aus dem Stapel entfernt und in einen Werttyp Zeiger entpackt.  
  
3.  Der Werttyp Zeiger wird auf den Stapel verschoben.  
  
 Ein Werttyp verfügt über zwei separate Darstellungen innerhalb der Common Language Infrastructure (CLI):  
  
-   Ein "RAW"-Formular, das verwendet wird, wenn ein Werttyp in ein anderes Objekt eingebettet ist.  
  
-   Ein geschachteltes Formular, in dem die Daten im Werttyp in ein Objekt umwickelt (geschachtelt) werden, damit es als unabhängige Entität vorhanden sein kann.  
  
 Die `unbox` Anweisung konvertiert den Objekt Verweis (Typ `O` ), die einfügende Darstellung eines Werttyps, in einen Werttyp Zeiger (ein verwalteter Zeiger, Typ `&` ), seine Unboxing-Form. Der angegebene Werttyp ( `valType` ) ist ein Metadatentoken, das den Typ des Werttyps angibt, der innerhalb des geschachtelten Objekts  
  
 Anders als bei <xref:System.Reflection.Emit.OpCodes.Box> , der erforderlich ist, um eine Kopie eines Werttyps für die Verwendung im-Objekt zu erstellen, `unbox` ist nicht erforderlich, um den Werttyp aus dem-Objekt zu kopieren. In der Regel wird nur die Adresse des Werttyps berechnet, der bereits in dem geschachtelten Objekt vorhanden ist.  
  
 <xref:System.InvalidCastException> wird ausgelöst, wenn das Objekt nicht als geschachtelt wird `valType` .  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn der Objekt Verweis ein NULL-Verweis ist.  
  
 <xref:System.TypeLoadException> wird ausgelöst, wenn der Werttyp `valType` nicht gefunden werden kann. Dies wird in der Regel erkannt, wenn MSIL-Anweisungen (Microsoft Intermediate Language) in systemeigenen Code konvertiert werden, anstatt zur Laufzeit.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `unbox` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Konvertiert die geschachtelte Darstellung eines n der Anweisung angegebenen Typs in seine nicht geschachtelte Form.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|A5-< `T` >|unbox. Any `typeTok`|Extrahieren Sie die Daten aus der zugehörigen Kasten `obj` Darstellung.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Ein Objekt Verweis `obj` wird auf den Stapel verschoben.  
  
2.  Der Objekt Verweis wird aus dem Stapel entfernt und in den in der Anweisung angegebenen Typ entpackt.  
  
3.  Der resultierende Objekt Verweis oder Werttyp wird auf den Stapel verschoben.  
  
 Wenn Sie auf die geschachtelte Form eines Werttyps angewendet wird, `unbox.any` extrahiert die Anweisung den in `obj` (vom Typ) enthaltenen Wert `O` und ist daher `unbox` mit gefolgt von identisch `ldobj` .  
  
 Wenn die Anweisung auf einen Verweistyp angewendet wird, `unbox.any` hat dies dieselbe Wirkung wie `castclass` `typeTok` .  
  
 Wenn der Operand `typeTok` ein generischer Typparameter ist, wird das Laufzeitverhalten durch den Typ bestimmt, der für diesen generischen Typparameter angegeben wird.  
  
 <xref:System.InvalidCastException> wird ausgelöst, wenn kein geschachtelter `obj` Typ ist.  
  
 <xref:System.NullReferenceException> wird ausgelöst, wenn `obj` ein NULL-Verweis ist.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `unbox.any` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Type%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass es sich bei einer Adresse, die sich momentan oben auf dem Auswertungsstapel befindet, möglicherweise um eine flüchtige Adresse handelt und daher die aus diesem Speicherort gelesenen Ergebnisse nicht zwischengespeichert werden können oder mehrere für diesen Speicherort ausgeführte Speichervorgänge nicht unterdrückt werden können.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|FE 13|ständigem.|Gibt an, dass der nachfolgende Zeiger Verweis flüchtig ist.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  Eine Adresse wird auf den Stapel verschoben.  
  
 `volatile`. Gibt an, dass es sich bei der Adresse um eine flüchtige Adresse handelt (d. h., Sie kann extern mit dem aktuellen Ausführungs Thread referenziert werden), und die Ergebnisse der Lesevorgänge können nicht zwischengespeichert werden Das Markieren eines Zugriffs als `volatile` wirkt sich nur auf den einzelnen Zugriff aus. andere Zugriffe auf denselben Speicherort müssen separat gekennzeichnet werden. Der Zugriff auf flüchtige Speicherorte muss nicht atomarisch ausgeführt werden.  
  
 Die <xref:System.Reflection.Emit.OpCodes.Unaligned> `volatile` Präfixe und können in einer der beiden Reihen folgen kombiniert werden. Sie müssen unmittelbar vor einer-,-,-,-,-,- `ldind` `stind` oder-Anweisung stehen `ldfld` `stfld` `ldobj` `stobj` `initblk` `cpblk` . Nur das `volatile` Präfix ist für die <xref:System.Reflection.Emit.OpCodes.Ldsfld> Anweisungen und zulässig <xref:System.Reflection.Emit.OpCodes.Stsfld> .  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `volatile` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Berechnet das bitweise XOR der beidem auf dem Stapel an oberster Position befindlichen Werte und legt das Ergebnis auf dem Auswertungsstapel ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle werden das hexadezimale und das MSIL-AssemblyFormat (Microsoft Intermediate Language) zusammen mit einer kurzen Verweis Zusammenfassung aufgelistet:  
  
|Format|AssemblyFormat|BESCHREIBUNG|  
|------------|---------------------|-----------------|  
|61|xor|Berechnet das bitweise XOR von zwei ganzzahligen Werten und gibt eine ganze Zahl zurück.|  
  
 Das Stapel Übergangs Verhalten ist in sequenzieller Reihenfolge:  
  
1.  `value1` wird auf den Stapel verschoben.  
  
2.  `value2` wird auf den Stapel verschoben.  
  
3.  `value2` und `value1` werden aus dem Stapel und ihrer bitweisen XOR-Berechnung aus dem Stapel entfernt.  
  
4.  Der bitweise XOR von `value2` und `value1` wird auf den Stapel verschoben.  
  
 Die `xor` -Anweisung berechnet das bitweise XOR der obersten beiden Werte im Stapel und verlässt das Ergebnis auf dem Stapel.  
  
 `Xor` ist ein ganzzahliger spezifischer Vorgang.  
  
 In der folgenden <xref:System.Reflection.Emit.ILGenerator.Emit%2A> Methoden Überladung kann der `xor` Opcode verwendet werden:  
  
-   <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%29?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
