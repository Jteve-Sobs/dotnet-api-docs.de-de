<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="TypeBuilder.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac50a3d455de9bd4fc2bafe3221ec13aeb7bd4ade87.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0a3d455de9bd4fc2bafe3221ec13aeb7bd4ade87</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Defines and creates new instances of classes during run time.</source>
          <target state="translated">Definiert und erstellt zur Laufzeit neue Instanzen von Klassen.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> is the root class used to control the creation of dynamic classes in the runtime.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> die Stammklasse dient zum Steuern der Erstellung von dynamischen Klassen in der Laufzeit verwendet.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>It provides a set of routines that are used to define classes, add methods and fields, and create the class inside a module.</source>
          <target state="translated">Er bietet einen Satz von Routinen, die zum Definieren von Klassen, Methoden und Felder hinzufügen und erstellen Sie die Klasse innerhalb eines Moduls verwendet werden.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>A new <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> can be created from a dynamic module by calling the <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType&gt;</ph> method, which returns a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">Ein neues <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> können aus einem dynamischen Modul erstellt werden, durch Aufrufen der <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType&gt;</ph> Methode, die zurückgibt ein <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Reflection emit provides the following options for defining types:</source>
          <target state="translated">Reflektionsausgabe bietet die folgenden Optionen zum Definieren der Typen:</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class or interface with the given name.</source>
          <target state="translated">Definieren Sie eine Klasse oder Schnittstelle mit dem angegebenen Namen.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class or interface with the given name and attributes.</source>
          <target state="translated">Definieren Sie eine Klasse oder Schnittstelle mit dem angegebenen Namen und Attributen.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class with the given name, attributes, and base class.</source>
          <target state="translated">Definieren Sie eine Klasse mit dem angegebenen Namen, die Attribute und die Basisklasse.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class with the given name, attributes, base class, and the set of interfaces that the class implements.</source>
          <target state="translated">Definieren Sie eine Klasse mit dem angegebenen Namen, Attribute, Basisklasse und die Gruppe von Schnittstellen, die die Klasse implementiert.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class with the given name, attributes, base class, and packing size.</source>
          <target state="translated">Definieren Sie eine Klasse mit dem angegebenen Namen, Attribute, Basisklasse und Komprimierungsgröße.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class with the given name, attributes, base class, and the class size as a whole.</source>
          <target state="translated">Definieren Sie eine Klasse mit dem angegebenen Namen, Attribute, Basisklasse und die Klassengröße als Ganzes.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class with the given name, attributes, base class, packing size, and the class size as a whole.</source>
          <target state="translated">Definieren Sie eine Klasse mit dem angegebenen Namen, Attribute, Basisklasse, Komprimierungsgröße und die Klassengröße als Ganzes.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>To create an array type, pointer type, or byref type for an incomplete type that is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object, use the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> method, <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A&gt;</ph> method, or <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A&gt;</ph> method, respectively.</source>
          <target state="translated">So erstellen ein Arraytyp, Zeigertyp oder Byref-Typ für einen unvollständigen Typ, der durch dargestellt wird eine <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> -Objekts die <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> -Methode, <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A&gt;</ph> -Methode, oder <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A&gt;</ph> Methode bzw.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Before a type is used, the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph> method must be called.</source>
          <target state="translated">Bevor ein Typ verwendet wird, die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph> -Methode muss aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source><bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept> completes the creation of the type.</source>
          <target state="translated"><bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept> schließt die Erstellung des Typs.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Following the call to <bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept>, the caller can instantiate the type by using the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> method, and invoke members of the type by using the <ph id="ph2">&lt;xref:System.Type.InvokeMember%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Nach dem Aufruf von <bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept>, der Aufrufer kann den Typ instanziieren, indem Sie mit der <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> -Methode, und rufen Sie Member des Typs mit der <ph id="ph2">&lt;xref:System.Type.InvokeMember%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>It is an error to invoke methods that change the implementation of a type after <bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept> has been called.</source>
          <target state="translated">Es ist ein Fehler zum Aufrufen von Methoden, die die Implementierung eines Typs nach dem Ändern <bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept> aufgerufen wurde.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>For example, the common language runtime throws an exception if the caller tries to add new members to a type.</source>
          <target state="translated">Beispielsweise löst die common Language Runtime eine Ausnahme aus, wenn der Aufrufer versucht, eine neue Elemente hinzufügen.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>A class initializer is created by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Ein Klasseninitialisierer wird erstellt, indem Sie mit der <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source><bpt id="p1">**</bpt>DefineTypeInitializer<ept id="p1">**</ept> returns a <ph id="ph1">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> object.</source>
          <target state="translated"><bpt id="p1">**</bpt>DefineTypeInitializer<ept id="p1">**</ept> gibt eine <ph id="ph1">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Nested types are defined by calling one of the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Geschachtelte Typen werden durch einen Aufruf der definiert die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Attributes</source>
          <target state="translated">Attribute</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class uses the <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeration to further specify the characteristics of the type to be created:</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> -Klasse verwendet die <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> Enumeration genauer die Merkmale des zu erstellenden Typs anzugeben:</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Interfaces are specified using the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType&gt;</ph> attributes.</source>
          <target state="translated">Schnittstellen werden angegeben, mit der <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType&gt;</ph> und <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType&gt;</ph> Attribute.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Concrete classes (classes that cannot be extended) are specified using the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">Konkrete Klassen (Klassen, die nicht erweitert werden) werden angegeben, mit der <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType&gt;</ph> Attribut.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Several attributes determine type visibility.</source>
          <target state="translated">Mehrere Attribute bestimmen typsichtbarkeit.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>See the description of the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeration.</source>
          <target state="translated">Siehe dazu die Beschreibung der <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> Enumeration.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>If <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> is specified, the class loader lays out fields in the order they are read from metadata.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> angegeben ist, wird das Ladeprogramm Layout der Felder in der Reihenfolge, die sie aus den Metadaten gelesen werden.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The class loader considers the specified packing size but ignores any specified field offsets.</source>
          <target state="translated">Das Klassenladeprogramm der hält der angegebene Komprimierungsgröße, ignoriert jedoch die angegebenen Feldoffsets.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The metadata preserves the order in which the field definitions are emitted.</source>
          <target state="translated">Die Metadaten behält die Reihenfolge, in der die Felddefinitionen ausgegeben werden.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Even across a merge, the metadata will not reorder the field definitions.</source>
          <target state="translated">Sogar über eine Zusammenführung wird die Metadaten die Felddefinitionen nicht neu anordnen.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The loader will honor the specified field offsets only if <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph> is specified.</source>
          <target state="translated">Das Ladeprogramm berücksichtigt nur, wenn das angegebene Feld Offsets <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph> angegeben ist.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Known Issues</source>
          <target state="translated">Bekannte Probleme</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Reflection emit does not verify whether a non-abstract class that implements an interface has implemented all the methods declared in the interface.</source>
          <target state="translated">Reflektionsausgabe überprüft nicht, ob eine nicht abstrakte Klasse, die eine Schnittstelle implementiert, alle in der Schnittstelle deklarierten Methoden implementiert hat.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>However, if the class does not implement all the methods declared in an interface, the runtime does not load the class.</source>
          <target state="translated">Jedoch, wenn die Klasse nicht alle in einer Schnittstelle deklarierten Methoden implementiert, wird die Common Language Runtime nicht die Klasse geladen.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Although <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> is derived from <ph id="ph2">&lt;xref:System.Type&gt;</ph>, some of the abstract methods defined in the <ph id="ph3">&lt;xref:System.Type&gt;</ph> class are not fully implemented in the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class.</source>
          <target state="translated">Obwohl <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> stammt aus <ph id="ph2">&lt;xref:System.Type&gt;</ph>, einige der abstrakten Methoden definiert, der <ph id="ph3">&lt;xref:System.Type&gt;</ph> Klasse sind nicht vollständig implementiert der <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Calls to these <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> methods throw a <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> exception.</source>
          <target state="translated">Aufrufe dieser <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> Methoden lösen eine <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> Ausnahme.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The desired functionality can be obtained by retrieving the created type using the <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and reflecting on the retrieved type.</source>
          <target state="translated">Die gewünschte Funktionalität erhalten Sie durch Abrufen des erstellten Typs mithilfe der <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> und Reflektieren des abgerufenen Typs.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>This section contains two code examples.</source>
          <target state="translated">Dieser Abschnitt enthält zwei Codebeispiele.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The first example shows how to create a dynamic type with a field, constructor, property, and method.</source>
          <target state="translated">Im erste Beispiel wird gezeigt, wie einen dynamischen Typ mit einem Feld, Konstruktor Eigenschaft und Methode erstellt wird.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The second example builds a method dynamically from user input.</source>
          <target state="translated">Im zweite Beispiel erstellt eine Methode dynamisch aus den Benutzereingaben.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source><bpt id="p1">**</bpt>Example one<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Beispiel einer<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The following code example shows how to define a dynamic assembly with one module.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie eine dynamische Assembly mit einem Modul definiert.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The module in the example assembly contains one type, <ph id="ph1">`MyDynamicType`</ph>, which has a private field, a property that gets and sets the private field, constructors that initialize the private field, and a method that multiplies a user-supplied number by the private field value and returns the result.</source>
          <target state="translated">Das Modul in der Beispielassembly enthält einen Typ <ph id="ph1">`MyDynamicType`</ph>, verfügt über ein privates Feld, eine Eigenschaft, die ermittelt und definiert das private Feld, Konstruktoren, die das private Feld zu initialisieren und eine Methode, die eine vom Benutzer angegebene Zahl von privaten Feld multipliziert. Wert und gibt das Ergebnis zurück.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType&gt;</ph> field is specified when the assembly is created.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType&gt;</ph> Feld wird angegeben, wenn die Assembly erstellt wird.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The assembly code is used immediately, and the assembly is also saved to disk so that it can be examined with <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> or used in another program.</source>
          <target state="translated">Der Assemblycode wird sofort verwendet werden soll, und die Assembly wird auch gespeichert, damit es mit geprüft werden auf den Datenträger <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> oder in einem anderen Programm verwendet.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source><bpt id="p1">**</bpt>Example two<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Beispiel 2<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The following code sample demonstrates how to build a dynamic type by using <ph id="ph1">`TypeBuilder`</ph>.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie einen dynamischen Typ zu erstellen, indem Sie mithilfe von <ph id="ph1">`TypeBuilder`</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The security action to be taken such as Demand, Assert, and so on.</source>
          <target state="translated">Die auszuführende Sicherheitsaktion (z. B. Demand, Assert usw.).</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The set of permissions the action applies to.</source>
          <target state="translated">Der Berechtigungssatz, für den die Aktion gilt.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>Adds declarative security to this type.</source>
          <target state="translated">Fügt diesem Typ deklarative Sicherheit hinzu.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source><ph id="ph1">`AddDeclarativeSecurity`</ph> may be called several times with each call specifying a security action (such as Demand, Assert, or Deny) and a set of permissions that apply to the action.</source>
          <target state="translated"><ph id="ph1">`AddDeclarativeSecurity`</ph> kann mehrmals aufgerufen werden mit jedem Aufruf eine Sicherheitsaktion (z. B. Demand, Assert oder DENY-Anweisung) und einen Satz von Berechtigungen, die für die Aktion gelten angeben.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a type by using this method are stored in the old XML metadata format.</source>
          <target state="translated">In der .NET Framework-Versionen 1.0, 1.1 und 2.0 sind die Attribute für deklarative Sicherheit auf einen Typ angewendet werden, mithilfe dieser Methode in das alte Format der XML-Metadaten gespeichert.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The following example demonstrates the use of the <ph id="ph1">`AddDeclarativeSecurity`</ph> method to add a security demand for <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag to a dynamic type named <ph id="ph4">`MyDynamicClass`</ph>, in an assembly named EmittedExample.dll.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung von der <ph id="ph1">`AddDeclarativeSecurity`</ph> Methode, um eine sicherheitsforderung für hinzuzufügen <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> Flag zu einem dynamischen Typ mit dem Namen <ph id="ph4">`MyDynamicClass`</ph>, in einer Assembly mit dem Namen EmittedExample.dll.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The example produces no console output; after you run it, you can use <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine EmittedExample.dll.</source>
          <target state="translated">Das Beispiel führt die Konsolenausgabe; Nachdem Sie es ausführen, können Sie <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> EmittedExample.dll untersuchen.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>In <ph id="ph1">`MyDynamicClass`</ph>, open the <ph id="ph2">`.class public auto ansi`</ph> statement to see the declarative permission.</source>
          <target state="translated">In <ph id="ph1">`MyDynamicClass`</ph>öffnen die <ph id="ph2">`.class public auto ansi`</ph> Anweisung, um die deklarative Berechtigung finden Sie unter.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> is invalid (<ph id="ph2">&lt;see langword="RequestMinimum" /&gt;</ph>, <ph id="ph3">&lt;see langword="RequestOptional" /&gt;</ph>, and <ph id="ph4">&lt;see langword="RequestRefuse" /&gt;</ph> are invalid).</source>
          <target state="translated">Die <ph id="ph1">&lt;paramref name="action" /&gt;</ph> ist ungültig (<ph id="ph2">&lt;see langword="RequestMinimum" /&gt;</ph>, <ph id="ph3">&lt;see langword="RequestOptional" /&gt;</ph> und <ph id="ph4">&lt;see langword="RequestRefuse" /&gt;</ph> sind ungültig).</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The containing type has been created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Der enthaltende Typ wurde mithilfe von <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The permission set <ph id="ph1">&lt;paramref name="pset" /&gt;</ph> contains an action that was added earlier by <ph id="ph2">&lt;see langword="AddDeclarativeSecurity" /&gt;</ph>.</source>
          <target state="translated">Der Berechtigungssatz <ph id="ph1">&lt;paramref name="pset" /&gt;</ph> enthält eine Aktion, die bereits durch <ph id="ph2">&lt;see langword="AddDeclarativeSecurity" /&gt;</ph> hinzugefügt wurde.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;paramref name="pset" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pset" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
          <source>The interface that this type implements.</source>
          <target state="translated">Die Schnittstelle, die dieser Typ implementiert.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
          <source>Adds an interface that this type implements.</source>
          <target state="translated">Fügt eine Schnittstelle hinzu, die dieser Typ implementiert.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
          <source>The following code sample demonstrates the implementation of an interface on a dynamically created type using <ph id="ph1">`AddInterfaceImplementation`</ph>.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Implementierung einer Schnittstelle in einer dynamisch erstellten Typ mit <ph id="ph1">`AddInterfaceImplementation`</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
          <source><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Der Typ wurde zuvor mit <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.Assembly">
          <source>Retrieves the dynamic assembly that contains this type definition.</source>
          <target state="translated">Ruft die dynamische Assembly ab, die diese Typdefinition enthält.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Assembly">
          <source>Read-only.</source>
          <target state="translated">Schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Assembly">
          <source>Retrieves the dynamic assembly that contains this type definition.</source>
          <target state="translated">Ruft die dynamische Assembly ab, die diese Typdefinition enthält.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>Returns the full name of this type qualified by the display name of the assembly.</source>
          <target state="translated">Gibt den vollständigen Name des Typs zurück, der durch den Anzeigenamen der Assembly gekennzeichnet ist.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>Read-only.</source>
          <target state="translated">Schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>The full name of this type qualified by the display name of the assembly.</source>
          <target state="translated">Der vollständige Name des Typs, der durch den Anzeigenamen der Assembly gekennzeichnet ist.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>The format of the returned string is the concatenation of the full name of the type (<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.FullName%2A&gt;</ph>) and the display name of the assembly (<ph id="ph2">&lt;xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType&gt;</ph>), separated by a comma and a space.</source>
          <target state="translated">Das Format der zurückgegebenen Zeichenfolge ist die Verkettung von den vollständigen Namen des Typs (<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.FullName%2A&gt;</ph>) und den Anzeigenamen der Assembly (<ph id="ph2">&lt;xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType&gt;</ph>), getrennt durch ein Komma und ein Leerzeichen.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for a description of the format of the display name of an assembly.</source>
          <target state="translated">Finden Sie unter <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> eine Beschreibung des Formats des Anzeigenamens einer Assembly.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>Version Information</source>
          <target state="translated">Versionsinformationen</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>In the .NET Framework versions 1.0 and 1.1, the value of this property does not include the culture or public key.</source>
          <target state="translated">In der .NET Framework-Versionen 1.0 und 1.1 enthalten der Wert dieser Eigenschaft nicht die Kultur oder den öffentlichen Schlüssel.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.BaseType">
          <source>Retrieves the base type of this type.</source>
          <target state="translated">Ruft den Basistyp dieses Typs ab.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.BaseType">
          <source>Read-only.</source>
          <target state="translated">Schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.BaseType">
          <source>Retrieves the base type of this type.</source>
          <target state="translated">Ruft den Basistyp dieses Typs ab.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object for the class.</source>
          <target state="translated">Erstellt ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt für die Klasse.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>After defining fields and methods on the class, <ph id="ph1">&lt;see langword="CreateType" /&gt;</ph> is called in order to load its <ph id="ph2">&lt;see langword="Type" /&gt;</ph> object.</source>
          <target state="translated">Nachdem die Felder und Methoden für die Klasse definiert sind, wird <ph id="ph1">&lt;see langword="CreateType" /&gt;</ph> aufgerufen, um das <ph id="ph2">&lt;see langword="Type" /&gt;</ph>-Objekt der Klasse zu laden.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>Returns the new <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object for this class.</source>
          <target state="translated">Gibt das neue <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt für diese Klasse zurück.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>If this type is a nested type, the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method must be called on the enclosing type before it is called on the nested type.</source>
          <target state="translated">Wenn dieser Typ ein geschachtelter Typ ist der <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> -Methode muss für den einschließenden Typ aufgerufen werden, bevor sie auf den geschachtelten Typ aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>If the current type derives from an incomplete type or implements incomplete interfaces, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method on the parent type and the interface types before calling it on the current type.</source>
          <target state="translated">Wenn der aktuelle Typ ein unvollständiger Typ abgeleitet oder unvollständige Schnittstellen implementiert, rufen Sie die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> -Methode für den übergeordneten Typ und die Schnittstellentypen vor dem Aufrufen dieser für den aktuellen Typ.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>If the enclosing type contains a field that is a value type defined as a nested type (for example, a field that is an enumeration defined as a nested type), calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method on the enclosing type will generate a <ph id="ph2">&lt;xref:System.AppDomain.TypeResolve?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Wenn der einschließende Typ ein Feld enthält, die ein Werttyp, der als ein geschachtelter Typ (z. B. ein Feld, das eine Enumeration, die als ein geschachtelter Typ definiert ist) definiert ist Aufrufen der <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> -Methode des einschließenden Typs generiert einen <ph id="ph2">&lt;xref:System.AppDomain.TypeResolve?displayProperty=nameWithType&gt;</ph> Ereignis.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>This is because the loader cannot determine the size of the enclosing type until the nested type has been completed.</source>
          <target state="translated">Dies ist, da das Ladeprogramm die Größe des einschließenden Typs nicht, bis zum Abschluss des geschachtelten Typs bestimmen kann.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The caller should define a handler for the <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph> event to complete the definition of the nested type by calling <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> on the <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the nested type.</source>
          <target state="translated">Der Aufrufer sollte definieren Sie einen Ereignishandler für das <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph> Ereignis zum Abschließen der Definition des geschachtelten Typs durch den Aufruf <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> auf die <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> Objekt, das den geschachtelten Typ darstellt.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The code example for this topic shows how to define such an event handler.</source>
          <target state="translated">Das Codebeispiel in diesem Thema zeigt, wie ein solcher Ereignishandler zu definieren.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>A type is created only once, no matter how many times the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method is called.</source>
          <target state="translated">Ein Typ wird nur einmal erstellt, unabhängig davon, wie oft die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> -Methode aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>All calls return the same <ph id="ph1">&lt;xref:System.Type&gt;</ph> object.</source>
          <target state="translated">Alle Aufruf zurück, die die gleiche <ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The following code example shows how to define an event handler for the <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve?displayProperty=nameWithType&gt;</ph> event, in order to call the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method on a nested type during a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> call on the enclosing type.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie definiert einen Ereignishandler für die <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve?displayProperty=nameWithType&gt;</ph> -Ereignis für den Aufruf der <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> Methode für einen geschachtelten Typ bei einer <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> für den einschließenden Typ aufgerufen.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The enclosing type has not been created.</source>
          <target state="translated">Der einschließende Typ wurde nicht erstellt.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>This type is non-abstract and contains an abstract method.</source>
          <target state="translated">Dieser Typ ist nicht abstrakt und enthält eine abstrakte Methode.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>This type is not an abstract class or an interface and has a method without a method body.</source>
          <target state="translated">Dieser Typ ist weder eine abstrakte Klasse noch eine Schnittstelle und hat eine Methode ohne Methodenkörper.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The type contains invalid Microsoft intermediate language (MSIL) code.</source>
          <target state="translated">Der Typ enthält ungültigen MSIL-Code (Microsoft Intermediate Language).</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The branch target is specified using a 1-byte offset, but the target is at a distance greater than 127 bytes from the branch.</source>
          <target state="translated">Das Verzweigungsziel ist mit einem Offset von 1 Byte angegeben, die Entfernung des Ziels von der Verzweigung ist jedoch größer als 127 Bytes.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The type cannot be loaded.</source>
          <target state="translated">Der Typ kann nicht geladen werden.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>For example, it contains a <ph id="ph1">&lt;see langword="static" /&gt;</ph> method that has the calling convention <ph id="ph2">&lt;see cref="F:System.Reflection.CallingConventions.HasThis" /&gt;</ph>.</source>
          <target state="translated">Er enthält beispielsweise eine <ph id="ph1">&lt;see langword="static" /&gt;</ph>-Methode, die die Aufrufkonvention <ph id="ph2">&lt;see cref="F:System.Reflection.CallingConventions.HasThis" /&gt;</ph> hat.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.TypeInfo" /&gt;</ph> object that represents this type.</source>
          <target state="translated">Ruft ein <ph id="ph1">&lt;see cref="T:System.Reflection.TypeInfo" /&gt;</ph>-Objekt ab, das diesen Typ darstellt.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo">
          <source>An object that represents this type.</source>
          <target state="translated">Ein Objekt, das diesen Typ darstellt.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod">
          <source>Gets the method that declared the current generic type parameter.</source>
          <target state="translated">Ruft die Methode ab, die den aktuellen generischen Typparameter deklariert hat.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> that represents the method that declared the current type, if the current type is a generic type parameter; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Eine <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> zur Darstellung der Methode, die den aktuellen Typ deklariert hat, wenn der aktuelle Typ ein generischer Typparameter ist, andernfalls <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod">
          <source>When emitting code, a generic type parameter is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object rather than by a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">Wenn Code ausgeben, wird durch ein generischen Typparameter dargestellt eine <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> Objekt und keine <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringType">
          <source>Returns the type that declared this type.</source>
          <target state="translated">Gibt den Typ zurück, der diesen Typ deklariert hat.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringType">
          <source>Read-only.</source>
          <target state="translated">Schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringType">
          <source>The type that declared this type.</source>
          <target state="translated">Der Typ, der diesen Typ deklariert hat.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Adds a new constructor to the dynamic type.</source>
          <target state="translated">Fügt dem dynamischen Typ einen neuen Konstruktor hinzu.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The attributes of the constructor.</source>
          <target state="translated">Die Attribute des Konstruktors.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The calling convention of the constructor.</source>
          <target state="translated">Die Aufrufkonvention des Konstruktors.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The parameter types of the constructor.</source>
          <target state="translated">Die Parametertypen des Konstruktors.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>Adds a new constructor to the type, with the given attributes and signature.</source>
          <target state="translated">Fügt dem Typ einen neuen Konstruktor mit den angegebenen Attributen und der Signatur hinzu.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The defined constructor.</source>
          <target state="translated">Der definierte Konstruktor.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>If you do not define a constructor for your dynamic type, a default constructor is provided automatically, and it calls the default constructor of the base class.</source>
          <target state="translated">Wenn Sie keinen Konstruktor für den dynamischen Typ definieren, ein Standardkonstruktor wird automatisch bereitgestellt, und er ruft den Standardkonstruktor der Basisklasse.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>If you define a constructor for your dynamic type, a default constructor is not provided.</source>
          <target state="translated">Wenn Sie einen Konstruktor für den dynamischen Typ definieren, wird ein Standardkonstruktor nicht bereitgestellt.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>You have the following options for providing a default constructor in addition to the constructor you defined:</source>
          <target state="translated">Sie haben die folgenden Optionen für die Bereitstellung eines Standardkonstruktors zusätzlich zu den Konstruktor aus, den Sie definiert:</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>If you want a default constructor that simply calls the default constructor of the base class, you can use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A&gt;</ph> method to create one (and optionally restrict access to it).</source>
          <target state="translated">Wenn Sie einen Standardkonstruktor möchten, der einfach den Standardkonstruktor der Basisklasse aufruft, können Sie die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A&gt;</ph> Methode zum Erstellen einer (und optional Beschränken des Zugriffs auf diese).</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>Do not provide an implementation for this default constructor.</source>
          <target state="translated">Stellen Sie eine Implementierung für diesen Standardkonstruktor nicht.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>If you do, an exception is thrown when you try to use the constructor.</source>
          <target state="translated">Wenn Sie dies tun, wird eine Ausnahme ausgelöst, wenn Sie versuchen, den Konstruktor zu verwenden.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>No exception is thrown when the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method is called.</source>
          <target state="translated">Es werden keine Ausnahmen ausgelöst, wenn die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> -Methode aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>If you want a default constructor that does something more than simply calling the default constructor of the base class, or that calls another constructor of the base class, or that does something else entirely, you must use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType&gt;</ph> method to create one, and provide your own implementation.</source>
          <target state="translated">Wenn Sie möchten einen Standardkonstruktor, der nicht mehr als einfach den Standardkonstruktor der Basisklasse aufrufen, oder einen anderen Konstruktor aufruft, etwas anderes die Basisklasse oder, die vollständig ist, müssen Sie die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType&gt;</ph> Methode, erstellen und eine eigene Implementierung bereitzustellen.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The following code sample demonstrates the use of <ph id="ph1">`DefineConstructor`</ph> to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> for MSIL population.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung von <ph id="ph1">`DefineConstructor`</ph> bestimmten Signatur und ihrer Attribute des Konstruktors für einen dynamischen Typ festgelegt und Zurückgeben eines entsprechenden <ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> für MSIL Auffüllung.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Der Typ wurde zuvor mit <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The attributes of the constructor.</source>
          <target state="translated">Die Attribute des Konstruktors.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The calling convention of the constructor.</source>
          <target state="translated">Die Aufrufkonvention des Konstruktors.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The parameter types of the constructor.</source>
          <target state="translated">Die Parametertypen des Konstruktors.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Ein Array mit Arrays von Typen.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Jedes Array von Typen stellt die erforderlichen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Wenn ein bestimmter Parameter keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> anstelle eines Arrays von Typen an.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Wenn keiner der Parameter erforderliche benutzerdefinierte Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> anstelle eines Arrays mit Arrays an.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Ein Array mit Arrays von Typen.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Jedes Array von Typen stellt die optionalen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Wenn ein bestimmter Parameter keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> anstelle eines Arrays von Typen an.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Wenn keiner der Parameter optionale benutzerdefinierte Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> anstelle eines Arrays mit Arrays an.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>Adds a new constructor to the type, with the given attributes, signature, and custom modifiers.</source>
          <target state="translated">Fügt dem Typ einen neuen Konstruktor mit den angegebenen Attributen, der angegebenen Signatur und den angegebenen benutzerdefinierten Modifizierern hinzu.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The defined constructor.</source>
          <target state="translated">Der definierte Konstruktor.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>This overload is provided for designers of managed compilers.</source>
          <target state="translated">Diese Überladung wird für Designer von verwalteten Compilern bereitgestellt.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
          <target state="translated">Weitere Informationen zu benutzerdefinierten Modifizierer finden Sie in der ECMA Partition II-Metadaten-Dokumentation.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. Sie finden sie unter <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> auf der Ecma International-Website.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The size of <ph id="ph1">&lt;paramref name="requiredCustomModifiers" /&gt;</ph> or <ph id="ph2">&lt;paramref name="optionalCustomModifiers" /&gt;</ph> does not equal the size of <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph>.</source>
          <target state="translated">Die Größe von <ph id="ph1">&lt;paramref name="requiredCustomModifiers" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="optionalCustomModifiers" /&gt;</ph> entspricht nicht die Größe von <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Der Typ wurde zuvor mit <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Für den aktuellen dynamischen Typ ist die <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph>-Eigenschaft <ph id="ph2">&lt;see langword="true" /&gt;</ph>, aber die <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph>-Eigenschaft ist <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>A <ph id="ph1">&lt;see langword="MethodAttributes" /&gt;</ph> object representing the attributes to be applied to the constructor.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see langword="MethodAttributes" /&gt;</ph>-Objekt, das die auf den Konstruktor anzuwendenden Attribute darstellt.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>Defines the default constructor.</source>
          <target state="translated">Definiert den Standardkonstruktor.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>The constructor defined here will simply call the default constructor of the parent.</source>
          <target state="translated">Der hier definierte Konstruktor ruft einfach den Standardkonstruktor des übergeordneten Elements auf.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>Returns the constructor.</source>
          <target state="translated">Gibt den Konstruktor zurück.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>Because the default constructor is automatically defined, it is necessary to call this method only in the following situations:</source>
          <target state="translated">Da der Standardkonstruktor automatisch definiert wird, ist es notwendig, diese Methode nur in den folgenden Situationen:</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>You have defined another constructor and you also want a default constructor that simply calls the base class constructor.</source>
          <target state="translated">Sie haben einen anderen Konstruktor definiert, und möchten auch einen Standardkonstruktor, der einfach den Basisklassenkonstruktor aufruft.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>You want to set the attributes on the default constructor to something other than <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.PrivateScope&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Public&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.HideBySig&gt;</ph>, <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.SpecialName&gt;</ph>, and <ph id="ph5">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName&gt;</ph>.</source>
          <target state="translated">Anders als die Attribute des Standardkonstruktors auf einen anderen Wert festlegen möchten <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.PrivateScope&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Public&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.HideBySig&gt;</ph>, <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.SpecialName&gt;</ph>, und <ph id="ph5">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>The following code sample demonstrates the use of <ph id="ph1">`DefineConstructor`</ph> to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> for MSIL population.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung von <ph id="ph1">`DefineConstructor`</ph> bestimmten Signatur und ihrer Attribute des Konstruktors für einen dynamischen Typ festgelegt und Zurückgeben eines entsprechenden <ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> für MSIL Auffüllung.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>The parent type (base type) does not have a default constructor.</source>
          <target state="translated">Der übergeordnete Typ (Basistyp) weist keinen Standardkonstruktor auf.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Der Typ wurde zuvor mit <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Für den aktuellen dynamischen Typ ist die <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph>-Eigenschaft <ph id="ph2">&lt;see langword="true" /&gt;</ph>, aber die <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph>-Eigenschaft ist <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The name of the event.</source>
          <target state="translated">Der Name des Ereignisses.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The attributes of the event.</source>
          <target state="translated">Die Attribute des Ereignisses.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The type of the event.</source>
          <target state="translated">Der Typ des Ereignisses.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>Adds a new event to the type, with the given name, attributes and event type.</source>
          <target state="translated">Fügt dem Typ ein neues Ereignis hinzu, das den angegebenen Namen, die angegebenen Attribute und den angegebenen Ereignistyp hat.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The defined event.</source>
          <target state="translated">Das definierte Ereignis.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source><ph id="ph1">&lt;paramref name="eventtype" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="eventtype" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Der Typ wurde zuvor mit <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Adds a new field to the dynamic type.</source>
          <target state="translated">Fügt ein neues Feld zum dynamischen Typ hinzu.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The name of the field.</source>
          <target state="translated">Der Name des Felds.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>fieldName<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>fieldName<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The type of the field</source>
          <target state="translated">Der Typ des Felds.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The attributes of the field.</source>
          <target state="translated">Die Attribute des Felds.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>Adds a new field to the type, with the given name, attributes, and field type.</source>
          <target state="translated">Fügt ein neues Feld mit dem angegebenen Namen, den angegebenen Attribute und dem angegebenen Feldtyp zum Typ hinzu.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The defined field.</source>
          <target state="translated">Das definierte Feld.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> is zero.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is System.Void.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist „System.Void“.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>A total size was specified for the parent class of this field.</source>
          <target state="translated">Für die übergeordnete Klasse dieses Felds wurde eine Gesamtgröße angegeben.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Der Typ wurde zuvor mit <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The name of the field.</source>
          <target state="translated">Der Name des Felds.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>fieldName<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>fieldName<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The type of the field</source>
          <target state="translated">Der Typ des Felds.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>An array of types representing the required custom modifiers for the field, such as <ph id="ph1">&lt;see cref="T:Microsoft.VisualC.IsConstModifier" /&gt;</ph>.</source>
          <target state="translated">Gibt ein Array von Typen zurück, das die erforderlichen benutzerdefinierten Modifizierer für das Feld darstellt, z. B. <ph id="ph1">&lt;see cref="T:Microsoft.VisualC.IsConstModifier" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>An array of types representing the optional custom modifiers for the field, such as <ph id="ph1">&lt;see cref="T:Microsoft.VisualC.IsConstModifier" /&gt;</ph>.</source>
          <target state="translated">Gibt ein Array von Typen zurück, das die optionalen benutzerdefinierten Modifizierer für das Feld darstellt, z. B. <ph id="ph1">&lt;see cref="T:Microsoft.VisualC.IsConstModifier" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The attributes of the field.</source>
          <target state="translated">Die Attribute des Felds.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>Adds a new field to the type, with the given name, attributes, field type, and custom modifiers.</source>
          <target state="translated">Fügt ein neues Feld mit dem angegebenen Namen, den Attributen, dem Feldtyp und den benutzerdefinierten Modifizierern zum Typ hinzu.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The defined field.</source>
          <target state="translated">Das definierte Feld.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>This overload is provided for designers of managed compilers.</source>
          <target state="translated">Diese Überladung wird für Designer von verwalteten Compilern bereitgestellt.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> is zero.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is System.Void.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist „System.Void“.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>A total size was specified for the parent class of this field.</source>
          <target state="translated">Für die übergeordnete Klasse dieses Felds wurde eine Gesamtgröße angegeben.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Der Typ wurde zuvor mit <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>An array of names for the generic type parameters.</source>
          <target state="translated">Ein Array von Namen für die generischen Typparameter.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>Defines the generic type parameters for the current type, specifying their number and their names, and returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> objects that can be used to set their constraints.</source>
          <target state="translated">Definiert die generischen Typparameter für den aktuellen Typ, gibt dabei deren Zahl und deren Namen an und gibt ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>-Objekten zurück, das dazu verwendet werden kann, deren Einschränkungen festzulegen.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> objects that can be used to define the constraints of the generic type parameters for the current type.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>-Objekten, das dazu verwendet werden kann, die Einschränkungen der generischen Typparameter für den aktuellen Typ zu definieren.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>Calling this method makes the current type a generic type.</source>
          <target state="translated">Beim Aufrufen dieser Methode wird der aktuelle Typ einen generischen Typ.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>If the method is called again on the same type, an <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
          <target state="translated">Wenn die Methode erneut auf den gleichen Typ aufgerufen wird eine <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>The following code example creates a generic type with two type parameters and saves them in the assembly GenericEmitExample1.dll.</source>
          <target state="translated">Im folgenden Codebeispiel wird ein generischer Typ mit zwei Typparametern erstellt und speichert sie in der Assembly GenericEmitExample1.dll gespeichert werden.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to view the generated types.</source>
          <target state="translated">Sie können die <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> So zeigen Sie die generierten Typen an.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>For a more detailed explanation of the steps involved in defining a dynamic generic type, see <bpt id="p1">[</bpt>How to: Define a Generic Type with Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md)</ept>.</source>
          <target state="translated">Eine ausführlichere Erläuterung der Schritte sind für einen dynamischen generischen Typ definieren, finden Sie unter <bpt id="p1">[</bpt>wie: Definieren eines generischen Typs mit Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>Generic type parameters have already been defined for this type.</source>
          <target state="translated">Es wurden bereits generische Typparameter für diesen Typ definiert.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source><ph id="ph1">&lt;paramref name="names" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="names" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>An element of <ph id="ph1">&lt;paramref name="names" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Element von <ph id="ph1">&lt;paramref name="names" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source><ph id="ph1">&lt;paramref name="names" /&gt;</ph> is an empty array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="names" /&gt;</ph> ist ein leeres Array.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The name used to refer to the data.</source>
          <target state="translated">Der Name, der zum Verweisen auf die Daten verwendet wird.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The blob of data.</source>
          <target state="translated">Das Daten-BLOB.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The attributes for the field.</source>
          <target state="translated">Die Attribute für das Feld.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>Defines initialized data field in the .sdata section of the portable executable (PE) file.</source>
          <target state="translated">Definiert das initialisierte Datenfeld im ".sdata"-Abschnitt der portierbaren ausführbaren Datei (Portable Executable, PE).</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>A field to reference the data.</source>
          <target state="translated">Ein Feld zum Verweisen auf die Daten.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The field that you create with this method will be <ph id="ph1">`static`</ph>, even if you do not include <ph id="ph2">`FieldAttributes.Static`</ph> in the <ph id="ph3">`attributes`</ph> parameter.</source>
          <target state="translated">Das Feld, das Sie mit dieser Methode erstellen, werden <ph id="ph1">`static`</ph>, selbst wenn Sie nicht einschließen, <ph id="ph2">`FieldAttributes.Static`</ph> in der <ph id="ph3">`attributes`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>Length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The size of the data is less than or equal to zero, or greater than or equal to 0x3f0000.</source>
          <target state="translated">Die Größe der Daten ist kleiner oder gleich 0 (null) bzw. größer oder gleich 0x3f0000.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="data" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="data" /&gt;</ph> ist <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> has been previously called.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> wurde bereits zuvor aufgerufen.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Adds a method to the type.</source>
          <target state="translated">Fügt dem Typ eine Methode hinzu.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The name of the method.</source>
          <target state="translated">Der Name der Methode.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The attributes of the method.</source>
          <target state="translated">Die Attribute der Methode.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>Adds a new method to the type, with the specified name and method attributes.</source>
          <target state="translated">Fügt eine neue Methode zum Typ mit dem angegebenen Namen und den Methodenattributen hinzu.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> representing the newly defined method.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>, der die neu definierte Methode darstellt.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>Use this method overload when you do not know the method signature at the time you define the method.</source>
          <target state="translated">Verwenden Sie diese methodenüberladung, wenn Sie nicht die Signatur der Methode zum Zeitpunkt kennen Sie die Methode definieren.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type.</source>
          <target state="translated">Beispielsweise könnte die Parametertypen und den Rückgabetyp einer generischen Methode durch generische Typparameter der Methode, die angegeben werden definiert werden muss, nachdem der Typ die Methode hinzugefügt wurden.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The parameters and return type of the method can be set later using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die Parameter und Rückgabetyp der Methode festgelegt werden können später mithilfe der <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>This method overload defines a method with <ph id="ph1">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Diese methodenüberladung definiert eine Methode mit <ph id="ph1">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>If you need to define a method without a signature, with a different calling convention, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29&gt;</ph> method overload.</source>
          <target state="translated">Wenn Sie eine Methode ohne eine Signatur, mit einer anderen Aufrufkonvention definieren verwenden die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29&gt;</ph> -methodenüberladung.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The following code example defines a generic method named <ph id="ph1">`DemoMethod`</ph> whose parameter type and return type are specified by its generic type parameters.</source>
          <target state="translated">Das folgende Codebeispiel definiert eine generische Methode mit dem Namen <ph id="ph1">`DemoMethod`</ph> , dessen Parametertyp und den Rückgabetyp von ihren generischen Typparametern angegeben werden.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The method is defined without a signature, using the standard calling convention.</source>
          <target state="translated">Die Methode definiert ist ohne eine Signatur, die herkömmliche Aufrufkonventionen verwenden.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> method is used to make <ph id="ph2">`DemoMethod`</ph> a generic method, and the newly defined type parameters are then used for the signature and return type.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> Methode wird verwendet, damit <ph id="ph2">`DemoMethod`</ph> einer generischen Methode und die neu definierte Typparameter werden für die Signatur verwendet und Rückgabetyp.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The type of the parent of this method is an interface, and this method is not virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Der Typ des übergeordneten Elements dieser Methode ist eine Schnittstelle, und diese Methode ist nicht virtuell (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Der Typ wurde zuvor mit <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Für den aktuellen dynamischen Typ ist die <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph>-Eigenschaft <ph id="ph2">&lt;see langword="true" /&gt;</ph>, aber die <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph>-Eigenschaft ist <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The name of the method.</source>
          <target state="translated">Der Name der Methode.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The attributes of the method.</source>
          <target state="translated">Die Attribute der Methode.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The calling convention of the method.</source>
          <target state="translated">Die Aufrufkonvention der Methode.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>Adds a new method to the type, with the specified name, method attributes, and calling convention.</source>
          <target state="translated">Fügt eine neue Methode zum Typ mit dem angegebenen Namen, den Methodenattributen und der Aufrufkonvention hinzu.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> representing the newly defined method.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>, der die neu definierte Methode darstellt.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>Use this method overload when you do not know the method signature at the time you define the method.</source>
          <target state="translated">Verwenden Sie diese methodenüberladung, wenn Sie nicht die Signatur der Methode zum Zeitpunkt kennen Sie die Methode definieren.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type.</source>
          <target state="translated">Beispielsweise könnte die Parametertypen und den Rückgabetyp einer generischen Methode durch generische Typparameter der Methode, die angegeben werden definiert werden muss, nachdem der Typ die Methode hinzugefügt wurden.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The parameters and return type of the method can be set later using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die Parameter und Rückgabetyp der Methode festgelegt werden können später mithilfe der <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The type of the parent of this method is an interface and this method is not virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Der Typ des übergeordneten Elements dieser Methode ist eine Schnittstelle, und diese Methode ist nicht virtuell (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Der Typ wurde zuvor mit <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Für den aktuellen dynamischen Typ ist die <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph>-Eigenschaft <ph id="ph2">&lt;see langword="true" /&gt;</ph>, aber die <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph>-Eigenschaft ist <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The name of the method.</source>
          <target state="translated">Der Name der Methode.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The attributes of the method.</source>
          <target state="translated">Die Attribute der Methode.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The return type of the method.</source>
          <target state="translated">Der Rückgabetyp der Methode</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The types of the parameters of the method.</source>
          <target state="translated">Die Typen der Parameter der Methode.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>Adds a new method to the type, with the specified name, method attributes, and method signature.</source>
          <target state="translated">Fügt eine neue Methode zum Typ mit dem angegebenen Namen, den Methodenattributen und der Methodensignatur hinzu.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The defined method.</source>
          <target state="translated">Die definierte Methode.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The following code sample demonstrates the use of <ph id="ph1">`DefineMethod`</ph> to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> for MSIL population.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung von <ph id="ph1">`DefineMethod`</ph> bestimmten Signatur und ihrer Attribute des Konstruktors für einen dynamischen Typ festlegen und zum Zurückgeben eines entsprechenden <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> für MSIL Auffüllung.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The type of the parent of this method is an interface, and this method is not virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Der Typ des übergeordneten Elements dieser Methode ist eine Schnittstelle, und diese Methode ist nicht virtuell (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Der Typ wurde zuvor mit <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Für den aktuellen dynamischen Typ ist die <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph>-Eigenschaft <ph id="ph2">&lt;see langword="true" /&gt;</ph>, aber die <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph>-Eigenschaft ist <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The name of the method.</source>
          <target state="translated">Der Name der Methode.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The attributes of the method.</source>
          <target state="translated">Die Attribute der Methode.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The calling convention of the method.</source>
          <target state="translated">Die Aufrufkonvention der Methode.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The return type of the method.</source>
          <target state="translated">Der Rückgabetyp der Methode</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The types of the parameters of the method.</source>
          <target state="translated">Die Typen der Parameter der Methode.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>Adds a new method to the type, with the specified name, method attributes, calling convention, and method signature.</source>
          <target state="translated">Fügt eine neue Methode zum Typ mit dem angegebenen Namen, den Methodenattributen, der Aufrufkonvention und der Methodensignatur hinzu.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> representing the newly defined method.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>, der die neu definierte Methode darstellt.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The following code sample demonstrates the use of <ph id="ph1">`DefineMethod`</ph> to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> for MSIL population.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung von <ph id="ph1">`DefineMethod`</ph> bestimmten Signatur und ihrer Attribute des Konstruktors für einen dynamischen Typ festlegen und zum Zurückgeben eines entsprechenden <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> für MSIL Auffüllung.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The type of the parent of this method is an interface, and this method is not virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Der Typ des übergeordneten Elements dieser Methode ist eine Schnittstelle, und diese Methode ist nicht virtuell (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Der Typ wurde zuvor mit <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Für den aktuellen dynamischen Typ ist die <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph>-Eigenschaft <ph id="ph2">&lt;see langword="true" /&gt;</ph>, aber die <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph>-Eigenschaft ist <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The name of the method.</source>
          <target state="translated">Der Name der Methode.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The attributes of the method.</source>
          <target state="translated">Die Attribute der Methode.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The calling convention of the method.</source>
          <target state="translated">Die Aufrufkonvention der Methode.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The return type of the method.</source>
          <target state="translated">Der Rückgabetyp der Methode</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">Ein Array von Typen, die die erforderlichen benutzerdefinierten Modifizierer, etwa <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, für den Rückgabetyp der Methode darstellen.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Wenn der Rückgabetyp keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">Ein Array von Typen, die die optionalen benutzerdefinierten Modifizierer, etwa <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, für den Rückgabetyp der Methode darstellen.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Wenn der Rückgabetyp keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The types of the parameters of the method.</source>
          <target state="translated">Die Typen der Parameter der Methode.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Ein Array mit Arrays von Typen.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Jedes Array von Typen stellt die erforderlichen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Wenn ein bestimmter Parameter keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> anstelle eines Arrays von Typen an.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Wenn keiner der Parameter erforderliche benutzerdefinierte Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> anstelle eines Arrays mit Arrays an.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Ein Array mit Arrays von Typen.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Jedes Array von Typen stellt die optionalen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Wenn ein bestimmter Parameter keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> anstelle eines Arrays von Typen an.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Wenn keiner der Parameter optionale benutzerdefinierte Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> anstelle eines Arrays mit Arrays an.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Adds a new method to the type, with the specified name, method attributes, calling convention, method signature, and custom modifiers.</source>
          <target state="translated">Fügt eine neue Methode zum Typ mit dem angegebenen Namen, den Methodenattributen, der Aufrufkonvention, der Methodensignatur und den benutzerdefinierten Modifizierern hinzu.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> object representing the newly added method.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>-Objekt, das die neu hinzugefügte Methode darstellt.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Use this overload if you need to specify custom modifiers.</source>
          <target state="translated">Verwenden Sie diese Überladung, wenn Sie benutzerdefinierte Modifizierer angeben müssen.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If you need to specify custom modifiers after the method has been created, as you would, for example, with a generic method whose parameter types are specified by its generic type parameters, you can use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29&gt;</ph> method overloads to define the method and then use the <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method to define the parameter and return types with custom modifiers.</source>
          <target state="translated">Wenn Sie benutzerdefinierten Modifizierer, nachdem die Methode erstellt wurde, wie angeben müssen, z. B. mit einer generischen Methode, deren Parametertypen, indem die generischen Typparameter angegeben werden, Sie können die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29&gt;</ph> oder <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29&gt;</ph> -methodenüberladungen, um zu definieren die Methode und anschließend mithilfe der <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> -Methode definieren Sie den Parameter und zurückgeben Typen mit benutzerdefinierten Modifizierer hat.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
          <target state="translated">Weitere Informationen zu benutzerdefinierten Modifizierer finden Sie in der ECMA Partition II-Metadaten-Dokumentation.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. Sie finden sie unter <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> auf der Ecma International-Website.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The type of the parent of this method is an interface, and this method is not virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Der Typ des übergeordneten Elements dieser Methode ist eine Schnittstelle, und diese Methode ist nicht virtuell (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The size of <ph id="ph1">&lt;paramref name="parameterTypeRequiredCustomModifiers" /&gt;</ph> or <ph id="ph2">&lt;paramref name="parameterTypeOptionalCustomModifiers" /&gt;</ph> does not equal the size of <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph>.</source>
          <target state="translated">Die Größe von <ph id="ph1">&lt;paramref name="parameterTypeRequiredCustomModifiers" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="parameterTypeOptionalCustomModifiers" /&gt;</ph> entspricht nicht der Größe von <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Der Typ wurde zuvor mit <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Für den aktuellen dynamischen Typ ist die <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph>-Eigenschaft <ph id="ph2">&lt;see langword="true" /&gt;</ph>, aber die <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph>-Eigenschaft ist <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The method body to be used.</source>
          <target state="translated">Der zu verwendende Methodentext.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>This should be a <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph> object.</source>
          <target state="translated">Dies sollte ein <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph>-Objekt sein.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The method whose declaration is to be used.</source>
          <target state="translated">Die Methode, deren Deklaration verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>Specifies a given method body that implements a given method declaration, potentially with a different name.</source>
          <target state="translated">Gibt einen bestimmten Methodentext an, der eine bestimmte Methodendeklaration, möglicherweise mit einem anderen Namen, implementiert.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>Do not use this method to emit method overrides or interface implementations.</source>
          <target state="translated">Verwenden Sie diese Methode nicht zum Ausgeben von methodenüberschreibungen oder schnittstellenimplementierungen.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>To override a method of a base class or to implement a method of an interface, simply emit a method with the same name and signature as the method to be overridden or implemented, as demonstrated in the code example.</source>
          <target state="translated">Um eine Methode einer Basisklasse zu überschreiben oder eine Methode einer Schnittstelle zu implementieren, geben Sie eine Methode mit demselben Namen und derselben Signatur einfach als die Methode, die außer Kraft gesetzt werden, oder implementieren fest, wie im Codebeispiel wird veranschaulicht.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> method is used when a method body and a method declaration have different names.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> Methode wird verwendet, wenn ein Methodentext und eine Methodendeklaration unterschiedliche Namen aufweisen.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>For example, a class might override a base class method and also provide a separate implementation for an interface member with the same name, as demonstrated in the code example.</source>
          <target state="translated">Beispielsweise kann eine Klasse eine Methode der Basisklasse überschreiben und auch bieten eine separate Implementierung für einen Schnittstellenmember mit dem gleichen Namen wie im Codebeispiel wird veranschaulicht.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source><ph id="ph1">`DefineMethodOverride`</ph> defines a <ph id="ph2">`methodimpl`</ph>, which consists of a pair of metadata tokens.</source>
          <target state="translated"><ph id="ph1">`DefineMethodOverride`</ph> definiert eine <ph id="ph2">`methodimpl`</ph>, die besteht aus einem Paar von Metadatentoken.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>One token points to an implementation, and the other token points to a declaration that the body implements.</source>
          <target state="translated">Ein Token zeigt auf eine Implementierung und der andere token verweist auf eine Deklaration, die der Text implementiert.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The body must be defined on the type the method impl is defined on, and the body must be virtual (<ph id="ph1">`Overridable`</ph> in Visual Basic).</source>
          <target state="translated">Der Text für den Typ der Methode "Impl" definiert ist, auf definiert sein, und der Text muss virtuell sein (<ph id="ph1">`Overridable`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The declaration can be made to a method defined on an interface implemented by the type, a method on a derived class, or a method defined in the type.</source>
          <target state="translated">Die Deklaration kann an eine Methode, die für eine Schnittstelle implementiert wird, indem Sie den Typ, einer Methode in einer abgeleiteten Klasse oder eine im Typ definierte Methode definierten vorgenommen werden.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>If the declaration is on an interface only, the slot defined for the interface is altered.</source>
          <target state="translated">Wenn die Deklaration nur für eine Schnittstelle ist, ist der Slot für die Schnittstelle geändert.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>If the declaration is made to a method on a base type, the slot for the method is overridden and any duplicates for the overridden method are also replaced.</source>
          <target state="translated">Wenn die Deklaration einer Methode in einem Basistyp erfolgt, Slot des für die Methode überschrieben wird, und auch alle Duplikate für die überschriebene Methode ersetzt werden.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The overridden method cannot be the actual method that is declared.</source>
          <target state="translated">Die überschriebene Methode darf nicht die tatsächlichen Methode sein, die deklariert wird.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>If the method is on the same type, the slot is replaced and any duplicates for the replaced methods are overridden.</source>
          <target state="translated">Wenn die Methode für den gleichen Typ ist, der Slot ersetzt, und alle Duplikate für die ersetzten Methoden überschrieben werden.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>For more information about method impls, see <ph id="ph1">`MethodImpl`</ph> in the ECMA Partition II Metadata documentation.</source>
          <target state="translated">Weitere Informationen zur Methode Impls finden Sie unter <ph id="ph1">`MethodImpl`</ph> in der ECMA Partition II-Metadaten-Dokumentation.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. Sie finden sie unter <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> auf der Ecma International-Website.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>After the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> method is called, some features of <ph id="ph2">`methodInfoBody`</ph> cannot be changed.</source>
          <target state="translated">Nach der <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> -Methode aufgerufen wird, werden einige Funktionen von <ph id="ph2">`methodInfoBody`</ph> kann nicht geändert werden.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>For example, you cannot apply an attribute to a generic type parameter of <ph id="ph1">`methodInfoBody`</ph> by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A&gt;</ph> method.</source>
          <target state="translated">Sie können z. B. ein Attribut auf einen generischen Typparameter anwenden <ph id="ph1">`methodInfoBody`</ph> mithilfe der <ph id="ph2">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>If you must use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> method, do so after all characteristics of <ph id="ph2">`methodInfoBody`</ph> have been defined.</source>
          <target state="translated">Wenn Sie verwenden, müssen die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> -Methode dazu nach allen Eigenschaften des <ph id="ph2">`methodInfoBody`</ph> definiert wurden.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The following code example contains an interface <ph id="ph1">`I`</ph> with a method <ph id="ph2">`M()`</ph>, a base class <ph id="ph3">`A`</ph> that implements the interface, and a derived class <ph id="ph4">`C`</ph> that overrides the base class implementation of <ph id="ph5">`M()`</ph> and also provides a separate explicit implementation of <ph id="ph6">`I.M()`</ph>.</source>
          <target state="translated">Das folgende Codebeispiel enthält eine Schnittstelle <ph id="ph1">`I`</ph> mit einer Methode <ph id="ph2">`M()`</ph>, eine Basisklasse <ph id="ph3">`A`</ph> , implementiert die Schnittstelle und eine abgeleitete Klasse <ph id="ph4">`C`</ph> überschreibt die basisklassenimplementierung der <ph id="ph5">`M()`</ph> sowie Stellt eine separate explizite Implementierung der <ph id="ph6">`I.M()`</ph>.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">`main()`</ph> method of the code example shows how to emit the derived class <ph id="ph2">`C`</ph>.</source>
          <target state="translated">Die <ph id="ph1">`main()`</ph> Methode des Codebeispiels wird veranschaulicht, wie zum Ausgeben von der abgeleiteten Klasse <ph id="ph2">`C`</ph>.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The override of <ph id="ph1">`A.M()`</ph> is accomplished simply by emitting a method <ph id="ph2">`M()`</ph> with the same signature.</source>
          <target state="translated">Die Außerkraftsetzung der <ph id="ph1">`A.M()`</ph> erfolgt einfach durch Ausgeben einer Methode <ph id="ph2">`M()`</ph> mit derselben Signatur.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>However, to provide a separate implementation of <ph id="ph1">`I.M()`</ph>, you must define a method body and then use the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> method to associate that method body with a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> representing <ph id="ph4">`I.M()`</ph>.</source>
          <target state="translated">Allerdings auf einer separaten Implementierung der <ph id="ph1">`I.M()`</ph>, müssen Sie einen Methodentext definieren und verwenden Sie dann die <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> Methode, um diese Methodentext mit zuzuordnen eine <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> darstellt <ph id="ph4">`I.M()`</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The name of the method body does not matter.</source>
          <target state="translated">Der Name des Methodentextes spielt keine Rolle.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The code example creates an instance of the emitted class.</source>
          <target state="translated">Das Codebeispiel erstellt eine Instanz der ausgegebenen-Klasse.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>It obtains a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object for <ph id="ph2">`I.M()`</ph>, and uses it to invoke the emitted class's explicit interface implementation.</source>
          <target state="translated">Er erhält eine <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> -Objekt für <ph id="ph2">`I.M()`</ph>, und verwendet es die ausgegebene aufrufen ist die explizite schnittstellenimplementierung.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>It then obtains a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object for <ph id="ph2">`A.M()`</ph>, and uses it to invoke the emitted class's override of that method.</source>
          <target state="translated">Er dann erhält ein <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> -Objekt für <ph id="ph2">`A.M()`</ph>, und verwendet, um das Aufrufen dieser Methode die ausgegebene Klasse überschrieben.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> does not belong to this class.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> gehört nicht zu dieser Klasse.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> or <ph id="ph2">&lt;paramref name="methodInfoDeclaration" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="methodInfoDeclaration" /&gt;</ph> ist <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Der Typ wurde zuvor mit <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> is not the type represented by this <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated">Der deklarierende Typ des <ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> ist nicht der von diesem <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> dargestellte Typ.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Defines a nested type.</source>
          <target state="translated">Definiert einen geschachtelten Typ.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>The short name of the type.</source>
          <target state="translated">Der Kurzname des Typs.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>Defines a nested type, given its name.</source>
          <target state="translated">Definiert einen geschachtelten Typ anhand des Namens.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>The defined nested type.</source>
          <target state="translated">Der definierte geschachtelte Typ.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">Diese Methode kann verwendet werden, zum Erstellen von geschachtelten Typen auch nach der <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> -Methode für den einschließenden Typ aufgerufen wurde.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">Der geschachtelte Typ muss abgeschlossen sein, bevor Sie ihn mit spiegeln können <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, oder <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">Siehe die Beschreibung der <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> für die Reihenfolge, in dem geschachtelte und schachteln Typen abgeschlossen werden soll.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">Ein doppelter Name ist nicht notwendigerweise erstellt, wenn <ph id="ph1">`name`</ph> identisch mit dem Namen von einem zuvor definierten Typ oder ein geschachtelter Typ ist.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">Um Duplikate zu sein, müssen den vollständigen Namen identisch, einschließlich des Namespace und alle schachteln Typen sein.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>Length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist 0 (null) oder größer als 1023.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">Dieser Vorgang würde einen Typ mit einem bereits vorhandenen <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in der aktuellen Assembly erstellen.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The short name of the type.</source>
          <target state="translated">Der Kurzname des Typs.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The attributes of the type.</source>
          <target state="translated">Die Attribute des Typs.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>Defines a nested type, given its name and attributes.</source>
          <target state="translated">Definiert einen geschachtelten Typ, wozu dessen Name und Attribute angegeben sind.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The defined nested type.</source>
          <target state="translated">Der definierte geschachtelte Typ.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">Diese Methode kann verwendet werden, zum Erstellen von geschachtelten Typen auch nach der <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> -Methode für den einschließenden Typ aufgerufen wurde.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">Der geschachtelte Typ muss abgeschlossen sein, bevor Sie ihn mit spiegeln können <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, oder <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">Siehe die Beschreibung der <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> für die Reihenfolge, in dem geschachtelte und schachteln Typen abgeschlossen werden soll.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">Ein doppelter Name ist nicht notwendigerweise erstellt, wenn <ph id="ph1">`name`</ph> identisch mit dem Namen von einem zuvor definierten Typ oder ein geschachtelter Typ ist.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">Um Duplikate zu sein, müssen den vollständigen Namen identisch, einschließlich des Namespace und alle schachteln Typen sein.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The nested attribute is not specified.</source>
          <target state="translated">Das geschachtelte Attribut ist nicht angegeben.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>This type is sealed.</source>
          <target state="translated">Dieser Typ ist versiegelt.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>This type is an array.</source>
          <target state="translated">Dieser Typ ist ein Array.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>This type is an interface, but the nested type is not an interface.</source>
          <target state="translated">Dieser Typ ist eine Schnittstelle, aber der geschachtelte Typ ist keine Schnittstelle.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist 0 (null) oder größer als 1023.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">Dieser Vorgang würde einen Typ mit einem bereits vorhandenen <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in der aktuellen Assembly erstellen.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The short name of the type.</source>
          <target state="translated">Der Kurzname des Typs.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The attributes of the type.</source>
          <target state="translated">Die Attribute des Typs.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The type that the nested type extends.</source>
          <target state="translated">Der Typ, den der geschachtelte Typ erweitert.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Defines a nested type, given its name, attributes, and the type that it extends.</source>
          <target state="translated">Definiert einen geschachtelten Typ bei gegebenem Namen, Attributen und erweitertem Typ.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The defined nested type.</source>
          <target state="translated">Der definierte geschachtelte Typ.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">Diese Methode kann verwendet werden, zum Erstellen von geschachtelten Typen auch nach der <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> -Methode für den einschließenden Typ aufgerufen wurde.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">Der geschachtelte Typ muss abgeschlossen sein, bevor Sie ihn mit spiegeln können <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, oder <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">Siehe die Beschreibung der <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> für die Reihenfolge, in dem geschachtelte und schachteln Typen abgeschlossen werden soll.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">Ein doppelter Name ist nicht notwendigerweise erstellt, wenn <ph id="ph1">`name`</ph> identisch mit dem Namen von einem zuvor definierten Typ oder ein geschachtelter Typ ist.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">Um Duplikate zu sein, müssen den vollständigen Namen identisch, einschließlich des Namespace und alle schachteln Typen sein.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The nested attribute is not specified.</source>
          <target state="translated">Das geschachtelte Attribut ist nicht angegeben.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This type is sealed.</source>
          <target state="translated">Dieser Typ ist versiegelt.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This type is an array.</source>
          <target state="translated">Dieser Typ ist ein Array.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This type is an interface, but the nested type is not an interface.</source>
          <target state="translated">Dieser Typ ist eine Schnittstelle, aber der geschachtelte Typ ist keine Schnittstelle.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist 0 (null) oder größer als 1023.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">Dieser Vorgang würde einen Typ mit einem bereits vorhandenen <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in der aktuellen Assembly erstellen.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The short name of the type.</source>
          <target state="translated">Der Kurzname des Typs.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The attributes of the type.</source>
          <target state="translated">Die Attribute des Typs.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The type that the nested type extends.</source>
          <target state="translated">Der Typ, den der geschachtelte Typ erweitert.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The total size of the type.</source>
          <target state="translated">Die Gesamtgröße des Typs.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>Defines a nested type, given its name, attributes, the total size of the type, and the type that it extends.</source>
          <target state="translated">Definiert einen geschachtelten Typ bei gegebenem Namen, Attributen, Gesamtgröße des Typs und erweitertem Typ.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The defined nested type.</source>
          <target state="translated">Der definierte geschachtelte Typ.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">Diese Methode kann verwendet werden, zum Erstellen von geschachtelten Typen auch nach der <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> -Methode für den einschließenden Typ aufgerufen wurde.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">Der geschachtelte Typ muss abgeschlossen sein, bevor Sie ihn mit spiegeln können <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, oder <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">Siehe die Beschreibung der <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> für die Reihenfolge, in dem geschachtelte und schachteln Typen abgeschlossen werden soll.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">Ein doppelter Name ist nicht notwendigerweise erstellt, wenn <ph id="ph1">`name`</ph> identisch mit dem Namen von einem zuvor definierten Typ oder ein geschachtelter Typ ist.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">Um Duplikate zu sein, müssen den vollständigen Namen identisch, einschließlich des Namespace und alle schachteln Typen sein.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The nested attribute is not specified.</source>
          <target state="translated">Das geschachtelte Attribut ist nicht angegeben.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>This type is sealed.</source>
          <target state="translated">Dieser Typ ist versiegelt.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>This type is an array.</source>
          <target state="translated">Dieser Typ ist ein Array.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>This type is an interface, but the nested type is not an interface.</source>
          <target state="translated">Dieser Typ ist eine Schnittstelle, aber der geschachtelte Typ ist keine Schnittstelle.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist 0 (null) oder größer als 1023.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">Dieser Vorgang würde einen Typ mit einem bereits vorhandenen <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in der aktuellen Assembly erstellen.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The short name of the type.</source>
          <target state="translated">Der Kurzname des Typs.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The attributes of the type.</source>
          <target state="translated">Die Attribute des Typs.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The type that the nested type extends.</source>
          <target state="translated">Der Typ, den der geschachtelte Typ erweitert.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The packing size of the type.</source>
          <target state="translated">Die Komprimierungsgröße des Typs.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>Defines a nested type, given its name, attributes, the type that it extends, and the packing size.</source>
          <target state="translated">Definiert einen geschachtelten Typ bei gegebenem Namen, Attributen, erweitertem Typ und Komprimierungsgröße.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The defined nested type.</source>
          <target state="translated">Der definierte geschachtelte Typ.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">Diese Methode kann verwendet werden, zum Erstellen von geschachtelten Typen auch nach der <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> -Methode für den einschließenden Typ aufgerufen wurde.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">Der geschachtelte Typ muss abgeschlossen sein, bevor Sie ihn mit spiegeln können <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, oder <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">Siehe die Beschreibung der <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> für die Reihenfolge, in dem geschachtelte und schachteln Typen abgeschlossen werden soll.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">Ein doppelter Name ist nicht notwendigerweise erstellt, wenn <ph id="ph1">`name`</ph> identisch mit dem Namen von einem zuvor definierten Typ oder ein geschachtelter Typ ist.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">Um Duplikate zu sein, müssen den vollständigen Namen identisch, einschließlich des Namespace und alle schachteln Typen sein.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The nested attribute is not specified.</source>
          <target state="translated">Das geschachtelte Attribut ist nicht angegeben.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>This type is sealed.</source>
          <target state="translated">Dieser Typ ist versiegelt.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>This type is an array.</source>
          <target state="translated">Dieser Typ ist ein Array.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>This type is an interface, but the nested type is not an interface.</source>
          <target state="translated">Dieser Typ ist eine Schnittstelle, aber der geschachtelte Typ ist keine Schnittstelle.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist 0 (null) oder größer als 1023.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">Dieser Vorgang würde einen Typ mit einem bereits vorhandenen <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in der aktuellen Assembly erstellen.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The short name of the type.</source>
          <target state="translated">Der Kurzname des Typs.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The attributes of the type.</source>
          <target state="translated">Die Attribute des Typs.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The type that the nested type extends.</source>
          <target state="translated">Der Typ, den der geschachtelte Typ erweitert.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The interfaces that the nested type implements.</source>
          <target state="translated">Die vom geschachtelte Typ implementierten Schnittstellen.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>Defines a nested type, given its name, attributes, the type that it extends, and the interfaces that it implements.</source>
          <target state="translated">Definiert einen geschachtelten Typ mit seinem Namen, den Attributen, dem erweiterten Typ und den implementierten Schnittstellen.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The defined nested type.</source>
          <target state="translated">Der definierte geschachtelte Typ.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">Diese Methode kann verwendet werden, zum Erstellen von geschachtelten Typen auch nach der <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> -Methode für den einschließenden Typ aufgerufen wurde.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">Der geschachtelte Typ muss abgeschlossen sein, bevor Sie ihn mit spiegeln können <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, oder <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">Siehe die Beschreibung der <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> für die Reihenfolge, in dem geschachtelte und schachteln Typen abgeschlossen werden soll.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">Ein doppelter Name ist nicht notwendigerweise erstellt, wenn <ph id="ph1">`name`</ph> identisch mit dem Namen von einem zuvor definierten Typ oder ein geschachtelter Typ ist.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">Um Duplikate zu sein, müssen den vollständigen Namen identisch, einschließlich des Namespace und alle schachteln Typen sein.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The nested attribute is not specified.</source>
          <target state="translated">Das geschachtelte Attribut ist nicht angegeben.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>This type is sealed.</source>
          <target state="translated">Dieser Typ ist versiegelt.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>This type is an array.</source>
          <target state="translated">Dieser Typ ist ein Array.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>This type is an interface, but the nested type is not an interface.</source>
          <target state="translated">Dieser Typ ist eine Schnittstelle, aber der geschachtelte Typ ist keine Schnittstelle.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist 0 (null) oder größer als 1023.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">Dieser Vorgang würde einen Typ mit einem bereits vorhandenen <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in der aktuellen Assembly erstellen.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>An element of the <ph id="ph1">&lt;paramref name="interfaces" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Element des <ph id="ph1">&lt;paramref name="interfaces" /&gt;</ph>-Arrays ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The short name of the type.</source>
          <target state="translated">Der Kurzname des Typs.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded null values.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The attributes of the type.</source>
          <target state="translated">Die Attribute des Typs.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The type that the nested type extends.</source>
          <target state="translated">Der Typ, den der geschachtelte Typ erweitert.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The packing size of the type.</source>
          <target state="translated">Die Komprimierungsgröße des Typs.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The total size of the type.</source>
          <target state="translated">Die Gesamtgröße des Typs.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>Defines a nested type, given its name, attributes, size, and the type that it extends.</source>
          <target state="translated">Definiert einen geschachtelten Typ bei gegebenem Namen, Attributen, Größe und erweitertem Typ.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The defined nested type.</source>
          <target state="translated">Der definierte geschachtelte Typ.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Definiert eine <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>-Methode.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Der Name der <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>-Methode.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the DLL in which the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method is defined.</source>
          <target state="translated">Der Name der DLL, in der die <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>-Methode definiert ist.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The attributes of the method.</source>
          <target state="translated">Die Attribute der Methode.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's calling convention.</source>
          <target state="translated">Die Aufrufkonvention der Methode.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's return type.</source>
          <target state="translated">Der Rückgabetyp der Methode.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The types of the method's parameters.</source>
          <target state="translated">Die Typen der Parameter der Methode.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The native calling convention.</source>
          <target state="translated">Die systemeigene Aufrufkonvention.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's native character set.</source>
          <target state="translated">Der systemeigene Zeichensatz der Methode.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method given its name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> flags.</source>
          <target state="translated">Definiert eine <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>-Methode anhand der Angaben für den Namen, den Namen der DLL, in der die Methode definiert ist, für die Attribute der Methode, die Aufrufkonvention der Methode, den Rückgabetyp der Methode, die Parametertypen der Methode und die <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph>-Flags.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The defined <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Die definierte <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>-Methode.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Some DLL import attributes (see the description of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) cannot be specified as arguments to this method.</source>
          <target state="translated">Einige DLL-Importattribute (siehe die Beschreibung der <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) kann nicht als Argumente für diese Methode angegeben werden.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For example, the DLL import attribute <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> must be added after the <ph id="ph2">`PInvoke`</ph> method is created, if the method returns a value.</source>
          <target state="translated">Z. B. import die DLL-Attribut <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> muss hinzugefügt werden, nachdem die <ph id="ph2">`PInvoke`</ph> Methode erstellt wird, wenn die Methode einen Wert zurückgibt.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example shows how to do this.</source>
          <target state="translated">Im Beispiel veranschaulicht dies.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A&gt;</ph> method to create a <ph id="ph2">`PInvoke`</ph> method, and how to add the <ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag to the method implementation flags after you create the <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, by using the <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph6">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A&gt;</ph> Methode zum Erstellen einer <ph id="ph2">`PInvoke`</ph> -Methode und zum Hinzufügen der <ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> -Kennzeichen an die die Methodenimplementierungsflags nach der Erstellung der <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, mithilfe der <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph6">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph>Methoden.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>To get a non-zero return value, you must add the <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Um einen Rückgabewert ungleich 0 (null) zu erhalten, fügen Sie der <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example creates a dynamic assembly with one dynamic module and a single type, <ph id="ph1">`MyType`</ph>, that contains the <ph id="ph2">`PInvoke`</ph> method.</source>
          <target state="translated">Das Beispiel erstellt eine dynamische Assembly mit einem dynamischen Modul und eines einzelnen Typs <ph id="ph1">`MyType`</ph>, enthält die <ph id="ph2">`PInvoke`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The <ph id="ph1">`PInvoke`</ph> method represents the Win32 <ph id="ph2">`GetTickCount`</ph> function.</source>
          <target state="translated">Die <ph id="ph1">`PInvoke`</ph> Methode darstellt, die Win32 <ph id="ph2">`GetTickCount`</ph> Funktion.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>When the example is run, it executes the <ph id="ph1">`PInvoke`</ph> method.</source>
          <target state="translated">Wenn das Beispiel ausgeführt wird, führt die <ph id="ph1">`PInvoke`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>It also saves the dynamic assembly as PInvokeTest.dll.</source>
          <target state="translated">Es speichert auch die dynamische Assembly als PInvokeTest.dll gespeichert.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the <ph id="ph1">`MyType`</ph> class and the <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">`PInvoke`</ph> method it contains.</source>
          <target state="translated">Können Sie die <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> Untersuchen der <ph id="ph1">`MyType`</ph> Klasse und die <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">`PInvoke`</ph> Methode, die es enthält.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can compile a Visual Basic or C# program that uses the static <ph id="ph1">`MyType.GetTickCount`</ph> method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, <ph id="ph2">`/r:PInvokeTest.dll`</ph>.</source>
          <target state="translated">Sie können ein Visual Basic- oder C#-Programm, die statische verwendet, Kompilieren <ph id="ph1">`MyType.GetTickCount`</ph> Methode, indem Sie z. B. einen Verweis auf die DLL beim Ausführen von csc.exe oder vbc.exe; z. B. <ph id="ph2">`/r:PInvokeTest.dll`</ph>.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is not static.</source>
          <target state="translated">Die Methode ist nicht statisch.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The parent type is an interface.</source>
          <target state="translated">Der übergeordnete Typ ist eine Schnittstelle.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is abstract.</source>
          <target state="translated">Die Methode ist abstrakt.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method was previously defined.</source>
          <target state="translated">Die Methode wurde bereits definiert.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> is zero.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="name" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> ist <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The containing type has been previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Der enthaltende Typ wurde zuvor mit <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Der Name der <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>-Methode.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the DLL in which the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method is defined.</source>
          <target state="translated">Der Name der DLL, in der die <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>-Methode definiert ist.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the entry point in the DLL.</source>
          <target state="translated">Der Name des Einstiegspunkts in die DLL.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The attributes of the method.</source>
          <target state="translated">Die Attribute der Methode.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's calling convention.</source>
          <target state="translated">Die Aufrufkonvention der Methode.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's return type.</source>
          <target state="translated">Der Rückgabetyp der Methode.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The types of the method's parameters.</source>
          <target state="translated">Die Typen der Parameter der Methode.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The native calling convention.</source>
          <target state="translated">Die systemeigene Aufrufkonvention.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's native character set.</source>
          <target state="translated">Der systemeigene Zeichensatz der Methode.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> flags.</source>
          <target state="translated">Definiert eine <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>-Methode anhand der Angaben für den Namen, den Namen der DLL, in der die Methode definiert ist, für den Namen des Einstiegspunkts, die Attribute der Methode, die Aufrufkonvention der Methode, den Rückgabetyp der Methode, die Parametertypen der Methode und die <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph>-Flags.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The defined <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Die definierte <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>-Methode.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Some DLL import attributes (see the description of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) cannot be specified as arguments to this method.</source>
          <target state="translated">Einige DLL-Importattribute (siehe die Beschreibung der <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) kann nicht als Argumente für diese Methode angegeben werden.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For example, the DLL import attribute <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> must be added after the <ph id="ph2">`PInvoke`</ph> method is created, if the method returns a value.</source>
          <target state="translated">Z. B. import die DLL-Attribut <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> muss hinzugefügt werden, nachdem die <ph id="ph2">`PInvoke`</ph> Methode erstellt wird, wenn die Methode einen Wert zurückgibt.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example shows how to do this.</source>
          <target state="translated">Im Beispiel veranschaulicht dies.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The following code example demonstrates how to use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A&gt;</ph> method to create a <ph id="ph2">`PInvoke`</ph> method, and how to add the <ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag to the method implementation flags after you create the <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, by using the <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph6">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A&gt;</ph> Methode zum Erstellen einer <ph id="ph2">`PInvoke`</ph> -Methode und zum Hinzufügen der <ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> -Kennzeichen an die die Methodenimplementierungsflags nach der Erstellung der <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, mithilfe der <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph6">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>To get a non-zero return value, you must add the <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Um einen Rückgabewert ungleich 0 (null) zu erhalten, fügen Sie der <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example creates a dynamic assembly with one dynamic module and a single type, <ph id="ph1">`MyType`</ph>, that contains the <ph id="ph2">`PInvoke`</ph> method.</source>
          <target state="translated">Das Beispiel erstellt eine dynamische Assembly mit einem dynamischen Modul und eines einzelnen Typs <ph id="ph1">`MyType`</ph>, enthält die <ph id="ph2">`PInvoke`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The <ph id="ph1">`PInvoke`</ph> method represents the Win32 <ph id="ph2">`GetTickCount`</ph> function.</source>
          <target state="translated">Die <ph id="ph1">`PInvoke`</ph> Methode darstellt, die Win32 <ph id="ph2">`GetTickCount`</ph> Funktion.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>When the example is run, it executes the <ph id="ph1">`PInvoke`</ph> method.</source>
          <target state="translated">Wenn das Beispiel ausgeführt wird, führt die <ph id="ph1">`PInvoke`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>It also saves the dynamic assembly as PInvokeTest.dll.</source>
          <target state="translated">Es speichert auch die dynamische Assembly als PInvokeTest.dll gespeichert.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the <ph id="ph1">`MyType`</ph> class and the <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">`PInvoke`</ph> method it contains.</source>
          <target state="translated">Können Sie die <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> Untersuchen der <ph id="ph1">`MyType`</ph> Klasse und die <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">`PInvoke`</ph> Methode, die es enthält.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can compile a Visual Basic or C# program that uses the static <ph id="ph1">`MyType.GetTickCount`</ph> method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, <ph id="ph2">`/r:PInvokeTest.dll`</ph>.</source>
          <target state="translated">Sie können ein Visual Basic- oder C#-Programm, die statische verwendet, Kompilieren <ph id="ph1">`MyType.GetTickCount`</ph> Methode, indem Sie z. B. einen Verweis auf die DLL beim Ausführen von csc.exe oder vbc.exe; z. B. <ph id="ph2">`/r:PInvokeTest.dll`</ph>.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is not static.</source>
          <target state="translated">Die Methode ist nicht statisch.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The parent type is an interface.</source>
          <target state="translated">Der übergeordnete Typ ist eine Schnittstelle.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is abstract.</source>
          <target state="translated">Die Methode ist abstrakt.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method was previously defined.</source>
          <target state="translated">Die Methode wurde bereits definiert.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> is zero.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> oder <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> oder <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> ist <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The containing type has been previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Der enthaltende Typ wurde zuvor mit <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Der Name der <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>-Methode.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the DLL in which the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method is defined.</source>
          <target state="translated">Der Name der DLL, in der die <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>-Methode definiert ist.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the entry point in the DLL.</source>
          <target state="translated">Der Name des Einstiegspunkts in die DLL.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The attributes of the method.</source>
          <target state="translated">Die Attribute der Methode.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's calling convention.</source>
          <target state="translated">Die Aufrufkonvention der Methode.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's return type.</source>
          <target state="translated">Der Rückgabetyp der Methode.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">Ein Array von Typen, die die erforderlichen benutzerdefinierten Modifizierer, etwa <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, für den Rückgabetyp der Methode darstellen.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Wenn der Rückgabetyp keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">Ein Array von Typen, die die optionalen benutzerdefinierten Modifizierer, etwa <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, für den Rückgabetyp der Methode darstellen.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Wenn der Rückgabetyp keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The types of the method's parameters.</source>
          <target state="translated">Die Typen der Parameter der Methode.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>An array of arrays of types.</source>
          <target state="translated">Ein Array mit Arrays von Typen.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Jedes Array von Typen stellt die erforderlichen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Wenn ein bestimmter Parameter keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> anstelle eines Arrays von Typen an.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Wenn keiner der Parameter erforderliche benutzerdefinierte Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> anstelle eines Arrays mit Arrays an.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>An array of arrays of types.</source>
          <target state="translated">Ein Array mit Arrays von Typen.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Jedes Array von Typen stellt die optionalen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Wenn ein bestimmter Parameter keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> anstelle eines Arrays von Typen an.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Wenn keiner der Parameter optionale benutzerdefinierte Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> anstelle eines Arrays mit Arrays an.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The native calling convention.</source>
          <target state="translated">Die systemeigene Aufrufkonvention.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's native character set.</source>
          <target state="translated">Der systemeigene Zeichensatz der Methode.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, the <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> flags, and custom modifiers for the parameters and return type.</source>
          <target state="translated">Definiert eine <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>-Methode anhand der Angaben für den Namen, den Namen der DLL, in der die Methode definiert ist, den Namen des Einstiegspunkts, die Attribute der Methode, die Aufrufkonvention der Methode, den Rückgabetyp der Methode, die Parametertypen der Methode, die <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph>-Flags, die benutzerdefinierten Modifizierer für die Parameter und den Rückgabetyp.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> representing the defined <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>, der die definierte <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph>-Methode darstellt.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Some DLL import attributes (see the description of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) cannot be specified as arguments to this method.</source>
          <target state="translated">Einige DLL-Importattribute (siehe die Beschreibung der <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) kann nicht als Argumente für diese Methode angegeben werden.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For example, the DLL import attribute <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> must be added after the <ph id="ph2">`PInvoke`</ph> method is created, if the method returns a value.</source>
          <target state="translated">Z. B. import die DLL-Attribut <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> muss hinzugefügt werden, nachdem die <ph id="ph2">`PInvoke`</ph> Methode erstellt wird, wenn die Methode einen Wert zurückgibt.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example shows how to do this.</source>
          <target state="translated">Im Beispiel veranschaulicht dies.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
          <target state="translated">Weitere Informationen zu benutzerdefinierten Modifizierer finden Sie in der ECMA Partition II-Metadaten-Dokumentation.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. Sie finden sie unter <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> auf der Ecma International-Website.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The following code example demonstrates how to use the [<ph id="ph1">\]</ph>, Type<ph id="ph2">\[</ph><ph id="ph3">\]</ph>, Type<ph id="ph4">\[</ph><ph id="ph5">\]</ph>, Type<ph id="ph6">\[</ph><ph id="ph7">\]</ph><ph id="ph8">\[</ph><ph id="ph9">\]</ph>, Type<ph id="ph10">\[</ph><ph id="ph11">\]</ph><ph id="ph12">\&lt;</ph>xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A&gt; method to create a <ph id="ph13">`PInvoke`</ph> method, and how to add the <ph id="ph14">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag to the method implementation flags after you create the <ph id="ph15">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, by using the <ph id="ph16">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph17">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie mithilfe der [<ph id="ph1">\]</ph>, Typ<ph id="ph2">\[</ph><ph id="ph3">\]</ph>, Typ<ph id="ph4">\[</ph><ph id="ph5">\]</ph>, Typ<ph id="ph6">\[</ph><ph id="ph7">\]</ph><ph id="ph8">\[</ph><ph id="ph9">\]</ph>, Typ<ph id="ph10">\[</ph> <ph id="ph11">\]</ph> <ph id="ph12">\&lt;</ph>xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A &gt; Methode zum Erstellen einer <ph id="ph13">`PInvoke`</ph> -Methode und zum Hinzufügen der <ph id="ph14">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> -Kennzeichen an die die Methodenimplementierungsflags nach der Erstellung der <ph id="ph15">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, mithilfe der <ph id="ph16">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph17">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example creates a dynamic assembly with one dynamic module and a single type, <ph id="ph1">`MyType`</ph>, that contains the <ph id="ph2">`PInvoke`</ph> method.</source>
          <target state="translated">Das Beispiel erstellt eine dynamische Assembly mit einem dynamischen Modul und eines einzelnen Typs <ph id="ph1">`MyType`</ph>, enthält die <ph id="ph2">`PInvoke`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The <ph id="ph1">`PInvoke`</ph> method represents the Win32 <ph id="ph2">`GetTickCount`</ph> function.</source>
          <target state="translated">Die <ph id="ph1">`PInvoke`</ph> Methode darstellt, die Win32 <ph id="ph2">`GetTickCount`</ph> Funktion.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>To get a non-zero return value, you must add the <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Um einen Rückgabewert ungleich 0 (null) zu erhalten, fügen Sie der <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example uses an overload that does not specify custom modifiers.</source>
          <target state="translated">Das Beispiel verwendet eine Überladung, die keine benutzerdefinierten Modifizierer angibt.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>To specify custom modifiers, change the example code to use this method overload instead.</source>
          <target state="translated">Ändern Sie den Beispielcode, um stattdessen verwenden Sie diese methodenüberladung zum Angeben von benutzerdefinierten Modifizierer.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>When the example is run, it executes the <ph id="ph1">`PInvoke`</ph> method.</source>
          <target state="translated">Wenn das Beispiel ausgeführt wird, führt die <ph id="ph1">`PInvoke`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>It also saves the dynamic assembly as PInvokeTest.dll.</source>
          <target state="translated">Es speichert auch die dynamische Assembly als PInvokeTest.dll gespeichert.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the <ph id="ph1">`MyType`</ph> class and the <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">`PInvoke`</ph> method it contains.</source>
          <target state="translated">Können Sie die <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> Untersuchen der <ph id="ph1">`MyType`</ph> Klasse und die <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">`PInvoke`</ph> Methode, die es enthält.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can compile a Visual Basic or C# program that uses the static <ph id="ph1">`MyType.GetTickCount`</ph> method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, <ph id="ph2">`/r:PInvokeTest.dll`</ph>.</source>
          <target state="translated">Sie können ein Visual Basic- oder C#-Programm, die statische verwendet, Kompilieren <ph id="ph1">`MyType.GetTickCount`</ph> Methode, indem Sie z. B. einen Verweis auf die DLL beim Ausführen von csc.exe oder vbc.exe; z. B. <ph id="ph2">`/r:PInvokeTest.dll`</ph>.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is not static.</source>
          <target state="translated">Die Methode ist nicht statisch.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The parent type is an interface.</source>
          <target state="translated">Der übergeordnete Typ ist eine Schnittstelle.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is abstract.</source>
          <target state="translated">Die Methode ist abstrakt.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method was previously defined.</source>
          <target state="translated">Die Methode wurde bereits definiert.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> is zero.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> oder <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The size of <ph id="ph1">&lt;paramref name="parameterTypeRequiredCustomModifiers" /&gt;</ph> or <ph id="ph2">&lt;paramref name="parameterTypeOptionalCustomModifiers" /&gt;</ph> does not equal the size of <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph>.</source>
          <target state="translated">Die Größe von <ph id="ph1">&lt;paramref name="parameterTypeRequiredCustomModifiers" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="parameterTypeOptionalCustomModifiers" /&gt;</ph> entspricht nicht die Größe von <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> oder <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> ist <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Der Typ wurde zuvor mit <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Für den aktuellen dynamischen Typ ist die <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph>-Eigenschaft <ph id="ph2">&lt;see langword="true" /&gt;</ph>, aber die <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph>-Eigenschaft ist <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Adds a new property to the type.</source>
          <target state="translated">Fügt der Abfrage eine neue Sortiereigenschaft hinzu.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The name of the property.</source>
          <target state="translated">Den Namen der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The attributes of the property.</source>
          <target state="translated">Die Attribute der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The return type of the property.</source>
          <target state="translated">Der Rückgabetyp der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The types of the parameters of the property.</source>
          <target state="translated">Die Typen der Parameter der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>Adds a new property to the type, with the given name and property signature.</source>
          <target state="translated">Fügt dem Typ eine neue Eigenschaft mit dem angegebenen Namen und der angegebenen Eigenschaftensignatur hinzu.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The defined property.</source>
          <target state="translated">Die definierte Eigenschaft.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The following code sample demonstrates how to define a dynamic property and obtain a <ph id="ph1">&lt;xref:System.Reflection.Emit.PropertyBuilder&gt;</ph> for specification.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie eine dynamische Eigenschaft definieren sowie das Abrufen einer <ph id="ph1">&lt;xref:System.Reflection.Emit.PropertyBuilder&gt;</ph> für Spezifikation.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>Note that a <ph id="ph1">`PropertyBuilder`</ph> must also have a corresponding <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, which will house the IL logic for the property.</source>
          <target state="translated">Beachten Sie, dass eine <ph id="ph1">`PropertyBuilder`</ph> benötigen auch eine entsprechende <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, wird die IL-Logik für die Eigenschaft gespeichert.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>Any of the elements of the <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Element des <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph>-Arrays ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Der Typ wurde zuvor mit <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The name of the property.</source>
          <target state="translated">Den Namen der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The attributes of the property.</source>
          <target state="translated">Die Attribute der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The calling convention of the property accessors.</source>
          <target state="translated">Die Aufrufkonvention der Eigenschaftsaccessoren.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The return type of the property.</source>
          <target state="translated">Der Rückgabetyp der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The types of the parameters of the property.</source>
          <target state="translated">Die Typen der Parameter der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>Adds a new property to the type, with the given name, attributes, calling convention, and property signature.</source>
          <target state="translated">Fügt dem Typ eine neue Eigenschaft mit den Angaben für den Namen und die Signatur der Eigenschaften hinzu.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The defined property.</source>
          <target state="translated">Die definierte Eigenschaft.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>Any of the elements of the <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Element des <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph>-Arrays ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Der Typ wurde zuvor mit <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The name of the property.</source>
          <target state="translated">Den Namen der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The attributes of the property.</source>
          <target state="translated">Die Attribute der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The return type of the property.</source>
          <target state="translated">Der Rückgabetyp der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the property.</source>
          <target state="translated">Ein Array von Typen, die die erforderlichen benutzerdefinierten Modifizierer, etwa <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, für den Rückgabetyp der Eigenschaft darstellen.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Wenn der Rückgabetyp keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> an. </target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the property.</source>
          <target state="translated">Ein Array von Typen, die die optionalen benutzerdefinierten Modifizierer, etwa <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, für den Rückgabetyp der Eigenschaft darstellen.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Wenn der Rückgabetyp keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> an. </target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The types of the parameters of the property.</source>
          <target state="translated">Die Typen der Parameter der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Ein Array mit Arrays von Typen.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Jedes Array von Typen stellt die erforderlichen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Wenn ein bestimmter Parameter keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> anstelle eines Arrays von Typen an.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Wenn keiner der Parameter erforderliche benutzerdefinierte Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> anstelle eines Arrays mit Arrays an.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Ein Array mit Arrays von Typen.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Jedes Array von Typen stellt die optionalen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Wenn ein bestimmter Parameter keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> anstelle eines Arrays von Typen an.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Wenn keiner der Parameter optionale benutzerdefinierte Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> anstelle eines Arrays mit Arrays an.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Adds a new property to the type, with the given name, property signature, and custom modifiers.</source>
          <target state="translated">Fügt dem Typ eine neue Eigenschaft hinzu, die den angegebenen Namen, die angegebene Eigenschaftensignatur und die angegebenen benutzerdefinierten Modifizierer hat.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The defined property.</source>
          <target state="translated">Die definierte Eigenschaft.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>This overload is provided for designers of managed compilers.</source>
          <target state="translated">Diese Überladung wird für Designer von verwalteten Compilern bereitgestellt.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
          <target state="translated">Weitere Informationen zu benutzerdefinierten Modifizierer finden Sie in der ECMA Partition II-Metadaten-Dokumentation.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. Sie finden sie unter <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> auf der Ecma International-Website.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist gleich <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Any of the elements of the <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph></source>
          <target state="translated">Irgendeines der Elemente des <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph>-Arrays ist gleich <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Der Typ wurde zuvor mit <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The name of the property.</source>
          <target state="translated">Den Namen der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The attributes of the property.</source>
          <target state="translated">Die Attribute der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The calling convention of the property accessors.</source>
          <target state="translated">Die Aufrufkonvention der Eigenschaftsaccessoren.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The return type of the property.</source>
          <target state="translated">Der Rückgabetyp der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the property.</source>
          <target state="translated">Ein Array von Typen, die die erforderlichen benutzerdefinierten Modifizierer, etwa <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, für den Rückgabetyp der Eigenschaft darstellen.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Wenn der Rückgabetyp keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> an. </target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the property.</source>
          <target state="translated">Ein Array von Typen, die die optionalen benutzerdefinierten Modifizierer, etwa <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, für den Rückgabetyp der Eigenschaft darstellen.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Wenn der Rückgabetyp keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> an. </target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The types of the parameters of the property.</source>
          <target state="translated">Die Typen der Parameter der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Ein Array mit Arrays von Typen.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Jedes Array von Typen stellt die erforderlichen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Wenn ein bestimmter Parameter keine erforderlichen benutzerdefinierten Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> anstelle eines Arrays von Typen an.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Wenn keiner der Parameter erforderliche benutzerdefinierte Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> anstelle eines Arrays mit Arrays an.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Ein Array mit Arrays von Typen.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Jedes Array von Typen stellt die optionalen benutzerdefinierten Modifizierer für den entsprechenden Parameter dar, z. B. <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Wenn ein bestimmter Parameter keine optionalen benutzerdefinierten Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> anstelle eines Arrays von Typen an.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Wenn keiner der Parameter optionale benutzerdefinierte Modifizierer hat, geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> anstelle eines Arrays mit Arrays an.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Adds a new property to the type, with the given name, calling convention, property signature, and custom modifiers.</source>
          <target state="translated">Fügt dem Typ eine neue Eigenschaft hinzu, die den angegebenen Namen, die angegebene Aufrufkonvention, die angegebene Eigenschaftensignatur und die angegebenen benutzerdefinierten Modifizierer hat.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The defined property.</source>
          <target state="translated">Die definierte Eigenschaft.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>This overload is provided for designers of managed compilers.</source>
          <target state="translated">Diese Überladung wird für Designer von verwalteten Compilern bereitgestellt.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
          <target state="translated">Weitere Informationen zu benutzerdefinierten Modifizierer finden Sie in der ECMA Partition II-Metadaten-Dokumentation.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. Sie finden sie unter <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> auf der Ecma International-Website.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>This method overload is introduced in the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Diese methodenüberladung wird eingeführt, der <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Any of the elements of the <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Element des <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph>-Arrays ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Der Typ wurde zuvor mit <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
          <source>Defines the initializer for this type.</source>
          <target state="translated">Definiert den Initialisierer für diesen Typ.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
          <source>Returns a type initializer.</source>
          <target state="translated">Gibt einen Typinitialisierer zurück.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
          <source>The initializer created is always public.</source>
          <target state="translated">Der erstellte Initialisierer ist immer öffentlich.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
          <source>The following code sample demonstrates how to create an initialization constructor using <ph id="ph1">`DefineTypeInitializer`</ph>.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie eine Initialisierung Konstruktor mit <ph id="ph1">`DefineTypeInitializer`</ph>.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
          <source>The containing type has been previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Der enthaltende Typ wurde zuvor mit <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The name used to refer to the data.</source>
          <target state="translated">Der Name, der zum Verweisen auf die Daten verwendet wird.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> darf keine eingebetteten NULL-Werte enthalten.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The size of the data field.</source>
          <target state="translated">Die Größe des Datenfelds.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The attributes for the field.</source>
          <target state="translated">Die Attribute für das Feld.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>Defines an uninitialized data field in the <ph id="ph1">&lt;see langword=".sdata" /&gt;</ph> section of the portable executable (PE) file.</source>
          <target state="translated">Definiert das initialisierte Datenfeld im <ph id="ph1">&lt;see langword=".sdata" /&gt;</ph>-Abschnitt der portierbaren ausführbaren Datei (Portable Executable, PE).</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>A field to reference the data.</source>
          <target state="translated">Ein Feld zum Verweisen auf die Daten.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The field that you create with this method will be <ph id="ph1">`static`</ph>, even if you do not include <ph id="ph2">`FieldAttributes.Static`</ph> in the <ph id="ph3">`attributes`</ph> parameter.</source>
          <target state="translated">Das Feld, das Sie mit dieser Methode erstellen, werden <ph id="ph1">`static`</ph>, selbst wenn Sie nicht einschließen, <ph id="ph2">`FieldAttributes.Static`</ph> in der <ph id="ph3">`attributes`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The following code sample demonstrates the use of <ph id="ph1">`DefineUninitializedData`</ph> to create an uninitialized data field in a dynamic type:</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung von <ph id="ph1">`DefineUninitializedData`</ph> initialisierte Datenfeld in einem dynamischen Typ zu erstellen:</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>Length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than or equal to zero, or greater than or equal to 0x003f0000.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist kleiner gleich 0 oder größer gleich 0x003f0000.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Der Typ wurde zuvor mit <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.FullName">
          <source>Retrieves the full path of this type.</source>
          <target state="translated">Ruft den vollständigen Pfad dieses Typs ab.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.FullName">
          <source>Read-only.</source>
          <target state="translated">Schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.FullName">
          <source>Retrieves the full path of this type.</source>
          <target state="translated">Ruft den vollständigen Pfad dieses Typs ab.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.FullName">
          <source>The returned format is "enclosingTypeFullName+nestedTypeName" for nested types and "typeName" for non-nested types.</source>
          <target state="translated">Das zurückgegebene Format ist "einschließenderTypVollständigerName + geschachtelterTypname" für geschachtelte Typen und "Typname" für den nicht geschachtelten Typen.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes">
          <source>Gets a value that indicates the covariance and special constraints of the current generic type parameter.</source>
          <target state="translated">Ruft einen Wert ab, der die Kovarianz und die speziellen Einschränkungen des aktuellen generischen Typparameters angibt.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph> values that describes the covariance and special constraints of the current generic type parameter.</source>
          <target state="translated">Eine bitweise Kombination von <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph>-Werten, die die Kovarianz und die speziellen Einschränkungen des aktuellen generischen Typparameters beschreiben.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes">
          <source>When emitting code, a generic type parameter is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object rather than by a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">Wenn Code ausgeben, wird durch ein generischen Typparameter dargestellt eine <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> Objekt und keine <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
          <source>Gets the position of a type parameter in the type parameter list of the generic type that declared the parameter.</source>
          <target state="translated">Ruft die Position eines Typparameters in der Typparameterliste des generischen Typs ab, der den Parameter deklariert hat.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
          <source>If the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object represents a generic type parameter, the position of the type parameter in the type parameter list of the generic type that declared the parameter; otherwise, undefined.</source>
          <target state="translated">Die Position des Typparameters in der Typparameterliste des generischen Typs, der den Parameter deklariert hat, wenn das aktuelle <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>-Objekt einen generischen Typparameter darstellt, andernfalls nicht definiert.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
          <source>When emitting code, a generic type parameter is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object rather than by a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">Wenn Code ausgeben, wird durch ein generischen Typparameter dargestellt eine <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> Objekt und keine <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> does not represent a generic type parameter, the value of this property is undefined.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> stellt keinen generischen Typparameter dar. der Wert dieser Eigenschaft ist nicht definiert.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A&gt;</ph> property to determine whether the current <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> represents a generic type parameter.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A&gt;</ph> -Eigenschaft können Sie bestimmen, ob die aktuelle <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> einen generischen Typparameter darstellt.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The constructed generic type whose constructor is returned.</source>
          <target state="translated">Der konstruierte generische Typ, dessen Konstruktor zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>A constructor on the generic type definition of <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept>, which specifies which constructor of <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> to return.</source>
          <target state="translated">Ein Konstruktor für die generische Typdefinition von <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept>, die angibt, welcher Konstruktor von <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> zurückgegeben werden soll.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>Returns the constructor of the specified constructed generic type that corresponds to the specified constructor of the generic type definition.</source>
          <target state="translated">Gibt den Konstruktor des angegebenen konstruierten generischen Typs zurück, der dem angegebenen Konstruktor der generischen Typdefinition entspricht.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> object that represents the constructor of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> corresponding to <ph id="ph3">&lt;paramref name="constructor" /&gt;</ph>, which specifies a constructor belonging to the generic type definition of <ph id="ph4">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>-Objekt, das den Konstruktor von <ph id="ph2">&lt;paramref name="type" /&gt;</ph> entsprechend <ph id="ph3">&lt;paramref name="constructor" /&gt;</ph> darstellt und einen Konstruktor angibt, der zur generischen Typdefinition von <ph id="ph4">&lt;paramref name="type" /&gt;</ph> gehört.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> method provides a way to get a <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object that represents a constructor of a constructed generic type whose generic type definition is represented by a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> Methode bietet eine Möglichkeit zum Abrufen einer <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> Objekt, das einen Konstruktor, der einen konstruierten generischen Typ darstellt, dessen Definition eines generischen Typs wird durch, eine <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>For example, suppose you have a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the type <ph id="ph2">`G&lt;T&gt;`</ph> in C# syntax (<ph id="ph3">`G(Of T)`</ph> in Visual Basic, <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> in C++) and a <ph id="ph5">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> object that represents a constructor of <ph id="ph6">`G&lt;T&gt;`</ph>.</source>
          <target state="translated">Nehmen wir beispielsweise an, Sie haben eine <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> -Objekt, das den Typ darstellt, <ph id="ph2">`G&lt;T&gt;`</ph> in C#-Syntax (<ph id="ph3">`G(Of T)`</ph> in Visual Basic <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> in C++) und ein <ph id="ph5">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> Objekt, das einen Konstruktor darstellt <ph id="ph6">`G&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>Suppose that <ph id="ph1">`G&lt;T&gt;`</ph> has a generic method with type parameter <ph id="ph2">`U`</ph> that creates an instance of the constructed type <ph id="ph3">`G&lt;U&gt;`</ph>.</source>
          <target state="translated">Nehmen wir an, die <ph id="ph1">`G&lt;T&gt;`</ph> verfügt über eine generische Methode mit Typparameter <ph id="ph2">`U`</ph> , erstellt eine Instanz des konstruierten Typs <ph id="ph3">`G&lt;U&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>In order to emit the code to create an instance of the constructed type, you need a <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object that represents the constructor of this constructed type — in other words, that creates an instance of <ph id="ph2">`G&lt;U&gt;`</ph>.</source>
          <target state="translated">Der Code zum Erstellen einer Instanz des konstruierten Typs ausgeben zu können, müssen Sie eine <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> Objekt, das den Konstruktor dieses darstellt konstruierter Typ – also erstellt, die eine Instanz des <ph id="ph2">`G&lt;U&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>To do this, first call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object, specifying the <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object that represents <ph id="ph4">`U`</ph> as the type argument.</source>
          <target state="translated">Zu diesem Zweck rufen Sie zuerst die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> Methode für die <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> -Objekt angeben der <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> Objekt, das darstellt <ph id="ph4">`U`</ph> als Typargument.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>Then call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> method with the return value of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method as parameter <ph id="ph3">`type`</ph> and the <ph id="ph4">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> object that represents the constructor of <ph id="ph5">`G&lt;U&gt;`</ph> as parameter <ph id="ph6">`constructor`</ph>.</source>
          <target state="translated">Rufen Sie anschließend die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> bei dem Rückgabewert der Methode der <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> Methode als Parameter <ph id="ph3">`type`</ph> und <ph id="ph4">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> -Objekt, das den Konstruktor darstellt <ph id="ph5">`G&lt;U&gt;`</ph> als Parameter <ph id="ph6">`constructor`</ph>.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The return value is the <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object you need to emit the function call.</source>
          <target state="translated">Der Rückgabewert ist der <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> müssen Sie die Ausgabe des Funktionsaufrufs-Objekt.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The code example demonstrates this scenario.</source>
          <target state="translated">Im Codebeispiel wird dieses Szenario veranschaulicht.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The following code example contains source code for a generic class named <ph id="ph1">`Sample`</ph> that has a type parameter named <ph id="ph2">`T`</ph>.</source>
          <target state="translated">Das folgende Codebeispiel enthält Quellcode für eine generische Klasse namens <ph id="ph1">`Sample`</ph> , die über einen Typparameter, der mit dem Namen verfügt <ph id="ph2">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The class has a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, and a generic method named <ph id="ph3">`GM`</ph> with its own type parameter, named <ph id="ph4">`U`</ph>.</source>
          <target state="translated">Die Klasse verfügt über ein Feld mit dem Namen <ph id="ph1">`Field`</ph>, des Typs <ph id="ph2">`T`</ph>, und eine generische Methode mit dem Namen <ph id="ph3">`GM`</ph> des eigenen Typparameters mit dem Namen <ph id="ph4">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>Method <ph id="ph1">`GM`</ph> creates an instance of <ph id="ph2">`Sample`</ph>, substituting its own type parameter <ph id="ph3">`U`</ph> for the type parameter of <ph id="ph4">`Sample`</ph>, and stores its input parameter in <ph id="ph5">`Field`</ph>.</source>
          <target state="translated">Methode <ph id="ph1">`GM`</ph> erstellt eine Instanz des <ph id="ph2">`Sample`</ph>, Ersetzen des eigenen Typparameters <ph id="ph3">`U`</ph> für den Typparameter von <ph id="ph4">`Sample`</ph>, und speichert dessen Eingabeparameter in <ph id="ph5">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>This source code is compiled but not used; you can view it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> and compare it to the code emitted by class <ph id="ph1">`Example`</ph>.</source>
          <target state="translated">Dieser Code wird kompiliert, aber nicht verwendet. sehen Sie es mit der <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> und vergleichen Sie sie mit der Code ausgegeben, die von Klasse <ph id="ph1">`Example`</ph>.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The code in class <ph id="ph1">`Example`</ph> demonstrates the use of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> method to emit generic code.</source>
          <target state="translated">Der Code in der Klasse <ph id="ph1">`Example`</ph> veranschaulicht die Verwendung von der <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> Methode, um generische Code ausgeben.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The <ph id="ph1">`Main`</ph> method of class <ph id="ph2">`Example`</ph> creates a dynamic assembly containing a class named <ph id="ph3">`Sample`</ph> and uses the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method to make it generic by adding a type parameter named <ph id="ph5">`T`</ph>.</source>
          <target state="translated">Die <ph id="ph1">`Main`</ph> -Methode der Klasse <ph id="ph2">`Example`</ph> erstellt eine dynamische Assembly mit einer Klasse mit dem Namen <ph id="ph3">`Sample`</ph> und verwendet die <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> Methode, um es generische machen, indem Sie einen Typparameter, der mit dem Namen <ph id="ph5">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>A default constructor and a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, are added to class <ph id="ph3">`Sample`</ph>.</source>
          <target state="translated">Einen Standardkonstruktor und ein Feld mit dem Namen <ph id="ph1">`Field`</ph>, des Typs <ph id="ph2">`T`</ph>, Klasse hinzugefügt werden <ph id="ph3">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>A method <ph id="ph1">`GM`</ph> is added and turned into a generic method by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Eine Methode <ph id="ph1">`GM`</ph> hinzugefügt und in einer generischen Methode umgewandelt werden, mithilfe der <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The type parameter of <ph id="ph1">`GM`</ph> is named <ph id="ph2">`U`</ph>.</source>
          <target state="translated">Der Typparameter der <ph id="ph1">`GM`</ph> lautet <ph id="ph2">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>After the type parameter is defined, the signature of <ph id="ph1">`GM`</ph> is added by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Nach dem Definieren des Typparameters die Signatur der <ph id="ph1">`GM`</ph> hinzugefügt wird, mithilfe der <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>There is no return type and no required or custom modifiers, so all the parameters of this method are <ph id="ph1">`null`</ph> except <ph id="ph2">`parameterTypes`</ph>; <ph id="ph3">`parameterTypes`</ph> sets the type of the method's only parameter to <ph id="ph4">`U`</ph>, the method's generic type parameter.</source>
          <target state="translated">Es gibt keinen Rückgabetyp und keine erforderlichen oder benutzerdefinierten Modifizierer, d. h. alle Parameter dieser Methode sind <ph id="ph1">`null`</ph> außer <ph id="ph2">`parameterTypes`</ph>; <ph id="ph3">`parameterTypes`</ph> legt den Typ der einzige Parameter von der Methode, um <ph id="ph4">`U`</ph>, generischen Typparameter der Methode.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The body of the method creates an instance of the constructed type <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> in Visual Basic), assigns the method's parameter to <ph id="ph3">`Field`</ph>, and then prints the value of <ph id="ph4">`Field`</ph>.</source>
          <target state="translated">Der Text der Methode erstellt eine Instanz des konstruierten Typs <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> in Visual Basic), weist der Methodenparameter, damit <ph id="ph3">`Field`</ph>, und gibt dann den Wert des <ph id="ph4">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> method is used to create a <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> that represents the default constructor of the constructed generic type <ph id="ph3">`Sample&lt;U&gt;`</ph> in the <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType&gt;</ph> instruction that creates the instance.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> Methode dient zum Erstellen einer <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> , die den Standardkonstruktor des konstruierten generischen Typs darstellt <ph id="ph3">`Sample&lt;U&gt;`</ph> in der <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType&gt;</ph> -Anweisung, die die Instanz erstellt.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>A dummy type is defined to hold the entry-point method <ph id="ph1">`Main`</ph>.</source>
          <target state="translated">Ein dummy-Typ wird definiert, um die Einstiegspunktmethode halten <ph id="ph1">`Main`</ph>.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>In the body of <ph id="ph1">`Main`</ph>, the static <ph id="ph2">`GM`</ph> method is invoked on the constructed generic type <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> in Visual Basic), with type <ph id="ph5">&lt;xref:System.String&gt;</ph> substituted for <ph id="ph6">`U`</ph>.</source>
          <target state="translated">Im Text des <ph id="ph1">`Main`</ph>, die statische <ph id="ph2">`GM`</ph> Methode wird aufgerufen, für den konstruierten generischen Typ <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> in Visual Basic), mit dem Typ <ph id="ph5">&lt;xref:System.String&gt;</ph> ersetzt <ph id="ph6">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</source>
          <target state="translated">Wenn das Codebeispiel ausgeführt wird, speichert es die ausgegebene Assembly als TypeBuilderGetFieldExample.exe.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>You can run TypeBuilderGetFieldExample.exe, and you can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to compare the emitted code with the code for the <ph id="ph1">`Sample`</ph> class that is compiled into the code example itself.</source>
          <target state="translated">Sie können TypeBuilderGetFieldExample.exe ausführen, und Sie können die <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> zum Vergleichen des ausgegebenen Codes durch den Code für die <ph id="ph1">`Sample`</ph> -Klasse, die in das Codebeispiel selbst kompiliert wird.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not represent a generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> stellt keinen generischen Typ dar.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not of type <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist nicht vom Typ <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="constructor" /&gt;</ph> is not a generic type definition.</source>
          <target state="translated">Der deklarierende Typ von <ph id="ph1">&lt;paramref name="constructor" /&gt;</ph> ist keine generische Typdefinition.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="constructor" /&gt;</ph> is not the generic type definition of <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated">Der deklarierende Typ von <ph id="ph1">&lt;paramref name="constructor" /&gt;</ph> ist nicht die generische Typdefinition von <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> as in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">Hierbei muss es sich um ein Bitflag aus <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> handeln, wie bei <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> usw.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> objects representing the public and non-public constructors defined for this class, as specified.</source>
          <target state="translated">Gibt, wie angegeben, ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>-Objekten zurück, die die öffentlichen und nicht öffentlichen Konstruktoren darstellen, die für diese Klasse definiert sind.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> objects representing the specified constructors defined for this class.</source>
          <target state="translated">Gibt ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>-Objekten zurück, die die angegebenen für diese Klasse definierten Konstruktoren darstellen.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>If no constructors are defined, an empty array is returned.</source>
          <target state="translated">Wenn keine Konstruktoren definiert sind, wird ein leeres Array zurückgegeben.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Rufen Sie den Typ mithilfe <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> und mithilfe der Reflektion für den abgerufenen Typ.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Diese Methode wird für unvollständige Typen nicht implementiert.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Returns the custom attributes defined for this type.</source>
          <target state="translated">Gibt die für diesen Typ definierten benutzerdefinierten Attribute zurück.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
          <source>Specifies whether to search this member's inheritance chain to find the attributes.</source>
          <target state="translated">Gibt an, ob die Vererbungskette dieses Members nach den Attributen durchsucht werden soll.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
          <source>Returns all the custom attributes defined for this type.</source>
          <target state="translated">Gibt alle für diesen Typ definierten benutzerdefinierten Attribute zurück.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
          <source>Returns an array of objects representing all the custom attributes of this type.</source>
          <target state="translated">Gibt ein Objektarray zurück, das alle benutzerdefinierten Attribute dieses Typs darstellt.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
          <source>This method is not currently supported for incomplete types.</source>
          <target state="translated">Diese Methode wird bei unvollständigen Typen derzeit nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
          <source>Retrieve the type using <ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Rufen Sie den Typ mithilfe von <ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph> ab, und rufen Sie <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> für den zurückgegebenen <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> auf.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The type of attribute to search for.</source>
          <target state="translated">Der Typ des zu suchenden Attributs.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Only attributes that are assignable to this type are returned.</source>
          <target state="translated">Nur Attribute, die diesem Typ zugeordnet werden können, werden zurückgegeben.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Specifies whether to search this member's inheritance chain to find the attributes.</source>
          <target state="translated">Gibt an, ob die Vererbungskette dieses Members nach den Attributen durchsucht werden soll.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Returns all the custom attributes of the current type that are assignable to a specified type.</source>
          <target state="translated">Gibt alle benutzerdefinierten Attribute des aktuellen Typs zurück, die einem angegebenen Typ zugewiesen werden können.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>An array of custom attributes defined on the current type.</source>
          <target state="translated">Ein Array benutzerdefinierter Attribute, die für den aktuellen Typ definiert sind.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This method is not currently supported for incomplete types.</source>
          <target state="translated">Diese Methode wird für unvollständige Typen derzeit nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Retrieve the type using <ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Rufen Sie den Typ mithilfe von <ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph> ab, und rufen Sie <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> für den zurückgegebenen <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> auf.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The type must be a type provided by the underlying runtime system.</source>
          <target state="translated">Der Typ muss ein vom zugrunde liegenden Laufzeitsystem bereitgestellter Typ sein.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetElementType">
          <source>Calling this method always throws <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen dieser Methode wird immer eine <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> ausgelöst.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetElementType">
          <source>This method is not supported.</source>
          <target state="translated">Diese Methode wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetElementType">
          <source>No value is returned.</source>
          <target state="translated">Es wird kein Wert zurückgegeben.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetElementType">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Rufen Sie den Typ mithilfe <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> und mithilfe der Reflektion für den abgerufenen Typ.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetElementType">
          <source>This method is not supported.</source>
          <target state="translated">Diese Methode wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The name of the event to search for.</source>
          <target state="translated">Der Name des Ereignisses, nach dem gesucht werden soll.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> values that limits the search.</source>
          <target state="translated">Eine bitweise Kombination von <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>-Werten, die die Suche einschränkt.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Returns the event with the specified name.</source>
          <target state="translated">Gibt das Ereignis mit dem angegebenen Namen zurück.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> object representing the event declared or inherited by this type with the specified name, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if there are no matches.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>-Objekt, das das von dem Typ mit dem angegebenen Namen deklarierte oder geerbte Ereignis darstellt, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn keine Übereinstimmungen gefunden wurden.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Rufen Sie den Typ mithilfe <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> und mithilfe der Reflektion für den abgerufenen Typ.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Diese Methode wird für unvollständige Typen nicht implementiert.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Returns the events defined by the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated">Gibt die vom aktuellen <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> definierten Ereignisse zurück.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents">
          <source>Returns the public events declared or inherited by this type.</source>
          <target state="translated">Gibt die öffentlichen Ereignisse zurück, die von diesem Typ deklariert oder geerbt wurden.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> objects representing the public events declared or inherited by this type.</source>
          <target state="translated">Gibt ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>-Objekten zurück, die die von diesem Typ deklarierten oder geerbten öffentlichen Ereignisse darstellen.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents">
          <source>An empty array is returned if there are no public events.</source>
          <target state="translated">Wenn keine öffentlichen Ereignisse vorhanden sind, wird ein leeres Array zurückgegeben.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Rufen Sie den Typ mithilfe <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A&gt;</ph> und mithilfe der Reflektion für den abgerufenen Typ.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Diese Methode wird für unvollständige Typen nicht implementiert.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> values that limits the search.</source>
          <target state="translated">Eine bitweise Kombination von <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>-Werten, die die Suche einschränkt.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>Returns the public and non-public events that are declared by this type.</source>
          <target state="translated">Gibt die öffentlichen und nicht öffentlichen Ereignisse zurück, die von diesem Typ deklariert werden.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> objects representing the events declared or inherited by this type that match the specified binding flags.</source>
          <target state="translated">Gibt ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>-Objekten zurück, die die von diesem Typ deklarierten oder geerbten Ereignisse darstellen, die den angegebenen Bindungsflags entsprechen.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>An empty array is returned if there are no matching events.</source>
          <target state="translated">Wenn keine übereinstimmenden Ereignisse vorhanden sind, wird ein leeres Array zurückgegeben.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Rufen Sie den Typ mithilfe <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> und mithilfe der Reflektion für den abgerufenen Typ.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Diese Methode wird für unvollständige Typen nicht implementiert.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Returns a field defined by the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated">Gibt ein vom aktuellen <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> definiertes Feld zurück.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The name of the field to get.</source>
          <target state="translated">Der Name des abzurufenden Felds.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> as in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">Hierbei muss es sich um ein Bitflag aus <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> handeln, wie bei <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> usw.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Returns the field specified by the given name.</source>
          <target state="translated">Gibt das vom angegebenen Namen angegebene Feld zurück.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> object representing the field declared or inherited by this type with the specified name and public or non-public modifier.</source>
          <target state="translated">Gibt das <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>-Objekt zurück, das das Feld darstellt, das von diesem Typ mit dem angegebenen Namen und dem öffentlichen oder nicht öffentlichen Modifizierer deklariert oder geerbt wurde.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>If there are no matches then <ph id="ph1">&lt;see langword="null" /&gt;</ph> is returned.</source>
          <target state="translated">Wenn keine Übereinstimmungen vorhanden sind, wird <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurückgegeben.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Rufen Sie den Typ mithilfe <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> und mithilfe der Reflektion für den abgerufenen Typ.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Diese Methode wird für unvollständige Typen nicht implementiert.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The constructed generic type whose field is returned.</source>
          <target state="translated">Der konstruierte generische Typ, dessen Feld zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>A field on the generic type definition of <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept>, which specifies which field of <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> to return.</source>
          <target state="translated">Ein Feld zur generischen Typdefinition von <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept>, das angibt, welches Feld von <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> zurückgegeben werden muss.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>Returns the field of the specified constructed generic type that corresponds to the specified field of the generic type definition.</source>
          <target state="translated">Gibt das Feld des angegebenen konstruierten generischen Typs zurück, der dem angegebenen Feld der generischen Typdefinition entspricht.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> object that represents the field of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> corresponding to <ph id="ph3">&lt;paramref name="field" /&gt;</ph>, which specifies a field belonging to the generic type definition of <ph id="ph4">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>-Objekt, das das Feld von <ph id="ph2">&lt;paramref name="type" /&gt;</ph> darstellt, das <ph id="ph3">&lt;paramref name="field" /&gt;</ph> entspricht, welches ein Feld angibt, das zur generischen Typdefinition von <ph id="ph4">&lt;paramref name="type" /&gt;</ph> gehört.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> method provides a way to get a <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object that represents a field of a constructed generic type whose generic type definition is represented by a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> Methode bietet eine Möglichkeit zum Abrufen einer <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> Objekt, das ein Feld eines konstruierten generischen Typs darstellt, dessen Definition eines generischen Typs wird durch, eine <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>For example, suppose you have a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the type <ph id="ph2">`G&lt;T&gt;`</ph> in C# syntax (<ph id="ph3">`G(Of T)`</ph> in Visual Basic, <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> in C++) and a <ph id="ph5">&lt;xref:System.Reflection.Emit.FieldBuilder&gt;</ph> object that represents a field <ph id="ph6">`public T F`</ph> in C# syntax (<ph id="ph7">`Public F As T`</ph> in Visual Basic, <ph id="ph8">`public: T F`</ph> in C++) that is defined by <ph id="ph9">`G&lt;T&gt;`</ph>.</source>
          <target state="translated">Nehmen wir beispielsweise an, Sie haben eine <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> -Objekt, das den Typ darstellt, <ph id="ph2">`G&lt;T&gt;`</ph> in C#-Syntax (<ph id="ph3">`G(Of T)`</ph> in Visual Basic <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> in C++) und ein <ph id="ph5">&lt;xref:System.Reflection.Emit.FieldBuilder&gt;</ph> -Objekt, das ein Feld darstellt <ph id="ph6">`public T F`</ph> in C#-Syntax (<ph id="ph7">`Public F As T`</ph>in Visual Basic <ph id="ph8">`public: T F`</ph> in C++), wird durch definiert <ph id="ph9">`G&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>Suppose that <ph id="ph1">`G&lt;T&gt;`</ph> has a generic method with type parameter <ph id="ph2">`U`</ph> that creates an instance of the constructed type <ph id="ph3">`G&lt;U&gt;`</ph> and calls field <ph id="ph4">`F`</ph> on that instance.</source>
          <target state="translated">Nehmen wir an, die <ph id="ph1">`G&lt;T&gt;`</ph> verfügt über eine generische Methode mit Typparameter <ph id="ph2">`U`</ph> , erstellt eine Instanz des konstruierten Typs <ph id="ph3">`G&lt;U&gt;`</ph> und Aufrufe Feld <ph id="ph4">`F`</ph> für diese Instanz.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>In order to emit the function call, you need a <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object that represents <ph id="ph2">`F`</ph> on the constructed type — in other words, that is of type <ph id="ph3">`U`</ph> rather than type <ph id="ph4">`T`</ph>.</source>
          <target state="translated">Damit des Funktionsaufrufs zu öffnen, müssen Sie eine <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> Objekt, das darstellt <ph id="ph2">`F`</ph> auf den konstruierten Typ – anders gesagt, ist vom Typ <ph id="ph3">`U`</ph> anstatt Typ <ph id="ph4">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>To do this, first call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object, specifying the <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object that represents <ph id="ph4">`U`</ph> as the type argument.</source>
          <target state="translated">Zu diesem Zweck rufen Sie zuerst die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> Methode für die <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> -Objekt angeben der <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> Objekt, das darstellt <ph id="ph4">`U`</ph> als Typargument.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>Then call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> method with the return value of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method as parameter <ph id="ph3">`type`</ph> and the <ph id="ph4">&lt;xref:System.Reflection.Emit.FieldBuilder&gt;</ph> object that represents <ph id="ph5">`F`</ph> as parameter <ph id="ph6">`field`</ph>.</source>
          <target state="translated">Rufen Sie anschließend die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> bei dem Rückgabewert der Methode der <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> Methode als Parameter <ph id="ph3">`type`</ph> und <ph id="ph4">&lt;xref:System.Reflection.Emit.FieldBuilder&gt;</ph> Objekt, das darstellt <ph id="ph5">`F`</ph> als Parameter <ph id="ph6">`field`</ph>.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The return value is the <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object you need to emit the function call.</source>
          <target state="translated">Der Rückgabewert ist der <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> müssen Sie die Ausgabe des Funktionsaufrufs-Objekt.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The code example demonstrates this scenario.</source>
          <target state="translated">Im Codebeispiel wird dieses Szenario veranschaulicht.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The following code example contains source code for a generic class named Sample that has a type parameter named <ph id="ph1">`T`</ph>.</source>
          <target state="translated">Das folgende Codebeispiel enthält Quellcode für eine generische Klasse namens Beispiel, das einen Typparameter, der mit dem Namen <ph id="ph1">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The class has a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, and a generic method named <ph id="ph3">`GM`</ph> with its own type parameter, named <ph id="ph4">`U`</ph>.</source>
          <target state="translated">Die Klasse verfügt über ein Feld mit dem Namen <ph id="ph1">`Field`</ph>, des Typs <ph id="ph2">`T`</ph>, und eine generische Methode mit dem Namen <ph id="ph3">`GM`</ph> des eigenen Typparameters mit dem Namen <ph id="ph4">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>Method <ph id="ph1">`GM`</ph> creates an instance of <ph id="ph2">`Sample`</ph>, substituting its own type parameter <ph id="ph3">`U`</ph> for the type parameter of <ph id="ph4">`Sample`</ph>, and stores its input parameter in <ph id="ph5">`Field`</ph>.</source>
          <target state="translated">Methode <ph id="ph1">`GM`</ph> erstellt eine Instanz des <ph id="ph2">`Sample`</ph>, Ersetzen des eigenen Typparameters <ph id="ph3">`U`</ph> für den Typparameter von <ph id="ph4">`Sample`</ph>, und speichert dessen Eingabeparameter in <ph id="ph5">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>This source code is compiled but not used; you can view it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> and compare it to the code emitted by class <ph id="ph1">`Example`</ph>.</source>
          <target state="translated">Dieser Code wird kompiliert, aber nicht verwendet. sehen Sie es mit der <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> und vergleichen Sie sie mit der Code ausgegeben, die von Klasse <ph id="ph1">`Example`</ph>.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The code in class <ph id="ph1">`Example`</ph> demonstrates the use of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> method to emit generic code.</source>
          <target state="translated">Der Code in der Klasse <ph id="ph1">`Example`</ph> veranschaulicht die Verwendung von der <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> Methode, um generische Code ausgeben.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The <ph id="ph1">`Main`</ph> method of class <ph id="ph2">`Example`</ph> creates a dynamic assembly containing a class named <ph id="ph3">`Sample`</ph>, and uses the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method to make it generic by adding a type parameter named <ph id="ph5">`T`</ph>.</source>
          <target state="translated">Die <ph id="ph1">`Main`</ph> -Methode der Klasse <ph id="ph2">`Example`</ph> erstellt eine dynamische Assembly mit einer Klasse mit dem Namen <ph id="ph3">`Sample`</ph>, und verwendet die <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> Methode, um es generische machen, indem Sie einen Typparameter, der mit dem Namen <ph id="ph5">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>A default constructor and a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, are added to class <ph id="ph3">`Sample`</ph>.</source>
          <target state="translated">Einen Standardkonstruktor und ein Feld mit dem Namen <ph id="ph1">`Field`</ph>, des Typs <ph id="ph2">`T`</ph>, Klasse hinzugefügt werden <ph id="ph3">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>A method <ph id="ph1">`GM`</ph> is added and turned into a generic method by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Eine Methode <ph id="ph1">`GM`</ph> hinzugefügt und in einer generischen Methode umgewandelt werden, mithilfe der <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The type parameter of <ph id="ph1">`GM`</ph> is named <ph id="ph2">`U`</ph>.</source>
          <target state="translated">Der Typparameter der <ph id="ph1">`GM`</ph> lautet <ph id="ph2">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>After the type parameter is defined, the signature of <ph id="ph1">`GM`</ph> is added by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Nach dem Definieren des Typparameters die Signatur der <ph id="ph1">`GM`</ph> hinzugefügt wird, mithilfe der <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>There is no return type and no required or custom modifiers, so all the parameters of this method are <ph id="ph1">`null`</ph> except <ph id="ph2">`parameterTypes`</ph>; <ph id="ph3">`parameterTypes`</ph> sets the type of the method's only parameter to <ph id="ph4">`U`</ph>, the method's generic type parameter.</source>
          <target state="translated">Es gibt keinen Rückgabetyp und keine erforderlichen oder benutzerdefinierten Modifizierer, d. h. alle Parameter dieser Methode sind <ph id="ph1">`null`</ph> außer <ph id="ph2">`parameterTypes`</ph>; <ph id="ph3">`parameterTypes`</ph> legt den Typ der einzige Parameter von der Methode, um <ph id="ph4">`U`</ph>, generischen Typparameter der Methode.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The body of the method creates an instance of the constructed type <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> in Visual Basic), assigns the method's parameter to <ph id="ph3">`Field`</ph>, and then prints the value of <ph id="ph4">`Field`</ph>.</source>
          <target state="translated">Der Text der Methode erstellt eine Instanz des konstruierten Typs <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> in Visual Basic), weist der Methodenparameter, damit <ph id="ph3">`Field`</ph>, und gibt dann den Wert des <ph id="ph4">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> method is used to create a <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> that represents the field of the constructed generic type <ph id="ph3">`Sample&lt;U&gt;`</ph> in the <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType&gt;</ph> instructions.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> Methode dient zum Erstellen einer <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> , die das Feld des konstruierten generischen Typs darstellt <ph id="ph3">`Sample&lt;U&gt;`</ph> in der <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType&gt;</ph> und <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType&gt;</ph> Anweisungen.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>A dummy type is defined to hold the entry-point method <ph id="ph1">`Main`</ph>.</source>
          <target state="translated">Ein dummy-Typ wird definiert, um die Einstiegspunktmethode halten <ph id="ph1">`Main`</ph>.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>In the body of <ph id="ph1">`Main`</ph>, the static <ph id="ph2">`GM`</ph> method is invoked on the constructed generic type <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> in Visual Basic), with type <ph id="ph5">&lt;xref:System.String&gt;</ph> substituted for <ph id="ph6">`U`</ph>.</source>
          <target state="translated">Im Text des <ph id="ph1">`Main`</ph>, die statische <ph id="ph2">`GM`</ph> Methode wird aufgerufen, für den konstruierten generischen Typ <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> in Visual Basic), mit dem Typ <ph id="ph5">&lt;xref:System.String&gt;</ph> ersetzt <ph id="ph6">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</source>
          <target state="translated">Wenn das Codebeispiel ausgeführt wird, speichert es die ausgegebene Assembly als TypeBuilderGetFieldExample.exe.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>You can run TypeBuilderGetFieldExample.exe, and you can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to compare the emitted code with the code for the <ph id="ph1">`Sample`</ph> class that is compiled into the code example itself.</source>
          <target state="translated">Sie können TypeBuilderGetFieldExample.exe ausführen, und Sie können die <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> zum Vergleichen des ausgegebenen Codes durch den Code für die <ph id="ph1">`Sample`</ph> -Klasse, die in das Codebeispiel selbst kompiliert wird.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not represent a generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> stellt keinen generischen Typ dar.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not of type <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist nicht vom Typ <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="field" /&gt;</ph> is not a generic type definition.</source>
          <target state="translated">Der deklarierende Typ von <ph id="ph1">&lt;paramref name="field" /&gt;</ph> ist keine generische Typdefinition.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="field" /&gt;</ph> is not the generic type definition of <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated">Der deklarierende Typ von <ph id="ph1">&lt;paramref name="field" /&gt;</ph> ist nicht die generische Typdefinition von <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> : <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">Hierbei muss es sich um ein Bitflag aus <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> handeln: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> usw.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>Returns the public and non-public fields that are declared by this type.</source>
          <target state="translated">Gibt die öffentlichen und nicht öffentlichen Felder zurück, die von diesem Typ deklariert werden.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> objects representing the public and non-public fields declared or inherited by this type.</source>
          <target state="translated">Gibt ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>-Objekten zurück, die die von diesem Typ deklarierten oder geerbten öffentlichen und nicht öffentlichen Felder darstellen.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>An empty array is returned if there are no fields, as specified.</source>
          <target state="translated">Wenn keine Felder vorhanden sind, wird ein leeres Array zurückgegeben, wie angegeben.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetFields%2A&gt;</ph> Methode gibt keinen zurück Felder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which fields are returned, because that order can vary.</source>
          <target state="translated">Der Code muss nicht auf die Reihenfolge, in der Felder zurückgegeben werden, abhängen, da dieser Reihenfolge variieren kann.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Rufen Sie den Typ mithilfe <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> und mithilfe der Reflektion für den abgerufenen Typ.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Diese Methode wird für unvollständige Typen nicht implementiert.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the type arguments of a generic type or the type parameters of a generic type definition.</source>
          <target state="translated">Gibt ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten zurück, die die Typargumente eines generischen Typs oder die Typargumente einer generischen Typdefinition darstellen.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>The elements of the array represent the type arguments of a generic type or the type parameters of a generic type definition.</source>
          <target state="translated">Die Elemente des Arrays stellen die Typargumente eines generischen Typs oder die Typparameter einer generischen Typdefinition dar.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>The elements of the returned array are in the order in which they appear in the list of type parameters for the generic type definition.</source>
          <target state="translated">Die Elemente des zurückgegebenen Arrays sind in der Reihenfolge, in der sie in der Liste mit Typparametern für die generische Typdefinition angezeigt werden.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object represents a generic type definition if the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method has been used to give it generic type parameters.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> -Objekt eine generische Typdefinition darstellt, wenn die <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> -Methode wurde verwendet, um generische Typparameter.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>This method retrieves the <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> objects that represent the generic type parameters.</source>
          <target state="translated">Diese Methode ruft die <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> Objekte, die die generischen Typparameter darstellen.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Weitere Informationen zu generischen Typen in der Reflektion und eine Liste der invarianten Bedingungen für Begriffe, die in generischen Reflektion, finden Sie unter der <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a generic type definition from which the current type can be obtained.</source>
          <target state="translated">Gibt ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt zurück, das eine generische Typdefinition darstellt, aus der der aktuelle Typ abgerufen werden kann.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing a generic type definition from which the current type can be obtained.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt, das eine generische Typdefinition darstellt, aus der der aktuelle Typ abgerufen werden kann.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>If you call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object for which the <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A&gt;</ph> property returns <ph id="ph4">`true`</ph>, the <ph id="ph5">&lt;xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A&gt;</ph> property returns the current instance.</source>
          <target state="translated">Beim Aufrufen der <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A&gt;</ph> Methode auf eine <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> Objekt, für das die <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A&gt;</ph> -Eigenschaft gibt <ph id="ph4">`true`</ph>, die <ph id="ph5">&lt;xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A&gt;</ph> Eigenschaft gibt die aktuelle Instanz zurück.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> that represents a generic type is always a generic type definition.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> , stellt einen generischen Typ ist immer eine generische Typdefinition.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>If you used the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method to construct a generic type from a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents a generic type definition, using the <ph id="ph3">&lt;xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType&gt;</ph> method on the constructed type gets back the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the generic type definition.</source>
          <target state="translated">Bei Verwendung der <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> Methode zum Erstellen eines generischen Typs aus eine <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> -Objekt, das eine generische Typdefinition darstellt, mit der <ph id="ph3">&lt;xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType&gt;</ph> Methode für den konstruierten Typ erhält wieder die <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> Objekt, das den generischen Typ darstellt Definition.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>The current type is not generic.</source>
          <target state="translated">Der aktuelle Typ ist nicht generisch.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Das heißt, <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> gibt <ph id="ph2">&lt;see langword="false" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>The name of the interface.</source>
          <target state="translated">Der Name der Schnittstelle.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="true" /&gt;</ph>, the search is case-insensitive.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;see langword="true" /&gt;</ph>, wird bei der Suche die Groß- und Kleinschreibung nicht berücksichtigt.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the search is case-sensitive.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;see langword="false" /&gt;</ph>, wird bei der Suche die Groß- und Kleinschreibung berücksichtigt.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>Returns the interface implemented (directly or indirectly) by this class with the fully qualified name matching the given interface name.</source>
          <target state="translated">Gibt die von dieser Klasse (direkt oder indirekt) implementierte Schnittstelle mit dem vollqualifizierten Namen zurück, der dem angegebenen Namen der Schnittstelle entspricht.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the implemented interface.</source>
          <target state="translated">Gibt ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt zurück, das die implementierte Schnittstelle darstellt.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>Returns null if no interface matching name is found.</source>
          <target state="translated">Gibt NULL zurück, wenn kein mit der Schnittstelle übereinstimmender Name gefunden wird.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Rufen Sie den Typ mithilfe <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> und mithilfe der Reflektion für den abgerufenen Typ.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Diese Methode wird für unvollständige Typen nicht implementiert.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the interface for which the mapping is to be retrieved.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> der Schnittstelle, für den die Zuordnung abgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
          <source>Returns an interface mapping for the requested interface.</source>
          <target state="translated">Gibt eine Schnittstellenzuordnung für die angeforderte Schnittstelle zurück.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
          <source>Returns the requested interface mapping.</source>
          <target state="translated">Gibt die angeforderte Schnittstellenzuordnung zurück.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Rufen Sie den Typ mithilfe <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> und mithilfe der Reflektion für den abgerufenen Typ.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Diese Methode wird für unvollständige Typen nicht implementiert.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaces">
          <source>Returns an array of all the interfaces implemented on this type and its base types.</source>
          <target state="translated">Gibt ein Array aller für diesen Typ und die zugehörigen Basistypen implementierten Schnittstellen zurück.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaces">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the implemented interfaces.</source>
          <target state="translated">Gibt ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten zurück, die die implementierten Schnittstellen darstellen.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaces">
          <source>If none are defined, an empty array is returned.</source>
          <target state="translated">Wenn keine definiert sind, wird ein leeres Array zurückgegeben.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The name of the member.</source>
          <target state="translated">Der Name des Members.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The type of the member to return.</source>
          <target state="translated">Der Typ des zurückzugebenden Members.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, as in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">Hierbei muss es sich um ein Bitflag aus <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> handeln, wie bei <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> usw.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Returns all the public and non-public members declared or inherited by this type, as specified.</source>
          <target state="translated">Gibt alle öffentlichen und nicht öffentlichen Member zurück, die gemäß Angabe von diesem Typ deklariert oder geerbt wurden.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing the public and non-public members defined on this type if <ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph> is used; otherwise, only the public members are returned.</source>
          <target state="translated">Gibt ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>-Objekten zurück, die die für diesen Typ definierten öffentlichen und nicht öffentlichen Member darstellen, wenn <ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph> verwendet wird. Andernfalls werden nur die öffentlichen Member zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Rufen Sie den Typ mithilfe <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> und mithilfe der Reflektion für den abgerufenen Typ.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Diese Methode wird für unvollständige Typen nicht implementiert.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, such as <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">Hierbei muss es sich um ein Bitflag aus <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> handeln, z. B. um <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> usw.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>Returns the members for the public and non-public members declared or inherited by this type.</source>
          <target state="translated">Gibt alle Member für die öffentlichen und nicht öffentlichen Member zurück, die von diesem Typ deklariert oder geerbt wurden.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing the public and non-public members declared or inherited by this type.</source>
          <target state="translated">Gibt ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>-Objekten zurück, die die von diesem Typ deklarierten oder geerbten öffentlichen und nicht öffentlichen Member darstellen.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>An empty array is returned if there are no matching members.</source>
          <target state="translated">Wenn keine übereinstimmenden Member vorhanden sind, wird ein leeres Array zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Rufen Sie den Typ mithilfe <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> und mithilfe der Reflektion für den abgerufenen Typ.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Diese Methode wird für unvollständige Typen nicht implementiert.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The constructed generic type whose method is returned.</source>
          <target state="translated">Der konstruierte generische Typ, dessen Methode zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>A method on the generic type definition of <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept>, which specifies which method of <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> to return.</source>
          <target state="translated">Eine Methode für die generische Typdefinition von <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept>, die angibt, welche Methode von <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> zurückgegeben werden soll.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>Returns the method of the specified constructed generic type that corresponds to the specified method of the generic type definition.</source>
          <target state="translated">Gibt die Methode des angegebenen konstruierten generischen Typs zurück, der der angegebenen Methode der generischen Typdefinition entspricht.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object that represents the method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> corresponding to <ph id="ph3">&lt;paramref name="method" /&gt;</ph>, which specifies a method belonging to the generic type definition of <ph id="ph4">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>-Objekt, das die Methode von <ph id="ph2">&lt;paramref name="type" /&gt;</ph> entsprechend <ph id="ph3">&lt;paramref name="method" /&gt;</ph> darstellt und eine Methode angibt, die zur generischen Typdefinition von <ph id="ph4">&lt;paramref name="type" /&gt;</ph> gehört.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> method provides a way to get a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a method of a constructed generic type whose generic type definition is represented by a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> Methode bietet eine Möglichkeit zum Abrufen einer <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> Objekt, das eine Methode einen konstruierten generischen Typ darstellt, dessen Definition eines generischen Typs wird durch, eine <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>For example, suppose you have a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the type <ph id="ph2">`G&lt;T&gt;`</ph> in C# syntax (<ph id="ph3">`G(Of T)`</ph> in Visual Basic, <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> in C++) and a <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> object that represents a method <ph id="ph6">`T M()`</ph> in C# syntax (<ph id="ph7">`Function M() As T`</ph> in Visual Basic, <ph id="ph8">`T M()`</ph> in C++) that is defined by <ph id="ph9">`G&lt;T&gt;`</ph>.</source>
          <target state="translated">Nehmen wir beispielsweise an, Sie haben eine <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> -Objekt, das den Typ darstellt <ph id="ph2">`G&lt;T&gt;`</ph> in C#-Syntax (<ph id="ph3">`G(Of T)`</ph> in Visual Basic <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> in C++) und ein <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> Objekt zur Darstellung einer Methode <ph id="ph6">`T M()`</ph> in C#-Syntax (<ph id="ph7">`Function M() As T`</ph>in Visual Basic <ph id="ph8">`T M()`</ph> in C++), wird durch definiert <ph id="ph9">`G&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>Suppose that <ph id="ph1">`G&lt;T&gt;`</ph> has a generic method with type parameter <ph id="ph2">`U`</ph> that creates an instance of the constructed type <ph id="ph3">`G&lt;U&gt;`</ph> and calls method <ph id="ph4">`M`</ph> on that instance.</source>
          <target state="translated">Nehmen wir an, die <ph id="ph1">`G&lt;T&gt;`</ph> verfügt über eine generische Methode mit Typparameter <ph id="ph2">`U`</ph> , erstellt eine Instanz des konstruierten Typs <ph id="ph3">`G&lt;U&gt;`</ph> und Methodenaufrufe <ph id="ph4">`M`</ph> für diese Instanz.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>In order to emit the function call, you need a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents <ph id="ph2">`M`</ph> on the constructed type — in other words, that returns type <ph id="ph3">`U`</ph> rather than type <ph id="ph4">`T`</ph>.</source>
          <target state="translated">Des Funktionsaufrufs zu öffnen, müssen Sie eine <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> Objekt, das darstellt <ph id="ph2">`M`</ph> auf den konstruierten Typ – also Typ zurückgibt <ph id="ph3">`U`</ph> anstatt Typ <ph id="ph4">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>To do this, first call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object, specifying the <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object that represents <ph id="ph4">`U`</ph> as the type argument.</source>
          <target state="translated">Zu diesem Zweck rufen Sie zuerst die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> Methode für die <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> -Objekt angeben der <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> Objekt, das darstellt <ph id="ph4">`U`</ph> als Typargument.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>Then call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> method with the return value of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method as parameter <ph id="ph3">`type`</ph> and the <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> object that represents <ph id="ph5">`T M()`</ph> as parameter <ph id="ph6">`method`</ph>.</source>
          <target state="translated">Rufen Sie anschließend die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> bei dem Rückgabewert der Methode der <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> Methode als Parameter <ph id="ph3">`type`</ph> und <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> Objekt, das darstellt <ph id="ph5">`T M()`</ph> als Parameter <ph id="ph6">`method`</ph>.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The return value is the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object you need to emit the function call.</source>
          <target state="translated">Der Rückgabewert ist der <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> müssen Sie die Ausgabe des Funktionsaufrufs-Objekt.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The code example demonstrates a scenario similar to this.</source>
          <target state="translated">Im Codebeispiel wird eines ähnliches Szenarios.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The following code example contains source code for a generic class named <ph id="ph1">`Sample`</ph> that has a type parameter named <ph id="ph2">`T`</ph>.</source>
          <target state="translated">Das folgende Codebeispiel enthält Quellcode für eine generische Klasse namens <ph id="ph1">`Sample`</ph> , die über einen Typparameter, der mit dem Namen verfügt <ph id="ph2">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The class has a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, and a generic method named <ph id="ph3">`GM`</ph> with its own type parameter, named <ph id="ph4">`U`</ph>.</source>
          <target state="translated">Die Klasse verfügt über ein Feld mit dem Namen <ph id="ph1">`Field`</ph>, des Typs <ph id="ph2">`T`</ph>, und eine generische Methode mit dem Namen <ph id="ph3">`GM`</ph> des eigenen Typparameters mit dem Namen <ph id="ph4">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>Method <ph id="ph1">`GM`</ph> creates an instance of <ph id="ph2">`Sample`</ph>, substituting its own type parameter <ph id="ph3">`U`</ph> for the type parameter of <ph id="ph4">`Sample`</ph>, and stores its input parameter in <ph id="ph5">`Field`</ph>.</source>
          <target state="translated">Methode <ph id="ph1">`GM`</ph> erstellt eine Instanz des <ph id="ph2">`Sample`</ph>, Ersetzen des eigenen Typparameters <ph id="ph3">`U`</ph> für den Typparameter von <ph id="ph4">`Sample`</ph>, und speichert dessen Eingabeparameter in <ph id="ph5">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>This source code is compiled but not used; you can view it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> and compare it to the code emitted by class <ph id="ph1">`Example`</ph>.</source>
          <target state="translated">Dieser Code wird kompiliert, aber nicht verwendet. sehen Sie es mit der <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> und vergleichen Sie sie mit der Code ausgegeben, die von Klasse <ph id="ph1">`Example`</ph>.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The code in class <ph id="ph1">`Example`</ph> demonstrates the use of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> method to emit generic code.</source>
          <target state="translated">Der Code in der Klasse <ph id="ph1">`Example`</ph> veranschaulicht die Verwendung von der <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> Methode, um generische Code ausgeben.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">`Main`</ph> method of class <ph id="ph2">`Example`</ph> creates a dynamic assembly containing a class named <ph id="ph3">`Sample`</ph> and uses the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method to make it generic by adding a type parameter named <ph id="ph5">`T`</ph>.</source>
          <target state="translated">Die <ph id="ph1">`Main`</ph> -Methode der Klasse <ph id="ph2">`Example`</ph> erstellt eine dynamische Assembly mit einer Klasse mit dem Namen <ph id="ph3">`Sample`</ph> und verwendet die <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> Methode, um es generische machen, indem Sie einen Typparameter, der mit dem Namen <ph id="ph5">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>A default constructor and a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, are added to class <ph id="ph3">`Sample`</ph>.</source>
          <target state="translated">Einen Standardkonstruktor und ein Feld mit dem Namen <ph id="ph1">`Field`</ph>, des Typs <ph id="ph2">`T`</ph>, Klasse hinzugefügt werden <ph id="ph3">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>A method <ph id="ph1">`GM`</ph> is added and turned into a generic method by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Eine Methode <ph id="ph1">`GM`</ph> hinzugefügt und in einer generischen Methode umgewandelt werden, mithilfe der <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The type parameter of <ph id="ph1">`GM`</ph> is named <ph id="ph2">`U`</ph>.</source>
          <target state="translated">Der Typparameter der <ph id="ph1">`GM`</ph> lautet <ph id="ph2">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>After the type parameter is defined, the signature of <ph id="ph1">`GM`</ph> is added by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Nach dem Definieren des Typparameters die Signatur der <ph id="ph1">`GM`</ph> hinzugefügt wird, mithilfe der <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>There is no return type and no required or custom modifiers, so all the parameters of this method are <ph id="ph1">`null`</ph> except <ph id="ph2">`parameterTypes`</ph>; <ph id="ph3">`parameterTypes`</ph> sets the type of the method's only parameter to <ph id="ph4">`U`</ph>, the method's generic type parameter.</source>
          <target state="translated">Es gibt keinen Rückgabetyp und keine erforderlichen oder benutzerdefinierten Modifizierer, d. h. alle Parameter dieser Methode sind <ph id="ph1">`null`</ph> außer <ph id="ph2">`parameterTypes`</ph>; <ph id="ph3">`parameterTypes`</ph> legt den Typ der einzige Parameter von der Methode, um <ph id="ph4">`U`</ph>, generischen Typparameter der Methode.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The body of the method creates an instance of the constructed type <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> in Visual Basic), assigns the method's parameter to <ph id="ph3">`Field`</ph>, and then prints the value of <ph id="ph4">`Field`</ph>.</source>
          <target state="translated">Der Text der Methode erstellt eine Instanz des konstruierten Typs <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> in Visual Basic), weist der Methodenparameter, damit <ph id="ph3">`Field`</ph>, und gibt dann den Wert des <ph id="ph4">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>A dummy type is defined to hold the entry-point method <ph id="ph1">`Main`</ph>.</source>
          <target state="translated">Ein dummy-Typ wird definiert, um die Einstiegspunktmethode halten <ph id="ph1">`Main`</ph>.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>In the body of <ph id="ph1">`Main`</ph>, the static <ph id="ph2">`GM`</ph> method is invoked on the constructed generic type <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> in Visual Basic), with type <ph id="ph5">&lt;xref:System.String&gt;</ph> substituted for <ph id="ph6">`U`</ph>.</source>
          <target state="translated">Im Text des <ph id="ph1">`Main`</ph>, die statische <ph id="ph2">`GM`</ph> Methode wird aufgerufen, für den konstruierten generischen Typ <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> in Visual Basic), mit dem Typ <ph id="ph5">&lt;xref:System.String&gt;</ph> ersetzt <ph id="ph6">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> method is used to create a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> for the static <ph id="ph3">`GM`</ph> method of the constructed generic type <ph id="ph4">`Sample&lt;U&gt;`</ph>, and the <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> method is then used to create a <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that can emitted in a method call.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> Methode dient zum Erstellen einer <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> für die statische <ph id="ph3">`GM`</ph> Methode des konstruierten generischen Typs <ph id="ph4">`Sample&lt;U&gt;`</ph>, und die <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> Methode dient dann zum Erstellen einer <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> können, die in einem Methodenaufruf ausgegeben.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</source>
          <target state="translated">Wenn das Codebeispiel ausgeführt wird, speichert es die ausgegebene Assembly als TypeBuilderGetFieldExample.exe.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>You can run TypeBuilderGetFieldExample.exe, and you can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to compare the emitted code with the code for the <ph id="ph1">`Sample`</ph> class that is compiled into the code example itself.</source>
          <target state="translated">Sie können TypeBuilderGetFieldExample.exe ausführen, und Sie können die <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> zum Vergleichen des ausgegebenen Codes durch den Code für die <ph id="ph1">`Sample`</ph> -Klasse, die in das Codebeispiel selbst kompiliert wird.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is a generic method that is not a generic method definition.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist eine generische Methode, aber keine generische Methodendefinition.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not represent a generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> stellt keinen generischen Typ dar.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not of type <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist nicht vom Typ <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a generic type definition.</source>
          <target state="translated">Der deklarierende Typ von <ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist keine generische Typdefinition.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not the generic type definition of <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated">Der deklarierende Typ von <ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist nicht die generische Typdefinition von <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> as in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">Hierbei muss es sich um ein Bitflag aus <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> handeln, wie bei <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> usw.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>Returns all the public and non-public methods declared or inherited by this type, as specified.</source>
          <target state="translated">Gibt alle öffentlichen und nicht öffentlichen Methoden zurück, die gemäß Angabe von diesem Typ deklariert oder geerbt wurden.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects representing the public and non-public methods defined on this type if <ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph> is used; otherwise, only the public methods are returned.</source>
          <target state="translated">Gibt ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>-Objekten zurück, die die für diesen Typ definierten öffentlichen und nicht öffentlichen Methoden darstellen, wenn <ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph> verwendet wird. Andernfalls werden lediglich die öffentlichen Methoden zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Rufen Sie den Typ mithilfe <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> und mithilfe der Reflektion für den abgerufenen Typ.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Diese Methode wird für unvollständige Typen nicht implementiert.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing the name of the nested type to get.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, der den Namen des abzurufenden geschachtelten Typs enthält.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Eine Bitmaske aus einem oder mehreren <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, die angeben, wie die Suche durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to conduct a case-sensitive search for public methods.</source>
          <target state="translated">Null, um eine Suche nach öffentlichen Methoden mit Beachtung der Groß-/Kleinschreibung durchzuführen.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Returns the public and non-public nested types that are declared by this type.</source>
          <target state="translated">Gibt die öffentlichen und nicht öffentlichen geschachtelten Typen zurück, die von diesem Typ deklariert werden.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the nested type that matches the specified requirements, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt, das den geschachtelten Typ darstellt, der den angegebenen Anforderungen entspricht, sofern dieser gefunden wird. Andernfalls <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Rufen Sie den Typ mithilfe <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> und mithilfe der Reflektion für den abgerufenen Typ.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>If this type is complete, for example, if <ph id="ph1">`CreateType`</ph> has been called on this type, but there are nested types that are not complete, then <ph id="ph2">`GetNestedTypes`</ph> will only return those nested types for which <ph id="ph3">`CreateType`</ph> has been called.</source>
          <target state="translated">Wenn dieser Typ abgeschlossen ist, z. B. wenn <ph id="ph1">`CreateType`</ph> für diesen Typ aufgerufen wurde, aber es sind geschachtelte Typen, die nicht abgeschlossen ist, klicken Sie dann <ph id="ph2">`GetNestedTypes`</ph> für die nur die geschachtelten Typen zurück <ph id="ph3">`CreateType`</ph> aufgerufen wurde.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Diese Methode wird für unvollständige Typen nicht implementiert.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, as in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">Hierbei muss es sich um ein Bitflag aus <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> handeln, wie bei <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> usw.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Returns the public and non-public nested types that are declared or inherited by this type.</source>
          <target state="translated">Gibt die öffentlichen und nicht öffentlichen geschachtelten Typen zurück, die von diesem Typ deklariert oder geerbt werden.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing all the types nested within the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, die sämtliche im aktuellen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> geschachtelten Typen darstellen, die den angegebenen Bindungseinschränkungen entsprechen.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if no types are nested within the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, or if none of the nested types match the binding constraints.</source>
          <target state="translated">Ein leeres Array vom Typ <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, wenn im aktuellen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> keine Typen geschachtelt sind oder keiner der geschachtelten Typen den Bindungseinschränkungen entspricht.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Rufen Sie den Typ mithilfe <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> und mithilfe der Reflektion für den abgerufenen Typ.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>If this type is complete, for example, if <ph id="ph1">`CreateType`</ph> has been called on this type, but there are nested types that are not complete, then <ph id="ph2">`GetNestedTypes`</ph> will only return those nested types for which <ph id="ph3">`CreateType`</ph> has been called.</source>
          <target state="translated">Wenn dieser Typ abgeschlossen ist, z. B. wenn <ph id="ph1">`CreateType`</ph> für diesen Typ aufgerufen wurde, aber es sind geschachtelte Typen, die nicht abgeschlossen ist, klicken Sie dann <ph id="ph2">`GetNestedTypes`</ph> für die nur die geschachtelten Typen zurück <ph id="ph3">`CreateType`</ph> aufgerufen wurde.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Diese Methode wird für unvollständige Typen nicht implementiert.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>This invocation attribute.</source>
          <target state="translated">Dieses Aufrufattribut.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> : <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">Hierbei muss es sich um ein Bitflag aus <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> handeln: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> usw.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>Returns all the public and non-public properties declared or inherited by this type, as specified.</source>
          <target state="translated">Gibt alle öffentlichen und nicht öffentlichen Eigenschaften zurück, die gemäß Angabe von diesem Typ deklariert oder geerbt wurden.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see langword="PropertyInfo" /&gt;</ph> objects representing the public and non-public properties defined on this type if <ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph> is used; otherwise, only the public properties are returned.</source>
          <target state="translated">Gibt ein Array von <ph id="ph1">&lt;see langword="PropertyInfo" /&gt;</ph>-Objekten zurück, die die für diesen Typ definierten öffentlichen und nicht öffentlichen Eigenschaften darstellen, wenn <ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph> verwendet wird. Andernfalls werden lediglich die öffentlichen Eigenschaften zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Rufen Sie den Typ mithilfe <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> und mithilfe der Reflektion für den abgerufenen Typ.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Diese Methode wird für unvollständige Typen nicht implementiert.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.GUID">
          <source>Retrieves the GUID of this type.</source>
          <target state="translated">Ruft die GUID dieses Typs ab.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GUID">
          <source>Read-only.</source>
          <target state="translated">Schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GUID">
          <source>Retrieves the GUID of this type</source>
          <target state="translated">Ruft die GUID dieses Typs ab.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GUID">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Rufen Sie den Typ mithilfe <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> und mithilfe der Reflektion für den abgerufenen Typ.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.GUID">
          <source>This method is not currently supported for incomplete types.</source>
          <target state="translated">Diese Methode wird für unvollständige Typen derzeit nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The name of the member to invoke.</source>
          <target state="translated">Der Name des aufzurufenden Members.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This can be a constructor, method, property, or field.</source>
          <target state="translated">Dies kann ein Konstruktor, eine Methode, eine Eigenschaft oder ein Feld sein.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A suitable invocation attribute must be specified.</source>
          <target state="translated">Es muss ein geeignetes Aufrufattribut angegeben werden.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Note that it is possible to invoke the default member of a class by passing an empty string as the name of the member.</source>
          <target state="translated">Beachten Sie, dass es möglich ist, den Standardmember einer Klasse aufzurufen, indem Sie eine leere Zeichenfolge als Name des Members übergeben.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The invocation attribute.</source>
          <target state="translated">Das Attribut für den Aufruf.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This must be a bit flag from <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>.</source>
          <target state="translated">Hierbei muss es sich um ein Bitflag aus <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> handeln.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects using reflection.</source>
          <target state="translated">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph>-Objekten über Reflektion ermöglicht.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If binder is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">Wenn der Binder <ph id="ph1">&lt;see langword="null" /&gt;</ph> ist, wird der Standardbinder verwendet.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>See <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</source>
          <target state="translated">Siehe <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The object on which to invoke the specified member.</source>
          <target state="translated">Das Objekt, für das der angegebene Member aufgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If the member is static, this parameter is ignored.</source>
          <target state="translated">Wenn der Member statisch ist, wird dieser Parameter ignoriert.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An argument list.</source>
          <target state="translated">Eine Argumentliste.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This is an array of Objects that contains the number, order, and type of the parameters of the member to be invoked.</source>
          <target state="translated">Dies ist ein Array von Objekten, das die Anzahl, Reihenfolge und den Typ der Parameter des aufzurufenden Members enthält.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If there are no parameters this should be null.</source>
          <target state="translated">Wenn keine Parameter vorhanden sind, muss dies gleich NULL sein.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array of the same length as <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> with elements that represent the attributes associated with the arguments of the member to be invoked.</source>
          <target state="translated">Ein Array derselben Länge wie <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> mit Elementen, die die Attribute darstellen, die den Argumenten des aufzurufenden Members zugeordnet sind.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A parameter has attributes associated with it in the metadata.</source>
          <target state="translated">Ein Parameter verfügt über Attribute, die ihm in den Metadaten zugeordnet werden.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>They are used by various interoperability services.</source>
          <target state="translated">Sie werden von verschiedenen Interoperabilitätsdiensten verwendet.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>See the metadata specs for more details.</source>
          <target state="translated">Weitere Informationen finden Sie in den Metadatenspezifikationen.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An instance of <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> used to govern the coercion of types.</source>
          <target state="translated">Eine Instanz von <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> für die Steuerung der Umwandlung von Typen.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If this is null, the <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Wenn diese NULL ist, wird die <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> für den aktuellen Thread verwendet.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>(Note that this is necessary to, for example, convert a String that represents 1000 to a Double value, since 1000 is represented differently by different cultures.)</source>
          <target state="translated">(Dies ist z. B. erforderlich, um eine Zeichenfolge, die 1000 darstellt, in einen Double-Wert zu konvertieren, da 1000 in verschiedenen Kulturen unterschiedlich dargestellt wird.)</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Each parameter in the <bpt id="p1">&lt;c&gt;</bpt>namedParameters<ept id="p1">&lt;/c&gt;</ept> array gets the value in the corresponding element in the <bpt id="p2">&lt;c&gt;</bpt>args<ept id="p2">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Jeder Parameter im <bpt id="p1">&lt;c&gt;</bpt>namedParameters<ept id="p1">&lt;/c&gt;</ept>-Array ruft den Wert im entsprechenden Element im <bpt id="p2">&lt;c&gt;</bpt>args<ept id="p2">&lt;/c&gt;</ept>-Array ab.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If the length of <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> is greater than the length of <bpt id="p2">&lt;c&gt;</bpt>namedParameters<ept id="p2">&lt;/c&gt;</ept>, the remaining argument values are passed in order.</source>
          <target state="translated">Wenn die Länge von <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> größer als die Länge von <bpt id="p2">&lt;c&gt;</bpt>namedParameters<ept id="p2">&lt;/c&gt;</ept> ist, werden die restlichen Argumentwerte in der Reihenfolge übergeben.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Invokes the specified member.</source>
          <target state="translated">Ruft den angegebenen Member auf.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the constraints of the specified binder and invocation attributes.</source>
          <target state="translated">Die Methode, die aufgerufen werden soll, muss zugänglich sein und mit der angegebenen Argumentliste unter den Einschränkungen des angegebenen Binders und der Aufrufattribute die spezifischste Übereinstimmung bereitstellen.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Returns the return value of the invoked member.</source>
          <target state="translated">Gibt den Rückgabewert des aufgerufenen Members zurück.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A method will be invoked if the number of parameters in the method declaration equals the number of arguments in the specified argument list, and the type of each argument can be converted by the binder to the type of the parameter.</source>
          <target state="translated">Eine Methode wird aufgerufen, wenn die Anzahl von Parametern in der Deklaration der Methode der Anzahl der Argumente in der angegebenen Argumentliste entspricht und der Typ jedes Arguments vom Binder in den Typ des Parameters konvertiert werden kann.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The binder will find all of the matching methods.</source>
          <target state="translated">Der Binder findet alle übereinstimmenden Methoden.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>These methods are found based on the type of binding requested (BindingFlags.InvokeMethod, BindingFlags.GetProperties, and so on.).</source>
          <target state="translated">Diese Methoden werden basierend auf den Typ der Bindung angeforderte (BindingFlags.InvokeMethod, BindingFlags.GetProperties und So weiter.) gefunden werden.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</source>
          <target state="translated">Der Satz von Methoden wird durch den Namen, Anzahl von Argumenten und einen Satz von Suchabfragen in der Binder definierten gefiltert.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>After the method is selected, it will be invoked.</source>
          <target state="translated">Wenn die Methode ausgewählt wurde, wird sie aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Accessibility is checked at that point.</source>
          <target state="translated">Eingabehilfen ist an diesem Punkt aktiviert.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The search can control which set of methods are searched based upon the accessibility attribute associated with the method.</source>
          <target state="translated">Die Suche kann steuern, welchen Satz von Methoden werden basierend auf der Eingabehilfen-Attribut, das der Methode zugeordnet durchsucht.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The <ph id="ph1">`IBinder.BindToMethod`</ph> method is responsible for selecting the method to be invoked.</source>
          <target state="translated">Die <ph id="ph1">`IBinder.BindToMethod`</ph> Methode ist verantwortlich für die Auswahl der Methode, die aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The default binder selects the most specific match.</source>
          <target state="translated">Der Standardbinder wählt die spezifischste Übereinstimmung.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Access restrictions are ignored for fully trusted code.</source>
          <target state="translated">Zugriffseinschränkungen für vollständig vertrauenswürdige Code ignoriert.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>That is, private constructors, methods, fields, and properties can be accessed and invoked using Reflection whenever the code is fully trusted.</source>
          <target state="translated">D. h. private Konstruktoren, Methoden, Felder und Eigenschaften zugegriffen werden können, und Sie aufgerufen wird, mithilfe von Reflektion im Code vollständig vertrauenswürdig ist.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This method is not currently supported.</source>
          <target state="translated">Diese Methode wird zurzeit nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>You can retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Sie können den Typ mithilfe abrufen <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> und mithilfe der Reflektion für den abgerufenen Typ.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This method is not currently supported for incomplete types.</source>
          <target state="translated">Diese Methode wird für unvollständige Typen derzeit nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Determines whether a specified type can be assigned to this object.</source>
          <target state="translated">Bestimmt, ob ein angegebener Typ diesem Objekt zugewiesen werden kann.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)">
          <source>The object to test.</source>
          <target state="translated">Das zu überprüfende Objekt.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)">
          <source>Gets a value that indicates whether a specified <ph id="ph1">&lt;see cref="T:System.Reflection.TypeInfo" /&gt;</ph> object can be assigned to this object.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob ein angegebenes <ph id="ph1">&lt;see cref="T:System.Reflection.TypeInfo" /&gt;</ph>-Objekt diesem Objekt zugewiesen werden kann.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeInfo" /&gt;</ph> can be assigned to this object; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;paramref name="typeInfo" /&gt;</ph> diesem Objekt zugewiesen werden kann, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
          <source>The object to test.</source>
          <target state="translated">Das zu überprüfende Objekt.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
          <source>Gets a value that indicates whether a specified <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> can be assigned to this object.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob ein angegebener <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> diesem Objekt zugewiesen werden kann</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="c" /&gt;</ph> parameter and the current type represent the same type, or if the current type is in the inheritance hierarchy of <ph id="ph3">&lt;paramref name="c" /&gt;</ph>, or if the current type is an interface that <ph id="ph4">&lt;paramref name="c" /&gt;</ph> supports.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der <ph id="ph2">&lt;paramref name="c" /&gt;</ph>-Parameter und der aktuelle Typ den gleichen Typ darstellen, wenn der aktuelle Typ in der Vererbungshierarchie von  <ph id="ph3">&lt;paramref name="c" /&gt;</ph> enthalten ist oder wenn der aktuelle Typ eine Schnittstelle ist, die von <ph id="ph4">&lt;paramref name="c" /&gt;</ph> unterstützt wird.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if none of these conditions are valid, or if <ph id="ph2">&lt;paramref name="c" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph>, wenn keine dieser Bedingungen gültig sind oder wenn <ph id="ph2">&lt;paramref name="c" /&gt;</ph><ph id="ph3">&lt;see langword="null" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType">
          <source>Gets a value that indicates whether this object represents a constructed generic type.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob dieses Objekt einen konstruierten generischen Typ darstellt.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this object represents a constructed generic type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn dieses Objekt einen konstruierten generischen Typ darstellt, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsCreated">
          <source>Returns a value that indicates whether the current dynamic type has been created.</source>
          <target state="translated">Gibt einen Wert zurück, der angibt, ob der aktuelle dynamische Typ erstellt wurde.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsCreated">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method has been called; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die <ph id="ph2">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>-Methode aufgerufen wurde, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.IsCreated">
          <source>After the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called, the type represented by the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object is complete.</source>
          <target state="translated">Nach der <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> -Methode aufgerufen wurde, den Typ von dargestellt die <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> -Objekts abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.IsCreated">
          <source>Exceptions are thrown on any further attempts to add members or change other characteristics of the type.</source>
          <target state="translated">Ausnahmen werden ausgelöst, auf alle weiteren Versuche, Mitglieder hinzufügen oder ändern andere Eigenschaften des Typs.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>The type of attribute to search for.</source>
          <target state="translated">Der Typ des zu suchenden Attributs.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Only attributes that are assignable to this type are returned.</source>
          <target state="translated">Nur Attribute, die diesem Typ zugeordnet werden können, werden zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Specifies whether to search this member's inheritance chain to find the attributes.</source>
          <target state="translated">Gibt an, ob die Vererbungskette dieses Members nach den Attributen durchsucht werden soll.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Determines whether a custom attribute is applied to the current type.</source>
          <target state="translated">Bestimmt, ob ein benutzerdefiniertes Attribut auf den aktuellen Typ angewendet wird.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if one or more instances of <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph>, or an attribute derived from <ph id="ph3">&lt;paramref name="attributeType" /&gt;</ph>, is defined on this type; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn eine oder mehrere Instanzen von <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph> oder ein von <ph id="ph3">&lt;paramref name="attributeType" /&gt;</ph> abgeleitetes Attribut für diesen Typ definiert ist, andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>This method is not supported for incomplete generic type parameters.</source>
          <target state="translated">Diese Methode wird für unvollständige generische Typparameter nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Rufen Sie den Typ mithilfe <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> und mithilfe der Reflektion für den abgerufenen Typ.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>This method is not currently supported for incomplete types.</source>
          <target state="translated">Diese Methode wird für unvollständige Typen derzeit nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Retrieve the type using <ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Rufen Sie den Typ mithilfe von <ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph> ab, und rufen Sie <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph> für den zurückgegebenen <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> auf.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is not defined.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> ist nicht definiert.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter">
          <source>Gets a value indicating whether the current type is a generic type parameter.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der aktuelle Typ ein generischer Typparameter ist.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object represents a generic type parameter; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn das aktuelle <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>-Objekt einen generischen Typparameter darstellt, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter">
          <source>When emitting code, a generic type parameter is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object rather than by a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">Wenn Code ausgeben, wird durch ein generischen Typparameter dargestellt eine <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> Objekt und keine <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
          <source>Gets a value indicating whether the current type is a generic type.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der aktuelle Typ ein generischer Typ ist.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the type represented by the current <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object is generic; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der durch das aktuelle <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>-Objekt dargestellte Typ generisch ist, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object represents a generic type definition if the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method has been used to give it generic type parameters.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> -Objekt eine generische Typdefinition darstellt, wenn die <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> -Methode wurde verwendet, um generische Typparameter.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class that is generic is always a generic type definition.</source>
          <target state="translated">Eine Instanz von der <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> Klasse, die generisch ist, ist immer eine generische Typdefinition.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
          <source>For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Weitere Informationen zu generischen Typen in der Reflektion und eine Liste der invarianten Bedingungen für Begriffe, die in generischen Reflektion, finden Sie unter der <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> represents a generic type definition from which other generic types can be constructed.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der aktuelle <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> eine generische Typdefinition darstellt, aus der andere generische Typen konstruiert werden können.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object represents a generic type definition; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn dieses <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>-Objekt eine generische Typdefinition darstellt, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object represents a generic type definition if the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method has been used to give it generic type parameters.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> -Objekt eine generische Typdefinition darstellt, wenn die <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> -Methode wurde verwendet, um generische Typparameter.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class that is generic is always a generic type definition.</source>
          <target state="translated">Eine Instanz von der <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> Klasse, die generisch ist, ist immer eine generische Typdefinition.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> can be used to build generic type definitions, but not constructed generic types.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> kann verwendet werden, um generische Typdefinitionen erstellt, aber keine generische Typen konstruiert.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>To get a constructed generic type, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> that represents a generic type definition.</source>
          <target state="translated">Um einen konstruierten generischen Typ zu erhalten, rufen die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> Methode auf eine <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> , die Definition eines generischen Typs darstellt.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Weitere Informationen zu generischen Typen in der Reflektion und eine Liste der invarianten Bedingungen für Begriffe, die in generischen Reflektion, finden Sie unter der <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Gets a value that indicates whether the current type is security-critical or security-safe-critical, and therefore can perform critical operations.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der aktuelle Typ sicherheitsrelevant ist und daher wichtige Vorgänge ausführen darf.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is security-critical or security-safe-critical; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is transparent.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der aktuelle Typ sicherheitsrelevant oder sicherheitsrelevant und sicher zugänglich ist, <ph id="ph2">&lt;see langword="false" /&gt;</ph>, wenn er transparent ist.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type, as determined by the common language runtime (CLR).</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, und <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> Eigenschaften melden die Transparenzebene eines Typs an, wie von der common Language Runtime (CLR) bestimmt.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">In der folgenden Tabelle werden die Kombinationen dieser Eigenschaften gezeigt:</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Security level</source>
          <target state="translated">Sicherheitsstufe</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">Kritisch</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Safe-critical</source>
          <target state="translated">Sicherheitskritisch</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">Transparent</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>The runtime begins evaluating transparency levels at the assembly.</source>
          <target state="translated">Die Common Language Runtime beginnt die Auswertung von Transparenzebenen in der Assembly.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</source>
          <target state="translated">Wenn die dynamische Assembly als sicherheitskritisch ist, z. B. die Anmerkungen auf Typen werden ignoriert, und alle Typen als sicherheitskritisch sind.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>By default, a dynamic assembly inherits the transparency of the assembly that emits it.</source>
          <target state="translated">Standardmäßig erbt eine dynamische Assembly die Transparenz der Assembly, die ihn ausgibt.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>You can override this default by using the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph> method overload and specifying security attributes.</source>
          <target state="translated">Sie können diese Standardeinstellung überschreiben, indem Sie mit der <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, oder <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph> methodenüberladung und Sicherheitsattribute angeben.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</source>
          <target state="translated">Sie können keine Sicherheitsstufen erhöhen, auf diese Weise; Transparenter Code kann nicht, also sicherheitstransparent oder sicherheitsrelevant und sicher zugänglich Code ausgeben.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</source>
          <target state="translated">Attribute müssen angegeben werden, wenn die dynamische Assembly erstellt wird, oder sie wirksam werden, bis die Assembly auf dem Datenträger gespeichert und erneut geladen wurde.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Default inheritance is limited to the runtime's evaluation of transparency.</source>
          <target state="translated">Standard-Vererbung ist auf die Laufzeit Auswertung der Transparenz beschränkt.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>No attributes are applied to the dynamic assembly.</source>
          <target state="translated">Keine Attribute werden auf die dynamische Assembly angewendet werden.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>If you want to add security attributes, you must apply them yourself.</source>
          <target state="translated">Wenn Sie Sicherheitsattribute hinzufügen möchten, müssen Sie sie selbst anwenden.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>For more information about reflection emit and transparency, see <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</source>
          <target state="translated">Weitere Informationen über die Reflektion ausgeben und Transparenz finden Sie unter <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Informationen zur Transparenz finden Sie unter <bpt id="p1">[</bpt>Sicherheitsänderungen<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>The current dynamic type has not been created by calling the <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method.</source>
          <target state="translated">Der aktuelle dynamische Typ wurde nicht erstellt, indem die <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>-Methode aufgerufen wurden.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Gets a value that indicates whether the current type is security-safe-critical; that is, whether it can perform critical operations and can be accessed by transparent code.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der aktuelle Typ sicherheitsgeschützt ist, d. h. ob er wichtige Vorgänge ausführen darf und ob von transparentem Code auf ihn zugegriffen werden kann.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is security-safe-critical; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is security-critical or transparent.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der aktuelle Typ sicherheitsrelevant und sicher zugänglich ist, <ph id="ph2">&lt;see langword="false" /&gt;</ph>, wenn er sicherheitsrelevant oder transparent ist.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type, as determined by the common language runtime (CLR).</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, und <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> Eigenschaften melden die Transparenzebene eines Typs an, wie von der common Language Runtime (CLR) bestimmt.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">In der folgenden Tabelle werden die Kombinationen dieser Eigenschaften gezeigt:</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Security level</source>
          <target state="translated">Sicherheitsstufe</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">Kritisch</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Safe-critical</source>
          <target state="translated">Sicherheitskritisch</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">Transparent</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>The runtime begins evaluating transparency levels at the assembly.</source>
          <target state="translated">Die Common Language Runtime beginnt die Auswertung von Transparenzebenen in der Assembly.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</source>
          <target state="translated">Wenn die dynamische Assembly als sicherheitskritisch ist, z. B. die Anmerkungen auf Typen werden ignoriert, und alle Typen als sicherheitskritisch sind.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>By default, a dynamic assembly inherits the transparency of the assembly that emits it.</source>
          <target state="translated">Standardmäßig erbt eine dynamische Assembly die Transparenz der Assembly, die ihn ausgibt.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>You can override this default by using the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph> method overload and specifying security attributes.</source>
          <target state="translated">Sie können diese Standardeinstellung überschreiben, indem Sie mit der <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, oder <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph> methodenüberladung und Sicherheitsattribute angeben.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</source>
          <target state="translated">Sie können keine Sicherheitsstufen erhöhen, auf diese Weise; Transparenter Code kann nicht, also sicherheitstransparent oder sicherheitsrelevant und sicher zugänglich Code ausgeben.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</source>
          <target state="translated">Attribute müssen angegeben werden, wenn die dynamische Assembly erstellt wird, oder sie wirksam werden, bis die Assembly auf dem Datenträger gespeichert und erneut geladen wurde.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Default inheritance is limited to the runtime's evaluation of transparency.</source>
          <target state="translated">Standard-Vererbung ist auf die Laufzeit Auswertung der Transparenz beschränkt.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>No attributes are applied to the dynamic assembly.</source>
          <target state="translated">Keine Attribute werden auf die dynamische Assembly angewendet werden.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>If you want to add security attributes, you must apply them yourself.</source>
          <target state="translated">Wenn Sie Sicherheitsattribute hinzufügen möchten, müssen Sie sie selbst anwenden.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>For more information about reflection emit and transparency, see <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</source>
          <target state="translated">Weitere Informationen über die Reflektion ausgeben und Transparenz finden Sie unter <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Informationen zur Transparenz finden Sie unter <bpt id="p1">[</bpt>Sicherheitsänderungen<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>The current dynamic type has not been created by calling the <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method.</source>
          <target state="translated">Der aktuelle dynamische Typ wurde nicht erstellt, indem die <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>-Methode aufgerufen wurden.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Gets a value that indicates whether the current type is transparent, and therefore cannot perform critical operations.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der aktuelle Typ transparent ist und daher keine wichtigen Vorgänge ausführen kann.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the type is security-transparent; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der Typ sicherheitstransparent ist, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type, as determined by the common language runtime (CLR).</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, und <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> Eigenschaften melden die Transparenzebene eines Typs an, wie von der common Language Runtime (CLR) bestimmt.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">In der folgenden Tabelle werden die Kombinationen dieser Eigenschaften gezeigt:</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Security level</source>
          <target state="translated">Sicherheitsstufe</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Critical</source>
          <target state="translated">Kritisch</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Safe-critical</source>
          <target state="translated">Sicherheitskritisch</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Transparent</source>
          <target state="translated">Transparent</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>The runtime begins evaluating transparency levels at the assembly.</source>
          <target state="translated">Die Common Language Runtime beginnt die Auswertung von Transparenzebenen in der Assembly.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</source>
          <target state="translated">Wenn die dynamische Assembly als sicherheitskritisch ist, z. B. die Anmerkungen auf Typen werden ignoriert, und alle Typen als sicherheitskritisch sind.</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>By default, a dynamic assembly inherits the transparency of the assembly that emits it.</source>
          <target state="translated">Standardmäßig erbt eine dynamische Assembly die Transparenz der Assembly, die ihn ausgibt.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>You can override this default by using the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph> method overload and specifying security attributes.</source>
          <target state="translated">Sie können diese Standardeinstellung überschreiben, indem Sie mit der <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, oder <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph> methodenüberladung und Sicherheitsattribute angeben.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</source>
          <target state="translated">Sie können keine Sicherheitsstufen erhöhen, auf diese Weise; Transparenter Code kann nicht, also sicherheitstransparent oder sicherheitsrelevant und sicher zugänglich Code ausgeben.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</source>
          <target state="translated">Attribute müssen angegeben werden, wenn die dynamische Assembly erstellt wird, oder sie wirksam werden, bis die Assembly auf dem Datenträger gespeichert und erneut geladen wurde.</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Default inheritance is limited to the runtime's evaluation of transparency.</source>
          <target state="translated">Standard-Vererbung ist auf die Laufzeit Auswertung der Transparenz beschränkt.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>No attributes are applied to the dynamic assembly.</source>
          <target state="translated">Keine Attribute werden auf die dynamische Assembly angewendet werden.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>If you want to add security attributes, you must apply them yourself.</source>
          <target state="translated">Wenn Sie Sicherheitsattribute hinzufügen möchten, müssen Sie sie selbst anwenden.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>For more information about reflection emit and transparency, see <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</source>
          <target state="translated">Weitere Informationen über die Reflektion ausgeben und Transparenz finden Sie unter <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Informationen zur Transparenz finden Sie unter <bpt id="p1">[</bpt>Sicherheitsänderungen<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>The current dynamic type has not been created by calling the <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method.</source>
          <target state="translated">Der aktuelle dynamische Typ wurde nicht erstellt, indem die <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>-Methode aufgerufen wurden.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> that is to be checked.</source>
          <target state="translated">Ein zu überprüfender <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
          <source>Determines whether this type is derived from a specified type.</source>
          <target state="translated">Bestimmt, ob dieser Typ von einem angegebenen Typ abgeleitet ist.</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
          <source>Read-only.</source>
          <target state="translated">Schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if this type is the same as the type <ph id="ph2">&lt;paramref name="c" /&gt;</ph>, or is a subtype of type <ph id="ph3">&lt;paramref name="c" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;see langword="true" /&gt;</ph> zurück, wenn dieser Typ derselbe Typ wie <ph id="ph2">&lt;paramref name="c" /&gt;</ph> oder ein Untertyp von <ph id="ph3">&lt;paramref name="c" /&gt;</ph> ist, andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents an array of the current type.</source>
          <target state="translated">Gibt ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt zurück, das ein Array des aktuellen Typs darstellt.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a one-dimensional array of the current type, with a lower bound of zero.</source>
          <target state="translated">Gibt ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt zurück, das ein eindimensionales Array vom aktuellen Typ mit einer unteren Grenze von 0 (null) darstellt.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing a one-dimensional array type whose element type is the current type, with a lower bound of zero.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt, das einen eindimensionalen Arraytyp, dessen Elementtyp dem aktuellen Typ entspricht, mit einer unteren Grenze von 0 (null) darstellt.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> method provides a way to generate an array type with any possible element type, including generic types.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> Methode bietet eine Möglichkeit, einen Arraytyp mit jedem beliebigen Elementtyp, einschließlich generischer Typen zu generieren.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>The following code example creates a dynamic module, an abstract type named <ph id="ph1">`Sample`</ph>, and an abstract method named <ph id="ph2">`TestMethod`</ph>.</source>
          <target state="translated">Das folgende Codebeispiel erstellt ein dynamisches Modul, ein abstrakter Datentyp mit dem Namen <ph id="ph1">`Sample`</ph>, und eine abstrakte Methode, die mit dem Namen <ph id="ph2">`TestMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source><ph id="ph1">`TestMethod`</ph> takes a <ph id="ph2">`ref`</ph> parameter (<ph id="ph3">`ByRef`</ph> in Visual Basic) of type <ph id="ph4">`Sample`</ph>, a pointer to type <ph id="ph5">`Sample`</ph>, and an array of type <ph id="ph6">`Sample`</ph>.</source>
          <target state="translated"><ph id="ph1">`TestMethod`</ph> akzeptiert eine <ph id="ph2">`ref`</ph> Parameter (<ph id="ph3">`ByRef`</ph> in Visual Basic) vom Typ <ph id="ph4">`Sample`</ph>, ein Zeiger auf den Typ <ph id="ph5">`Sample`</ph>, und ein Array vom Typ <ph id="ph6">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>It returns a two-dimensional array of type <ph id="ph1">`Sample`</ph>.</source>
          <target state="translated">Es gibt ein zweidimensionales Array vom Typ <ph id="ph1">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>The code example saves the dynamic module to disk, so you can examine it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</source>
          <target state="translated">Im Codebeispiel wird das dynamische Modul auf den Datenträger gespeichert, sodass Sie prüfen können, mit der <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>The number of dimensions for the array.</source>
          <target state="translated">Die Anzahl von Dimensionen für das Array.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents an array of the current type, with the specified number of dimensions.</source>
          <target state="translated">Gibt ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt zurück, das ein Array vom aktuellen Typ mit der angegebenen Anzahl von Dimensionen darstellt.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a one-dimensional array of the current type.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt, das ein eindimensionales Array des aktuellen Typs darstellt.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> method provides a way to generate an array type with any possible element type, including generic types.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> Methode bietet eine Möglichkeit, einen Arraytyp mit jedem beliebigen Elementtyp, einschließlich generischer Typen zu generieren.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>The following code example creates a dynamic module, an abstract type named <ph id="ph1">`Sample`</ph>, and an abstract method named <ph id="ph2">`TestMethod`</ph>.</source>
          <target state="translated">Das folgende Codebeispiel erstellt ein dynamisches Modul, ein abstrakter Datentyp mit dem Namen <ph id="ph1">`Sample`</ph>, und eine abstrakte Methode, die mit dem Namen <ph id="ph2">`TestMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source><ph id="ph1">`TestMethod`</ph> takes a <ph id="ph2">`ref`</ph> parameter (<ph id="ph3">`ByRef`</ph> in Visual Basic) of type <ph id="ph4">`Sample`</ph>, a pointer to type <ph id="ph5">`Sample`</ph>, and an array of type <ph id="ph6">`Sample`</ph>.</source>
          <target state="translated"><ph id="ph1">`TestMethod`</ph> akzeptiert eine <ph id="ph2">`ref`</ph> Parameter (<ph id="ph3">`ByRef`</ph> in Visual Basic) vom Typ <ph id="ph4">`Sample`</ph>, ein Zeiger auf den Typ <ph id="ph5">`Sample`</ph>, und ein Array vom Typ <ph id="ph6">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>It returns a two-dimensional array of type <ph id="ph1">`Sample`</ph>.</source>
          <target state="translated">Es gibt ein zweidimensionales Array vom Typ <ph id="ph1">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>The code example saves the dynamic module to disk, so you can examine it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</source>
          <target state="translated">Im Codebeispiel wird das dynamische Modul auf den Datenträger gespeichert, sodass Sie prüfen können, mit der <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> is not a valid array dimension.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> ist keine gültige Arraydimension.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the current type when passed as a <ph id="ph2">&lt;see langword="ref" /&gt;</ph> parameter (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Gibt ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt zurück, das beim Übergeben als <ph id="ph2">&lt;see langword="ref" /&gt;</ph>-Parameter (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic) den aktuellen Typ darstellt.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the current type when passed as a <ph id="ph2">&lt;see langword="ref" /&gt;</ph> parameter (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt, das beim Übergeben als <ph id="ph2">&lt;see langword="ref" /&gt;</ph>-Parameter (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic) den aktuellen Typ darstellt.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A&gt;</ph> method provides a way to generate <ph id="ph2">`ref`</ph> types (<ph id="ph3">`ByRef`</ph> in Visual Basic) for parameter lists.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A&gt;</ph> Methode bietet eine Möglichkeit zum Generieren von <ph id="ph2">`ref`</ph> Typen (<ph id="ph3">`ByRef`</ph> in Visual Basic) für Parameter aufgeführt sind.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>Using Microsoft intermediate language (MSIL) syntax, if the current <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> represents <ph id="ph2">`MyType`</ph>, then the type returned by this method would be <ph id="ph3">`MyType&amp;`</ph>.</source>
          <target state="translated">Mithilfe von Microsoft intermediate Language (MSIL)-Syntax, wenn die aktuelle <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> darstellt <ph id="ph2">`MyType`</ph>, und klicken Sie dann der Typ, der von dieser Methode zurückgegebene wäre <ph id="ph3">`MyType&amp;`</ph>.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>The following code example creates a dynamic module, an abstract type named <ph id="ph1">`Sample`</ph>, and an abstract method named <ph id="ph2">`TestMethod`</ph>.</source>
          <target state="translated">Das folgende Codebeispiel erstellt ein dynamisches Modul, ein abstrakter Datentyp mit dem Namen <ph id="ph1">`Sample`</ph>, und eine abstrakte Methode, die mit dem Namen <ph id="ph2">`TestMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source><ph id="ph1">`TestMethod`</ph> takes a <ph id="ph2">`ref`</ph> parameter (<ph id="ph3">`ByRef`</ph> in Visual Basic) of type <ph id="ph4">`Sample`</ph>, a pointer to type <ph id="ph5">`Sample`</ph>, and an array of type <ph id="ph6">`Sample`</ph>.</source>
          <target state="translated"><ph id="ph1">`TestMethod`</ph> akzeptiert eine <ph id="ph2">`ref`</ph> Parameter (<ph id="ph3">`ByRef`</ph> in Visual Basic) vom Typ <ph id="ph4">`Sample`</ph>, ein Zeiger auf den Typ <ph id="ph5">`Sample`</ph>, und ein Array vom Typ <ph id="ph6">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>It returns a two-dimensional array of type <ph id="ph1">`Sample`</ph>.</source>
          <target state="translated">Es gibt ein zweidimensionales Array vom Typ <ph id="ph1">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>The code example saves the dynamic module to disk, so you can examine it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</source>
          <target state="translated">Im Codebeispiel wird das dynamische Modul auf den Datenträger gespeichert, sodass Sie prüfen können, mit der <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>An array of types to be substituted for the type parameters of the current generic type definition.</source>
          <target state="translated">Ein Array von Typen, die die Typparameter der aktuellen generischen Typdefinition ersetzen sollen.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>Substitutes the elements of an array of types for the type parameters of the current generic type definition, and returns the resulting constructed type.</source>
          <target state="translated">Ersetzt die Typparameter der aktuellen generischen Typdefinition durch die Elemente eines Arrays von Typen und gibt den resultierenden konstruierten Typ zurück.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the constructed type formed by substituting the elements of <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> for the type parameters of the current generic type.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, der den konstruierten Typ darstellt, der durch Ersetzen der Typparameter des aktuellen generischen Typs durch die Elemente von <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> erstellt wurde.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>Use this method when your emitted code requires a type constructed from the current generic type definition.</source>
          <target state="translated">Verwenden Sie diese Methode, wenn Sie den ausgegebene Code aus der Definition des aktuellen generischen Typs erstellter Typ erforderlich ist.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>It is not necessary to call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method before calling the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> that represents a generic type definition.</source>
          <target state="translated">Es ist nicht notwendig, rufen Sie die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> Methode vor dem Aufruf der <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> Methode auf eine <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> , die Definition eines generischen Typs darstellt.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> does not represent the definition of a generic type, an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> stellt nicht die Definition eines generischen Typs dar. ein <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>The object returned by this method functions as a placeholder for a constructed generic type in your emitted code.</source>
          <target state="translated">Das Objekt, das durch diese Methode funktioniert als Platzhalter für einen konstruierten generischen Typ im ausgegebenen Code zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>It is an instance of a class derived from <ph id="ph1">&lt;xref:System.Type&gt;</ph> that has limited capabilities.</source>
          <target state="translated">Dies ist eine Instanz einer Klasse abgeleitet <ph id="ph1">&lt;xref:System.Type&gt;</ph> , dessen Funktionen beschränkt.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>In particular:</source>
          <target state="translated">Insbesondere:</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>To get methods, fields, and constructors for these constructed generic types, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29&gt;</ph> method overloads.</source>
          <target state="translated">Um die Methoden, Felder und Konstruktoren, die für diese generische Typen konstruiert abzurufen, verwenden die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29&gt;</ph>, und <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29&gt;</ph> methodenüberladungen.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>Two instances that represent the same constructed type do not compare as equal.</source>
          <target state="translated">Zwei Instanzen, die den gleichen konstruierten Typ darstellen vergleichen nicht als gleich.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>For example, in the following code <ph id="ph1">`t1.Equals(t2)`</ph> returns <ph id="ph2">`false`</ph>:</source>
          <target state="translated">Im folgenden Code beispielsweise <ph id="ph1">`t1.Equals(t2)`</ph> gibt <ph id="ph2">`false`</ph>:</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>The current type does not represent the definition of a generic type.</source>
          <target state="translated">Der aktuelle Typ stellt keine Definition eines generischen Typs dar.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Das heißt, <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> gibt <ph id="ph2">&lt;see langword="false" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>Any element of <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein beliebiges Element von <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>The <ph id="ph1">&lt;see cref="P:System.Type.Module" /&gt;</ph> property of any element of <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="P:System.Type.Module" /&gt;</ph>-Eigenschaft eines beliebigen Elements von <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> ist <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>The <ph id="ph1">&lt;see cref="P:System.Reflection.Module.Assembly" /&gt;</ph> property of the module of any element of <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="P:System.Reflection.Module.Assembly" /&gt;</ph>-Eigenschaft des Moduls eines beliebigen Elements von <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> ist <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the type of an unmanaged pointer to the current type.</source>
          <target state="translated">Gibt ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt zurück, das den Typ eines nicht verwalteten Zeigers auf den aktuellen Typ darstellt.</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the type of an unmanaged pointer to the current type.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt, das den Typ eines nicht verwalteten Zeigers auf den aktuellen Typ darstellt.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A&gt;</ph> method provides a way to generate pointer types for parameter lists.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A&gt;</ph> Methode bietet eine Möglichkeit zum Generieren von Zeigertypen für Parameterlisten.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>Using Microsoft intermediate language (MSIL) syntax, if the current <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> represents <ph id="ph2">`MyType`</ph>, then the type returned by this method would be <ph id="ph3">`MyType*`</ph>.</source>
          <target state="translated">Mithilfe von Microsoft intermediate Language (MSIL)-Syntax, wenn die aktuelle <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> darstellt <ph id="ph2">`MyType`</ph>, und klicken Sie dann der Typ, der von dieser Methode zurückgegebene wäre <ph id="ph3">`MyType*`</ph>.</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>The following code example creates a dynamic module, an abstract type named <ph id="ph1">`Sample`</ph>, and an abstract method named <ph id="ph2">`TestMethod`</ph>.</source>
          <target state="translated">Das folgende Codebeispiel erstellt ein dynamisches Modul, ein abstrakter Datentyp mit dem Namen <ph id="ph1">`Sample`</ph>, und eine abstrakte Methode, die mit dem Namen <ph id="ph2">`TestMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source><ph id="ph1">`TestMethod`</ph> takes a <ph id="ph2">`ref`</ph> parameter (<ph id="ph3">`ByRef`</ph> in Visual Basic) of type <ph id="ph4">`Sample`</ph>, a pointer to type <ph id="ph5">`Sample`</ph>, and an array of type <ph id="ph6">`Sample`</ph>.</source>
          <target state="translated"><ph id="ph1">`TestMethod`</ph> akzeptiert eine <ph id="ph2">`ref`</ph> Parameter (<ph id="ph3">`ByRef`</ph> in Visual Basic) vom Typ <ph id="ph4">`Sample`</ph>, ein Zeiger auf den Typ <ph id="ph5">`Sample`</ph>, und ein Array vom Typ <ph id="ph6">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>It returns a two-dimensional array of type <ph id="ph1">`Sample`</ph>.</source>
          <target state="translated">Es gibt ein zweidimensionales Array vom Typ <ph id="ph1">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>The code example saves the dynamic module to disk, so you can examine it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</source>
          <target state="translated">Im Codebeispiel wird das dynamische Modul auf den Datenträger gespeichert, sodass Sie prüfen können, mit der <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.Module">
          <source>Retrieves the dynamic module that contains this type definition.</source>
          <target state="translated">Ruft das dynamische Modul ab, das diese Typdefinition enthält.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Module">
          <source>Read-only.</source>
          <target state="translated">Schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Module">
          <source>Retrieves the dynamic module that contains this type definition.</source>
          <target state="translated">Ruft das dynamische Modul ab, das diese Typdefinition enthält.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.Name">
          <source>Retrieves the name of this type.</source>
          <target state="translated">Ruft den Namen dieses Typs ab.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Name">
          <source>Read-only.</source>
          <target state="translated">Schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Name">
          <source>Retrieves the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> name of this type.</source>
          <target state="translated">Ruft den <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Namen dieses Typs ab.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.Namespace">
          <source>Retrieves the namespace where this <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> is defined.</source>
          <target state="translated">Ruft den Namespace ab, in dem dieser <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> definiert ist.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Namespace">
          <source>Read-only.</source>
          <target state="translated">Schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Namespace">
          <source>Retrieves the namespace where this <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> is defined.</source>
          <target state="translated">Ruft den Namespace ab, in dem dieser <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> definiert ist.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.PackingSize">
          <source>Retrieves the packing size of this type.</source>
          <target state="translated">Ruft die Komprimierungsgröße dieses Typs ab.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.PackingSize">
          <source>Read-only.</source>
          <target state="translated">Schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.PackingSize">
          <source>Retrieves the packing size of this type.</source>
          <target state="translated">Ruft die Komprimierungsgröße dieses Typs ab.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.ReflectedType">
          <source>Returns the type that was used to obtain this type.</source>
          <target state="translated">Gibt den Typ zurück, mit dem dieser Typ abgerufen wurde.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.ReflectedType">
          <source>Read-only.</source>
          <target state="translated">Schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.ReflectedType">
          <source>The type that was used to obtain this type.</source>
          <target state="translated">Der Typ, mit dem dieser Typ abgerufen wurde.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Sets a custom attribute.</source>
          <target state="translated">Legt ein benutzerdefiniertes Attribut fest.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>An instance of a helper class to define the custom attribute.</source>
          <target state="translated">Eine Instanz einer Hilfsklasse zum Definieren des benutzerdefinierten Attributs.</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>Set a custom attribute using a custom attribute builder.</source>
          <target state="translated">Legt ein benutzerdefiniertes Attribut mithilfe eines benutzerdefinierten Attribut-Generators fest.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source><ph id="ph1">&lt;paramref name="customBuilder" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="customBuilder" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Für den aktuellen dynamischen Typ ist die <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph>-Eigenschaft <ph id="ph2">&lt;see langword="true" /&gt;</ph>, aber die <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph>-Eigenschaft ist <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The constructor for the custom attribute.</source>
          <target state="translated">Der Konstruktor für das benutzerdefinierte Attribut.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>A byte blob representing the attributes.</source>
          <target state="translated">Ein Byte-BLOB, das die Attribute darstellt.</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>Sets a custom attribute using a specified custom attribute blob.</source>
          <target state="translated">Legt ein benutzerdefiniertes Attribut mithilfe eines angegebenen benutzerdefinierten Attribut-BLOBs fest.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>For more information on how to format <ph id="ph1">`binaryAttribute`</ph>, see the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Weitere Informationen zum Formatieren <ph id="ph1">`binaryAttribute`</ph>, finden Sie in der Dokumentation der Common Language Infrastructure (CLI), insbesondere in "Partition II: Metadata Definition and Semantics".</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. Sie finden sie unter <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> auf der Ecma International-Website.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Member nicht mehr benötigt <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> Flag.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsaspekte bei der Reflektionsausgabe<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="con" /&gt;</ph> or <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="con" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph> ist <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Für den aktuellen dynamischen Typ ist die <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph>-Eigenschaft <ph id="ph2">&lt;see langword="true" /&gt;</ph>, aber die <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph>-Eigenschaft ist <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>The new base type.</source>
          <target state="translated">Der neue Basistyp.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>Sets the base type of the type currently under construction.</source>
          <target state="translated">Legt den Basistyp des Typs fest, der sich derzeit in Bearbeitung befindet.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>If <ph id="ph1">`parent`</ph> is <ph id="ph2">`null`</ph>, <ph id="ph3">&lt;xref:System.Object&gt;</ph> is used as the base type.</source>
          <target state="translated">Wenn <ph id="ph1">`parent`</ph> ist <ph id="ph2">`null`</ph>, <ph id="ph3">&lt;xref:System.Object&gt;</ph> als Basistyp verwendet wird.</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>In the .NET Framework versions 1.0 and 1.1, no exception is thrown if <ph id="ph1">`parent`</ph> is an interface type, but a <ph id="ph2">&lt;xref:System.TypeLoadException&gt;</ph> is thrown when the <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method is called.</source>
          <target state="translated">In der .NET Framework-Versionen 1.0 und 1.1, wird keine Ausnahme ausgelöst, wenn <ph id="ph1">`parent`</ph> ein Schnittstellentyp ist jedoch ein <ph id="ph2">&lt;xref:System.TypeLoadException&gt;</ph> wird ausgelöst, wenn die <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> -Methode aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.SetParent%2A&gt;</ph> method does not check for most invalid parent types.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.SetParent%2A&gt;</ph> Methode überprüft nicht für die meisten Ungültiger übergeordneter Typen.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>For example, it does not reject a parent type that has no default constructor when the current type has a default constructor, it does not reject sealed types, and it does not reject the <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> type.</source>
          <target state="translated">Angenommen, sie lehnt keinen übergeordneter Typ, der über keinen Standardkonstruktor verfügt, wenn der aktuelle Typ verfügt über einen Standardkonstruktor und nicht versiegelte Typen lehnt nicht lehnt die <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> Typ.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>In all these cases, exceptions are thrown by the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method.</source>
          <target state="translated">In all diesen Fällen-Ausnahmen werden ausgelöst, durch die <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Der Typ wurde zuvor mit <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source><ph id="ph1">&lt;paramref name="parent" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the current instance represents an interface whose attributes do not include <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.Abstract" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parent" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und die aktuelle Instanz stellt eine Schnittstelle dar, deren Attribute <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.Abstract" /&gt;</ph> nicht einbeziehen.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Für den aktuellen dynamischen Typ ist die <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph>-Eigenschaft <ph id="ph2">&lt;see langword="true" /&gt;</ph>, aber die <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph>-Eigenschaft ist <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source><ph id="ph1">&lt;paramref name="parent" /&gt;</ph> is an interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parent" /&gt;</ph> ist eine Schnittstelle.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>This exception condition is new in the .NET Framework version 2.0.</source>
          <target state="translated">Diese Ausnahmebedingung ist neu in .NET Framework, Version 2.0.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.Size">
          <source>Retrieves the total size of a type.</source>
          <target state="translated">Ruft die Gesamtgröße eines Typs ab.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Size">
          <source>Read-only.</source>
          <target state="translated">Schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Size">
          <source>Retrieves this type’s total size.</source>
          <target state="translated">Ruft die Gesamtgröße dieses Typs ab.</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Für zukünftige Verwendung reserviert.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Muss IID_NULL sein.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Das übergebene Array von zuzuordnenden Namen.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Die Anzahl der zuzuordnenden Namen.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">Der Gebietsschemakontext, in dem die Namen interpretiert werden sollen.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">Das vom Aufrufer zugewiesene Array, das die IDs entsprechend den Namen empfängt.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Ordnet eine Reihe von Namen einer entsprechenden Reihe von Dispatchbezeichnern zu.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Weitere Informationen zu <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, finden Sie in der MSDN Library.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Spät gebundener Zugriff mithilfe der <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept>-Schnittstelle in COM wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">Die zurückzugebenden Typinformationen.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">Der Gebietsschemabezeichner für die Typinformationen.</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Empfängt einen Zeiger auf das angeforderte Objekt mit den Typinformationen.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Ruft die Typinformationen für ein Objekt ab, die dann zum Abrufen der Typinformationen für eine Schnittstelle verwendet werden können.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Weitere Informationen zu <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, finden Sie in der MSDN Library.</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Spät gebundener Zugriff mithilfe der <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept>-Schnittstelle in COM wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Zeigt auf einen Speicherort, der die Anzahl der Schnittstellen mit Typinformationen empfängt, die vom Objekt bereitgestellt werden.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Ruft die Anzahl der Schnittstellen mit Typinformationen ab, die von einem Objekt bereitgestellt werden (0 oder 1).</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Weitere Informationen zu <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, finden Sie in der MSDN Library.</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Spät gebundener Zugriff mithilfe der <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept>-Schnittstelle in COM wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Bezeichnet den Member.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Für zukünftige Verwendung reserviert.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Muss IID_NULL sein.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">Der Gebietsschemakontext, in dem Argumente interpretiert werden sollen.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Flags, die den Kontext des Aufrufs beschreiben.</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Ein Zeiger auf eine Struktur, die ein Array von Argumenten und ein Array von Argument-DISPIDs für benannte Argumente sowie Zähler für die Anzahl der Elemente in jedem Array enthält.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Ein Verweis auf den Speicherort, an dem das Ergebnis gespeichert werden soll.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Ein Zeiger auf eine Struktur mit Ausnahmeinformationen.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">Der Index des ersten Arguments mit einem Fehler.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Stellt den Zugriff auf von einem Objekt verfügbar gemachte Eigenschaften und Methoden bereit.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Weitere Informationen zu <ph id="ph1">`IDispatch::Invoke`</ph>, finden Sie in der MSDN Library.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Spät gebundener Zugriff mithilfe der <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept>-Schnittstelle in COM wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.ToString">
          <source>Returns the name of the type excluding the namespace.</source>
          <target state="translated">Gibt den Namen des Typs ohne den Namespace zurück.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.ToString">
          <source>Read-only.</source>
          <target state="translated">Schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.ToString">
          <source>The name of the type excluding the namespace.</source>
          <target state="translated">Der Name des Typs ohne den Namespace.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
          <source>Not supported in dynamic modules.</source>
          <target state="translated">Wird in dynamischen Modulen nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
          <source>Read-only.</source>
          <target state="translated">Schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Rufen Sie den Typ mithilfe <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> und mithilfe der Reflektion für den abgerufenen Typ.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
          <source>Not supported in dynamic modules.</source>
          <target state="translated">Wird in dynamischen Modulen nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.TypeToken">
          <source>Returns the type token of this type.</source>
          <target state="translated">Gibt das Typtoken dieses Typs zurück.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.TypeToken">
          <source>Read-only.</source>
          <target state="translated">Schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.TypeToken">
          <source>Returns the <ph id="ph1">&lt;see langword="TypeToken" /&gt;</ph> of this type.</source>
          <target state="translated">Gibt das <ph id="ph1">&lt;see langword="TypeToken" /&gt;</ph> dieses Typs zurück.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.TypeToken">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Der Typ wurde zuvor mit <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
          <source>Returns the underlying system type for this <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>.</source>
          <target state="translated">Gibt den zugrunde liegenden Systemtyp für diesen <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
          <source>Read-only.</source>
          <target state="translated">Schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
          <source>Returns the underlying system type.</source>
          <target state="translated">Gibt den zugrunde liegenden Systemtyp zurück.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
          <source>This type is an enumeration, but there is no underlying system type.</source>
          <target state="translated">Dieser Typ ist eine Enumeration, aber es ist kein zugrunde liegender Systemtyp vorhanden.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize">
          <source>Represents that total size for the type is not specified.</source>
          <target state="translated">Stellt dar, dass die Gesamtgröße für den Typ nicht angegeben ist.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>