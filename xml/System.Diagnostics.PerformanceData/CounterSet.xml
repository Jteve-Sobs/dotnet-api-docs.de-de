<Type Name="CounterSet" FullName="System.Diagnostics.PerformanceData.CounterSet">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="28db19b296edf4b25db2105c1fa9c49c7103a8a1" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30398184" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class CounterSet : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit CounterSet extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.PerformanceData.CounterSet" />
  <TypeSignature Language="VB.NET" Value="Public Class CounterSet&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class CounterSet : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Definiert einen Satz logischer Indikatoren.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.Diagnostics.PerformanceData.CounterSet.Dispose%2A> Methode, wenn Sie fertig sind, um die Registrierung des Anbieters zu entfernen und alle freizugeben sind verwaltete und nicht verwalteten Ressourcen.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Diagnostics.PerformanceData>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CounterSet (Guid providerGuid, Guid counterSetGuid, System.Diagnostics.PerformanceData.CounterSetInstanceType instanceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Guid providerGuid, valuetype System.Guid counterSetGuid, valuetype System.Diagnostics.PerformanceData.CounterSetInstanceType instanceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceData.CounterSet.#ctor(System.Guid,System.Guid,System.Diagnostics.PerformanceData.CounterSetInstanceType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (providerGuid As Guid, counterSetGuid As Guid, instanceType As CounterSetInstanceType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CounterSet(Guid providerGuid, Guid counterSetGuid, System::Diagnostics::PerformanceData::CounterSetInstanceType instanceType);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="providerGuid" Type="System.Guid" />
        <Parameter Name="counterSetGuid" Type="System.Guid" />
        <Parameter Name="instanceType" Type="System.Diagnostics.PerformanceData.CounterSetInstanceType" />
      </Parameters>
      <Docs>
        <param name="providerGuid">Eine GUID, die den Anbieter der Indikatordaten eindeutig identifiziert. Verwenden Sie die im Manifest angegebene GUID.</param>
        <param name="counterSetGuid">Eine GUID, die den Indikatorensatz für einen Anbieter eindeutig identifiziert. Verwenden Sie die im Manifest angegebene GUID.</param>
        <param name="instanceType">Identifiziert den Typ des Indikatorensatzes, beispielsweise, ob es sich um einen Indikatorensatz mit einer einzigen oder mit mehreren Instanzen handelt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.PerformanceData.CounterSet" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Registriert den Anbieter. Aufrufen der <xref:System.Diagnostics.PerformanceData.CounterSet.Dispose%2A> Methode entfernt die Registrierung.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Diagnostics.PerformanceData>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InsufficientMemoryException">Es ist nicht genügend Arbeitsspeicher verfügbar, um den Vorgang abzuschließen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Wird in Versionen vor Windows Vista nicht unterstützt.</exception>
        <exception cref="T:System.ArgumentException">Einer der Parameter ist NULL oder nicht gültig.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Fehler bei einem zugrunde liegenden Win32-Funktionsaufruf.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddCounter">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt dem Indikatorensatz einen Indikator hinzu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddCounter">
      <MemberSignature Language="C#" Value="public void AddCounter (int counterId, System.Diagnostics.PerformanceData.CounterType counterType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCounter(int32 counterId, valuetype System.Diagnostics.PerformanceData.CounterType counterType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceData.CounterSet.AddCounter(System.Int32,System.Diagnostics.PerformanceData.CounterType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCounter(int counterId, System::Diagnostics::PerformanceData::CounterType counterType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="counterId" Type="System.Int32" />
        <Parameter Name="counterType" Type="System.Diagnostics.PerformanceData.CounterType" />
      </Parameters>
      <Docs>
        <param name="counterId">Identifiziert den Indikator. Verwenden Sie denselben Wert, den Sie im Manifest verwendet haben, um den Indikator zu definieren.</param>
        <param name="counterType">Identifiziert den Indikatortyp. Der Indikatortyp bestimmt, wie die Indikatordaten berechnet werden, wie ihr Durchschnittswert ermittelt wird und wie sie angezeigt werden.</param>
        <summary>Fügt dem Indikatorensatz unter Verwendung des angegebenen Indikatorbezeichners und -typs einen Indikator hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen dem Indikatorensatz Indikatoren hinzufügen, bevor Sie eine Instanz des Indikatorensatzes erstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Indikatorbezeichner ist bereits im Satz vorhanden oder ist negativ, oder der Indikatortyp ist NULL oder nicht gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Sie können dem Indikatorensatz keine Indikatoren hinzufügen, nachdem Sie eine Instanz des Indikatorensatzes erstellt haben.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddCounter">
      <MemberSignature Language="C#" Value="public void AddCounter (int counterId, System.Diagnostics.PerformanceData.CounterType counterType, string counterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCounter(int32 counterId, valuetype System.Diagnostics.PerformanceData.CounterType counterType, string counterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceData.CounterSet.AddCounter(System.Int32,System.Diagnostics.PerformanceData.CounterType,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCounter(int counterId, System::Diagnostics::PerformanceData::CounterType counterType, System::String ^ counterName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="counterId" Type="System.Int32" />
        <Parameter Name="counterType" Type="System.Diagnostics.PerformanceData.CounterType" />
        <Parameter Name="counterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="counterId">Identifiziert den Indikator. Verwenden Sie denselben Wert, den Sie im Manifest verwendet haben, um den Indikator zu definieren.</param>
        <param name="counterType">Identifiziert den Indikatortyp. Der Indikatortyp bestimmt, wie die Indikatordaten berechnet werden, wie ihr Durchschnittswert ermittelt wird und wie sie angezeigt werden.</param>
        <param name="counterName">Der Name des Indikators. Sie können diesen Namen verwenden, um den Indikator in der Instanz des Indikatorensatzes zu indizieren. (Siehe <see cref="P:System.Diagnostics.PerformanceData.CounterSetInstanceCounterDataSet.Item(System.String)" />.)</param>
        <summary>Fügt dem Indikatorensatz unter Verwendung des angegebenen Indikatorbezeichners, -typs und Anzeigenamens für den Indikator einen Indikator hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen dem Indikatorensatz Indikatoren hinzufügen, bevor Sie eine Instanz des Indikatorensatzes erstellen.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Diagnostics.PerformanceData>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Indikatorbezeichner ist bereits im Satz vorhanden oder ist negativ, oder der Indikatortyp ist NULL oder nicht gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Sie können dem Indikatorensatz keine Indikatoren hinzufügen, nachdem Sie eine Instanz des Indikatorensatzes erstellt haben.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateCounterSetInstance">
      <MemberSignature Language="C#" Value="public System.Diagnostics.PerformanceData.CounterSetInstance CreateCounterSetInstance (string instanceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.PerformanceData.CounterSetInstance CreateCounterSetInstance(string instanceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceData.CounterSet.CreateCounterSetInstance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCounterSetInstance (instanceName As String) As CounterSetInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::PerformanceData::CounterSetInstance ^ CreateCounterSetInstance(System::String ^ instanceName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceData.CounterSetInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="instanceName">Der Name der Instanz. Der Name muss eindeutig sein.</param>
        <summary>Erstellt eine Instanz des Indikatorensatzes.</summary>
        <returns>Eine Instanz des Indikatorensatzes, die die Indikatordaten enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode einmal für Einzelinstanz-Indikatorensätze und eine oder mehrere Male für Indikatorensätze mit mehreren Instanzen.  
  
 Der Anbieter bestimmt, wenn er eine Instanz erstellt. Wenn die Leistungsindikatordaten mehr statisch ist, kann der Anbieter eine Instanz bei der Initialisierung des erstellen. Z. B. die Anzahl der Prozessoren auf einem Computer statisch ausgedehnte damit ein Anbieters, das Leistungsindikatordaten für Prozessoren bereitstellt, eine Instanz für jeden Prozessor auf dem Computer bei der Initialisierung des erstellen konnte. Leistungsindikatoren, die dynamischerer, z. B. Datenträger oder Verarbeiten von Leistungsindikatoren, würden die Anbieter die neuen Instanzen als Antwort auf ein neues USB-Gerät hinzugefügt wird oder ein neuer Prozess erstellt wird erstellen.  
  
 Der Anbieter sollte den Zähler beibehalten, die Daten auf dem neuesten Stand durchgehend.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Diagnostics.PerformanceData>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Instanzname ist NULL.</exception>
        <exception cref="T:System.InvalidOperationException">Sie müssen dem Indikatorensatz Indikatoren hinzufügen, bevor Sie eine Instanz des Indikatorensatzes erstellen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die von diesem Objekt verwendeten Ressourcen frei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceData.CounterSet.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von diesem Objekt verwendeten nicht verwalteten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceData.CounterSet.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="True" />, wenn diese Methode über die Dispose-Methode aufgerufen wurde, andernfalls <see langword="False" />.</param>
        <summary>Gibt alle von diesem Objekt verwendeten, nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~CounterSet ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceData.CounterSet.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!CounterSet ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt Ressourcen frei, bevor das Objekt durch die Garbage Collection freigegeben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird automatisch von der Laufzeit aufgerufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>