<Type Name="InputBinding" FullName="System.Windows.Input.InputBinding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="afed80ac748380a5fef227ddfb0f18272d0bef07" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53483744" /></Metadata><TypeSignature Language="C#" Value="public class InputBinding : System.Windows.Freezable, System.Windows.Input.ICommandSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit InputBinding extends System.Windows.Freezable implements class System.Windows.Input.ICommandSource" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.InputBinding" />
  <TypeSignature Language="VB.NET" Value="Public Class InputBinding&#xA;Inherits Freezable&#xA;Implements ICommandSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class InputBinding : System::Windows::Freezable, System::Windows::Input::ICommandSource" />
  <TypeSignature Language="F#" Value="type InputBinding = class&#xA;    inherit Freezable&#xA;    interface ICommandSource" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Freezable</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-3.0">System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Input.ICommandSource</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt eine Bindung zwischen einer <see cref="T:System.Windows.Input.InputGesture" /> und einem Befehl dar. Der Befehl ist potenziell ein <see cref="T:System.Windows.Input.RoutedCommand" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können angeben, dass die Eingabe des Benutzers einen Befehl aufruft, durch das Erstellen einer <xref:System.Windows.Input.InputBinding>. Wenn der Benutzer die angegebene Eingabe ausführt der <xref:System.Windows.Input.ICommand> , festgelegt ist, um die <xref:System.Windows.Input.InputBinding.Command%2A> Eigenschaft ausgeführt wird.  
  
 Sie können angeben, die <xref:System.Windows.Input.InputBinding> Ruft einen Befehl aus, die für ein Objekt definiert ist, durch das Erstellen einer Bindung auf den <xref:System.Windows.Input.InputBinding.Command%2A>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A>, und <xref:System.Windows.Input.InputBinding.CommandTarget%2A> Eigenschaften. Dadurch können Sie definieren einen benutzerdefinierten Befehl und Benutzereingaben zuordnen. Weitere Informationen finden Sie in das zweite Beispiel im Abschnitt "Beispiele".  
  
 Ein <xref:System.Windows.Input.InputBinding> kann auf ein bestimmtes Objekt oder auf Klassenebene definiert werden, durch die Registrierung einer <xref:System.Windows.Input.CommandManager.RegisterClassInputBinding%2A> mit der <xref:System.Windows.Input.CommandManager>.  
  
 Die <xref:System.Windows.Input.InputBinding> Klasse selbst unterstützt keine XAML-Verwendung, weil sie keinen öffentlichen Standardkonstruktor verfügbar macht (es ist ein Standardkonstruktor, aber es geschützt ist). Jedoch abgeleitete Klassen einen öffentlichen Konstruktor verfügbar machen, und aus diesem Grund können Eigenschaften festlegen, für die abgeleitete Klasse, die von übernommenen <xref:System.Windows.Input.InputBinding> mit einer XAML-Verwendung. Zwei vorhandene <xref:System.Windows.Input.InputBinding>-abgeleitete Klassen, die in XAML instanziiert werden und die Eigenschaften in XAML festlegen können, sind <xref:System.Windows.Input.KeyBinding> und <xref:System.Windows.Input.MouseBinding>. Die Eigenschaft in der [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] programmieren, legen Sie im XAML und übernimmt eine oder mehrere <xref:System.Windows.Input.InputBinding> Objekte als Werte der <xref:System.Windows.UIElement.InputBindings%2A?displayProperty=nameWithType> Eigenschaft.  
  
<a name="xamlObjectElementUsage_InputBinding"></a>   
## <a name="xaml-object-element-usage"></a>Verwendung von XAML-Objektelementen  
 \<*inputBindingDerivedClass…/*>  
  
<a name="xamlValues_InputBinding"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 `inputBindingDerivedClass`  
 Eine abgeleitete Klasse von <xref:System.Windows.Input.InputBinding> , unterstützt die Objektelementsyntax, z. B. <xref:System.Windows.Input.KeyBinding> oder <xref:System.Windows.Input.MouseBinding>. Siehe Hinweise.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit einer <xref:System.Windows.Input.KeyBinding> binden ein <xref:System.Windows.Input.KeyGesture> auf die <xref:System.Windows.Input.ApplicationCommands.Open%2A> Befehl. Wenn die Tastenkombination ausgeführt wird, wird der Befehl zum Öffnen aufgerufen.  
  
 [!code-xaml[commandingoverviewsnippets#CommandingOverviewXAMLKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewxamlkeybinding)]  
  
 Die folgenden Beispiele zeigen, wie Sie einen benutzerdefinierten Befehl zu binden <xref:System.Windows.Input.InputBinding> Objekte. Diese Beispiele erstellen Sie eine Anwendung, die dem Benutzer ermöglicht, die die Hintergrundfarbe ändern, indem Sie eine der folgenden Aktionen ausführen:  
  
-   Klicken Sie auf eine Schaltfläche.  
  
-   STRG + C drücken.  
  
-   Mit der rechten Maustaste ein <xref:System.Windows.Controls.StackPanel> (außerhalb der <xref:System.Windows.Controls.ListBox>).  
  
 Im erste Beispiel wird eine Klasse namens `SimpleDelegateCommand`. Diese Klasse akzeptieren einen Delegaten, sodass das Objekt, das den Befehl erstellt die Aktion definieren kann, die auftritt, wenn der Befehl ausgeführt wird. `SimpleDelegateCommand` definiert außerdem Eigenschaften, die angeben, welche Taste, und bewegen Sie den Mauszeiger Eingabe Ruft den Befehl. `GestureKey` und `GestureModifier` Geben Sie die Tastatureingaben; `MouseGesture` gibt an, die Mauseingabe.  
  
 [!code-csharp[InputCommandBinding#DelegateCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/inputcommandbinding/csharp/mainwindow.xaml.cs#delegatecommand)]
 [!code-vb[InputCommandBinding#DelegateCommand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/inputcommandbinding/visualbasic/mainwindow.xaml.vb#delegatecommand)]  
  
 Das folgende Beispiel erstellt und initialisiert die `ColorChangeCommand`, d.h. eine `SimpleDelegateCommand`. Im Beispiel definiert auch die Methode, die ausgeführt wird, wenn der Befehl aufgerufen wird, und legt die `GestureKey`, `GestureModifier`, und `MouseGesture` Eigenschaften. Eine Anwendung aufrufen würde die `InitializeCommand` Methode, wenn das Programm beginnt, z. B. in den Konstruktor des eine <xref:System.Windows.Window>.  
  
 [!code-csharp[InputCommandBinding#InitializeCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/inputcommandbinding/csharp/mainwindow.xaml.cs#initializecommand)]
 [!code-vb[InputCommandBinding#InitializeCommand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/inputcommandbinding/visualbasic/mainwindow.xaml.vb#initializecommand)]  
  
 Im folgende Beispiel wird schließlich die Benutzeroberfläche erstellt. Im Beispiel wird eine <xref:System.Windows.Input.KeyBinding> und ein <xref:System.Windows.Input.MouseBinding> auf eine <xref:System.Windows.Controls.StackPanel> , enthält eine <xref:System.Windows.Controls.Button> und <xref:System.Windows.Controls.ListBox>. Wenn der Benutzer wählt ein Element in der <xref:System.Windows.Controls.ListBox>, er oder sie können die Farbe des Hintergrunds ändern, mit der ausgewählten Farbe. In jedem Fall die `CommandParameter` Eigenschaft gebunden ist, um das ausgewählte Element in der <xref:System.Windows.Controls.ListBox>, und die `Command` Eigenschaft gebunden ist die `ColorChangeCommand`. Die <xref:System.Windows.Input.KeyBinding.Key%2A?displayProperty=nameWithType>, <xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType>, und <xref:System.Windows.Input.MouseBinding.MouseAction%2A?displayProperty=nameWithType> Eigenschaften in den entsprechenden Eigenschaften gebunden sind, auf die `SimpleDelegateCommand` Klasse.  
  
 [!code-xaml[InputCommandBinding#UI](~/samples/snippets/csharp/VS_Snippets_Wpf/inputcommandbinding/csharp/mainwindow.xaml#ui)]  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.UIElement.InputBindings" />
    <altmember cref="T:System.Windows.Input.CommandBinding" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Input.InputBinding" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected InputBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; InputBinding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Stellt die Basisinitialisierung für von <see cref="T:System.Windows.Input.InputBinding" /> abgeleitete Klassen bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.InputBinding> Technisch gesehen eine abstrakte Klasse ist, aber der Standardkonstruktor wird absichtlich Zugriff geschützt. Dies wirkt sich die machen <xref:System.Windows.Input.InputBinding> eine "abstrakte" Klasse für XAML. Vorhandene Eigenschaften in [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] , deren XAML-Verwendungen, die Objekte des Typs erwarten <xref:System.Windows.Input.InputBinding>, aber Sie nicht angeben, ein <xref:System.Windows.Input.InputBinding> -Instanz in XAML. Stattdessen können Sie angeben eines gerätespezifischen <xref:System.Windows.Input.InputBinding> abgeleiteten Klassen als Werte, z. B. <xref:System.Windows.Input.KeyBinding> oder <xref:System.Windows.Input.MouseBinding>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie eine benutzerdefinierte implementieren <see cref="T:System.Windows.Input.InputBinding" /> , das eine XAML-Verwendung unterstützt, verwenden Sie diesen Konstruktor für die Basis-Initialisierung.</para></block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InputBinding (System.Windows.Input.ICommand command, System.Windows.Input.InputGesture gesture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Input.ICommand command, class System.Windows.Input.InputGesture gesture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.#ctor(System.Windows.Input.ICommand,System.Windows.Input.InputGesture)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (command As ICommand, gesture As InputGesture)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InputBinding(System::Windows::Input::ICommand ^ command, System::Windows::Input::InputGesture ^ gesture);" />
      <MemberSignature Language="F#" Value="new System.Windows.Input.InputBinding : System.Windows.Input.ICommand * System.Windows.Input.InputGesture -&gt; System.Windows.Input.InputBinding" Usage="new System.Windows.Input.InputBinding (command, gesture)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="command" Type="System.Windows.Input.ICommand" />
        <Parameter Name="gesture" Type="System.Windows.Input.InputGesture" />
      </Parameters>
      <Docs>
        <param name="command">Der Befehl, der <paramref name="gesture" /> zugeordnet werden soll.</param>
        <param name="gesture">Die Eingabegeste, die <paramref name="command" /> zugeordnet werden soll.</param>
        <summary>Initialisiert mit dem angegebenen Befehl und der Eingabestiftbewegung eine neue Instanz der <see cref="T:System.Windows.Input.InputBinding" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie eine vorhandene Eingabe Bindungsklassen mit Softwareentwickler sind, in der Regel verwenden nicht diesen Konstruktor, Sie auch, wenn Sie benutzerdefinierte Befehle definieren. Stattdessen verwenden Sie entweder Konstruktoren von abgeleiteten Klassen (<xref:System.Windows.Input.KeyBinding> und <xref:System.Windows.Input.MouseBinding>), oder verwenden Sie diesen Konstruktor als die Basis Instanziierung einer benutzerdefinierten Klasse. Obwohl die <xref:System.Windows.Input.InputBinding> Klasse unterstützt verschiedene Eingabegeräte im Prinzip in der Praxis müssen Sie auswählen, welches Gerät die eingabebindung darstellt. Nur lassen sich nur ein <xref:System.Windows.Input.InputBinding.Gesture%2A> Wert für die eingabebindung und Gesten sind gerätespezifisch.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie diesen Konstruktor verwenden, um das Zuordnen einer <xref:System.Windows.Input.KeyGesture> mit einem <xref:System.Windows.Input.RoutedCommand>.  
  
 [!code-csharp[commandlibrarysnippets#InputBindingAddingComand](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml.cs#inputbindingaddingcomand)]
 [!code-vb[commandlibrarysnippets#InputBindingAddingComand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandLibrarySnippets/visualbasic/window1.xaml.vb#inputbindingaddingcomand)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="command" /> oder <paramref name="gesture" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected override void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Das zu klonende Objekt.</param>
        <summary>Kopiert die Basiswerte (nicht animiert) der Eigenschaften des angegebenen Objekts.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Das zu klonende Objekt.</param>
        <summary>Kopiert die aktuellen Werte der Eigenschaften des angegebenen Objekts.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Command">
      <MemberSignature Language="C#" Value="public System.Windows.Input.ICommand Command { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.ICommand Command" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.Command" />
      <MemberSignature Language="VB.NET" Value="Public Property Command As ICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::ICommand ^ Command { System::Windows::Input::ICommand ^ get(); void set(System::Windows::Input::ICommand ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Command : System.Windows.Input.ICommand with get, set" Usage="System.Windows.Input.InputBinding.Command" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Input.CommandConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.ICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die dieser Eingabebindung zugeordnete <see cref="T:System.Windows.Input.ICommand" />-Klasse ab oder legt diese fest.</summary>
        <value>Der verknüpfte Befehl.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Input.InputBinding> Klasse unterstützt keine XAML-Verwendung, weil sie keinen öffentlichen Standardkonstruktor verfügbar macht (er verfügt über einen Standardkonstruktor, aber es geschützt ist). Jedoch abgeleitete Klassen einen öffentlichen Konstruktor verfügbar machen, und aus diesem Grund können Eigenschaften, die von übernommenen <xref:System.Windows.Input.InputBinding>. Zwei vorhandene <xref:System.Windows.Input.InputBinding> abgeleitete Klassen, die in XAML instanziiert werden und die Eigenschaften in XAML-Verwendungen festlegen können, sind <xref:System.Windows.Input.KeyBinding> und <xref:System.Windows.Input.MouseBinding>.  
  
 <xref:System.Windows.Input.ICommand> verweist auf einen Typkonverter, die bestimmte bereits vorhandene ermöglicht <xref:System.Windows.Input.ICommand> Implementierungen, um Werte in Form einer Zeichenfolge anzugeben. Diese Typkonvertierungsverhalten legt fest, der Form der Attribut-Wert dieser Eigenschaft. Sie können auch eine Bindung die <xref:System.Windows.Input.InputBinding.Command%2A>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A>, und <xref:System.Windows.Input.InputBinding.CommandTarget%2A> Eigenschaften, die eine <xref:System.Windows.Input.ICommand> , die für ein Objekt definiert ist. Dadurch können Sie definieren einen benutzerdefinierten Befehl und Benutzereingaben zuordnen. Weitere Informationen finden Sie im zweite Beispiel in <xref:System.Windows.Input.InputBinding>.  
  
<a name="xamlAttributeUsage_Command"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
 <`inputBindingDerivedClass` `Command`="<xref:System.Windows.Input.ICommand>"/>  
  
<a name="xamlPropertyElementUsage_Command"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<inputBindingDerivedClass>  
  <inputBindingDerivedClass.Command>  
    <iCommandImplementation/>  
  </inputBindingDerivedClass.Command>  
</inputBindingDerivedClass>  
```  
  
<a name="xamlValues_Command"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 `inputBindingDerivedClass`  
 Eine abgeleitete Klasse von <xref:System.Windows.Input.InputBinding> , unterstützt die Objektelementsyntax, z. B. <xref:System.Windows.Input.KeyBinding> oder <xref:System.Windows.Input.MouseBinding>. Siehe Hinweise.  
  
 `iCommandImplementation`  
 Eine objektimplementierung von <xref:System.Windows.Input.ICommand> , das Objektelement-Syntax unterstützt (verfügt über einen öffentlichen Standardkonstruktor).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit einer <xref:System.Windows.Input.KeyBinding> binden ein <xref:System.Windows.Input.KeyGesture> auf die <xref:System.Windows.Input.ApplicationCommands.Open%2A?displayProperty=nameWithType> Befehl. Wenn die Tastenkombination ausgeführt wird, wird der Befehl zum Öffnen aufgerufen.  
  
 [!code-xaml[commandingoverviewsnippets#CommandingOverviewXAMLKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewxamlkeybinding)]  
  
 [!code-csharp[commandingoverviewsnippets#CommandingOverviewKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewkeybinding)]
 [!code-vb[commandingoverviewsnippets#CommandingOverviewKeyBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewkeybinding)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <see cref="P:System.Windows.Input.InputBinding.Command" />-Wert ist <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.InputGesture" />
      </Docs>
    </Member>
    <Member MemberName="CommandParameter">
      <MemberSignature Language="C#" Value="public object CommandParameter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object CommandParameter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.CommandParameter" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandParameter As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ CommandParameter { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommandParameter : obj with get, set" Usage="System.Windows.Input.InputBinding.CommandParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die befehlsspezifischen Daten für einen bestimmten Befehl ab oder legt diese fest.</summary>
        <value>Die befehlsspezifischen Daten. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Input.InputBinding.CommandParameter%2A> Eigenschaft wird verwendet, um bestimmte Informationen an den Befehl übergeben werden, bei der Ausführung. Der Typ der Daten wird durch den Befehl definiert. Viele Befehle erwarten keine Befehlsparameter; Bei diesen Befehlen werden übergebene Befehlsparameter ignoriert.  
  
 Ist der Befehl, der eine eingabebindung zugeordnet ist eine <xref:System.Windows.Input.RoutedCommand>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A> von die eingabebindung übergeben wird die <xref:System.Windows.Input.RoutedCommand> Handler durch den <xref:System.Windows.Input.ExecutedRoutedEventArgs> und die <xref:System.Windows.Input.CanExecuteRoutedEventArgs> Ereignisdaten, die beim Verarbeiten des Befehls.  
  
 Der Datentyp und den Zweck des Command-Parameters sind für jeden Befehl anders definiert und kann `null`. Sie binden die <xref:System.Windows.Input.InputBinding.Command%2A>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A>, und <xref:System.Windows.Input.InputBinding.CommandTarget%2A> Eigenschaften, die eine <xref:System.Windows.Input.ICommand> , die für ein Objekt definiert ist. Dadurch können Sie definieren einen benutzerdefinierten Befehl und Benutzereingaben zuordnen. Weitere Informationen finden Sie im zweite Beispiel in <xref:System.Windows.Input.InputBinding>.  
  
 Die <xref:System.Windows.Input.InputBinding> Klasse unterstützt keine XAML-Verwendung, weil sie keinen öffentlichen Standardkonstruktor verfügbar macht (er verfügt über einen Standardkonstruktor, aber es geschützt ist). Jedoch abgeleitete Klassen einen öffentlichen Konstruktor verfügbar machen, und aus diesem Grund können Eigenschaften festlegen, die von übernommenen <xref:System.Windows.Input.InputBinding> mit XAML-Verwendung. Zwei vorhandene <xref:System.Windows.Input.InputBinding> abgeleitete Klassen, die in XAML instanziiert werden und die Eigenschaften in XAML festlegen können, sind <xref:System.Windows.Input.KeyBinding> und <xref:System.Windows.Input.MouseBinding>.  
  
<a name="xamlAttributeUsage_CommandParameter"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<inputBindingDerivedClass CommandParameter="commandParameterString"/>  
```  
  
<a name="xamlPropertyElementUsage_CommandParameter"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<inputBindingDerivedClass>  
  <inputBindingDerivedClass.CommandParameter>  
    <commandParameterObject/>  
  </inputBindingDerivedClass.CommandParameter>  
</inputBindingDerivedClass>  
```  
  
<a name="xamlValues_CommandParameter"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 `inputBindingDerivedClass`  
 Eine abgeleitete Klasse von <xref:System.Windows.Input.InputBinding> , unterstützt die Objektelementsyntax, z. B. <xref:System.Windows.Input.KeyBinding> oder <xref:System.Windows.Input.MouseBinding>. Siehe Hinweise.  
  
 `commandParameterString`  
 Eine Zeichenfolge, die von einem bestimmten Befehl verarbeitet wird. Zeichenfolgen sind der allgemeine Typ für Parameter des Befehls verwendet werden, da sie leicht in XAML festgelegt werden können. Das erwartete Zeichenfolgenformat und seinen Zweck finden Sie in der Dokumentation für einen bestimmten Befehl, dem die eingabebindung zugeordnet ist. Viele Befehle erwarten keine Parameter.  
  
 `commandParameterObject`  
 Ein Objekt, das von einem bestimmten Befehl verarbeitet wird. Alle vorhandenen [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Befehle Zeichenfolgen verwenden. Aus diesem Grund ist dieser Eigenschaftenelement-Syntax nur für Szenarien mit benutzerdefinierten Befehlen relevant. Um diese Syntax unterstützt die `commandParameterObject` -Objekt unterstützt ebenfalls Objektelementsyntax (muss über einen öffentlichen Standardkonstruktor verfügen).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandParameterProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandParameterProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandParameterProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.InputBinding.CommandParameterProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandParameterProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandParameterProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandParameterProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.InputBinding.CommandParameterProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Input.InputBinding.CommandParameter" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.InputBinding.CommandProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.InputBinding.CommandProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Input.InputBinding.Command" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTarget">
      <MemberSignature Language="C#" Value="public System.Windows.IInputElement CommandTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.IInputElement CommandTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.CommandTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTarget As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::IInputElement ^ CommandTarget { System::Windows::IInputElement ^ get(); void set(System::Windows::IInputElement ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommandTarget : System.Windows.IInputElement with get, set" Usage="System.Windows.Input.InputBinding.CommandTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Zielelement des Befehls ab oder legt dieses fest.</summary>
        <value>Das Ziel des Befehls. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Windows Presentation Foundation-Befehlssystem ist die <xref:System.Windows.Input.InputBinding.CommandTarget%2A> Eigenschaft für eine <xref:System.Windows.Input.ICommandSource> Objekt ist nur anwendbar, wenn die <xref:System.Windows.Input.ICommand> ist eine <xref:System.Windows.Input.RoutedCommand>. Wenn <xref:System.Windows.Input.InputBinding.CommandTarget%2A> auf eine <xref:System.Windows.Input.ICommandSource> festgelegt und der entsprechende Befehl kein <xref:System.Windows.Input.RoutedCommand> ist, wird das Befehlsziel ignoriert.  
  
 Bei Verwendung mit einem <xref:System.Windows.Input.RoutedCommand>, das Befehlsziel ist das Objekt auf dem die <xref:System.Windows.Input.CommandManager.Executed> und <xref:System.Windows.Input.CommandManager.CanExecute> Ereignisse ausgelöst werden. Wenn die <xref:System.Windows.Input.InputBinding.CommandTarget%2A> Eigenschaft nicht festgelegt ist, wird das Element mit dem Tastaturfokus als Ziel verwendet.  
  
 Die <xref:System.Windows.Input.InputBinding> Klasse selbst unterstützt keine XAML-Verwendung, weil sie keinen öffentlichen Standardkonstruktor verfügbar macht (es ist ein Standardkonstruktor, aber es geschützt ist). Jedoch abgeleitete Klassen einen öffentlichen Konstruktor verfügbar machen, und aus diesem Grund können Eigenschaften festlegen, die von übernommenen <xref:System.Windows.Input.InputBinding> mit einer XAML-Verwendung. Zwei vorhandene <xref:System.Windows.Input.InputBinding> abgeleitete Klassen, die in XAML instanziiert werden und die Eigenschaften in XAML festlegen können, sind <xref:System.Windows.Input.KeyBinding> und <xref:System.Windows.Input.MouseBinding>.  
  
<a name="xamlAttributeUsage_CommandTarget"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<inputBindingDerivedClass CommandTarget="bindingToTarget"/>  
```  
  
<a name="xamlValues_CommandTarget"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 `inputBindingDerivedClass`  
 Eine abgeleitete Klasse von <xref:System.Windows.Input.InputBinding> , unterstützt die Objektelementsyntax, z. B. <xref:System.Windows.Input.KeyBinding> oder <xref:System.Windows.Input.MouseBinding>. Siehe Hinweise.  
  
 `bindingToTarget`  
 Eine Zeichenfolge, die einen Bindungssyntax verwendet, die einen Objektverweis zu einer vorhandenen zurückgeben kann, mit dem Namen Element. Siehe Hinweise.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTargetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandTargetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandTargetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.InputBinding.CommandTargetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandTargetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandTargetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandTargetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.InputBinding.CommandTargetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifiziert die <see cref="P:System.Windows.Input.InputBinding.CommandTarget" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="inputBinding.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine Instanz eines <see cref="T:System.Windows.Input.InputBinding" />-Objekts.</summary>
        <returns>Das neue Objekt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Gesture">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Input.InputGesture Gesture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputGesture Gesture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.Gesture" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Gesture As InputGesture" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Input::InputGesture ^ Gesture { System::Windows::Input::InputGesture ^ get(); void set(System::Windows::Input::InputGesture ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Gesture : System.Windows.Input.InputGesture with get, set" Usage="System.Windows.Input.InputBinding.Gesture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputGesture</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die dieser Eingabebindung zugeordnete <see cref="T:System.Windows.Input.InputGesture" />-Klasse ab oder legt diese fest.</summary>
        <value>Die zugeordnete Stiftbewegung. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Eingabegeste ist die Aktion, die den Befehl aufruft. Beispiele für die in die Eingabeaktionen [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sind <xref:System.Windows.Input.KeyGesture> und <xref:System.Windows.Input.MouseGesture>. Ein <xref:System.Windows.Input.KeyGesture> ist eine Kombination aus einem <xref:System.Windows.Input.Key> und einen Satz von <xref:System.Windows.Input.ModifierKeys>. Ein <xref:System.Windows.Input.MouseGesture> ist eine Kombination aus einem <xref:System.Windows.Input.MouseAction> und einen Satz von <xref:System.Windows.Input.ModifierKeys>.  
  
 Die <xref:System.Windows.Input.InputBinding> Klasse selbst unterstützt keine XAML-Verwendung, weil sie keinen öffentlichen Standardkonstruktor verfügbar macht (es ist ein Standardkonstruktor, aber es geschützt ist). Jedoch abgeleitete Klassen einen öffentlichen Konstruktor verfügbar machen, und daher Eigenschaften festlegen, die von übernommenen <xref:System.Windows.Input.InputBinding> mit einer XAML-Verwendung. Zwei vorhandene <xref:System.Windows.Input.InputBinding> abgeleitete Klassen, die in XAML instanziiert werden und die Eigenschaften in XAML festlegen können, sind <xref:System.Windows.Input.KeyBinding> und <xref:System.Windows.Input.MouseBinding>.  
  
<a name="xamlAttributeUsage_gesture"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
 <<xref:System.Windows.Input.KeyBinding> `Gesture`="<xref:System.Windows.Input.KeyGesture>"/>  
  
- oder - 
  
 <<xref:System.Windows.Input.MouseBinding> `Gesture`="<xref:System.Windows.Input.MouseGesture>"/>  
  
- oder - 
  
 <`inputBindingDerivedClass` `Gesture`="<xref:System.Windows.Input.InputGesture>"/>  
  
<a name="xamlPropertyElementUsage_gesture"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<inputBindingDerivedClass>  
  <inputBindingDerivedClass.Gesture>  
    <inputGestureImplementation/>  
  </inputBindingDerivedClass.Gesture>  
</inputBindingDerivedClass>  
```  
  
<a name="xamlValues_gesture"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 `inputBindingDerivedClass`  
 Eine abgeleitete Klasse von <xref:System.Windows.Input.InputBinding> , unterstützt die Objektelementsyntax, z. B. <xref:System.Windows.Input.KeyBinding> oder <xref:System.Windows.Input.MouseBinding>. Siehe Hinweise.  
  
 `inputGestureImplementation`  
 Eine benutzerdefinierte abgeleitete Klasse von <xref:System.Windows.Input.InputGesture> , das Objektelement-Syntax unterstützt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit einer <xref:System.Windows.Input.KeyBinding> binden ein <xref:System.Windows.Input.KeyGesture> auf eine <xref:System.Windows.Input.RoutedCommand>. Wenn die <xref:System.Windows.Input.KeyGesture> ALT + L gedrückt wird, die <xref:System.Windows.Input.ApplicationCommands.Close%2A> Befehl aufgerufen wird.  
  
 [!code-xaml[commandlibrarysnippets#KeyBindingWithKeyAndModifiersXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml#keybindingwithkeyandmodifiersxaml)]  
  
 [!code-csharp[commandlibrarysnippets#KeyBindingWithKeyAndModifiers](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml.cs#keybindingwithkeyandmodifiers)]
 [!code-vb[commandlibrarysnippets#KeyBindingWithKeyAndModifiers](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandLibrarySnippets/visualbasic/window1.xaml.vb#keybindingwithkeyandmodifiers)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.KeyGesture" />
        <altmember cref="T:System.Windows.Input.MouseGesture" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Das zu klonende Objekt.</param>
        <summary>Definiert die Instanz als fixierten Klon des angegebenen <see cref="T:System.Windows.Freezable" />-Objekts mithilfe von Basiseigenschaftswerten (nicht animiert).</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Das zu klonende Objekt.</param>
        <summary>Macht diese aktuelle Instanz zu einem fixierten Klon des angegebenen <see cref="T:System.Windows.Freezable" />-Objekts. Wenn das Objekt über animierte Abhängigkeitseigenschaften verfügt, werden die aktuellen animierten Werte kopiert.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>