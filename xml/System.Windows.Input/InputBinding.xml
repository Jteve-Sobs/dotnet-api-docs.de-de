<Type Name="InputBinding" FullName="System.Windows.Input.InputBinding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c701543cf78be82eeaa3f9705791e280a033479a" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36507813" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class InputBinding : System.Windows.Freezable, System.Windows.Input.ICommandSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit InputBinding extends System.Windows.Freezable implements class System.Windows.Input.ICommandSource" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.InputBinding" />
  <TypeSignature Language="VB.NET" Value="Public Class InputBinding&#xA;Inherits Freezable&#xA;Implements ICommandSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class InputBinding : System::Windows::Freezable, System::Windows::Input::ICommandSource" />
  <TypeSignature Language="F#" Value="type InputBinding = class&#xA;    inherit Freezable&#xA;    interface ICommandSource" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Freezable</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Input.ICommandSource</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt eine Bindung zwischen einer <see cref="T:System.Windows.Input.InputGesture" /> und einem Befehl dar. Der Befehl ist potenziell ein <see cref="T:System.Windows.Input.RoutedCommand" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können angeben, dass eine Benutzereingabe einen Befehl, durch das Erstellen aufruft einer <xref:System.Windows.Input.InputBinding>. Wenn der Benutzer die angegebene Eingabe ausführt der <xref:System.Windows.Input.ICommand> , wird festgelegt, um die <xref:System.Windows.Input.InputBinding.Command%2A> -Eigenschaft ausgeführt.  
  
 Sie können angeben, die <xref:System.Windows.Input.InputBinding> aufruft, einen Befehl, der für ein Objekt definiert ist, durch das Erstellen einer Bindung auf den <xref:System.Windows.Input.InputBinding.Command%2A>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A>, und <xref:System.Windows.Input.InputBinding.CommandTarget%2A> Eigenschaften. Dadurch können Sie zum Definieren eines benutzerdefinierten Befehls und Benutzereingaben zuordnen. Weitere Informationen finden Sie im zweite Beispiel im Abschnitt "Beispiele".  
  
 Ein <xref:System.Windows.Input.InputBinding> kann auf ein bestimmtes Objekt oder auf Klassenebene definiert werden, indem Sie registrieren einen <xref:System.Windows.Input.CommandManager.RegisterClassInputBinding%2A> mit der <xref:System.Windows.Input.CommandManager>.  
  
 Die <xref:System.Windows.Input.InputBinding> Klasse selbst unterstützt keine Verwendung von XAML-Verwendung, da sie keinen öffentlichen Standardkonstruktor verfügbar macht (es ist ein Standardkonstruktor, aber er geschützt ist). Allerdings abgeleitete Klassen können einen öffentlichen Konstruktor verfügbar machen, und aus diesem Grund können Eigenschaften festlegen, für die abgeleitete Klasse, die vom geerbt werden <xref:System.Windows.Input.InputBinding> mit einer XAML-Verwendung. Zwei vorhandene <xref:System.Windows.Input.InputBinding>-abgeleiteten Klassen, die in XAML instanziiert werden können und Eigenschaften in XAML festlegen können, sind <xref:System.Windows.Input.KeyBinding> und <xref:System.Windows.Input.MouseBinding>. Die Eigenschaft in der [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] also programming in XAML und nimmt legen Sie eine oder mehrere <xref:System.Windows.Input.InputBinding> Objekte als Werte ist die <xref:System.Windows.UIElement.InputBindings%2A?displayProperty=nameWithType> Eigenschaft.  
  
<a name="xamlObjectElementUsage_InputBinding"></a>   
## <a name="xaml-object-element-usage"></a>Verwendung von XAML-Objektelementen  
 \<*inputBindingDerivedClass…/*>  
  
<a name="xamlValues_InputBinding"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 `inputBindingDerivedClass`  
 Eine abgeleitete Klasse von <xref:System.Windows.Input.InputBinding> , die Syntax der Object-Element, z. B. unterstützt <xref:System.Windows.Input.KeyBinding> oder <xref:System.Windows.Input.MouseBinding>. Siehe Hinweise.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie eine <xref:System.Windows.Input.KeyBinding> zum Binden einer <xref:System.Windows.Input.KeyGesture> auf die <xref:System.Windows.Input.ApplicationCommands.Open%2A> Befehl. Wenn die Tastenkombination ausgeführt wird, wird der Befehl zum Öffnen aufgerufen.  
  
 [!code-xaml[commandingoverviewsnippets#CommandingOverviewXAMLKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewxamlkeybinding)]  
  
 Den folgenden Beispielen wird veranschaulicht, wie Sie einen benutzerdefinierten Befehl zum Binden <xref:System.Windows.Input.InputBinding> Objekte. In diesen Beispielen erstellen Sie eine Anwendung, die dem Benutzer ermöglicht, die die Hintergrundfarbe ändern, indem Sie eine der folgenden Aktionen ausführen:  
  
-   Klicken Sie auf eine Schaltfläche.  
  
-   STRG + C drücken.  
  
-   Mit der rechten Maustaste ein <xref:System.Windows.Controls.StackPanel> (außerhalb der <xref:System.Windows.Controls.ListBox>).  
  
 Im erste Beispiel erstellt eine Klasse namens `SimpleDelegateCommand`. Diese Klasse akzeptiert einen Delegaten, sodass das Objekt, das den Befehl erstellt die Aktion definieren kann, die auftritt, wenn der Befehl ausgeführt wird. `SimpleDelegateCommand` definiert auch Eigenschaften, die angeben, welche Schlüssel und eine Maus Eingabe Ruft den Befehl. `GestureKey` und `GestureModifier` Geben Sie die Tastatureingaben; `MouseGesture` gibt die Mauseingabe an.  
  
 [!code-csharp[InputCommandBinding#DelegateCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/inputcommandbinding/csharp/mainwindow.xaml.cs#delegatecommand)]
 [!code-vb[InputCommandBinding#DelegateCommand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/inputcommandbinding/visualbasic/mainwindow.xaml.vb#delegatecommand)]  
  
 Das folgende Beispiel erstellt und initialisiert die `ColorChangeCommand`, also eine `SimpleDelegateCommand`. Im Beispiel definiert auch die Methode, die ausgeführt wird, wenn der Befehl aufgerufen wird, und legt die `GestureKey`, `GestureModifier`, und `MouseGesture` Eigenschaften. Eine Anwendung aufrufen würde die `InitializeCommand` Methode, wenn das Programm beginnt, z. B. in den Konstruktor des eine <xref:System.Windows.Window>.  
  
 [!code-csharp[InputCommandBinding#InitializeCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/inputcommandbinding/csharp/mainwindow.xaml.cs#initializecommand)]
 [!code-vb[InputCommandBinding#InitializeCommand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/inputcommandbinding/visualbasic/mainwindow.xaml.vb#initializecommand)]  
  
 Im folgende Beispiel wird schließlich die Benutzeroberfläche erstellt. Im Beispiel fügt eine <xref:System.Windows.Input.KeyBinding> und ein <xref:System.Windows.Input.MouseBinding> auf eine <xref:System.Windows.Controls.StackPanel> , enthält eine <xref:System.Windows.Controls.Button> und ein <xref:System.Windows.Controls.ListBox>. Wenn der Benutzer wählt ein Element in der <xref:System.Windows.Controls.ListBox>, er oder sie können die Farbe des Hintergrunds der ausgewählten Farbe ändern. In jedem Fall die `CommandParameter` Eigenschaft gebunden ist, um das ausgewählte Element in der <xref:System.Windows.Controls.ListBox>, und die `Command` Eigenschaft gebunden ist die `ColorChangeCommand`. Die <xref:System.Windows.Input.KeyBinding.Key%2A?displayProperty=nameWithType>, <xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType>, und <xref:System.Windows.Input.MouseBinding.MouseAction%2A?displayProperty=nameWithType> Eigenschaften an die entsprechenden Eigenschaften gebunden sind, auf die `SimpleDelegateCommand` Klasse.  
  
 [!code-xaml[InputCommandBinding#UI](~/samples/snippets/csharp/VS_Snippets_Wpf/inputcommandbinding/csharp/mainwindow.xaml#ui)]  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.UIElement.InputBindings" />
    <altmember cref="T:System.Windows.Input.CommandBinding" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Input.InputBinding" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected InputBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; InputBinding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Stellt die Basisinitialisierung für von <see cref="T:System.Windows.Input.InputBinding" /> abgeleitete Klassen bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.InputBinding> Technisch gesehen eine abstrakte Klasse ist, aber der Standardkonstruktor wird absichtlich Zugriff geschützt. Dies entspricht dem festlegen, dass <xref:System.Windows.Input.InputBinding> eine "abstract" Klasse für XAML. Es gibt vorhandene Eigenschaften in [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] , auf denen XAML-Verwendungen, die Objekte des Typs zu erwarten <xref:System.Windows.Input.InputBinding>, aber nicht angeben eine <xref:System.Windows.Input.InputBinding> Instanz in XAML. Stattdessen können Sie angeben eines gerätespezifischen <xref:System.Windows.Input.InputBinding> abgeleiteten Klassen als Werte für die Instanz <xref:System.Windows.Input.KeyBinding> oder <xref:System.Windows.Input.MouseBinding>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie eine benutzerdefinierte implementieren <see cref="T:System.Windows.Input.InputBinding" /> , das eine XAML-Verwendung unterstützt, verwenden Sie diesen Konstruktor für die Basis-Initialisierung.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InputBinding (System.Windows.Input.ICommand command, System.Windows.Input.InputGesture gesture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Input.ICommand command, class System.Windows.Input.InputGesture gesture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.#ctor(System.Windows.Input.ICommand,System.Windows.Input.InputGesture)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (command As ICommand, gesture As InputGesture)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InputBinding(System::Windows::Input::ICommand ^ command, System::Windows::Input::InputGesture ^ gesture);" />
      <MemberSignature Language="F#" Value="new System.Windows.Input.InputBinding : System.Windows.Input.ICommand * System.Windows.Input.InputGesture -&gt; System.Windows.Input.InputBinding" Usage="new System.Windows.Input.InputBinding (command, gesture)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="command" Type="System.Windows.Input.ICommand" />
        <Parameter Name="gesture" Type="System.Windows.Input.InputGesture" />
      </Parameters>
      <Docs>
        <param name="command">Der Befehl, der <c>gesture</c> zugeordnet werden soll.</param>
        <param name="gesture">Die Eingabegeste, die <c>command</c> zugeordnet werden soll.</param>
        <summary>Initialisiert mit dem angegebenen Befehl und der Eingabestiftbewegung eine neue Instanz der <see cref="T:System.Windows.Input.InputBinding" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Auch wenn Sie benutzerdefinierte Befehle definieren, wird dieses Konstruktors wird im Allgemeinen nicht von als Entwickler von Software mithilfe von vorhandenen Eingaben Binden von Klassen verwenden. Stattdessen verwenden Sie entweder Konstruktoren von abgeleiteten Klassen (<xref:System.Windows.Input.KeyBinding> und <xref:System.Windows.Input.MouseBinding>), oder verwenden Sie diesen Konstruktor als die Basis Instanziierung einer benutzerdefinierten Klasse. Obwohl die <xref:System.Windows.Input.InputBinding> Klasse unterstützt verschiedene Eingabegeräte grundsätzlich in der Praxis müssen Sie auswählen, welches Gerät die eingabebindung dar. Nur einstellbaren nur eine <xref:System.Windows.Input.InputBinding.Gesture%2A> Wert eingabebindung und Gesten sind gerätespezifisch.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie dieser Konstruktor verwendet, um Zuordnen einer <xref:System.Windows.Input.KeyGesture> mit einem <xref:System.Windows.Input.RoutedCommand>.  
  
 [!code-csharp[commandlibrarysnippets#InputBindingAddingComand](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml.cs#inputbindingaddingcomand)]
 [!code-vb[commandlibrarysnippets#InputBindingAddingComand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandLibrarySnippets/visualbasic/window1.xaml.vb#inputbindingaddingcomand)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="command" /> oder <paramref name="gesture" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected override void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Das zu klonende Objekt.</param>
        <summary>Kopiert die Basiswerte (nicht animiert) der Eigenschaften des angegebenen Objekts.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Das zu klonende Objekt.</param>
        <summary>Kopiert die aktuellen Werte der Eigenschaften des angegebenen Objekts.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Command">
      <MemberSignature Language="C#" Value="public System.Windows.Input.ICommand Command { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.ICommand Command" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.Command" />
      <MemberSignature Language="VB.NET" Value="Public Property Command As ICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::ICommand ^ Command { System::Windows::Input::ICommand ^ get(); void set(System::Windows::Input::ICommand ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Command : System.Windows.Input.ICommand with get, set" Usage="System.Windows.Input.InputBinding.Command" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.ICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die dieser Eingabebindung zugeordnete <see cref="T:System.Windows.Input.ICommand" />-Klasse ab oder legt diese fest.</summary>
        <value>Der verknüpfte Befehl.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Input.InputBinding> Klasse unterstützt keine Verwendung von XAML-Verwendung, da sie keinen öffentlichen Standardkonstruktor verfügbar macht (er verfügt über einen Standardkonstruktor, aber er geschützt ist). Allerdings abgeleitete Klassen können einen öffentlichen Konstruktor verfügbar machen und können daher aus geerbte Eigenschaften, <xref:System.Windows.Input.InputBinding>. Zwei vorhandene <xref:System.Windows.Input.InputBinding> abgeleitete Klassen, die in XAML instanziiert werden können und Eigenschaften in XAML-Verwendungen festlegen können, sind <xref:System.Windows.Input.KeyBinding> und <xref:System.Windows.Input.MouseBinding>.  
  
 <xref:System.Windows.Input.ICommand> verweist auf einen Typkonverter, die bestimmte bereits vorhandene ermöglicht <xref:System.Windows.Input.ICommand> Implementierungen Angabe von Werten in Form einer Zeichenfolge. Diese Typkonvertierungsverhalten legt die Attributform Wert dieser Eigenschaft fest. Sie auch eine Bindung die <xref:System.Windows.Input.InputBinding.Command%2A>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A>, und <xref:System.Windows.Input.InputBinding.CommandTarget%2A> Eigenschaften einer <xref:System.Windows.Input.ICommand> , die für ein Objekt definiert ist. Dadurch können Sie zum Definieren eines benutzerdefinierten Befehls und Benutzereingaben zuordnen. Weitere Informationen finden Sie im zweite Beispiel <xref:System.Windows.Input.InputBinding>.  
  
<a name="xamlAttributeUsage_Command"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
 <`inputBindingDerivedClass` `Command`="<xref:System.Windows.Input.ICommand>"/>  
  
<a name="xamlPropertyElementUsage_Command"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<inputBindingDerivedClass>  
  <inputBindingDerivedClass.Command>  
    <iCommandImplementation/>  
  </inputBindingDerivedClass.Command>  
</inputBindingDerivedClass>  
```  
  
<a name="xamlValues_Command"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 `inputBindingDerivedClass`  
 Eine abgeleitete Klasse von <xref:System.Windows.Input.InputBinding> , die Syntax der Object-Element, z. B. unterstützt <xref:System.Windows.Input.KeyBinding> oder <xref:System.Windows.Input.MouseBinding>. Siehe Hinweise.  
  
 `iCommandImplementation`  
 Eine Objekt-Implementierung von <xref:System.Windows.Input.ICommand> , unterstützt die Syntax der Object-Element (verfügt über einen öffentlichen Standardkonstruktor).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie eine <xref:System.Windows.Input.KeyBinding> zum Binden einer <xref:System.Windows.Input.KeyGesture> auf die <xref:System.Windows.Input.ApplicationCommands.Open%2A?displayProperty=nameWithType> Befehl. Wenn die Tastenkombination ausgeführt wird, wird der Befehl zum Öffnen aufgerufen.  
  
 [!code-xaml[commandingoverviewsnippets#CommandingOverviewXAMLKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewxamlkeybinding)]  
  
 [!code-csharp[commandingoverviewsnippets#CommandingOverviewKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewkeybinding)]
 [!code-vb[commandingoverviewsnippets#CommandingOverviewKeyBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewkeybinding)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <see cref="P:System.Windows.Input.InputBinding.Command" />-Wert ist <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.InputGesture" />
      </Docs>
    </Member>
    <Member MemberName="CommandParameter">
      <MemberSignature Language="C#" Value="public object CommandParameter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object CommandParameter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.CommandParameter" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandParameter As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ CommandParameter { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommandParameter : obj with get, set" Usage="System.Windows.Input.InputBinding.CommandParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die befehlsspezifischen Daten für einen bestimmten Befehl ab oder legt diese fest.</summary>
        <value>Die befehlsspezifischen Daten. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Input.InputBinding.CommandParameter%2A> Eigenschaft wird verwendet, um bestimmte Informationen an den Befehl übergeben werden, bei der Ausführung. Der Typ der Daten wird vom Befehl definiert. Viele Befehle erwarten keine Befehlsparameter; für diese Befehle werden alle übergebenen Befehlsparameter ignoriert.  
  
 Ist der Befehl, der eingabebindung zugeordnet ist ein <xref:System.Windows.Input.RoutedCommand>, die <xref:System.Windows.Input.InputBinding.CommandParameter%2A> der Eingabe Bindung wird zum Übergeben der <xref:System.Windows.Input.RoutedCommand> Handler über die <xref:System.Windows.Input.ExecutedRoutedEventArgs> und die <xref:System.Windows.Input.CanExecuteRoutedEventArgs> Ereignisdaten, die beim Verarbeiten des Befehls.  
  
 Den Datentyp und den Zweck der Befehlsparameter für jeden Befehl anders definiert und kann `null`. Sie binden die <xref:System.Windows.Input.InputBinding.Command%2A>, <xref:System.Windows.Input.InputBinding.CommandParameter%2A>, und <xref:System.Windows.Input.InputBinding.CommandTarget%2A> Eigenschaften einer <xref:System.Windows.Input.ICommand> , die für ein Objekt definiert ist. Dadurch können Sie zum Definieren eines benutzerdefinierten Befehls und Benutzereingaben zuordnen. Weitere Informationen finden Sie im zweite Beispiel <xref:System.Windows.Input.InputBinding>.  
  
 Die <xref:System.Windows.Input.InputBinding> Klasse unterstützt keine Verwendung von XAML-Verwendung, da sie keinen öffentlichen Standardkonstruktor verfügbar macht (er verfügt über einen Standardkonstruktor, aber er geschützt ist). Allerdings abgeleitete Klassen können einen öffentlichen Konstruktor verfügbar machen, und aus diesem Grund können Eigenschaften festlegen, die von geerbt werden <xref:System.Windows.Input.InputBinding> mit XAML-Verwendung. Zwei vorhandene <xref:System.Windows.Input.InputBinding> abgeleiteten Klassen, die in XAML instanziiert werden können und Eigenschaften in XAML festlegen können, sind <xref:System.Windows.Input.KeyBinding> und <xref:System.Windows.Input.MouseBinding>.  
  
<a name="xamlAttributeUsage_CommandParameter"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<inputBindingDerivedClass CommandParameter="commandParameterString"/>  
```  
  
<a name="xamlPropertyElementUsage_CommandParameter"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<inputBindingDerivedClass>  
  <inputBindingDerivedClass.CommandParameter>  
    <commandParameterObject/>  
  </inputBindingDerivedClass.CommandParameter>  
</inputBindingDerivedClass>  
```  
  
<a name="xamlValues_CommandParameter"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 `inputBindingDerivedClass`  
 Eine abgeleitete Klasse von <xref:System.Windows.Input.InputBinding> , die Syntax der Object-Element, z. B. unterstützt <xref:System.Windows.Input.KeyBinding> oder <xref:System.Windows.Input.MouseBinding>. Siehe Hinweise.  
  
 `commandParameterString`  
 Eine Zeichenfolge, die von einem bestimmten Befehl verarbeitet wird. Zeichenfolgen sind der allgemeine Typ für Parameter des Befehls verwendet werden, da sie problemlos in XAML festgelegt werden können. Das erwartete Zeichenfolgenformat und ihren Zweck finden Sie in der Dokumentation für einen bestimmten Befehl, dem die Eingabe Bindung zugeordnet ist. Viele Befehle erwarten keine Parameter.  
  
 `commandParameterObject`  
 Ein Objekt, das von einem bestimmten Befehl verarbeitet wird. Alle vorhandenen [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Befehle unstrukturierte Zeichenfolgen verwenden. Daher ist diese Eigenschaftenelementsyntax nur für Szenarien mit benutzerdefinierten Befehlen relevant. Um diese Syntax zu unterstützen die `commandParameterObject` Objekt muss auch die Syntax der Object-Element (muss über einen öffentlichen Standardkonstruktor verfügen) unterstützen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandParameterProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandParameterProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandParameterProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.InputBinding.CommandParameterProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandParameterProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandParameterProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandParameterProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.InputBinding.CommandParameterProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Input.InputBinding.CommandParameter" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.InputBinding.CommandProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.InputBinding.CommandProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Input.InputBinding.Command" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTarget">
      <MemberSignature Language="C#" Value="public System.Windows.IInputElement CommandTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.IInputElement CommandTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.CommandTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTarget As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::IInputElement ^ CommandTarget { System::Windows::IInputElement ^ get(); void set(System::Windows::IInputElement ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommandTarget : System.Windows.IInputElement with get, set" Usage="System.Windows.Input.InputBinding.CommandTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Zielelement des Befehls ab oder legt dieses fest.</summary>
        <value>Das Ziel des Befehls. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Windows Presentation Foundation Befehlssystem die <xref:System.Windows.Input.InputBinding.CommandTarget%2A> Eigenschaft auf eine <xref:System.Windows.Input.ICommandSource> Objekt ist nur anwendbar, wenn die <xref:System.Windows.Input.ICommand> ist eine <xref:System.Windows.Input.RoutedCommand>. Wenn <xref:System.Windows.Input.InputBinding.CommandTarget%2A> auf eine <xref:System.Windows.Input.ICommandSource> festgelegt und der entsprechende Befehl kein <xref:System.Windows.Input.RoutedCommand> ist, wird das Befehlsziel ignoriert.  
  
 Bei Verwendung mit einem <xref:System.Windows.Input.RoutedCommand>, das Befehlsziel ist das Objekt auf dem die <xref:System.Windows.Input.CommandManager.Executed> und <xref:System.Windows.Input.CommandManager.CanExecute> Ereignisse ausgelöst werden. Wenn die <xref:System.Windows.Input.InputBinding.CommandTarget%2A> Eigenschaft nicht festgelegt ist, wird das Element mit dem Tastaturfokus als Ziel verwendet.  
  
 Die <xref:System.Windows.Input.InputBinding> Klasse selbst unterstützt keine XAML-Verwendung, da sie keinen öffentlichen Standardkonstruktor verfügbar macht (es ist ein Standardkonstruktor, aber er geschützt ist). Allerdings abgeleitete Klassen können einen öffentlichen Konstruktor verfügbar machen, und aus diesem Grund können Eigenschaften festlegen, die von geerbt werden <xref:System.Windows.Input.InputBinding> mit einer XAML-Verwendung. Zwei vorhandene <xref:System.Windows.Input.InputBinding> abgeleiteten Klassen, die in XAML instanziiert werden können und Eigenschaften in XAML festlegen können, sind <xref:System.Windows.Input.KeyBinding> und <xref:System.Windows.Input.MouseBinding>.  
  
<a name="xamlAttributeUsage_CommandTarget"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<inputBindingDerivedClass CommandTarget="bindingToTarget"/>  
```  
  
<a name="xamlValues_CommandTarget"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 `inputBindingDerivedClass`  
 Eine abgeleitete Klasse von <xref:System.Windows.Input.InputBinding> , die Syntax der Object-Element, z. B. unterstützt <xref:System.Windows.Input.KeyBinding> oder <xref:System.Windows.Input.MouseBinding>. Siehe Hinweise.  
  
 `bindingToTarget`  
 Eine Zeichenfolge, die einen Typ der Bindungssyntax verwendet, die einen Objektverweis zu einer vorhandenen zurückgeben, können mit dem Namen Element aus. Siehe Hinweise.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTargetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandTargetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandTargetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.InputBinding.CommandTargetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandTargetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandTargetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandTargetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.InputBinding.CommandTargetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Input.InputBinding.CommandTarget" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable&#xA;override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="inputBinding.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine Instanz eines <see cref="T:System.Windows.Input.InputBinding" />-Objekts.</summary>
        <returns>Das neue Objekt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Gesture">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Input.InputGesture Gesture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputGesture Gesture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.Gesture" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Gesture As InputGesture" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Input::InputGesture ^ Gesture { System::Windows::Input::InputGesture ^ get(); void set(System::Windows::Input::InputGesture ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Gesture : System.Windows.Input.InputGesture with get, set" Usage="System.Windows.Input.InputBinding.Gesture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputGesture</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die dieser Eingabebindung zugeordnete <see cref="T:System.Windows.Input.InputGesture" />-Klasse ab oder legt diese fest.</summary>
        <value>Die zugeordnete Stiftbewegung. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Eingabeaktion ist die Aktion, die den Befehl aufruft. Beispiele für Eingabeaktionen in [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sind <xref:System.Windows.Input.KeyGesture> und <xref:System.Windows.Input.MouseGesture>. Ein <xref:System.Windows.Input.KeyGesture> ist eine Kombination aus einem <xref:System.Windows.Input.Key> und einen Satz von <xref:System.Windows.Input.ModifierKeys>. Ein <xref:System.Windows.Input.MouseGesture> ist eine Kombination aus einem <xref:System.Windows.Input.MouseAction> und einen Satz von <xref:System.Windows.Input.ModifierKeys>.  
  
 Die <xref:System.Windows.Input.InputBinding> Klasse selbst unterstützt keine XAML-Verwendung, da sie keinen öffentlichen Standardkonstruktor verfügbar macht (es ist ein Standardkonstruktor, aber er geschützt ist). Allerdings abgeleitete Klassen können einen öffentlichen Konstruktor verfügbar machen und somit Festlegen von geerbte Eigenschaften, <xref:System.Windows.Input.InputBinding> mit einer XAML-Verwendung. Zwei vorhandene <xref:System.Windows.Input.InputBinding> abgeleiteten Klassen, die in XAML instanziiert werden können und Eigenschaften in XAML festlegen können, sind <xref:System.Windows.Input.KeyBinding> und <xref:System.Windows.Input.MouseBinding>.  
  
<a name="xamlAttributeUsage_gesture"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
 <<xref:System.Windows.Input.KeyBinding> `Gesture`="<xref:System.Windows.Input.KeyGesture>"/>  
  
 \- oder –  
  
 <<xref:System.Windows.Input.MouseBinding> `Gesture`="<xref:System.Windows.Input.MouseGesture>"/>  
  
 \- oder –  
  
 <`inputBindingDerivedClass` `Gesture`="<xref:System.Windows.Input.InputGesture>"/>  
  
<a name="xamlPropertyElementUsage_gesture"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<inputBindingDerivedClass>  
  <inputBindingDerivedClass.Gesture>  
    <inputGestureImplementation/>  
  </inputBindingDerivedClass.Gesture>  
</inputBindingDerivedClass>  
```  
  
<a name="xamlValues_gesture"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 `inputBindingDerivedClass`  
 Eine abgeleitete Klasse von <xref:System.Windows.Input.InputBinding> , die Syntax der Object-Element, z. B. unterstützt <xref:System.Windows.Input.KeyBinding> oder <xref:System.Windows.Input.MouseBinding>. Siehe Hinweise.  
  
 `inputGestureImplementation`  
 Eine benutzerdefinierte abgeleitete Klasse der <xref:System.Windows.Input.InputGesture> , unterstützt die Syntax der Object-Element.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie eine <xref:System.Windows.Input.KeyBinding> zum Binden einer <xref:System.Windows.Input.KeyGesture> auf eine <xref:System.Windows.Input.RoutedCommand>. Wenn die <xref:System.Windows.Input.KeyGesture> ALT + L gedrückt wird, die <xref:System.Windows.Input.ApplicationCommands.Close%2A> Befehl aufgerufen wird.  
  
 [!code-xaml[commandlibrarysnippets#KeyBindingWithKeyAndModifiersXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml#keybindingwithkeyandmodifiersxaml)]  
  
 [!code-csharp[commandlibrarysnippets#KeyBindingWithKeyAndModifiers](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml.cs#keybindingwithkeyandmodifiers)]
 [!code-vb[commandlibrarysnippets#KeyBindingWithKeyAndModifiers](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandLibrarySnippets/visualbasic/window1.xaml.vb#keybindingwithkeyandmodifiers)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.KeyGesture" />
        <altmember cref="T:System.Windows.Input.MouseGesture" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Das zu klonende Objekt.</param>
        <summary>Definiert die Instanz als fixierten Klon des angegebenen <see cref="T:System.Windows.Freezable" />-Objekts mithilfe von Basiseigenschaftswerten (nicht animiert).</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Das zu klonende Objekt.</param>
        <summary>Legt die aktuelle Instanz als fixierten Klon des angegebenen <see cref="T:System.Windows.Freezable" /> fest. Wenn das Objekt über animierte Abhängigkeitseigenschaften verfügt, werden die aktuellen animierten Werte kopiert.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>