<Type Name="InputBinding" FullName="System.Windows.Input.InputBinding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="257352587cbebd153130af2566c44f8aadc46dea" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69172598" /></Metadata><TypeSignature Language="C#" Value="public class InputBinding : System.Windows.Freezable, System.Windows.Input.ICommandSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit InputBinding extends System.Windows.Freezable implements class System.Windows.Input.ICommandSource" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.InputBinding" />
  <TypeSignature Language="VB.NET" Value="Public Class InputBinding&#xA;Inherits Freezable&#xA;Implements ICommandSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class InputBinding : System::Windows::Freezable, System::Windows::Input::ICommandSource" />
  <TypeSignature Language="F#" Value="type InputBinding = class&#xA;    inherit Freezable&#xA;    interface ICommandSource" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Freezable</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-3.0">System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Input.ICommandSource</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt eine Bindung zwischen einer <see cref="T:System.Windows.Input.InputGesture" /> und einem Befehl dar. Der Befehl ist potenziell ein <see cref="T:System.Windows.Input.RoutedCommand" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können angeben, dass die Benutzereingabe einen Befehl aufruft, <xref:System.Windows.Input.InputBinding>indem Sie einen erstellen. Wenn der Benutzer die angegebene Eingabe ausführt, wird <xref:System.Windows.Input.ICommand> das, das auf die <xref:System.Windows.Input.InputBinding.Command%2A> -Eigenschaft festgelegt ist, ausgeführt.  
  
 Sie können angeben, dass <xref:System.Windows.Input.InputBinding> der einen Befehl aufruft, der für ein-Objekt definiert ist, indem eine <xref:System.Windows.Input.InputBinding.Command%2A>Bindung <xref:System.Windows.Input.InputBinding.CommandParameter%2A>für die <xref:System.Windows.Input.InputBinding.CommandTarget%2A> Eigenschaften, und erstellt wird. Dies ermöglicht es Ihnen, einen benutzerdefinierten Befehl zu definieren und ihn Benutzereingaben zuzuordnen. Weitere Informationen finden Sie im zweiten Beispiel im Abschnitt "Beispiele".  
  
 Ein <xref:System.Windows.Input.InputBinding> -Objekt kann für ein bestimmtes-Objekt oder auf Klassenebene definiert werden, <xref:System.Windows.Input.CommandManager.RegisterClassInputBinding%2A> indem ein <xref:System.Windows.Input.CommandManager>mit dem registriert wird.  
  
 Die <xref:System.Windows.Input.InputBinding> Klasse selbst unterstützt die XAML-Verwendung nicht, da Sie keinen öffentlichen Parameter losen Konstruktor verfügbar macht (es ist ein Parameter loser Konstruktor vorhanden, der jedoch geschützt ist). Abgeleitete Klassen können jedoch einen öffentlichen Konstruktor verfügbar machen und können daher Eigenschaften für die abgeleitete Klasse festlegen, die <xref:System.Windows.Input.InputBinding> von mit einer XAML-Verwendung geerbt werden. Zwei vorhandene <xref:System.Windows.Input.InputBinding>von abgeleitete Klassen, die in XAML instanziiert werden können und Eigenschaften in XAML festlegen <xref:System.Windows.Input.KeyBinding> können <xref:System.Windows.Input.MouseBinding>, sind und. Die typische Eigenschaft in [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] der Programmierung, die in XAML festgelegt wird und ein <xref:System.Windows.Input.InputBinding> oder mehrere Objekte als Werte <xref:System.Windows.UIElement.InputBindings%2A?displayProperty=nameWithType> annimmt, ist die-Eigenschaft.  
  
<a name="xamlObjectElementUsage_InputBinding"></a>   
## <a name="xaml-object-element-usage"></a>Verwendung von XAML-Objektelementen  
 \<*inputBindingDerivedClass…/*>  
  
<a name="xamlValues_InputBinding"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 `inputBindingDerivedClass`  
 Eine abgeleitete Klasse <xref:System.Windows.Input.InputBinding> von, die Objekt Element Syntax unterstützt <xref:System.Windows.Input.KeyBinding> , <xref:System.Windows.Input.MouseBinding>z. b. oder. Siehe Hinweise.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein <xref:System.Windows.Input.KeyBinding> zum Binden eines <xref:System.Windows.Input.KeyGesture> an den <xref:System.Windows.Input.ApplicationCommands.Open%2A> Befehl verwendet wird. Wenn die Tastenkombination ausgeführt wird, wird der Befehl "Öffnen" aufgerufen.  
  
 [!code-xaml[commandingoverviewsnippets#CommandingOverviewXAMLKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewxamlkeybinding)]  
  
 In den folgenden Beispielen wird gezeigt, wie ein benutzerdefinierter <xref:System.Windows.Input.InputBinding> Befehl an Objekte gebunden wird. In diesen Beispielen wird eine Anwendung erstellt, die es dem Benutzer ermöglicht, die Hintergrundfarbe zu ändern, indem eine der folgenden Aktionen durchgeführt wird:  
  
-   Klicken auf eine Schaltfläche.  
  
-   Drücken von STRG + C.  
  
-   Klicken Sie mit der <xref:System.Windows.Controls.StackPanel> rechten Maustaste auf <xref:System.Windows.Controls.ListBox>(außerhalb der).  
  
 Im ersten Beispiel wird eine Klasse mit `SimpleDelegateCommand`dem Namen erstellt. Diese Klasse akzeptiert einen Delegaten, damit das Objekt, das den Befehl erstellt, die Aktion definieren kann, die bei der Ausführung des Befehls auftritt. `SimpleDelegateCommand`definiert auch Eigenschaften, die angeben, welche Schlüssel-und Maus Eingaben den Befehl aufrufen. `GestureKey`und `GestureModifier` geben die Tastatureingabe an. `MouseGesture` gibt die Mauseingabe an.  
  
 [!code-csharp[InputCommandBinding#DelegateCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/inputcommandbinding/csharp/mainwindow.xaml.cs#delegatecommand)]
 [!code-vb[InputCommandBinding#DelegateCommand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/inputcommandbinding/visualbasic/mainwindow.xaml.vb#delegatecommand)]  
  
 Im folgenden Beispiel wird das `ColorChangeCommand`erstellt und initialisiert, das ein `SimpleDelegateCommand`ist. Das Beispiel definiert auch die Methode, die ausgeführt wird, wenn der Befehl aufgerufen wird `GestureKey`, `GestureModifier`und legt `MouseGesture` die Eigenschaften, und fest. Eine Anwendung ruft die `InitializeCommand` -Methode auf, wenn das Programm beginnt, z. b. im Konstruktor einer. <xref:System.Windows.Window>  
  
 [!code-csharp[InputCommandBinding#InitializeCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/inputcommandbinding/csharp/mainwindow.xaml.cs#initializecommand)]
 [!code-vb[InputCommandBinding#InitializeCommand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/inputcommandbinding/visualbasic/mainwindow.xaml.vb#initializecommand)]  
  
 Im folgenden Beispiel wird die Benutzeroberfläche erstellt. Im Beispiel wird ein <xref:System.Windows.Input.KeyBinding> und ein <xref:System.Windows.Input.MouseBinding> <xref:System.Windows.Controls.StackPanel> hinzugefügt, das eine <xref:System.Windows.Controls.Button> und eine <xref:System.Windows.Controls.ListBox>enthält. Wenn der Benutzer ein Element in der <xref:System.Windows.Controls.ListBox>auswählt, kann er die Farbe des Hintergrunds in die ausgewählte Farbe ändern. In jedem Fall wird die `CommandParameter` -Eigenschaft an das ausgewählte Element <xref:System.Windows.Controls.ListBox>in gebunden, und die `Command` -Eigenschaft ist an `ColorChangeCommand`gebunden. Die <xref:System.Windows.Input.KeyBinding.Key%2A?displayProperty=nameWithType>Eigenschaften <xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType>, und <xref:System.Windows.Input.MouseBinding.MouseAction%2A?displayProperty=nameWithType> sind an die entsprechenden Eigenschaften der `SimpleDelegateCommand` -Klasse gebunden.  
  
 [!code-xaml[InputCommandBinding#UI](~/samples/snippets/csharp/VS_Snippets_Wpf/inputcommandbinding/csharp/mainwindow.xaml#ui)]  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.UIElement.InputBindings" />
    <altmember cref="T:System.Windows.Input.CommandBinding" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Input.InputBinding" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected InputBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; InputBinding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Stellt die Basisinitialisierung für von <see cref="T:System.Windows.Input.InputBinding" /> abgeleitete Klassen bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.InputBinding>ist technisch gesehen keine abstrakte Klasse, aber der Parameter lose Konstruktor ist absichtlich geschützter Zugriff. Dies hat den Effekt, eine <xref:System.Windows.Input.InputBinding> "abstrakte" Klasse für XAML zu erstellen. Es gibt vorhandene Eigenschaften in [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] , die XAML-Verwendungen aufweisen, die Objekte <xref:System.Windows.Input.InputBinding>vom Typ erwarten. Sie können <xref:System.Windows.Input.InputBinding> jedoch keine Instanz in XAML angeben. Stattdessen können Sie eine der gerätespezifischen <xref:System.Windows.Input.InputBinding> abgeleiteten Klassen als Werte angeben, <xref:System.Windows.Input.KeyBinding> beispielsweise oder <xref:System.Windows.Input.MouseBinding>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie ein benutzerdefiniertes <see cref="T:System.Windows.Input.InputBinding" /> implementieren, das eine XAML-Verwendung unterstützt, verwenden Sie diesen Konstruktor für die Basis Initialisierung.</para></block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InputBinding (System.Windows.Input.ICommand command, System.Windows.Input.InputGesture gesture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Input.ICommand command, class System.Windows.Input.InputGesture gesture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.#ctor(System.Windows.Input.ICommand,System.Windows.Input.InputGesture)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (command As ICommand, gesture As InputGesture)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InputBinding(System::Windows::Input::ICommand ^ command, System::Windows::Input::InputGesture ^ gesture);" />
      <MemberSignature Language="F#" Value="new System.Windows.Input.InputBinding : System.Windows.Input.ICommand * System.Windows.Input.InputGesture -&gt; System.Windows.Input.InputBinding" Usage="new System.Windows.Input.InputBinding (command, gesture)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="command" Type="System.Windows.Input.ICommand" />
        <Parameter Name="gesture" Type="System.Windows.Input.InputGesture" />
      </Parameters>
      <Docs>
        <param name="command">Der Befehl, der <paramref name="gesture" /> zugeordnet werden soll.</param>
        <param name="gesture">Die Eingabegeste, die <paramref name="command" /> zugeordnet werden soll.</param>
        <summary>Initialisiert mit dem angegebenen Befehl und der Eingabestiftbewegung eine neue Instanz der <see cref="T:System.Windows.Input.InputBinding" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein Softwareentwickler sind, der vorhandene Eingabe Bindungs Klassen verwendet, wird dieser Konstruktor im Allgemeinen nicht verwendet, auch wenn Sie benutzerdefinierte Befehle definieren. Stattdessen verwenden Sie entweder Konstruktoren abgeleiteter Klassen (<xref:System.Windows.Input.KeyBinding> und <xref:System.Windows.Input.MouseBinding>), oder Sie verwenden diesen Konstruktor als Basis Instanziierung einer benutzerdefinierten Klasse. Obwohl die <xref:System.Windows.Input.InputBinding> -Klasse verschiedene Eingabegeräte im Prinzip unterstützt, müssen Sie in der Praxis das Gerät auswählen, das die Eingabe Bindung darstellt. Sie können nur einen <xref:System.Windows.Input.InputBinding.Gesture%2A> Wert für die Eingabe Bindung festlegen, und Gesten sind gerätespezifisch.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie dieser Konstruktor verwendet wird, <xref:System.Windows.Input.KeyGesture> um eine <xref:System.Windows.Input.RoutedCommand>mit einem zuzuordnen.  
  
 [!code-csharp[commandlibrarysnippets#InputBindingAddingCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml.cs#inputbindingaddingcommand)]
 [!code-vb[commandlibrarysnippets#InputBindingAddingCommand](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandLibrarySnippets/visualbasic/window1.xaml.vb#inputbindingaddingcommand)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="command" /> oder <paramref name="gesture" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected override void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Das zu klonende Objekt.</param>
        <summary>Kopiert die Basiswerte (nicht animiert) der Eigenschaften des angegebenen Objekts.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Das zu klonende Objekt.</param>
        <summary>Kopiert die aktuellen Werte der Eigenschaften des angegebenen Objekts.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Command">
      <MemberSignature Language="C#" Value="public System.Windows.Input.ICommand Command { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.ICommand Command" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.Command" />
      <MemberSignature Language="VB.NET" Value="Public Property Command As ICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::ICommand ^ Command { System::Windows::Input::ICommand ^ get(); void set(System::Windows::Input::ICommand ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Command : System.Windows.Input.ICommand with get, set" Usage="System.Windows.Input.InputBinding.Command" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Input.CommandConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.ICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die dieser Eingabebindung zugeordnete <see cref="T:System.Windows.Input.ICommand" />-Klasse ab oder legt diese fest.</summary>
        <value>Der verknüpfte Befehl.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Input.InputBinding> -Klasse unterstützt die XAML-Verwendung nicht, da Sie keinen öffentlichen Parameter losen Konstruktor verfügbar macht (Sie verfügt über einen Parameter losen Konstruktor, der jedoch geschützt ist). Abgeleitete Klassen können jedoch einen öffentlichen Konstruktor verfügbar machen und können daher Eigenschaften verwenden, die von <xref:System.Windows.Input.InputBinding>geerbt werden. Zwei vorhandene <xref:System.Windows.Input.InputBinding> abgeleitete Klassen, die in XAML instanziiert werden können und Eigenschaften mit XAML-Verwendungen <xref:System.Windows.Input.KeyBinding> festlegen <xref:System.Windows.Input.MouseBinding>können, sind und.  
  
 <xref:System.Windows.Input.ICommand>verweist auf einen Typkonverter, mit dem bestimmte <xref:System.Windows.Input.ICommand> bereits vorhandene Implementierungen Werte in Form einer Zeichenfolge angeben können. Mit diesem Typkonvertierungs Verhalten wird das Attribut Wert Formular dieser Eigenschaft festgelegt. Sie <xref:System.Windows.Input.InputBinding.Command%2A>können auch die Eigenschaften, <xref:System.Windows.Input.InputBinding.CommandParameter%2A>und <xref:System.Windows.Input.InputBinding.CommandTarget%2A> an eine <xref:System.Windows.Input.ICommand> binden, die für ein-Objekt definiert ist. Dies ermöglicht es Ihnen, einen benutzerdefinierten Befehl zu definieren und ihn Benutzereingaben zuzuordnen. Weitere Informationen finden Sie im zweiten Beispiel unter <xref:System.Windows.Input.InputBinding>.  
  
<a name="xamlAttributeUsage_Command"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
 <`inputBindingDerivedClass` `Command`="<xref:System.Windows.Input.ICommand>"/>  
  
<a name="xamlPropertyElementUsage_Command"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<inputBindingDerivedClass>  
  <inputBindingDerivedClass.Command>  
    <iCommandImplementation/>  
  </inputBindingDerivedClass.Command>  
</inputBindingDerivedClass>  
```  
  
<a name="xamlValues_Command"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 `inputBindingDerivedClass`  
 Eine abgeleitete Klasse <xref:System.Windows.Input.InputBinding> von, die Objekt Element Syntax unterstützt <xref:System.Windows.Input.KeyBinding> , <xref:System.Windows.Input.MouseBinding>z. b. oder. Siehe Hinweise.  
  
 `iCommandImplementation`  
 Eine Objekt Implementierung von <xref:System.Windows.Input.ICommand> , die die Objekt Element Syntax unterstützt (verfügt über einen öffentlichen Parameter losen Konstruktor).  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein <xref:System.Windows.Input.KeyBinding> zum Binden eines <xref:System.Windows.Input.KeyGesture> an den <xref:System.Windows.Input.ApplicationCommands.Open%2A?displayProperty=nameWithType> Befehl verwendet wird. Wenn die Tastenkombination ausgeführt wird, wird der Befehl "Öffnen" aufgerufen.  
  
 [!code-xaml[commandingoverviewsnippets#CommandingOverviewXAMLKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewxamlkeybinding)]  
  
 [!code-csharp[commandingoverviewsnippets#CommandingOverviewKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewkeybinding)]
 [!code-vb[commandingoverviewsnippets#CommandingOverviewKeyBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewkeybinding)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <see cref="P:System.Windows.Input.InputBinding.Command" />-Wert ist <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.InputGesture" />
      </Docs>
    </Member>
    <Member MemberName="CommandParameter">
      <MemberSignature Language="C#" Value="public object CommandParameter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object CommandParameter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.CommandParameter" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandParameter As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ CommandParameter { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommandParameter : obj with get, set" Usage="System.Windows.Input.InputBinding.CommandParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die befehlsspezifischen Daten für einen bestimmten Befehl ab oder legt diese fest.</summary>
        <value>Die befehlsspezifischen Daten. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Input.InputBinding.CommandParameter%2A> -Eigenschaft wird verwendet, um bestimmte Informationen an den Befehl zu übergeben, wenn diese ausgeführt wird. Der Typ der Daten wird durch den-Befehl definiert. Viele Befehle erwarten keine Befehlsparameter. bei diesen Befehlen werden alle bestandenen Befehlsparameter ignoriert.  
  
 Wenn der Befehl, dem eine Eingabe Bindung zugeordnet ist, ein <xref:System.Windows.Input.RoutedCommand>ist, <xref:System.Windows.Input.InputBinding.CommandParameter%2A> wird der der Eingabe Bindung durch die <xref:System.Windows.Input.ExecutedRoutedEventArgs> und <xref:System.Windows.Input.RoutedCommand> die <xref:System.Windows.Input.CanExecuteRoutedEventArgs> Ereignisdaten bei der Verarbeitung des Befehls an die Handler übermittelt.  
  
 Der Datentyp und Zweck des Befehls Parameters sind für jeden Befehl unterschiedlich definiert und können sein `null`. Sie können die <xref:System.Windows.Input.InputBinding.Command%2A>Eigenschaften, <xref:System.Windows.Input.InputBinding.CommandParameter%2A>und <xref:System.Windows.Input.InputBinding.CommandTarget%2A> an eine <xref:System.Windows.Input.ICommand> binden, die für ein-Objekt definiert ist. Dies ermöglicht es Ihnen, einen benutzerdefinierten Befehl zu definieren und ihn Benutzereingaben zuzuordnen. Weitere Informationen finden Sie im zweiten Beispiel unter <xref:System.Windows.Input.InputBinding>.  
  
 Die <xref:System.Windows.Input.InputBinding> -Klasse unterstützt die XAML-Verwendung nicht, da Sie keinen öffentlichen Parameter losen Konstruktor verfügbar macht (Sie verfügt über einen Parameter losen Konstruktor, der jedoch geschützt ist). Abgeleitete Klassen können jedoch einen öffentlichen Konstruktor verfügbar machen und können daher Eigenschaften festlegen, die von mit <xref:System.Windows.Input.InputBinding> der XAML-Verwendung geerbt werden. Zwei vorhandene <xref:System.Windows.Input.InputBinding> abgeleitete Klassen, die in XAML instanziiert werden können und Eigenschaften in XAML festlegen <xref:System.Windows.Input.KeyBinding> können <xref:System.Windows.Input.MouseBinding>, sind und.  
  
<a name="xamlAttributeUsage_CommandParameter"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<inputBindingDerivedClass CommandParameter="commandParameterString"/>  
```  
  
<a name="xamlPropertyElementUsage_CommandParameter"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<inputBindingDerivedClass>  
  <inputBindingDerivedClass.CommandParameter>  
    <commandParameterObject/>  
  </inputBindingDerivedClass.CommandParameter>  
</inputBindingDerivedClass>  
```  
  
<a name="xamlValues_CommandParameter"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 `inputBindingDerivedClass`  
 Eine abgeleitete Klasse <xref:System.Windows.Input.InputBinding> von, die Objekt Element Syntax unterstützt <xref:System.Windows.Input.KeyBinding> , <xref:System.Windows.Input.MouseBinding>z. b. oder. Siehe Hinweise.  
  
 `commandParameterString`  
 Eine Zeichenfolge, die von einem bestimmten Befehl verarbeitet wird. Zeichen folgen sind der allgemeine Typ, der für Befehlsparameter verwendet wird, da Sie problemlos in XAML festgelegt werden können. Das erwartete Zeichen folgen Format und dessen Zweck finden Sie in der Dokumentation für den jeweiligen Befehl, dem die Eingabe Bindung zugeordnet ist. Viele Befehle erwarten keine Parameter.  
  
 `commandParameterObject`  
 Ein Objekt, das von einem bestimmten Befehl verarbeitet wird. Alle vorhandenen [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Befehle verwenden Zeichen folgen. Daher ist diese Eigenschafts Element Syntax nur für benutzerdefinierte Befehls Szenarien relevant. Um diese Syntax zu unterstützen, muss `commandParameterObject` das-Objekt auch die Objekt Element Syntax unterstützen (muss einen öffentlichen Parameter losen Konstruktor aufweisen).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandParameterProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandParameterProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandParameterProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.InputBinding.CommandParameterProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandParameterProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandParameterProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandParameterProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.InputBinding.CommandParameterProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Input.InputBinding.CommandParameter" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.InputBinding.CommandProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.InputBinding.CommandProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Input.InputBinding.Command" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTarget">
      <MemberSignature Language="C#" Value="public System.Windows.IInputElement CommandTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.IInputElement CommandTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.CommandTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTarget As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::IInputElement ^ CommandTarget { System::Windows::IInputElement ^ get(); void set(System::Windows::IInputElement ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommandTarget : System.Windows.IInputElement with get, set" Usage="System.Windows.Input.InputBinding.CommandTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Zielelement des Befehls ab oder legt dieses fest.</summary>
        <value>Das Ziel des Befehls. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.InputBinding.CommandTarget%2A> Im Windows Presentation Foundation Befehlssystem <xref:System.Windows.Input.ICommandSource> <xref:System.Windows.Input.RoutedCommand>ist die-Eigenschaft für ein-Objekt nur anwendbar, wenn eine ist.<xref:System.Windows.Input.ICommand> Wenn <xref:System.Windows.Input.InputBinding.CommandTarget%2A> auf eine <xref:System.Windows.Input.ICommandSource> festgelegt und der entsprechende Befehl kein <xref:System.Windows.Input.RoutedCommand> ist, wird das Befehlsziel ignoriert.  
  
 Bei Verwendung mit einem <xref:System.Windows.Input.RoutedCommand>ist das Befehls Ziel das Objekt, für das das <xref:System.Windows.Input.CommandManager.Executed> - <xref:System.Windows.Input.CommandManager.CanExecute> Ereignis und das-Ereignis ausgelöst werden. Wenn die <xref:System.Windows.Input.InputBinding.CommandTarget%2A> -Eigenschaft nicht festgelegt ist, wird das-Element mit dem Tastaturfokus als Ziel verwendet.  
  
 Die <xref:System.Windows.Input.InputBinding> Klasse selbst unterstützt die XAML-Verwendung nicht, da Sie keinen öffentlichen Parameter losen Konstruktor verfügbar macht (es ist ein Parameter loser Konstruktor vorhanden, der jedoch geschützt ist). Abgeleitete Klassen können jedoch einen öffentlichen Konstruktor verfügbar machen und können daher Eigenschaften festlegen, die von <xref:System.Windows.Input.InputBinding> mit einer XAML-Verwendung geerbt werden. Zwei vorhandene <xref:System.Windows.Input.InputBinding> abgeleitete Klassen, die in XAML instanziiert werden können und Eigenschaften in XAML festlegen <xref:System.Windows.Input.KeyBinding> können <xref:System.Windows.Input.MouseBinding>, sind und.  
  
<a name="xamlAttributeUsage_CommandTarget"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<inputBindingDerivedClass CommandTarget="bindingToTarget"/>  
```  
  
<a name="xamlValues_CommandTarget"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 `inputBindingDerivedClass`  
 Eine abgeleitete Klasse <xref:System.Windows.Input.InputBinding> von, die Objekt Element Syntax unterstützt <xref:System.Windows.Input.KeyBinding> , <xref:System.Windows.Input.MouseBinding>z. b. oder. Siehe Hinweise.  
  
 `bindingToTarget`  
 Eine Zeichenfolge, die einen Typ von Bindungs Syntax verwendet, der einen Objekt Verweis auf ein vorhandenes benanntes Element zurückgeben kann. Siehe Hinweise.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTargetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandTargetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandTargetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.InputBinding.CommandTargetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandTargetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandTargetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandTargetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.InputBinding.CommandTargetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Input.InputBinding.CommandTarget" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="inputBinding.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine Instanz eines <see cref="T:System.Windows.Input.InputBinding" />-Objekts.</summary>
        <returns>Das neue Objekt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Gesture">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Input.InputGesture Gesture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputGesture Gesture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.InputBinding.Gesture" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Gesture As InputGesture" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Input::InputGesture ^ Gesture { System::Windows::Input::InputGesture ^ get(); void set(System::Windows::Input::InputGesture ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Gesture : System.Windows.Input.InputGesture with get, set" Usage="System.Windows.Input.InputBinding.Gesture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputGesture</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die dieser Eingabebindung zugeordnete <see cref="T:System.Windows.Input.InputGesture" />-Klasse ab oder legt diese fest.</summary>
        <value>Die zugeordnete Stiftbewegung. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Eingabe Geste ist die Aktion, die den Befehl aufruft. Beispiele für Eingabe Gesten in [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sind <xref:System.Windows.Input.KeyGesture> und <xref:System.Windows.Input.MouseGesture>. Eine <xref:System.Windows.Input.KeyGesture> ist eine Kombination aus <xref:System.Windows.Input.Key> einem und einem Satz <xref:System.Windows.Input.ModifierKeys>von. Eine <xref:System.Windows.Input.MouseGesture> ist eine Kombination aus <xref:System.Windows.Input.MouseAction> einem und einem Satz <xref:System.Windows.Input.ModifierKeys>von.  
  
 Die <xref:System.Windows.Input.InputBinding> Klasse selbst unterstützt die XAML-Verwendung nicht, da Sie keinen öffentlichen Parameter losen Konstruktor verfügbar macht (es ist ein Parameter loser Konstruktor vorhanden, der jedoch geschützt ist). Abgeleitete Klassen können jedoch einen öffentlichen Konstruktor verfügbar machen und können daher Eigenschaften festlegen, die von <xref:System.Windows.Input.InputBinding> mit einer XAML-Verwendung geerbt werden. Zwei vorhandene <xref:System.Windows.Input.InputBinding> abgeleitete Klassen, die in XAML instanziiert werden können und Eigenschaften in XAML festlegen <xref:System.Windows.Input.KeyBinding> können <xref:System.Windows.Input.MouseBinding>, sind und.  
  
<a name="xamlAttributeUsage_gesture"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
 <<xref:System.Windows.Input.KeyBinding> `Gesture`="<xref:System.Windows.Input.KeyGesture>"/>  
  
- oder -
  
 <<xref:System.Windows.Input.MouseBinding> `Gesture`="<xref:System.Windows.Input.MouseGesture>"/>  
  
- oder -
  
 <`inputBindingDerivedClass` `Gesture`="<xref:System.Windows.Input.InputGesture>"/>  
  
<a name="xamlPropertyElementUsage_gesture"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<inputBindingDerivedClass>  
  <inputBindingDerivedClass.Gesture>  
    <inputGestureImplementation/>  
  </inputBindingDerivedClass.Gesture>  
</inputBindingDerivedClass>  
```  
  
<a name="xamlValues_gesture"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 `inputBindingDerivedClass`  
 Eine abgeleitete Klasse <xref:System.Windows.Input.InputBinding> von, die Objekt Element Syntax unterstützt <xref:System.Windows.Input.KeyBinding> , <xref:System.Windows.Input.MouseBinding>z. b. oder. Siehe Hinweise.  
  
 `inputGestureImplementation`  
 Eine benutzerdefinierte abgeleitete <xref:System.Windows.Input.InputGesture> Klasse von, die die Objekt Element Syntax unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein <xref:System.Windows.Input.KeyBinding> -verwendet wird <xref:System.Windows.Input.KeyGesture> , um <xref:System.Windows.Input.RoutedCommand>eine an eine zu binden. Wenn ALT + L gedrückt wird, wird der <xref:System.Windows.Input.ApplicationCommands.Close%2A> Befehl aufgerufen. <xref:System.Windows.Input.KeyGesture>  
  
 [!code-xaml[commandlibrarysnippets#KeyBindingWithKeyAndModifiersXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml#keybindingwithkeyandmodifiersxaml)]  
  
 [!code-csharp[commandlibrarysnippets#KeyBindingWithKeyAndModifiers](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandLibrarySnippets/CSharp/Window1.xaml.cs#keybindingwithkeyandmodifiers)]
 [!code-vb[commandlibrarysnippets#KeyBindingWithKeyAndModifiers](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandLibrarySnippets/visualbasic/window1.xaml.vb#keybindingwithkeyandmodifiers)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.KeyGesture" />
        <altmember cref="T:System.Windows.Input.MouseGesture" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Das zu klonende Objekt.</param>
        <summary>Definiert die Instanz als fixierten Klon des angegebenen <see cref="T:System.Windows.Freezable" />-Objekts mithilfe von Basiseigenschaftswerten (nicht animiert).</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.InputBinding.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="inputBinding.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Das zu klonende Objekt.</param>
        <summary>Legt die aktuelle Instanz als fixierten Klon des angegebenen <see cref="T:System.Windows.Freezable" /> fest. Wenn das Objekt über animierte Abhängigkeitseigenschaften verfügt, werden die aktuellen animierten Werte kopiert.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
