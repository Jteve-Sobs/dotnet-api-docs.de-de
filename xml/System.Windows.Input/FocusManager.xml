<Type Name="FocusManager" FullName="System.Windows.Input.FocusManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1d6d9fcb88d7d279e85f852ae0f07a5a866d3b86" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39876940" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class FocusManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit FocusManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.FocusManager" />
  <TypeSignature Language="VB.NET" Value="Public Class FocusManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class FocusManager abstract sealed" />
  <TypeSignature Language="F#" Value="type FocusManager = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt eine Reihe statischer Methoden sowie angefügte Eigenschaften und Ereignisse bereit, um Fokusbereiche zu ermitteln und festzulegen und das fokussierte Element innerhalb des Bereichs festzulegen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Windows Presentation Foundation (WPF), es gibt zwei Konzepte, die Fokus betreffen: Tastaturfokus und logischer Fokus.  
  
 Der Tastaturfokus bezieht sich auf das Element, das derzeit Tastatureingaben empfängt.  Es kann nur ein Element mit dem Tastaturfokus vorhanden sein.  Dieses Element mit dem Tastaturfokus verfügt <xref:System.Windows.IInputElement.IsKeyboardFocused%2A> festgelegt `true`.  <xref:System.Windows.Input.Keyboard.FocusedElement%2A?displayProperty=nameWithType> Gibt das Element mit dem Tastaturfokus.  
  
 Der logische Fokus bezieht sich auf die <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> in einem bestimmten Fokusbereich.  
  
 Ein Fokusbereich ist ein Containerelement, das verfolgt die <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> innerhalb seines Bereichs.  In der Standardeinstellung die <xref:System.Windows.Window> Klasse ist als Fokusbereich festgelegt sind das <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, und <xref:System.Windows.Controls.ToolBar> Klassen.  Ein Element, das ist ein Fokusbereich ist <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> festgelegt `true`.  
  
 Es können mehrere Elemente mit dem logischem Fokus vorhanden sein, aber es kann nur ein Element mit dem logischem Fokus innerhalb eines Fokusbereichs vorhanden sein.  Ein Element mit dem logischem Fokus muss nicht notwendigerweise über den Tastaturfokus, aber ein Element mit Tastaturfokus wird über den logischen Fokus.  Es ist möglich, einen Fokusbereich in einem Fokusbereich zu definieren.  In diesem Fall können sowohl den Fokusbereich übergeordneten und untergeordneten Fokusbereich haben eine <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType>.  
  
 Das folgende Szenario veranschaulicht, wie sich der Tastaturfokus und logischer Fokus in einer WPF-Anwendung ändern, die eine <xref:System.Windows.Window> mit einer <xref:System.Windows.Controls.TextBox> und <xref:System.Windows.Controls.Menu> IValidator.h eine <xref:System.Windows.Controls.MenuItem>.  Wenn über den Tastaturfokus von geändert wird die <xref:System.Windows.Controls.TextBox> auf die <xref:System.Windows.Controls.MenuItem>, <xref:System.Windows.Controls.TextBox> Verluste über den Tastaturfokus, behält jedoch den logischen Fokus für die <xref:System.Windows.Window> Bereich konzentrieren.  Die <xref:System.Windows.Controls.MenuItem> erhält den Tastaturfokus sowie den logischen Fokus für das <xref:System.Windows.Controls.Menu> Bereich konzentrieren.  Wenn der Tastaturfokus zurückgibt, in das Stammverzeichnis <xref:System.Windows.Window>, das Element im <xref:System.Windows.Window> Fokusbereich mit dem logischem Fokus erhält den Tastaturfokus, die in diesem Fall ist die <xref:System.Windows.Controls.TextBox>.  Die <xref:System.Windows.Controls.TextBox> verfügt jetzt über den Tastaturfokus und logischer Fokus.  Die <xref:System.Windows.Controls.MenuItem> den Tastaturfokus verliert, behält jedoch den logischen Fokus für das <xref:System.Windows.Controls.Menu> Bereich konzentrieren.  
  
 Der Standardwert von <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> auf eine <xref:System.Windows.Window>, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ToolBar>, und <xref:System.Windows.Controls.ContextMenu> ist `true`.  
  
 Weitere Informationen zu konzentrieren, finden Sie unter den [Übersicht über die Eingabe](~/docs/framework/wpf/advanced/input-overview.md) und [Fokus – Übersicht](~/docs/framework/wpf/advanced/focus-overview.md).  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddGotFocusHandler">
      <MemberSignature Language="C#" Value="public static void AddGotFocusHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddGotFocusHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.AddGotFocusHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddGotFocusHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddGotFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddGotFocusHandler : System.Windows.DependencyObject * System.Windows.RoutedEventHandler -&gt; unit" Usage="System.Windows.Input.FocusManager.AddGotFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der hinzuzufügende Ereignishandler.</param>
        <summary>Fügt einen Handler für das angefügte <see cref="E:System.Windows.Input.FocusManager.GotFocus" />-Ereignis hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLostFocusHandler">
      <MemberSignature Language="C#" Value="public static void AddLostFocusHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddLostFocusHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.AddLostFocusHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddLostFocusHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddLostFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddLostFocusHandler : System.Windows.DependencyObject * System.Windows.RoutedEventHandler -&gt; unit" Usage="System.Windows.Input.FocusManager.AddLostFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der hinzuzufügende Ereignishandler.</param>
        <summary>Fügt einen Handler für das angefügte <see cref="E:System.Windows.Input.FocusManager.LostFocus" />-Ereignis hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusedElement">
      <MemberSignature Language="C#" Value="see GetFocusedElement, and SetFocusedElement" />
      <MemberSignature Language="ILAsm" Value="see GetFocusedElement, and SetFocusedElement" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.FocusManager.FocusedElement" />
      <MemberSignature Language="VB.NET" Value="see GetFocusedElement, and SetFocusedElement" />
      <MemberSignature Language="F#" Value="see GetFocusedElement, and SetFocusedElement" Usage="see GetFocusedElement, and SetFocusedElement" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ermittelt, ob das Element, an das diese Eigenschaft angefügt ist, über den logischen Fokus verfügt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Input.FocusManager.FocusedElement%2A> ist das Element, das logischen Fokus für einen bestimmten Fokusbereich verfügt.  Dieses Objekt kann nicht haben oder über den Tastaturfokus.  Tastaturfokus bezieht sich auf das Element, das Tastatureingaben empfängt.  Weitere Informationen zu den Fokus, über den Tastaturfokus und logischer Fokus zu erhalten, finden Sie unter den [Übersicht über die Eingabe](~/docs/framework/wpf/advanced/input-overview.md).  
  
 <xref:System.Windows.Input.FocusManager.GetFocusedElement%2A> und <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A> kann zum Abrufen und Festlegen von das Fokuselement im angegebenen Fokusbereich verwendet werden.  
  
<a name="dependencyPropertyInfo_FocusedElement"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Input.FocusManager.FocusedElementProperty>|  
|Metadaten-Eigenschaften festgelegt, um **"true"**|None|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie eine <xref:System.Windows.Controls.Button> das fokussierte Element.  
  
 [!code-xml[markupsnippets#MarkupFocusManagerFocusedElementXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/MarkupSnippets/CSharp/Window1.xaml#markupfocusmanagerfocusedelementxaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusedElementProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusedElementProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusedElementProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.FocusManager.FocusedElementProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusedElementProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusedElementProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusedElementProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.FocusManager.FocusedElementProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Input.FocusManager.FocusedElement" />-Eigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFocusedElement">
      <MemberSignature Language="C#" Value="public static System.Windows.IInputElement GetFocusedElement (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.IInputElement GetFocusedElement(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.GetFocusedElement(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFocusedElement (element As DependencyObject) As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::IInputElement ^ GetFocusedElement(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFocusedElement : System.Windows.DependencyObject -&gt; System.Windows.IInputElement" Usage="System.Windows.Input.FocusManager.GetFocusedElement element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Das Element mit dem logischem Fokus im angegebenen Fokusbereich.</param>
        <summary>Ruft das Element mit dem logischem Fokus im angegebenen Fokusbereich ab.</summary>
        <returns>Das Element im angegebenen Fokusbereich mit dem logischem Fokus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Input.FocusManager.FocusedElement%2A> ist das Element, das logischen Fokus für einen bestimmten Fokusbereich verfügt.  Dieses Objekt kann nicht haben oder über den Tastaturfokus.  Tastaturfokus bezieht sich auf das Element, das Tastatureingaben empfängt.  Weitere Informationen zu den Fokus, über den Tastaturfokus und logischer Fokus zu erhalten, finden Sie unter den [Übersicht über die Eingabe](~/docs/framework/wpf/advanced/input-overview.md).  
  
 Wenn `element` kein Fokusbereich ist, gibt diese Methode zurück `null`.  
  
 Verwendung <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A>, um anzugeben, das Element mit dem logischem Fokus in einem angegebenen Fokusbereich.  
  
   
  
## Examples  
 Im folgende Beispiel wird das Element mit dem logischem Fokus mithilfe der <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A> und es wird das Element mit dem logischem Fokus über die <xref:System.Windows.Input.FocusManager.GetFocusedElement%2A>.  
  
 [!code-csharp[focussnippets#FocusGetSetFocusedElement](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSnippets/CSharp/Window1.xaml.cs#focusgetsetfocusedelement)]
 [!code-vb[focussnippets#FocusGetSetFocusedElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSnippets/visualbasic/window1.xaml.vb#focusgetsetfocusedelement)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFocusScope">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyObject GetFocusScope (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyObject GetFocusScope(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.GetFocusScope(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFocusScope (element As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyObject ^ GetFocusScope(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFocusScope : System.Windows.DependencyObject -&gt; System.Windows.DependencyObject" Usage="System.Windows.Input.FocusManager.GetFocusScope element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, für das der nächste Fokusbereich abgerufen werden soll.</param>
        <summary>Ermittelt den nächsten Vorgänger des angegebenen Elements, dessen <see cref="P:System.Windows.Input.FocusManager.IsFocusScope" /> auf <see langword="true" /> festgelegt ist.</summary>
        <returns>Der Fokusbereich für das angegebene Element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert von <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> auf eine <xref:System.Windows.Window>, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ToolBar>, <xref:System.Windows.Controls.ContextMenu> ist `true`.  
  
 Ein Fokusbereich ist ein Containerelement, das verfolgt die <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> innerhalb seines Bereichs.  In der Standardeinstellung die <xref:System.Windows.Window> Klasse ist als Fokusbereich festgelegt sind das <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, und <xref:System.Windows.Controls.ToolBar> Klassen.  Ein Element, das ist ein Fokusbereich ist <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> festgelegt `true`.  
  
 Weitere Informationen zu den Fokus, über den Tastaturfokus und logischer Fokus zu erhalten, finden Sie unter den [Übersicht über die Eingabe](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetIsFocusScope">
      <MemberSignature Language="C#" Value="public static bool GetIsFocusScope (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GetIsFocusScope(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.GetIsFocusScope(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIsFocusScope (element As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GetIsFocusScope(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetIsFocusScope : System.Windows.DependencyObject -&gt; bool" Usage="System.Windows.Input.FocusManager.GetIsFocusScope element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, von dem die angefügte Eigenschaft gelesen werden soll.</param>
        <summary>Ermittelt, ob das angegebene <see cref="T:System.Windows.DependencyObject" /> ein Fokusbereich ist.</summary>
        <returns>
          <see langword="true" />, wenn <see cref="P:System.Windows.Input.FocusManager.IsFocusScope" /> für das angegebene Element auf <see langword="true" /> festgelegt ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Fokusbereich ist ein Containerelement, das verfolgt die <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> innerhalb seines Bereichs.  In der Standardeinstellung die <xref:System.Windows.Window> Klasse ist als Fokusbereich festgelegt sind das <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, und <xref:System.Windows.Controls.ToolBar> Klassen.  Ein Element, das ist ein Fokusbereich ist <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> festgelegt `true`.  
  
 Weitere Informationen zu den Fokus, über den Tastaturfokus und logischer Fokus zu erhalten, finden Sie unter den [Übersicht über die Eingabe](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="see AddGotFocusHandler, and RemoveGotFocusHandler" />
      <MemberSignature Language="ILAsm" Value="see AddGotFocusHandler, and RemoveGotFocusHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.FocusManager.GotFocus" />
      <MemberSignature Language="VB.NET" Value="see AddGotFocusHandler, and RemoveGotFocusHandler" />
      <MemberSignature Language="F#" Value="see AddGotFocusHandler, and RemoveGotFocusHandler" Usage="see AddGotFocusHandler, and RemoveGotFocusHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tritt ein, wenn ein Element den Fokus erhält.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.FocusManager.GotFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.FocusManager.GotFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet das angefügte <see cref="E:System.Windows.Input.FocusManager.GotFocus" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocusScope">
      <MemberSignature Language="C#" Value="see GetIsFocusScope, and SetIsFocusScope" />
      <MemberSignature Language="ILAsm" Value="see GetIsFocusScope, and SetIsFocusScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.FocusManager.IsFocusScope" />
      <MemberSignature Language="VB.NET" Value="see GetIsFocusScope, and SetIsFocusScope" />
      <MemberSignature Language="F#" Value="see GetIsFocusScope, and SetIsFocusScope" Usage="see GetIsFocusScope, and SetIsFocusScope" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ermittelt, ob das Element, an das diese Eigenschaft angefügt ist, einen Fokusbereich darstellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Fokusbereich ist ein Containerelement, das verfolgt die <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> innerhalb seines Bereichs.  In der Standardeinstellung die <xref:System.Windows.Window> Klasse ist als Fokusbereich festgelegt sind das <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, und <xref:System.Windows.Controls.ToolBar> Klassen.  Ein Element, das ist ein Fokusbereich ist <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> festgelegt `true`.  
  
 Weitere Informationen zu den Fokus, über den Tastaturfokus und logischer Fokus zu erhalten, finden Sie unter den [Übersicht über die Eingabe](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="dependencyPropertyInfo_IsFocusScope"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Input.FocusManager.IsFocusScopeProperty>|  
|Metadaten-Eigenschaften festgelegt, um **"true"**|None|  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Windows.Controls.StackPanel> als Fokusbereich festgelegt.  
  
 [!code-xml[markupsnippets#MarkupIsFocusScopeXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/MarkupSnippets/CSharp/Window1.xaml#markupisfocusscopexaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocusScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFocusScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFocusScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.FocusManager.IsFocusScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFocusScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFocusScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsFocusScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.FocusManager.IsFocusScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Input.FocusManager.IsFocusScope" />-Eigenschaft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert von <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> auf eine <xref:System.Windows.Window>, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ToolBar>, <xref:System.Windows.Controls.ContextMenu> ist `true`.  
  
 Ein Fokusbereich ist ein Containerelement, das verfolgt die <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> innerhalb seines Bereichs.  In der Standardeinstellung die <xref:System.Windows.Window> Klasse ist als Fokusbereich festgelegt sind das <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, und <xref:System.Windows.Controls.ToolBar> Klassen.  Ein Element, das ist ein Fokusbereich ist <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> festgelegt `true`.  
  
 Weitere Informationen zu den Fokus, über den Tastaturfokus und logischer Fokus zu erhalten, finden Sie unter den [Übersicht über die Eingabe](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="see AddLostFocusHandler, and RemoveLostFocusHandler" />
      <MemberSignature Language="ILAsm" Value="see AddLostFocusHandler, and RemoveLostFocusHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.FocusManager.LostFocus" />
      <MemberSignature Language="VB.NET" Value="see AddLostFocusHandler, and RemoveLostFocusHandler" />
      <MemberSignature Language="F#" Value="see AddLostFocusHandler, and RemoveLostFocusHandler" Usage="see AddLostFocusHandler, and RemoveLostFocusHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tritt auf, wenn ein Element den Fokus verliert.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.FocusManager.LostFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.FocusManager.LostFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet das angefügte <see cref="E:System.Windows.Input.FocusManager.LostFocus" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveGotFocusHandler">
      <MemberSignature Language="C#" Value="public static void RemoveGotFocusHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveGotFocusHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.RemoveGotFocusHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveGotFocusHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveGotFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveGotFocusHandler : System.Windows.DependencyObject * System.Windows.RoutedEventHandler -&gt; unit" Usage="System.Windows.Input.FocusManager.RemoveGotFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der zu entfernende Ereignishandler.</param>
        <summary>Entfernt einen Handler für das angefügte <see cref="E:System.Windows.Input.FocusManager.GotFocus" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveLostFocusHandler">
      <MemberSignature Language="C#" Value="public static void RemoveLostFocusHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveLostFocusHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.RemoveLostFocusHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveLostFocusHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveLostFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveLostFocusHandler : System.Windows.DependencyObject * System.Windows.RoutedEventHandler -&gt; unit" Usage="System.Windows.Input.FocusManager.RemoveLostFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der zu entfernende Ereignishandler.</param>
        <summary>Entfernt einen Handler für das angefügte <see cref="E:System.Windows.Input.FocusManager.LostFocus" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetFocusedElement">
      <MemberSignature Language="C#" Value="public static void SetFocusedElement (System.Windows.DependencyObject element, System.Windows.IInputElement value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFocusedElement(class System.Windows.DependencyObject element, class System.Windows.IInputElement value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.SetFocusedElement(System.Windows.DependencyObject,System.Windows.IInputElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFocusedElement (element As DependencyObject, value As IInputElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFocusedElement(System::Windows::DependencyObject ^ element, System::Windows::IInputElement ^ value);" />
      <MemberSignature Language="F#" Value="static member SetFocusedElement : System.Windows.DependencyObject * System.Windows.IInputElement -&gt; unit" Usage="System.Windows.Input.FocusManager.SetFocusedElement (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.IInputElement" />
      </Parameters>
      <Docs>
        <param name="element">Der Fokusbereich, in dem das angegebene Element als <see cref="P:System.Windows.Input.FocusManager.FocusedElement" /> festgelegt werden soll.</param>
        <param name="value">Das Element, das den logischen Fokus erhalten soll.</param>
        <summary>Legt den logischen Fokus für das angegebene Element fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Input.FocusManager.FocusedElement%2A> ist das Element, das logischen Fokus für einen bestimmten Fokusbereich verfügt.  Dieses Objekt kann nicht haben oder über den Tastaturfokus.  Tastaturfokus bezieht sich auf das Element, das Tastatureingaben empfängt.  Weitere Informationen zu den Fokus, über den Tastaturfokus und logischer Fokus zu erhalten, finden Sie unter den [Übersicht über die Eingabe](~/docs/framework/wpf/advanced/input-overview.md).  
  
 Es ist möglich, einen Fokusbereich angeben, der ein Vorgänger des Fokusbereich ist, in das Element enthalten ist.  Z. B. wenn ein <xref:System.Windows.Controls.StackPanel> wird als Fokusbereich festgelegt und seinem übergeordneten Element <xref:System.Windows.Window> ein Fokusbereich ist ein <xref:System.Windows.Controls.TextBox> untergeordnetes Element des der <xref:System.Windows.Controls.StackPanel> angeben der <xref:System.Windows.Window> als Fokusbereich beim Aufrufen von <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A>.  Die <xref:System.Windows.Controls.TextBox> ist <xref:System.Windows.Input.FocusManager.FocusedElement%2A> für beide die <xref:System.Windows.Window> Bereich konzentrieren und die <xref:System.Windows.Controls.StackPanel> Bereich konzentrieren.  
  
 <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A> den angegebene Element logischen Fokus im angegebenen Fokusbereich erhalten und versucht, die den Element den Tastaturfokus erhalten.  
  
   
  
## Examples  
 Im folgende Beispiel wird das Element mit dem logischem Fokus mithilfe der <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A> und es wird das Element mit dem logischem Fokus über die <xref:System.Windows.Input.FocusManager.GetFocusedElement%2A>.  
  
 [!code-csharp[focussnippets#FocusGetSetFocusedElement](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSnippets/CSharp/Window1.xaml.cs#focusgetsetfocusedelement)]
 [!code-vb[focussnippets#FocusGetSetFocusedElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSnippets/visualbasic/window1.xaml.vb#focusgetsetfocusedelement)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetIsFocusScope">
      <MemberSignature Language="C#" Value="public static void SetIsFocusScope (System.Windows.DependencyObject element, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetIsFocusScope(class System.Windows.DependencyObject element, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.SetIsFocusScope(System.Windows.DependencyObject,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetIsFocusScope (element As DependencyObject, value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetIsFocusScope(System::Windows::DependencyObject ^ element, bool value);" />
      <MemberSignature Language="F#" Value="static member SetIsFocusScope : System.Windows.DependencyObject * bool -&gt; unit" Usage="System.Windows.Input.FocusManager.SetIsFocusScope (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, das als Fokusbereich festgelegt werden soll.</param>
        <param name="value">
          <see langword="true" />, wenn <c>element</c> ein Fokusbereich ist, andernfalls <see langword="false" />.</param>
        <summary>Legt das angegebene <see cref="T:System.Windows.DependencyObject" /> als Fokusbereich fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Fokusbereich ist ein Containerelement, das verfolgt die <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> innerhalb seines Bereichs.  In der Standardeinstellung die <xref:System.Windows.Window> Klasse ist als Fokusbereich festgelegt sind das <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, und <xref:System.Windows.Controls.ToolBar> Klassen.  Ein Element, das ist ein Fokusbereich ist <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> festgelegt `true`.  
  
 Weitere Informationen zu den Fokus, über den Tastaturfokus und logischer Fokus zu erhalten, finden Sie unter den [Übersicht über die Eingabe](~/docs/framework/wpf/advanced/input-overview.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Element einen Fokusbereich mit <xref:System.Windows.Input.FocusManager.SetIsFocusScope%2A>.  
  
 [!code-csharp[focussnippets#FocusSetIsFocusScope](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSnippets/CSharp/Window1.xaml.cs#focussetisfocusscope)]
 [!code-vb[focussnippets#FocusSetIsFocusScope](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSnippets/visualbasic/window1.xaml.vb#focussetisfocusscope)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>