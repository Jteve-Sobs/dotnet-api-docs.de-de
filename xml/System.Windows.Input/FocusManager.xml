<Type Name="FocusManager" FullName="System.Windows.Input.FocusManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="83d83150d64a10e751976181c0d5499bc4228676" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69173068" /></Metadata><TypeSignature Language="C#" Value="public static class FocusManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit FocusManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.FocusManager" />
  <TypeSignature Language="VB.NET" Value="Public Class FocusManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class FocusManager abstract sealed" />
  <TypeSignature Language="F#" Value="type FocusManager = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt eine Reihe statischer Methoden sowie angefügte Eigenschaften und Ereignisse bereit, um Fokusbereiche zu ermitteln und festzulegen und das fokussierte Element innerhalb des Bereichs festzulegen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Windows Presentation Foundation (WPF) gibt es zwei Konzepte, die den Fokus betreffen: Tastaturfokus und logischer Fokus.  
  
 Der Tastaturfokus bezieht sich auf das Element, das derzeit Tastatureingaben empfängt.  Es darf nur ein Element mit dem Tastaturfokus vorhanden sein.  Dieses Element mit dem Tastaturfokus <xref:System.Windows.IInputElement.IsKeyboardFocused%2A> ist auf `true`festgelegt.  <xref:System.Windows.Input.Keyboard.FocusedElement%2A?displayProperty=nameWithType>Gibt das Element mit dem Tastaturfokus zurück.  
  
 Der logische Fokus bezieht sich auf <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> die innerhalb eines bestimmten Fokusbereichs.  
  
 Ein Fokusbereich ist ein Containerelement, das den <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> innerhalb seines Bereichs verfolgt.  Standardmäßig ist die <xref:System.Windows.Window> -Klasse ein Schwerpunktbereich, ebenso wie <xref:System.Windows.Controls.Menu>die <xref:System.Windows.Controls.ContextMenu>Klassen, <xref:System.Windows.Controls.ToolBar> und.  Ein Element, bei dem es sich um <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> `true`einen Fokusbereich handelt.  
  
 Es können mehrere Elemente mit logischem Fokus vorhanden sein, aber es kann nur ein Element mit logischem Fokus innerhalb eines einzelnen Fokusbereichs vorhanden sein.  Ein Element mit dem logischen Fokus hat nicht unbedingt den Tastaturfokus, aber ein Element mit dem Tastaturfokus hat den logischen Fokus.  Es ist möglich, einen Schwerpunktbereich innerhalb eines Schwerpunktbereichs zu definieren.  In diesem Fall können sowohl der übergeordnete Fokusbereich als auch der untergeordnete Fokusbereich <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType>über einen verfügen.  
  
 Im folgenden <xref:System.Windows.Window> Szenario wird veranschaulicht, <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.Menu> <xref:System.Windows.Controls.MenuItem>wie der Tastaturfokus und der logische Fokus in einer WPF-Anwendung geändert werden  Wenn sich der Tastaturfokus von <xref:System.Windows.Controls.TextBox> der in <xref:System.Windows.Controls.MenuItem>den ändert <xref:System.Windows.Controls.TextBox> , ist der Tastaturfokus verloren, behält jedoch <xref:System.Windows.Window> den logischen Fokus für den Fokusbereich.  Der <xref:System.Windows.Controls.MenuItem> erhält Tastaturfokus und erhält den logischen Fokus für <xref:System.Windows.Controls.Menu> den Schwerpunktbereich.  Wenn der Tastaturfokus zum <xref:System.Windows.Window>Stamm zurückkehrt, erhält das Element im <xref:System.Windows.Window> Fokusbereich mit logischem Fokus den Tastaturfokus, was in diesem Fall <xref:System.Windows.Controls.TextBox>der ist.  Der <xref:System.Windows.Controls.TextBox> verfügt jetzt über Tastaturfokus und logischer Fokus.  Das <xref:System.Windows.Controls.MenuItem> verliert den Tastaturfokus, behält aber den logischen Fokus <xref:System.Windows.Controls.Menu> für den Schwerpunktbereich bei.  
  
 Der Standardwert von <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> <xref:System.Windows.Window>für, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ToolBar>und <xref:System.Windows.Controls.ContextMenu> ist. `true`  
  
 Weitere Informationen zum Fokus finden Sie in der Übersicht über die [Eingaben](~/docs/framework/wpf/advanced/input-overview.md) und den [Fokus](~/docs/framework/wpf/advanced/focus-overview.md).  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddGotFocusHandler">
      <MemberSignature Language="C#" Value="public static void AddGotFocusHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddGotFocusHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.AddGotFocusHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddGotFocusHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddGotFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddGotFocusHandler : System.Windows.DependencyObject * System.Windows.RoutedEventHandler -&gt; unit" Usage="System.Windows.Input.FocusManager.AddGotFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler, der hinzugefügt werden soll.</param>
        <summary>Fügt einen Handler für das angefügte <see cref="E:System.Windows.Input.FocusManager.GotFocus" /> -Ereignis hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLostFocusHandler">
      <MemberSignature Language="C#" Value="public static void AddLostFocusHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddLostFocusHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.AddLostFocusHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddLostFocusHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddLostFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddLostFocusHandler : System.Windows.DependencyObject * System.Windows.RoutedEventHandler -&gt; unit" Usage="System.Windows.Input.FocusManager.AddLostFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" /> , das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler, der hinzugefügt werden soll.</param>
        <summary>Fügt einen Handler für das angefügte <see cref="E:System.Windows.Input.FocusManager.LostFocus" />-Ereignis hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusedElement">
      <MemberSignature Language="C#" Value="see GetFocusedElement, and SetFocusedElement" />
      <MemberSignature Language="ILAsm" Value="see GetFocusedElement, and SetFocusedElement" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.FocusManager.FocusedElement" />
      <MemberSignature Language="VB.NET" Value="see GetFocusedElement, and SetFocusedElement" />
      <MemberSignature Language="F#" Value="see GetFocusedElement, and SetFocusedElement" Usage="see GetFocusedElement, and SetFocusedElement" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ermittelt, ob das Element, an das diese Eigenschaft angefügt ist, über den logischen Fokus verfügt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Windows.Input.FocusManager.FocusedElement%2A> -Element ist das Element, das den logischen Fokus für einen bestimmten Fokusbereich hat.  Dieses Objekt kann den Tastaturfokus haben oder nicht.  Der Tastaturfokus bezieht sich auf das Element, das Tastatureingaben empfängt.  Weitere Informationen zum Fokus, Tastaturfokus und logischer Fokus finden Sie in der [Eingabe Übersicht](~/docs/framework/wpf/advanced/input-overview.md).  
  
 <xref:System.Windows.Input.FocusManager.GetFocusedElement%2A>und <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A> können verwendet werden, um das fokussierte Element innerhalb des angegebenen Fokusbereichs zu erhalten und festzulegen.  
  
<a name="dependencyPropertyInfo_FocusedElement"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Input.FocusManager.FocusedElementProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie <xref:System.Windows.Controls.Button> das fokussierte Element erstellen.  
  
 [!code-xml[markupsnippets#MarkupFocusManagerFocusedElementXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/MarkupSnippets/CSharp/Window1.xaml#markupfocusmanagerfocusedelementxaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusedElementProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusedElementProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusedElementProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.FocusManager.FocusedElementProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusedElementProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusedElementProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusedElementProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.FocusManager.FocusedElementProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Input.FocusManager.FocusedElement" />-Eigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFocusedElement">
      <MemberSignature Language="C#" Value="public static System.Windows.IInputElement GetFocusedElement (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.IInputElement GetFocusedElement(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.GetFocusedElement(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFocusedElement (element As DependencyObject) As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::IInputElement ^ GetFocusedElement(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFocusedElement : System.Windows.DependencyObject -&gt; System.Windows.IInputElement" Usage="System.Windows.Input.FocusManager.GetFocusedElement element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Das Element mit dem logischem Fokus im angegebenen Fokusbereich.</param>
        <summary>Ruft das Element mit dem logischem Fokus im angegebenen Fokusbereich ab.</summary>
        <returns>Das Element im angegebenen Fokusbereich mit dem logischem Fokus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Windows.Input.FocusManager.FocusedElement%2A> -Element ist das Element, das den logischen Fokus für einen bestimmten Fokusbereich hat.  Dieses Objekt kann den Tastaturfokus haben oder nicht.  Der Tastaturfokus bezieht sich auf das Element, das Tastatureingaben empfängt.  Weitere Informationen zum Fokus, Tastaturfokus und logischer Fokus finden Sie in der [Eingabe Übersicht](~/docs/framework/wpf/advanced/input-overview.md).  
  
 Wenn `element` kein Fokusbereich ist, wird von dieser Methode zurück `null`gegeben.  
  
 Verwenden <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A>Sie, um das Element mit dem logischen Fokus innerhalb eines angegebenen Fokusbereichs anzugeben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das-Element mit dem <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A> logischen Fokus mithilfe von festgelegt, und das-Element mit dem logischen Fokus wird mithilfe des <xref:System.Windows.Input.FocusManager.GetFocusedElement%2A>-Elements abgerufen.  
  
 [!code-csharp[focussnippets#FocusGetSetFocusedElement](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSnippets/CSharp/Window1.xaml.cs#focusgetsetfocusedelement)]
 [!code-vb[focussnippets#FocusGetSetFocusedElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSnippets/visualbasic/window1.xaml.vb#focusgetsetfocusedelement)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="element" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFocusScope">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyObject GetFocusScope (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyObject GetFocusScope(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.GetFocusScope(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFocusScope (element As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyObject ^ GetFocusScope(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFocusScope : System.Windows.DependencyObject -&gt; System.Windows.DependencyObject" Usage="System.Windows.Input.FocusManager.GetFocusScope element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, für das der nächste Fokusbereich abgerufen werden soll.</param>
        <summary>Ermittelt den nächsten Vorgänger des angegebenen Elements, dessen <see cref="P:System.Windows.Input.FocusManager.IsFocusScope" /> auf <see langword="true" /> festgelegt ist.</summary>
        <returns>Der Fokusbereich für das angegebene Element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert von <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> <xref:System.Windows.Window>in, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ToolBar>, <xref:System.Windows.Controls.ContextMenu> ist. `true`  
  
 Ein Fokusbereich ist ein Containerelement, das den <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> innerhalb seines Bereichs verfolgt.  Standardmäßig ist die <xref:System.Windows.Window> -Klasse ein Schwerpunktbereich, ebenso wie <xref:System.Windows.Controls.Menu>die <xref:System.Windows.Controls.ContextMenu>Klassen, <xref:System.Windows.Controls.ToolBar> und.  Ein Element, bei dem es sich um <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> `true`einen Fokusbereich handelt.  
  
 Weitere Informationen zum Fokus, Tastaturfokus und logischer Fokus finden Sie in der [Eingabe Übersicht](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="element" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetIsFocusScope">
      <MemberSignature Language="C#" Value="public static bool GetIsFocusScope (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GetIsFocusScope(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.GetIsFocusScope(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIsFocusScope (element As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GetIsFocusScope(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetIsFocusScope : System.Windows.DependencyObject -&gt; bool" Usage="System.Windows.Input.FocusManager.GetIsFocusScope element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, von dem die angefügte Eigenschaft gelesen werden soll.</param>
        <summary>Ermittelt, ob das angegebene <see cref="T:System.Windows.DependencyObject" /> ein Fokusbereich ist.</summary>
        <returns><see langword="true" />, wenn <see cref="P:System.Windows.Input.FocusManager.IsFocusScope" /> für das angegebene Element auf <see langword="true" /> festgelegt ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Fokusbereich ist ein Containerelement, das den <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> innerhalb seines Bereichs verfolgt.  Standardmäßig ist die <xref:System.Windows.Window> -Klasse ein Schwerpunktbereich, ebenso wie <xref:System.Windows.Controls.Menu>die <xref:System.Windows.Controls.ContextMenu>Klassen, <xref:System.Windows.Controls.ToolBar> und.  Ein Element, bei dem es sich um <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> `true`einen Fokusbereich handelt.  
  
 Weitere Informationen zum Fokus, Tastaturfokus und logischer Fokus finden Sie in der [Eingabe Übersicht](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="see AddGotFocusHandler, and RemoveGotFocusHandler" />
      <MemberSignature Language="ILAsm" Value="see AddGotFocusHandler, and RemoveGotFocusHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.FocusManager.GotFocus" />
      <MemberSignature Language="VB.NET" Value="see AddGotFocusHandler, and RemoveGotFocusHandler" />
      <MemberSignature Language="F#" Value="see AddGotFocusHandler, and RemoveGotFocusHandler" Usage="see AddGotFocusHandler, and RemoveGotFocusHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tritt ein, wenn ein Element den Fokus erhält.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.FocusManager.GotFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.FocusManager.GotFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet das angefügte <see cref="E:System.Windows.Input.FocusManager.GotFocus" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocusScope">
      <MemberSignature Language="C#" Value="see GetIsFocusScope, and SetIsFocusScope" />
      <MemberSignature Language="ILAsm" Value="see GetIsFocusScope, and SetIsFocusScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.FocusManager.IsFocusScope" />
      <MemberSignature Language="VB.NET" Value="see GetIsFocusScope, and SetIsFocusScope" />
      <MemberSignature Language="F#" Value="see GetIsFocusScope, and SetIsFocusScope" Usage="see GetIsFocusScope, and SetIsFocusScope" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ermittelt, ob das Element, an das diese Eigenschaft angefügt ist, einen Fokusbereich darstellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Fokusbereich ist ein Containerelement, das den <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> innerhalb seines Bereichs verfolgt.  Standardmäßig ist die <xref:System.Windows.Window> -Klasse ein Schwerpunktbereich, ebenso wie <xref:System.Windows.Controls.Menu>die <xref:System.Windows.Controls.ContextMenu>Klassen, <xref:System.Windows.Controls.ToolBar> und.  Ein Element, bei dem es sich um <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> `true`einen Fokusbereich handelt.  
  
 Weitere Informationen zum Fokus, Tastaturfokus und logischer Fokus finden Sie in der [Eingabe Übersicht](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="dependencyPropertyInfo_IsFocusScope"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Input.FocusManager.IsFocusScopeProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.Windows.Controls.StackPanel> Fokusbereich erstellt.  
  
 [!code-xml[markupsnippets#MarkupIsFocusScopeXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/MarkupSnippets/CSharp/Window1.xaml#markupisfocusscopexaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocusScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFocusScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFocusScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.FocusManager.IsFocusScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFocusScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFocusScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsFocusScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.FocusManager.IsFocusScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Input.FocusManager.IsFocusScope" />-Eigenschaft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert von <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> <xref:System.Windows.Window>in, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ToolBar>, <xref:System.Windows.Controls.ContextMenu> ist. `true`  
  
 Ein Fokusbereich ist ein Containerelement, das den <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> innerhalb seines Bereichs verfolgt.  Standardmäßig ist die <xref:System.Windows.Window> -Klasse ein Schwerpunktbereich, ebenso wie <xref:System.Windows.Controls.Menu>die <xref:System.Windows.Controls.ContextMenu>Klassen, <xref:System.Windows.Controls.ToolBar> und.  Ein Element, bei dem es sich um <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> `true`einen Fokusbereich handelt.  
  
 Weitere Informationen zum Fokus, Tastaturfokus und logischer Fokus finden Sie in der [Eingabe Übersicht](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="see AddLostFocusHandler, and RemoveLostFocusHandler" />
      <MemberSignature Language="ILAsm" Value="see AddLostFocusHandler, and RemoveLostFocusHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.FocusManager.LostFocus" />
      <MemberSignature Language="VB.NET" Value="see AddLostFocusHandler, and RemoveLostFocusHandler" />
      <MemberSignature Language="F#" Value="see AddLostFocusHandler, and RemoveLostFocusHandler" Usage="see AddLostFocusHandler, and RemoveLostFocusHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tritt auf, wenn ein Element den Fokus verliert.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.FocusManager.LostFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.FocusManager.LostFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet das angefügte <see cref="E:System.Windows.Input.FocusManager.LostFocus" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveGotFocusHandler">
      <MemberSignature Language="C#" Value="public static void RemoveGotFocusHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveGotFocusHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.RemoveGotFocusHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveGotFocusHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveGotFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveGotFocusHandler : System.Windows.DependencyObject * System.Windows.RoutedEventHandler -&gt; unit" Usage="System.Windows.Input.FocusManager.RemoveGotFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler, der entfernt werden soll.</param>
        <summary>Entfernt einen Handler für das angefügte <see cref="E:System.Windows.Input.FocusManager.GotFocus" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveLostFocusHandler">
      <MemberSignature Language="C#" Value="public static void RemoveLostFocusHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveLostFocusHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.RemoveLostFocusHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveLostFocusHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveLostFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveLostFocusHandler : System.Windows.DependencyObject * System.Windows.RoutedEventHandler -&gt; unit" Usage="System.Windows.Input.FocusManager.RemoveLostFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler, der entfernt werden soll.</param>
        <summary>Entfernt einen Handler für das angefügte <see cref="E:System.Windows.Input.FocusManager.LostFocus" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetFocusedElement">
      <MemberSignature Language="C#" Value="public static void SetFocusedElement (System.Windows.DependencyObject element, System.Windows.IInputElement value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFocusedElement(class System.Windows.DependencyObject element, class System.Windows.IInputElement value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.SetFocusedElement(System.Windows.DependencyObject,System.Windows.IInputElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFocusedElement (element As DependencyObject, value As IInputElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFocusedElement(System::Windows::DependencyObject ^ element, System::Windows::IInputElement ^ value);" />
      <MemberSignature Language="F#" Value="static member SetFocusedElement : System.Windows.DependencyObject * System.Windows.IInputElement -&gt; unit" Usage="System.Windows.Input.FocusManager.SetFocusedElement (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.IInputElement" />
      </Parameters>
      <Docs>
        <param name="element">Der Fokusbereich, in dem das angegebene Element als <see cref="P:System.Windows.Input.FocusManager.FocusedElement" /> festgelegt werden soll.</param>
        <param name="value">Das Element, das den logischen Fokus erhalten soll.</param>
        <summary>Legt den logischen Fokus für das angegebene Element fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.FocusManager.FocusedElement%2A> Ist das Element, das den logischen Fokus für den bestimmten Fokusbereich hat.  Dieses Objekt kann den Tastaturfokus haben oder nicht.  Der Tastaturfokus bezieht sich auf das Element, das Tastatureingaben empfängt.  Weitere Informationen zum Fokus, Tastaturfokus und logischer Fokus finden Sie in der [Eingabe Übersicht](~/docs/framework/wpf/advanced/input-overview.md).  
  
 Es ist möglich, einen Schwerpunktbereich anzugeben, der ein Vorgänger des Fokusbereichs ist, in dem sich das Element befindet.  Wenn <xref:System.Windows.Controls.StackPanel> z. b. ein Fokusbereich und das übergeordnete <xref:System.Windows.Window> Element ein Fokusbereich ist <xref:System.Windows.Controls.StackPanel> , <xref:System.Windows.Controls.TextBox> kann ein untergeordnetes Element von <xref:System.Windows.Window> als Fokusbereich angeben, wenn <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A>aufgerufen wird.  Der <xref:System.Windows.Controls.TextBox> -Wert <xref:System.Windows.Input.FocusManager.FocusedElement%2A> ist dann sowohl <xref:System.Windows.Window> für den Fokusbereich <xref:System.Windows.Controls.StackPanel> als auch für den Fokusbereich.  
  
 <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A>gibt dem angegebenen Element den logischen Fokus im angegebenen Fokusbereich und versucht, dem Element Tastaturfokus zu übergeben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das-Element mit dem <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A> logischen Fokus mithilfe von festgelegt, und das-Element mit dem logischen Fokus wird mithilfe des <xref:System.Windows.Input.FocusManager.GetFocusedElement%2A>-Elements abgerufen.  
  
 [!code-csharp[focussnippets#FocusGetSetFocusedElement](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSnippets/CSharp/Window1.xaml.cs#focusgetsetfocusedelement)]
 [!code-vb[focussnippets#FocusGetSetFocusedElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSnippets/visualbasic/window1.xaml.vb#focusgetsetfocusedelement)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetIsFocusScope">
      <MemberSignature Language="C#" Value="public static void SetIsFocusScope (System.Windows.DependencyObject element, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetIsFocusScope(class System.Windows.DependencyObject element, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.SetIsFocusScope(System.Windows.DependencyObject,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetIsFocusScope (element As DependencyObject, value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetIsFocusScope(System::Windows::DependencyObject ^ element, bool value);" />
      <MemberSignature Language="F#" Value="static member SetIsFocusScope : System.Windows.DependencyObject * bool -&gt; unit" Usage="System.Windows.Input.FocusManager.SetIsFocusScope (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, das als Fokusbereich festgelegt werden soll.</param>
        <param name="value"><see langword="true" />, wenn <paramref name="element" /> ein Fokusbereich ist; andernfalls <see langword="false" />.</param>
        <summary>Legt das angegebene <see cref="T:System.Windows.DependencyObject" /> als Fokusbereich fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Fokusbereich ist ein Containerelement, das den <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> innerhalb seines Bereichs verfolgt.  Standardmäßig ist die <xref:System.Windows.Window> -Klasse ein Schwerpunktbereich, ebenso wie <xref:System.Windows.Controls.Menu>die <xref:System.Windows.Controls.ContextMenu>Klassen, <xref:System.Windows.Controls.ToolBar> und.  Ein Element, bei dem es sich um <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> `true`einen Fokusbereich handelt.  
  
 Weitere Informationen zum Fokus, Tastaturfokus und logischer Fokus finden Sie in der [Eingabe Übersicht](~/docs/framework/wpf/advanced/input-overview.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Element mithilfe <xref:System.Windows.Input.FocusManager.SetIsFocusScope%2A>von zu einem Fokusbereich.  
  
 [!code-csharp[focussnippets#FocusSetIsFocusScope](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSnippets/CSharp/Window1.xaml.cs#focussetisfocusscope)]
 [!code-vb[focussnippets#FocusSetIsFocusScope](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSnippets/visualbasic/window1.xaml.vb#focussetisfocusscope)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
