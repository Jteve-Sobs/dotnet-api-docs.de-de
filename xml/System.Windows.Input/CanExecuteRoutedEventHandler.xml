<Type Name="CanExecuteRoutedEventHandler" FullName="System.Windows.Input.CanExecuteRoutedEventHandler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b58d57ed8af24dc09435b5af9ca2f36030c2ddbc" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36508145" />
  </Metadata>
  <TypeSignature Language="C#" Value="public delegate void CanExecuteRoutedEventHandler(object sender, CanExecuteRoutedEventArgs e);" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed CanExecuteRoutedEventHandler extends System.MulticastDelegate" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.CanExecuteRoutedEventHandler" />
  <TypeSignature Language="VB.NET" Value="Public Delegate Sub CanExecuteRoutedEventHandler(sender As Object, e As CanExecuteRoutedEventArgs)" />
  <TypeSignature Language="C++ CLI" Value="public delegate void CanExecuteRoutedEventHandler(System::Object ^ sender, CanExecuteRoutedEventArgs ^ e);" />
  <TypeSignature Language="F#" Value="type CanExecuteRoutedEventHandler = delegate of obj * CanExecuteRoutedEventArgs -&gt; unit" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Delegate</BaseTypeName>
  </Base>
  <Parameters>
    <Parameter Name="sender" Type="System.Object" />
    <Parameter Name="e" Type="System.Windows.Input.CanExecuteRoutedEventArgs" />
  </Parameters>
  <ReturnValue>
    <ReturnType>System.Void</ReturnType>
  </ReturnValue>
  <Docs>
    <param name="sender">Das Befehlsziel, das den Handler aufruft.</param>
    <param name="e">Die Ereignisdaten.</param>
    <summary>Stellt die Methode zur Behandlung des <see cref="E:System.Windows.Input.CommandBinding.CanExecute" />-Ereignisses dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Input.CanExecuteRoutedEventHandler> bestimmt, ob die Ereignisquelle zugeordnete Befehl für das Befehlsziel ausführen kann. Wenn der Befehl umfasst eine Befehlsquelle an, der ein Ziel angibt, die Zielinformationen erhalten Sie über `sender`. Wenn die <xref:System.Windows.Input.ICommandSource.CommandTarget%2A> ist nicht festgelegt ist, wird das Element mit dem Tastaturfokus ist das Ziel, und kann auch über abgerufen werden `sender`.  Wenn ermittelt wird, dass der Befehl auf dem Ziel ausgeführt werden kann und dann die <xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A?displayProperty=nameWithType> Eigenschaft sollte festgelegt werden, um `true`ist, andernfalls legen Sie es auf `false`.  
  
 Sie müssen nicht abhängig von Ereignisdaten an den Befehl, Quelle und Ziel zu bestimmen. Sie können die Verwendung des Handlers bei bekannten möglich Befehl aufrufen, beschränken, obwohl dies schwieriger zu erreichen, wenn die Befehlsstruktur umfassend Befehlsrouting zum Ausführen desselben Befehls auf aufeinander folgenden potenziellen Zielen in einem Ereignis abhängig ist die Route.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine <xref:System.Windows.Input.CanExecuteRoutedEventHandler> festlegt <xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A> auf `true`.  
  
 [!code-csharp[commandwithhandler#CommandHandlerCanExecuteHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/commandWithHandler/CSharp/Window1.xaml.cs#commandhandlercanexecutehandler)]
 [!code-vb[commandwithhandler#CommandHandlerCanExecuteHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/commandWithHandler/VisualBasic/Window1.xaml.vb#commandhandlercanexecutehandler)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Input.CommandBinding" />
    <altmember cref="T:System.Windows.Input.ExecutedRoutedEventHandler" />
  </Docs>
</Type>