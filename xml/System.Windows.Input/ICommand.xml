<Type Name="ICommand" FullName="System.Windows.Input.ICommand">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ea5eff6a81bd27b0ab5ad70e628f1d59b7ee7f56" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface ICommand" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract ICommand" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.ICommand" />
  <TypeSignature Language="VB.NET" Value="Public Interface ICommand" />
  <TypeSignature Language="C++ CLI" Value="public interface class ICommand" />
  <AssemblyInfo>
    <AssemblyName>System.ObjectModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("PresentationCore, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="cd4b9-101">Definiert einen Befehl.</span>
      <span class="sxs-lookup">
        <span data-stu-id="cd4b9-101">Defines a command.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cd4b9-102"><xref:System.Windows.Input.RoutedCommand> und <xref:System.Windows.Input.RoutedUICommand> sind zwei Implementierungen der <xref:System.Windows.Input.ICommand> -Schnittstelle in [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)].</span><span class="sxs-lookup"><span data-stu-id="cd4b9-102"><xref:System.Windows.Input.RoutedCommand> and <xref:System.Windows.Input.RoutedUICommand> are two implementations of the <xref:System.Windows.Input.ICommand> interface in [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)].</span></span>  
  
## <a name="icommand-in-windows-runtime-apps"></a><span data-ttu-id="cd4b9-103">ICommand in Windows-Runtime-apps</span><span class="sxs-lookup"><span data-stu-id="cd4b9-103">ICommand in Windows Runtime apps</span></span>  
 <span data-ttu-id="cd4b9-104">Die <xref:System.Windows.Input.ICommand> Schnittstelle ist der Codevertrag für Befehle, die in .NET für Windows-Runtime-apps geschrieben sind.</span><span class="sxs-lookup"><span data-stu-id="cd4b9-104">The <xref:System.Windows.Input.ICommand> interface is the code contract for commands that are written in .NET for Windows Runtime apps.</span></span> <span data-ttu-id="cd4b9-105">Diese Befehle geben Sie das Verhalten der Befehle für Benutzeroberflächenelemente, z. B. eine Windows-Runtime-XAML `Button` und insbesondere eine `AppBarButton`.</span><span class="sxs-lookup"><span data-stu-id="cd4b9-105">These commands provide the commanding behavior for UI elements such as a Windows Runtime XAML `Button` and in particular an `AppBarButton`.</span></span> <span data-ttu-id="cd4b9-106">Wenn Sie Befehle für Windows-Runtime-apps definieren verwenden Sie im Wesentlichen die gleichen Techniken, die Sie zum Definieren von Befehlen für eine app .NET verwenden würden.</span><span class="sxs-lookup"><span data-stu-id="cd4b9-106">If you're defining commands for Windows Runtime apps you use basically the same techniques you'd use for defining commands for a .NET app.</span></span> <span data-ttu-id="cd4b9-107">Implementieren Sie den Befehl durch Definition einer Klasse, die implementiert <xref:System.Windows.Input.ICommand> , und implementieren Sie speziell die <xref:System.Windows.Input.ICommand.Execute%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="cd4b9-107">Implement the command by defining a class that implements <xref:System.Windows.Input.ICommand> and specifically implement the <xref:System.Windows.Input.ICommand.Execute%2A> method.</span></span>  
  
 <span data-ttu-id="cd4b9-108">XAML für Windows-Runtime unterstützt keine x`:Static`, sodass Sie nicht versuchen, verwenden Sie die `x:Static` Markuperweiterung, wenn der Befehl von Windows-Runtime-XAML verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="cd4b9-108">XAML for Windows Runtime does not support x`:Static`, so don't attempt to use the `x:Static` markup extension if the command is used from Windows Runtime XAML.</span></span> <span data-ttu-id="cd4b9-109">Darüber hinaus ist keine Windows-Runtime alle vordefinierten Befehl-Bibliotheken daher die Verwendung von XAML-Syntax, die hier gezeigten wirklich für die Groß-/Kleinschreibung gelten nicht, in dem Sie die Schnittstelle implementieren und definieren den Befehl für die Verwendung der Windows-Runtime.</span><span class="sxs-lookup"><span data-stu-id="cd4b9-109">Also, the Windows Runtime does not have any predefined command libraries, so the XAML syntax shown here doesn't really apply for the case where you're implementing the interface and defining the command for Windows Runtime usage.</span></span>  
  
<a name="xamlTextUsage_ICommand"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="cd4b9-110">Verwendung von XAML-Attributen</span><span class="sxs-lookup"><span data-stu-id="cd4b9-110">XAML Attribute Usage</span></span>  
 <span data-ttu-id="cd4b9-111">\<*-Objekteigenschaft*= "*PredefinedCommandName*" / ></span><span class="sxs-lookup"><span data-stu-id="cd4b9-111">\<*object property*="*predefinedCommandName*"/></span></span>  
  
 <span data-ttu-id="cd4b9-112">\- oder –</span><span class="sxs-lookup"><span data-stu-id="cd4b9-112">\- or -</span></span>  
  
 <span data-ttu-id="cd4b9-113">\<*-Objekteigenschaft*= "*predefinedCommandName.predefinedCommandName*" / ></span><span class="sxs-lookup"><span data-stu-id="cd4b9-113">\<*object property*="*predefinedCommandName.predefinedCommandName*"/></span></span>  
  
 <span data-ttu-id="cd4b9-114">\- oder –</span><span class="sxs-lookup"><span data-stu-id="cd4b9-114">\- or -</span></span>  
  
 <span data-ttu-id="cd4b9-115">\<*-Objekteigenschaft*= "{ *customClassName.customCommandName*}" / ></span><span class="sxs-lookup"><span data-stu-id="cd4b9-115">\<*object property*="{ *customClassName.customCommandName*}"/></span></span>  
  
<a name="xamlValues_ICommand"></a>   
## <a name="xaml-values"></a><span data-ttu-id="cd4b9-116">XAML-Werte</span><span class="sxs-lookup"><span data-stu-id="cd4b9-116">XAML Values</span></span>  
 <span data-ttu-id="cd4b9-117">*predefinedClassName*</span><span class="sxs-lookup"><span data-stu-id="cd4b9-117">*predefinedClassName*</span></span>  
 <span data-ttu-id="cd4b9-118">Einer der vordefinierten Befehlsklassen.</span><span class="sxs-lookup"><span data-stu-id="cd4b9-118">One of the predefined command classes.</span></span>  
  
 <span data-ttu-id="cd4b9-119">*predefinedCommandName*</span><span class="sxs-lookup"><span data-stu-id="cd4b9-119">*predefinedCommandName*</span></span>  
 <span data-ttu-id="cd4b9-120">Einer der vordefinierten Befehle.</span><span class="sxs-lookup"><span data-stu-id="cd4b9-120">One of the predefined commands.</span></span>  
  
 <span data-ttu-id="cd4b9-121">*customClassName*</span><span class="sxs-lookup"><span data-stu-id="cd4b9-121">*customClassName*</span></span>  
 <span data-ttu-id="cd4b9-122">Eine benutzerdefinierte Klasse, die die benutzerdefinierte Befehl enthält.</span><span class="sxs-lookup"><span data-stu-id="cd4b9-122">A custom class that contains the custom command.</span></span> <span data-ttu-id="cd4b9-123">Benutzerdefinierte Klassen im Allgemeinen erfordern eine `xlmns` Präfix-Zuordnung; Siehe [XAML-Namespaces und Namespace-Zuordnung für WPF-XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="cd4b9-123">Custom classes generally require an `xlmns` prefix mapping; see [XAML Namespaces and Namespace Mapping for WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
 <span data-ttu-id="cd4b9-124">*customCommandName*</span><span class="sxs-lookup"><span data-stu-id="cd4b9-124">*customCommandName*</span></span>  
 <span data-ttu-id="cd4b9-125">Einen benutzerdefinierten Befehl.</span><span class="sxs-lookup"><span data-stu-id="cd4b9-125">A custom command.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CanExecute">
      <MemberSignature Language="C#" Value="public bool CanExecute (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanExecute(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.ICommand.CanExecute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanExecute (parameter As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanExecute(System::Object ^ parameter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">
          <span data-ttu-id="cd4b9-126">Vom Befehl verwendete Daten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cd4b9-126">Data used by the command.</span>
          </span>
          <span data-ttu-id="cd4b9-127">Wenn der Befehl keine Datenübergabe erfordert, kann das Objekt auf <see langword="null" /> festgelegt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cd4b9-127">If the command does not require data to be passed, this object can be set to <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cd4b9-128">Definiert die Methode, die bestimmt, ob der Befehl im aktuellen Zustand ausgeführt werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cd4b9-128">Defines the method that determines whether the command can execute in its current state.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="cd4b9-129">
            <see langword="true" />, wenn der Befehl ausgeführt werden kann, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cd4b9-129">
              <see langword="true" /> if this command can be executed; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cd4b9-130">In der Regel eine Befehlsquelle aufgerufen der <xref:System.Windows.Input.ICommand.CanExecute%2A> Methode bei der <xref:System.Windows.Input.ICommand.CanExecuteChanged> Ereignis wird ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="cd4b9-130">Typically, a command source calls the <xref:System.Windows.Input.ICommand.CanExecute%2A> method when the <xref:System.Windows.Input.ICommand.CanExecuteChanged> event is raised.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.ICommandSource" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="CanExecuteChanged">
      <MemberSignature Language="C#" Value="event EventHandler CanExecuteChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CanExecuteChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.ICommand.CanExecuteChanged" />
      <MemberSignature Language="VB.NET" Value="Event CanExecuteChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CanExecuteChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="cd4b9-131">Tritt ein, wenn Änderungen auftreten, die sich auf die Ausführung des Befehls auswirken.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cd4b9-131">Occurs when changes occur that affect whether or not the command should execute.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cd4b9-132">In der Regel ruft eine Befehlsquelle <xref:System.Windows.Input.ICommand.CanExecute%2A> auf den Befehl aus, wenn dieses Ereignis auftritt.</span><span class="sxs-lookup"><span data-stu-id="cd4b9-132">Normally, a command source calls <xref:System.Windows.Input.ICommand.CanExecute%2A> on the command when this event occurs.</span></span>  
  
 <span data-ttu-id="cd4b9-133">Normalerweise, wenn der Befehl nicht ausführen kann, deaktiviert die Befehlsquelle.</span><span class="sxs-lookup"><span data-stu-id="cd4b9-133">Normally, if the command cannot execute, the command source disables itself.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.ICommandSource" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Execute(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.ICommand.Execute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::Object ^ parameter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">
          <span data-ttu-id="cd4b9-134">Vom Befehl verwendete Daten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cd4b9-134">Data used by the command.</span>
          </span>
          <span data-ttu-id="cd4b9-135">Wenn der Befehl keine Datenübergabe erfordert, kann das Objekt auf <see langword="null" /> festgelegt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cd4b9-135">If the command does not require data to be passed, this object can be set to <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="cd4b9-136">Definiert die Methode, die aufgerufen wird, wenn der Befehl aufgerufen wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="cd4b9-136">Defines the method to be called when the command is invoked.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Input.ICommandSource" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
  </Members>
</Type>