<Type Name="CommandManager" FullName="System.Windows.Input.CommandManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2584288fb981e51bb64430217bf548ab7e5085a9" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36508076" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class CommandManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit CommandManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.CommandManager" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class CommandManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class CommandManager sealed" />
  <TypeSignature Language="F#" Value="type CommandManager = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt Dienstprogrammmethoden für Befehle bereit, um <see cref="T:System.Windows.Input.CommandBinding" />- und <see cref="T:System.Windows.Input.InputBinding" />-Objekte für Klassenbesitzer und Befehle zu registrieren sowie Ereignishandler für Befehle hinzuzufügen und zu entfernen und stellt Dienste zum Abfragen des Befehlsstatus bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Input.CommandManager> ist verantwortlich für die Verwaltung von weitergeleiteten Befehlen.  Weitere Informationen über Befehle finden Sie unter [Befehle (Übersicht)](~/docs/framework/wpf/advanced/commanding-overview.md).  
  
 Verwendung <xref:System.Windows.Input.CommandManager.RegisterClassCommandBinding%2A> zum Registrieren einer <xref:System.Windows.Input.CommandBinding> auf eine Klasse im Gegensatz zu einer Instanz.  
  
 Verwendung <xref:System.Windows.Input.CommandManager.RegisterClassInputBinding%2A> zum Registrieren einer <xref:System.Windows.Input.InputBinding> auf eine Klasse im Gegensatz zu einer Instanz.  
  
 Die Methode <xref:System.Windows.Input.CommandManager.InvalidateRequerySuggested%2A> zwingt <xref:System.Windows.Input.CommandManager> zum Auslösen des Ereignisses <xref:System.Windows.Input.CommandManager.RequerySuggested>.  Die <xref:System.Windows.Input.CommandManager.RequerySuggested> Ereignis weist eine Befehlsquelle, um den Befehl Abfragen, um zu bestimmen, ob der Befehl ausgeführt werden kann oder nicht zugeordnet ist.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Input.RoutedCommand" />
    <altmember cref="T:System.Windows.Input.CommandBinding" />
    <altmember cref="T:System.Windows.Input.ICommandSource" />
    <altmember cref="T:System.Windows.Input.ICommand" />
  </Docs>
  <Members>
    <Member MemberName="AddCanExecuteHandler">
      <MemberSignature Language="C#" Value="public static void AddCanExecuteHandler (System.Windows.UIElement element, System.Windows.Input.CanExecuteRoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddCanExecuteHandler(class System.Windows.UIElement element, class System.Windows.Input.CanExecuteRoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.CommandManager.AddCanExecuteHandler(System.Windows.UIElement,System.Windows.Input.CanExecuteRoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddCanExecuteHandler (element As UIElement, handler As CanExecuteRoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddCanExecuteHandler(System::Windows::UIElement ^ element, System::Windows::Input::CanExecuteRoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddCanExecuteHandler : System.Windows.UIElement * System.Windows.Input.CanExecuteRoutedEventHandler -&gt; unit" Usage="System.Windows.Input.CommandManager.AddCanExecuteHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
        <Parameter Name="handler" Type="System.Windows.Input.CanExecuteRoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, an das <c>handler</c> angefügt werden soll.</param>
        <param name="handler">Der ausführbare Handler.</param>
        <summary>Fügt den angegebenen <see cref="T:System.Windows.Input.CanExecuteRoutedEventHandler" /> an das angegebene Element an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Windows.Input.CanExecuteRoutedEventHandler> und ein <xref:System.Windows.Input.ExecutedRoutedEventHandler> und angefügt, um eine <xref:System.Windows.Controls.Button> also eine Befehlsquelle für die <xref:System.Windows.Input.ApplicationCommands.Help%2A> Befehl.  
  
 Zunächst wird die <xref:System.Windows.Controls.Button> erstellt und zugeordnet wird die <xref:System.Windows.Input.ApplicationCommands.Help%2A> Befehl.  
  
 [!code-xaml[commandingoverviewsnippets#CommandingOverviewCmdManagerAddHandlersXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewcmdmanageraddhandlersxaml)]  
  
 Als Nächstes werden die <xref:System.Windows.Input.CanExecuteRoutedEventHandler>- und <xref:System.Windows.Input.ExecutedRoutedEventHandler>-Objekte erstellt.  
  
 [!code-csharp[commandingoverviewsnippets#CommandingOverviewCmdManagerExecutedHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewcmdmanagerexecutedhandler)]
 [!code-vb[commandingoverviewsnippets#CommandingOverviewCmdManagerExecutedHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewcmdmanagerexecutedhandler)]  
  
 [!code-csharp[commandingoverviewsnippets#CommandingOverviewCmdManagerCanExecuteHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewcmdmanagercanexecutehandler)]
 [!code-vb[commandingoverviewsnippets#CommandingOverviewCmdManagerCanExecuteHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewcmdmanagercanexecutehandler)]  
  
 Und schließlich werden die Handler an angefügt der <xref:System.Windows.Controls.Button> mithilfe der <xref:System.Windows.Input.CommandManager.AddCanExecuteHandler%2A> und <xref:System.Windows.Input.CommandManager.AddExecutedHandler%2A>.  
  
 [!code-csharp[commandingoverviewsnippets#CommandingOverviewCmdManagerAddHandlers](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewcmdmanageraddhandlers)]
 [!code-vb[commandingoverviewsnippets#CommandingOverviewCmdManagerAddHandlers](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewcmdmanageraddhandlers)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> oder <paramref name="handler" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.ICommand" />
      </Docs>
    </Member>
    <Member MemberName="AddExecutedHandler">
      <MemberSignature Language="C#" Value="public static void AddExecutedHandler (System.Windows.UIElement element, System.Windows.Input.ExecutedRoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddExecutedHandler(class System.Windows.UIElement element, class System.Windows.Input.ExecutedRoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.CommandManager.AddExecutedHandler(System.Windows.UIElement,System.Windows.Input.ExecutedRoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddExecutedHandler (element As UIElement, handler As ExecutedRoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddExecutedHandler(System::Windows::UIElement ^ element, System::Windows::Input::ExecutedRoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddExecutedHandler : System.Windows.UIElement * System.Windows.Input.ExecutedRoutedEventHandler -&gt; unit" Usage="System.Windows.Input.CommandManager.AddExecutedHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
        <Parameter Name="handler" Type="System.Windows.Input.ExecutedRoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, an das <c>handler</c> angefügt werden soll.</param>
        <param name="handler">Der ausgeführte Handler.</param>
        <summary>Fügt den angegebenen <see cref="T:System.Windows.Input.ExecutedRoutedEventHandler" /> an das angegebene Element an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Windows.Input.CanExecuteRoutedEventHandler> und ein <xref:System.Windows.Input.ExecutedRoutedEventHandler> und angefügt, um eine <xref:System.Windows.Controls.Button> also eine Befehlsquelle für die <xref:System.Windows.Input.ApplicationCommands.Help%2A> Befehl.  
  
 Zunächst wird die <xref:System.Windows.Controls.Button> erstellt und zugeordnet wird die <xref:System.Windows.Input.ApplicationCommands.Help%2A> Befehl.  
  
 [!code-xaml[commandingoverviewsnippets#CommandingOverviewCmdManagerAddHandlersXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewcmdmanageraddhandlersxaml)]  
  
 Als Nächstes werden die <xref:System.Windows.Input.CanExecuteRoutedEventHandler>- und <xref:System.Windows.Input.ExecutedRoutedEventHandler>-Objekte erstellt.  
  
 [!code-csharp[commandingoverviewsnippets#CommandingOverviewCmdManagerExecutedHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewcmdmanagerexecutedhandler)]
 [!code-vb[commandingoverviewsnippets#CommandingOverviewCmdManagerExecutedHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewcmdmanagerexecutedhandler)]  
  
 [!code-csharp[commandingoverviewsnippets#CommandingOverviewCmdManagerCanExecuteHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewcmdmanagercanexecutehandler)]
 [!code-vb[commandingoverviewsnippets#CommandingOverviewCmdManagerCanExecuteHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewcmdmanagercanexecutehandler)]  
  
 Und schließlich werden die Handler an angefügt der <xref:System.Windows.Controls.Button> mithilfe der <xref:System.Windows.Input.CommandManager.AddCanExecuteHandler%2A> und <xref:System.Windows.Input.CommandManager.AddExecutedHandler%2A>.  
  
 [!code-csharp[commandingoverviewsnippets#CommandingOverviewCmdManagerAddHandlers](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewcmdmanageraddhandlers)]
 [!code-vb[commandingoverviewsnippets#CommandingOverviewCmdManagerAddHandlers](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewcmdmanageraddhandlers)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> oder <paramref name="handler" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.ICommand" />
      </Docs>
    </Member>
    <Member MemberName="AddPreviewCanExecuteHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewCanExecuteHandler (System.Windows.UIElement element, System.Windows.Input.CanExecuteRoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewCanExecuteHandler(class System.Windows.UIElement element, class System.Windows.Input.CanExecuteRoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.CommandManager.AddPreviewCanExecuteHandler(System.Windows.UIElement,System.Windows.Input.CanExecuteRoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewCanExecuteHandler (element As UIElement, handler As CanExecuteRoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewCanExecuteHandler(System::Windows::UIElement ^ element, System::Windows::Input::CanExecuteRoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewCanExecuteHandler : System.Windows.UIElement * System.Windows.Input.CanExecuteRoutedEventHandler -&gt; unit" Usage="System.Windows.Input.CommandManager.AddPreviewCanExecuteHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
        <Parameter Name="handler" Type="System.Windows.Input.CanExecuteRoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, an das <c>handler</c> angefügt werden soll.</param>
        <param name="handler">Der ausführbare Handler.</param>
        <summary>Fügt den angegebenen <see cref="T:System.Windows.Input.CanExecuteRoutedEventHandler" /> an das angegebene Element an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Windows.Input.CanExecuteRoutedEventHandler> und ein <xref:System.Windows.Input.ExecutedRoutedEventHandler> und angefügt, um eine <xref:System.Windows.Controls.Button> also eine Befehlsquelle für die <xref:System.Windows.Input.ApplicationCommands.Help%2A> Befehl.  
  
 Zunächst wird die <xref:System.Windows.Controls.Button> erstellt und zugeordnet wird die <xref:System.Windows.Input.ApplicationCommands.Help%2A> Befehl.  
  
 [!code-xaml[commandingoverviewsnippets#CommandingOverviewCmdManagerAddHandlersXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewcmdmanageraddhandlersxaml)]  
  
 Als Nächstes werden die <xref:System.Windows.Input.CanExecuteRoutedEventHandler>- und <xref:System.Windows.Input.ExecutedRoutedEventHandler>-Objekte erstellt.  
  
 [!code-csharp[commandingoverviewsnippets#CommandingOverviewCmdManagerExecutedHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewcmdmanagerexecutedhandler)]
 [!code-vb[commandingoverviewsnippets#CommandingOverviewCmdManagerExecutedHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewcmdmanagerexecutedhandler)]  
  
 [!code-csharp[commandingoverviewsnippets#CommandingOverviewCmdManagerCanExecuteHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewcmdmanagercanexecutehandler)]
 [!code-vb[commandingoverviewsnippets#CommandingOverviewCmdManagerCanExecuteHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewcmdmanagercanexecutehandler)]  
  
 Schließlich werden die Handler an angefügt der <xref:System.Windows.Controls.Button> mithilfe der <xref:System.Windows.Input.CommandManager.AddCanExecuteHandler%2A> und <xref:System.Windows.Input.CommandManager.AddExecutedHandler%2A>.  
  
 [!code-csharp[commandingoverviewsnippets#CommandingOverviewCmdManagerAddHandlers](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewcmdmanageraddhandlers)]
 [!code-vb[commandingoverviewsnippets#CommandingOverviewCmdManagerAddHandlers](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewcmdmanageraddhandlers)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> oder <paramref name="handler" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.ICommand" />
      </Docs>
    </Member>
    <Member MemberName="AddPreviewExecutedHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewExecutedHandler (System.Windows.UIElement element, System.Windows.Input.ExecutedRoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewExecutedHandler(class System.Windows.UIElement element, class System.Windows.Input.ExecutedRoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.CommandManager.AddPreviewExecutedHandler(System.Windows.UIElement,System.Windows.Input.ExecutedRoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewExecutedHandler (element As UIElement, handler As ExecutedRoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewExecutedHandler(System::Windows::UIElement ^ element, System::Windows::Input::ExecutedRoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewExecutedHandler : System.Windows.UIElement * System.Windows.Input.ExecutedRoutedEventHandler -&gt; unit" Usage="System.Windows.Input.CommandManager.AddPreviewExecutedHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
        <Parameter Name="handler" Type="System.Windows.Input.ExecutedRoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, an das <c>handler</c> angefügt werden soll.</param>
        <param name="handler">Der ausführbare Handler.</param>
        <summary>Fügt den angegebenen <see cref="T:System.Windows.Input.ExecutedRoutedEventHandler" /> an das angegebene Element an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Windows.Input.CanExecuteRoutedEventHandler> und ein <xref:System.Windows.Input.ExecutedRoutedEventHandler> und angefügt, um eine <xref:System.Windows.Controls.Button> also eine Befehlsquelle für die <xref:System.Windows.Input.ApplicationCommands.Help%2A> Befehl.  
  
 Zunächst wird die <xref:System.Windows.Controls.Button> erstellt und zugeordnet wird die <xref:System.Windows.Input.ApplicationCommands.Help%2A> Befehl.  
  
 [!code-xaml[commandingoverviewsnippets#CommandingOverviewCmdManagerAddHandlersXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewcmdmanageraddhandlersxaml)]  
  
 Als Nächstes werden die <xref:System.Windows.Input.CanExecuteRoutedEventHandler>- und <xref:System.Windows.Input.ExecutedRoutedEventHandler>-Objekte erstellt.  
  
 [!code-csharp[commandingoverviewsnippets#CommandingOverviewCmdManagerExecutedHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewcmdmanagerexecutedhandler)]
 [!code-vb[commandingoverviewsnippets#CommandingOverviewCmdManagerExecutedHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewcmdmanagerexecutedhandler)]  
  
 [!code-csharp[commandingoverviewsnippets#CommandingOverviewCmdManagerCanExecuteHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewcmdmanagercanexecutehandler)]
 [!code-vb[commandingoverviewsnippets#CommandingOverviewCmdManagerCanExecuteHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewcmdmanagercanexecutehandler)]  
  
 Schließlich werden die Handler an angefügt der <xref:System.Windows.Controls.Button> mithilfe der <xref:System.Windows.Input.CommandManager.AddCanExecuteHandler%2A> und <xref:System.Windows.Input.CommandManager.AddExecutedHandler%2A>.  
  
 [!code-csharp[commandingoverviewsnippets#CommandingOverviewCmdManagerAddHandlers](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewcmdmanageraddhandlers)]
 [!code-vb[commandingoverviewsnippets#CommandingOverviewCmdManagerAddHandlers](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewcmdmanageraddhandlers)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> oder <paramref name="handler" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.ICommand" />
      </Docs>
    </Member>
    <Member MemberName="CanExecute">
      <MemberSignature Language="C#" Value="see AddCanExecuteHandler, and RemoveCanExecuteHandler" />
      <MemberSignature Language="ILAsm" Value="see AddCanExecuteHandler, and RemoveCanExecuteHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.CommandManager.CanExecute" />
      <MemberSignature Language="VB.NET" Value="see AddCanExecuteHandler, and RemoveCanExecuteHandler" />
      <MemberSignature Language="F#" Value="see AddCanExecuteHandler, and RemoveCanExecuteHandler" Usage="see AddCanExecuteHandler, and RemoveCanExecuteHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanExecuteEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent CanExecuteEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent CanExecuteEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.CommandManager.CanExecuteEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CanExecuteEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ CanExecuteEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable CanExecuteEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.CommandManager.CanExecuteEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet das angefügte <see cref="E:System.Windows.Input.CommandManager.CanExecute" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Executed">
      <MemberSignature Language="C#" Value="see AddExecutedHandler, and RemoveExecutedHandler" />
      <MemberSignature Language="ILAsm" Value="see AddExecutedHandler, and RemoveExecutedHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.CommandManager.Executed" />
      <MemberSignature Language="VB.NET" Value="see AddExecutedHandler, and RemoveExecutedHandler" />
      <MemberSignature Language="F#" Value="see AddExecutedHandler, and RemoveExecutedHandler" Usage="see AddExecutedHandler, and RemoveExecutedHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecutedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ExecutedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ExecutedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.CommandManager.ExecutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ExecutedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ExecutedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ExecutedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.CommandManager.ExecutedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet das angefügte <see cref="E:System.Windows.Input.CommandManager.Executed" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidateRequerySuggested">
      <MemberSignature Language="C#" Value="public static void InvalidateRequerySuggested ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InvalidateRequerySuggested() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.CommandManager.InvalidateRequerySuggested" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub InvalidateRequerySuggested ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void InvalidateRequerySuggested();" />
      <MemberSignature Language="F#" Value="static member InvalidateRequerySuggested : unit -&gt; unit" Usage="System.Windows.Input.CommandManager.InvalidateRequerySuggested " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwingt den <see cref="T:System.Windows.Input.CommandManager" /> das <see cref="E:System.Windows.Input.CommandManager.RequerySuggested" />-Ereignis auszulösen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Input.CommandManager> zahlt nur auf bestimmte Bedingungen feststellen, wenn das Befehlsziel geändert hat, z. B. die Änderung in den Tastaturfokus.  In Situationen, in denen die <xref:System.Windows.Input.CommandManager> bestimmt eine Änderung der Bedingungen, die dazu führen, einen Befehl nicht dass ausgeführt werden, können nicht ausreichend <xref:System.Windows.Input.CommandManager.InvalidateRequerySuggested%2A> aufgerufen werden, um zu erzwingen der <xref:System.Windows.Input.CommandManager> zum Auslösen der <xref:System.Windows.Input.CommandManager.RequerySuggested> Ereignis.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Windows.Threading.DispatcherTimer> in regelmäßigen Abständen Aufrufen <xref:System.Windows.Input.CommandManager.InvalidateRequerySuggested%2A> Erzwingen der <xref:System.Windows.Input.CommandManager> zum Auslösen der <xref:System.Windows.Input.CommandManager.RequerySuggested> Ereignis.  
  
 [!code-csharp[InvalidateRequeryWithDispatcherTimer#InvalidateSampleDispatcherTimer](~/samples/snippets/csharp/VS_Snippets_Wpf/InvalidateRequeryWithDispatcherTimer/CSharp/Window1.xaml.cs#invalidatesampledispatchertimer)]
 [!code-vb[InvalidateRequeryWithDispatcherTimer#InvalidateSampleDispatcherTimer](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InvalidateRequeryWithDispatcherTimer/visualbasic/window1.xaml.vb#invalidatesampledispatchertimer)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewCanExecute">
      <MemberSignature Language="C#" Value="see AddPreviewCanExecuteHandler, and RemovePreviewCanExecuteHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewCanExecuteHandler, and RemovePreviewCanExecuteHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.CommandManager.PreviewCanExecute" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewCanExecuteHandler, and RemovePreviewCanExecuteHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewCanExecuteHandler, and RemovePreviewCanExecuteHandler" Usage="see AddPreviewCanExecuteHandler, and RemovePreviewCanExecuteHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewCanExecuteEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewCanExecuteEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewCanExecuteEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.CommandManager.PreviewCanExecuteEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewCanExecuteEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewCanExecuteEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewCanExecuteEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.CommandManager.PreviewCanExecuteEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet das angefügte <see cref="E:System.Windows.Input.CommandManager.PreviewCanExecute" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewExecuted">
      <MemberSignature Language="C#" Value="see AddPreviewExecutedHandler, and RemovePreviewExecutedHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewExecutedHandler, and RemovePreviewExecutedHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.CommandManager.PreviewExecuted" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewExecutedHandler, and RemovePreviewExecutedHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewExecutedHandler, and RemovePreviewExecutedHandler" Usage="see AddPreviewExecutedHandler, and RemovePreviewExecutedHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewExecutedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewExecutedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewExecutedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.CommandManager.PreviewExecutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewExecutedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewExecutedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewExecutedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.CommandManager.PreviewExecutedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet das angefügte <see cref="E:System.Windows.Input.CommandManager.PreviewExecuted" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterClassCommandBinding">
      <MemberSignature Language="C#" Value="public static void RegisterClassCommandBinding (Type type, System.Windows.Input.CommandBinding commandBinding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClassCommandBinding(class System.Type type, class System.Windows.Input.CommandBinding commandBinding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.CommandManager.RegisterClassCommandBinding(System.Type,System.Windows.Input.CommandBinding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClassCommandBinding(Type ^ type, System::Windows::Input::CommandBinding ^ commandBinding);" />
      <MemberSignature Language="F#" Value="static member RegisterClassCommandBinding : Type * System.Windows.Input.CommandBinding -&gt; unit" Usage="System.Windows.Input.CommandManager.RegisterClassCommandBinding (type, commandBinding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="commandBinding" Type="System.Windows.Input.CommandBinding" />
      </Parameters>
      <Docs>
        <param name="type">Die Klasse, für die <c>commandBinding</c> registriert werden soll.</param>
        <param name="commandBinding">Die Befehlsbindung, die registriert werden soll.</param>
        <summary>Registriert eine <see cref="T:System.Windows.Input.CommandBinding" /> mit dem angegebenen Typ.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ermöglicht eine <xref:System.Windows.Input.CommandBinding> anstelle einer Instanz einer Klasse mit einer Klasse zugeordnet werden soll.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> oder <paramref name="commandBinding" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterClassInputBinding">
      <MemberSignature Language="C#" Value="public static void RegisterClassInputBinding (Type type, System.Windows.Input.InputBinding inputBinding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClassInputBinding(class System.Type type, class System.Windows.Input.InputBinding inputBinding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.CommandManager.RegisterClassInputBinding(System.Type,System.Windows.Input.InputBinding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClassInputBinding(Type ^ type, System::Windows::Input::InputBinding ^ inputBinding);" />
      <MemberSignature Language="F#" Value="static member RegisterClassInputBinding : Type * System.Windows.Input.InputBinding -&gt; unit" Usage="System.Windows.Input.CommandManager.RegisterClassInputBinding (type, inputBinding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="inputBinding" Type="System.Windows.Input.InputBinding" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ, mit dem <c>inputBinding</c> registriert werden soll.</param>
        <param name="inputBinding">Die Eingabebindung, die registriert werden soll.</param>
        <summary>Registriert die angegebene <see cref="T:System.Windows.Input.InputBinding" /> für den angegebenen Typ.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ermöglicht eine <xref:System.Windows.Input.InputBinding> eines Typs statt einer Instanz einer Klasse zugeordnet werden soll.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> oder <paramref name="inputBinding" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveCanExecuteHandler">
      <MemberSignature Language="C#" Value="public static void RemoveCanExecuteHandler (System.Windows.UIElement element, System.Windows.Input.CanExecuteRoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveCanExecuteHandler(class System.Windows.UIElement element, class System.Windows.Input.CanExecuteRoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.CommandManager.RemoveCanExecuteHandler(System.Windows.UIElement,System.Windows.Input.CanExecuteRoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveCanExecuteHandler (element As UIElement, handler As CanExecuteRoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveCanExecuteHandler(System::Windows::UIElement ^ element, System::Windows::Input::CanExecuteRoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveCanExecuteHandler : System.Windows.UIElement * System.Windows.Input.CanExecuteRoutedEventHandler -&gt; unit" Usage="System.Windows.Input.CommandManager.RemoveCanExecuteHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
        <Parameter Name="handler" Type="System.Windows.Input.CanExecuteRoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, aus dem <c>handler</c> entfernt wird.</param>
        <param name="handler">Der ausführbare Handler.</param>
        <summary>Trennt den angegebenen <see cref="T:System.Windows.Input.CanExecuteRoutedEventHandler" /> vom angegebenen Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird getrennt eine <xref:System.Windows.Input.CanExecuteRoutedEventHandler> und ein <xref:System.Windows.Input.ExecutedRoutedEventHandler> die hatte zuvor zu angefügt wurde eine <xref:System.Windows.Controls.Button>.  
  
 [!code-csharp[commandingoverviewsnippets#CommandingOverviewCmdManagerRemoveHandlers](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewcmdmanagerremovehandlers)]
 [!code-vb[commandingoverviewsnippets#CommandingOverviewCmdManagerRemoveHandlers](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewcmdmanagerremovehandlers)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> oder <paramref name="handler" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.ICommand" />
      </Docs>
    </Member>
    <Member MemberName="RemoveExecutedHandler">
      <MemberSignature Language="C#" Value="public static void RemoveExecutedHandler (System.Windows.UIElement element, System.Windows.Input.ExecutedRoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveExecutedHandler(class System.Windows.UIElement element, class System.Windows.Input.ExecutedRoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.CommandManager.RemoveExecutedHandler(System.Windows.UIElement,System.Windows.Input.ExecutedRoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveExecutedHandler (element As UIElement, handler As ExecutedRoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveExecutedHandler(System::Windows::UIElement ^ element, System::Windows::Input::ExecutedRoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveExecutedHandler : System.Windows.UIElement * System.Windows.Input.ExecutedRoutedEventHandler -&gt; unit" Usage="System.Windows.Input.CommandManager.RemoveExecutedHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
        <Parameter Name="handler" Type="System.Windows.Input.ExecutedRoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, aus dem <c>handler</c> entfernt wird.</param>
        <param name="handler">Der ausgeführte Handler.</param>
        <summary>Trennt den angegebenen <see cref="T:System.Windows.Input.ExecutedRoutedEventHandler" /> vom angegebenen Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird getrennt eine <xref:System.Windows.Input.CanExecuteRoutedEventHandler> und ein <xref:System.Windows.Input.ExecutedRoutedEventHandler> die hatte zuvor zu angefügt wurde eine <xref:System.Windows.Controls.Button>.  
  
 [!code-csharp[commandingoverviewsnippets#CommandingOverviewCmdManagerRemoveHandlers](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewcmdmanagerremovehandlers)]
 [!code-vb[commandingoverviewsnippets#CommandingOverviewCmdManagerRemoveHandlers](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewcmdmanagerremovehandlers)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> oder <paramref name="handler" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.ICommand" />
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewCanExecuteHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewCanExecuteHandler (System.Windows.UIElement element, System.Windows.Input.CanExecuteRoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewCanExecuteHandler(class System.Windows.UIElement element, class System.Windows.Input.CanExecuteRoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.CommandManager.RemovePreviewCanExecuteHandler(System.Windows.UIElement,System.Windows.Input.CanExecuteRoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewCanExecuteHandler (element As UIElement, handler As CanExecuteRoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewCanExecuteHandler(System::Windows::UIElement ^ element, System::Windows::Input::CanExecuteRoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewCanExecuteHandler : System.Windows.UIElement * System.Windows.Input.CanExecuteRoutedEventHandler -&gt; unit" Usage="System.Windows.Input.CommandManager.RemovePreviewCanExecuteHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
        <Parameter Name="handler" Type="System.Windows.Input.CanExecuteRoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, aus dem <c>handler</c> entfernt wird.</param>
        <param name="handler">Der ausführbare Handler.</param>
        <summary>Trennt den angegebenen <see cref="T:System.Windows.Input.CanExecuteRoutedEventHandler" /> vom angegebenen Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird getrennt eine <xref:System.Windows.Input.CanExecuteRoutedEventHandler> und ein <xref:System.Windows.Input.ExecutedRoutedEventHandler> die hatte zuvor zu angefügt wurde eine <xref:System.Windows.Controls.Button>.  
  
 [!code-csharp[commandingoverviewsnippets#CommandingOverviewCmdManagerRemoveHandlers](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewcmdmanagerremovehandlers)]
 [!code-vb[commandingoverviewsnippets#CommandingOverviewCmdManagerRemoveHandlers](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewcmdmanagerremovehandlers)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> oder <paramref name="handler" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.ICommand" />
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewExecutedHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewExecutedHandler (System.Windows.UIElement element, System.Windows.Input.ExecutedRoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewExecutedHandler(class System.Windows.UIElement element, class System.Windows.Input.ExecutedRoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.CommandManager.RemovePreviewExecutedHandler(System.Windows.UIElement,System.Windows.Input.ExecutedRoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewExecutedHandler (element As UIElement, handler As ExecutedRoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewExecutedHandler(System::Windows::UIElement ^ element, System::Windows::Input::ExecutedRoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewExecutedHandler : System.Windows.UIElement * System.Windows.Input.ExecutedRoutedEventHandler -&gt; unit" Usage="System.Windows.Input.CommandManager.RemovePreviewExecutedHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
        <Parameter Name="handler" Type="System.Windows.Input.ExecutedRoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, aus dem <c>handler</c> entfernt wird.</param>
        <param name="handler">Der ausgeführte Handler.</param>
        <summary>Trennt den angegebenen <see cref="T:System.Windows.Input.ExecutedRoutedEventHandler" /> vom angegebenen Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird getrennt eine <xref:System.Windows.Input.CanExecuteRoutedEventHandler> und ein <xref:System.Windows.Input.ExecutedRoutedEventHandler> die hatte zuvor zu angefügt wurde eine <xref:System.Windows.Controls.Button>.  
  
 [!code-csharp[commandingoverviewsnippets#CommandingOverviewCmdManagerRemoveHandlers](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewcmdmanagerremovehandlers)]
 [!code-vb[commandingoverviewsnippets#CommandingOverviewCmdManagerRemoveHandlers](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewcmdmanagerremovehandlers)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> oder <paramref name="handler" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.ICommand" />
      </Docs>
    </Member>
    <Member MemberName="RequerySuggested">
      <MemberSignature Language="C#" Value="public static event EventHandler RequerySuggested;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RequerySuggested" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.CommandManager.RequerySuggested" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event RequerySuggested As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ RequerySuggested;" />
      <MemberSignature Language="F#" Value="member this.RequerySuggested : EventHandler " Usage="member this.RequerySuggested : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="T:System.Windows.Input.CommandManager" /> Bedingungen erkennt, die eine Befehlsausführung beeinflussen könnten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis hält die Verbindung mit dem Ereignishandler als einen schwachen Verweis. Objekte, die für dieses Ereignis lauscht sollten einen starken Verweis an ihren Ereignishandler Dies wird Garbage Collection zu verhindern. Dies kann erfolgen, da Sie ein privates Feld und den Handler als des Werts zugewiesen werden, vor oder nach dem Anfügen an dieses Ereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>