<Type Name="KeyEventArgs" FullName="System.Windows.Input.KeyEventArgs">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b2c5f4b3c5b9bb811d7794a39951e25434e8cdff" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78840862" /></Metadata><TypeSignature Language="C#" Value="public class KeyEventArgs : System.Windows.Input.KeyboardEventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit KeyEventArgs extends System.Windows.Input.KeyboardEventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.KeyEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class KeyEventArgs&#xA;Inherits KeyboardEventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class KeyEventArgs : System::Windows::Input::KeyboardEventArgs" />
  <TypeSignature Language="F#" Value="type KeyEventArgs = class&#xA;    inherit KeyboardEventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Input.KeyboardEventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt Daten für die Routingereignisse <see cref="E:System.Windows.UIElement.KeyUp" /> und <see cref="E:System.Windows.UIElement.KeyDown" /> sowie dazugehörige angefügte und Vorschauereignisse bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Ereignisdaten Klasse wird mit den folgenden angefügten Ereignissen verwendet:  
  
-   <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType>  
  
 Diese Ereignisdaten Klasse wird auch mit den folgenden Routing Ereignissen für Basiselemente verwendet. Diese Routing Ereignisse leiten die zuvor aufgelisteten angefügten Ereignisse weiter, um Sie für das allgemeine Element Modell in [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]besser zugänglich zu machen.  
  
-   <xref:System.Windows.UIElement.KeyUp?displayProperty=nameWithType>  
  
-   <xref:System.Windows.UIElement.KeyDown?displayProperty=nameWithType>  
  
-   <xref:System.Windows.UIElement.PreviewKeyUp?displayProperty=nameWithType>  
  
-   <xref:System.Windows.UIElement.PreviewKeyDown?displayProperty=nameWithType>  
  
-   <xref:System.Windows.ContentElement.KeyUp?displayProperty=nameWithType>  
  
-   <xref:System.Windows.ContentElement.KeyDown?displayProperty=nameWithType>  
  
-   <xref:System.Windows.ContentElement.PreviewKeyUp?displayProperty=nameWithType>  
  
-   <xref:System.Windows.ContentElement.PreviewKeyDown?displayProperty=nameWithType>  
  
 Die angefügten Ereignisse und die Routing Ereignisse für das Basiselement nutzen Ihre Ereignisdaten gemeinsam, und die Blasen-und tunnelingversionen der Routing Ereignisse geben auch Ereignisdaten frei. Dies kann sich auf die behandelten Merkmale des Ereignisses auswirken, wenn es die Ereignis Route durchläuft. Weitere Informationen finden Sie unter [Übersicht über die Eingabe](~/docs/framework/wpf/advanced/input-overview.md).  
  
 Ein Schlüssel kann sich in den Status "hoch" und "ein-oder ausgeschaltet" oder "nach unten" und "ein/aus" befinden. Aus diesem Grund ist es nicht so einfach, festzustellen, ob es sich um einen Schlüssel handelt, der den <xref:System.Windows.Input.KeyEventArgs.KeyStates%2A> Wert als numerischen Wert überprüft. Stattdessen sollten Sie den Wert überprüfen, indem Sie ihn als Flagenumeration behandeln. Verwenden Sie einen `AND` Vergleich des ersten Bits. Verwenden Sie alternativ die Hilfseigenschaften <xref:System.Windows.Input.KeyEventArgs.IsUp%2A>, <xref:System.Windows.Input.KeyEventArgs.IsDown%2A>und <xref:System.Windows.Input.KeyEventArgs.IsToggled%2A>, um zu bestimmen, ob ein bestimmter Schlüssel ein-oder ausgeschaltet ist.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Input.KeyEventHandler" />
    <altmember cref="T:System.Windows.Input.KeyboardEventArgs" />
    <altmember cref="T:System.Windows.Input.KeyboardEventHandler" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public KeyEventArgs (System.Windows.Input.KeyboardDevice keyboard, System.Windows.PresentationSource inputSource, int timestamp, System.Windows.Input.Key key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Input.KeyboardDevice keyboard, class System.Windows.PresentationSource inputSource, int32 timestamp, valuetype System.Windows.Input.Key key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.KeyEventArgs.#ctor(System.Windows.Input.KeyboardDevice,System.Windows.PresentationSource,System.Int32,System.Windows.Input.Key)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (keyboard As KeyboardDevice, inputSource As PresentationSource, timestamp As Integer, key As Key)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; KeyEventArgs(System::Windows::Input::KeyboardDevice ^ keyboard, System::Windows::PresentationSource ^ inputSource, int timestamp, System::Windows::Input::Key key);" />
      <MemberSignature Language="F#" Value="new System.Windows.Input.KeyEventArgs : System.Windows.Input.KeyboardDevice * System.Windows.PresentationSource * int * System.Windows.Input.Key -&gt; System.Windows.Input.KeyEventArgs" Usage="new System.Windows.Input.KeyEventArgs (keyboard, inputSource, timestamp, key)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="keyboard" Type="System.Windows.Input.KeyboardDevice" />
        <Parameter Name="inputSource" Type="System.Windows.PresentationSource" />
        <Parameter Name="timestamp" Type="System.Int32" />
        <Parameter Name="key" Type="System.Windows.Input.Key" />
      </Parameters>
      <Docs>
        <param name="keyboard">Das logische Tastaturgerät, das diesem Ereignis zugeordnet ist.</param>
        <param name="inputSource">Die Eingabequelle.</param>
        <param name="timestamp">Die Zeit der Eingabe.</param>
        <param name="key">Die Taste, auf die das Ereignis verweist.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Input.KeyEventArgs" />-Klasse.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Input.KeyEventHandler" />
        <altmember cref="T:System.Windows.Input.KeyboardEventArgs" />
        <altmember cref="T:System.Windows.Input.KeyboardEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="DeadCharProcessedKey">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Key DeadCharProcessedKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Input.Key DeadCharProcessedKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.KeyEventArgs.DeadCharProcessedKey" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeadCharProcessedKey As Key" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Key DeadCharProcessedKey { System::Windows::Input::Key get(); };" />
      <MemberSignature Language="F#" Value="member this.DeadCharProcessedKey : System.Windows.Input.Key" Usage="System.Windows.Input.KeyEventArgs.DeadCharProcessedKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Key</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Taste ab, die Teil einer Tottastenkombination ist, um ein einzelnes kombiniertes Zeichen zu erstellen.</summary>
        <value>Die Taste, die Teil einer Tottastenkombination ist, um ein einzelnes kombiniertes Zeichen zu erstellen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine unzustellbare Taste erzeugt kein sichtbares Zeichen, gibt aber an, dass der Schlüssel mit dem Zeichen kombiniert werden soll, das durch den nächsten Buchstaben gedrückt wird  Wenn <xref:System.Windows.Input.KeyEventArgs.Key%2A> <xref:System.Windows.Input.Key.DeadCharProcessed?displayProperty=nameWithType>zurückgibt, können Sie diese Eigenschaft verwenden, um den tatsächlich eingegebenen Schlüssel zu erhalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImeProcessedKey">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Key ImeProcessedKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Input.Key ImeProcessedKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.KeyEventArgs.ImeProcessedKey" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ImeProcessedKey As Key" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Key ImeProcessedKey { System::Windows::Input::Key get(); };" />
      <MemberSignature Language="F#" Value="member this.ImeProcessedKey : System.Windows.Input.Key" Usage="System.Windows.Input.KeyEventArgs.ImeProcessedKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Key</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Taste ab, auf die das Ereignis verweist, wenn die Taste von einem [!INCLUDE[TLA#tla_ime](~/includes/tlasharptla-ime-md.md)] verarbeitet wird.</summary>
        <value>Die <see cref="T:System.Windows.Input.Key" />, auf die das Ereignis verweist.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Input.KeyEventHandler" />
        <altmember cref="T:System.Windows.Input.KeyboardEventArgs" />
        <altmember cref="T:System.Windows.Input.KeyboardEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="InputSource">
      <MemberSignature Language="C#" Value="public System.Windows.PresentationSource InputSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PresentationSource InputSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.KeyEventArgs.InputSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputSource As PresentationSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PresentationSource ^ InputSource { System::Windows::PresentationSource ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InputSource : System.Windows.PresentationSource" Usage="System.Windows.Input.KeyEventArgs.InputSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PresentationSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Eingabequelle ab, die diese Eingabe bereitgestellt hat.</summary>
        <value>Die Eingabequelle.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Input.KeyEventHandler" />
        <altmember cref="T:System.Windows.Input.KeyboardEventArgs" />
        <altmember cref="T:System.Windows.Input.KeyboardEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected override void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.KeyEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberSignature Language="F#" Value="override this.InvokeEventHandler : Delegate * obj -&gt; unit" Usage="keyEventArgs.InvokeEventHandler (genericHandler, genericTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler">Der generische Handler, der auf typspezifische Weise aufgerufen werden soll.</param>
        <param name="genericTarget">Das Ziel, für das der Handler aufgerufen werden soll.</param>
        <summary>Ruft Ereignishandler auf typspezifische Weise auf, wodurch sich die Effizienz des Ereignissystems erhöhen kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung wandelt den generischen Handler als <xref:System.Windows.Input.KeyEventHandler> um und ruft ihn anschließend auf. Ausführliche Informationen zu diesem Implementierungs Muster und den dafür genannten Gründen finden Sie unter Übersicht über <xref:System.Windows.RoutedEventArgs.InvokeEventHandler%2A> und Routing [Ereignisse](~/docs/framework/wpf/advanced/routed-events-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDown">
      <MemberSignature Language="C#" Value="public bool IsDown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDown" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.KeyEventArgs.IsDown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDown { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDown : bool" Usage="System.Windows.Input.KeyEventArgs.IsDown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Taste, auf die das Ereignis verweist, im gedrückten Zustand ist.</summary>
        <value><see langword="true" />, wenn die Taste gedrückt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Input.Keyboard>-Klasse stellt auch Informationen über den Zustand der Schlüssel auf der Tastatur bereit. Die <xref:System.Windows.Input.Keyboard.IsKeyDown%2A>-Methode gibt beispielsweise zurück, ob ein angegebener Schlüssel nicht angezeigt wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird überprüft, ob der einer Instanz von zugeordnete Schlüssel durch Abrufen des Status der <xref:System.Windows.Input.KeyEventArgs.IsDown%2A>-Eigenschaft nicht mehr <xref:System.Windows.Input.KeyEventArgs>.  
  
 [!code-csharp[keyargssnippetsample#KeyEventArgsIsDown](~/samples/snippets/csharp/VS_Snippets_Wpf/KeyArgsSnippetSample/CSharp/Window1.xaml.cs#keyeventargsisdown)]
 [!code-vb[keyargssnippetsample#KeyEventArgsIsDown](~/samples/snippets/visualbasic/VS_Snippets_Wpf/KeyArgsSnippetSample/visualbasic/window1.xaml.vb#keyeventargsisdown)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.KeyEventHandler" />
        <altmember cref="T:System.Windows.Input.KeyboardEventArgs" />
        <altmember cref="T:System.Windows.Input.KeyboardEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="IsRepeat">
      <MemberSignature Language="C#" Value="public bool IsRepeat { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRepeat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.KeyEventArgs.IsRepeat" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRepeat As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRepeat { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsRepeat : bool" Usage="System.Windows.Input.KeyEventArgs.IsRepeat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Taste, auf die das Ereignis verweist, eine wiederholte Taste ist.</summary>
        <value><see langword="true" />, wenn die Taste wiederholt wird, andernfalls <see langword="false" />.  Es ist kein Standardwert vorhanden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird überprüft, ob der einer Instanz <xref:System.Windows.Input.KeyEventArgs> von zugeordnete Schlüssel ein wiederholter Schlüssel ist, indem der Status der <xref:System.Windows.Input.KeyEventArgs.IsRepeat%2A>-Eigenschaft erhalten wird.  
  
 [!code-csharp[keyargssnippetsample#KeyEventArgsIsRepeat](~/samples/snippets/csharp/VS_Snippets_Wpf/KeyArgsSnippetSample/CSharp/Window1.xaml.cs#keyeventargsisrepeat)]
 [!code-vb[keyargssnippetsample#KeyEventArgsIsRepeat](~/samples/snippets/visualbasic/VS_Snippets_Wpf/KeyArgsSnippetSample/visualbasic/window1.xaml.vb#keyeventargsisrepeat)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.KeyEventHandler" />
        <altmember cref="T:System.Windows.Input.KeyboardEventArgs" />
        <altmember cref="T:System.Windows.Input.KeyboardEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="IsToggled">
      <MemberSignature Language="C#" Value="public bool IsToggled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsToggled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.KeyEventArgs.IsToggled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsToggled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsToggled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsToggled : bool" Usage="System.Windows.Input.KeyEventArgs.IsToggled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Taste, auf die das Ereignis verweist, im umgeschalteten Zustand ist.</summary>
        <value><see langword="true" />, wenn die Taste umgeschaltet ist, andernfalls <see langword="false" />.  Es ist kein Standardwert vorhanden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Input.Keyboard>-Klasse stellt auch Informationen über den Zustand der Schlüssel auf der Tastatur bereit. Die <xref:System.Windows.Input.Keyboard.IsKeyToggled%2A>-Methode gibt beispielsweise zurück, ob ein angegebener Schlüssel ein-und ausgeschaltet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird überprüft, ob der einem <xref:System.Windows.Input.KeyEventArgs> zugeordnete Schlüssel durch Abrufen des Status der <xref:System.Windows.Input.KeyEventArgs.IsToggled%2A>-Eigenschaft ein-und ausgeschaltet wird.  
  
 [!code-csharp[keyargssnippetsample#KeyEventArgsIsToggled](~/samples/snippets/csharp/VS_Snippets_Wpf/KeyArgsSnippetSample/CSharp/Window1.xaml.cs#keyeventargsistoggled)]
 [!code-vb[keyargssnippetsample#KeyEventArgsIsToggled](~/samples/snippets/visualbasic/VS_Snippets_Wpf/KeyArgsSnippetSample/visualbasic/window1.xaml.vb#keyeventargsistoggled)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.KeyEventHandler" />
        <altmember cref="T:System.Windows.Input.KeyboardEventArgs" />
        <altmember cref="T:System.Windows.Input.KeyboardEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="IsUp">
      <MemberSignature Language="C#" Value="public bool IsUp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUp" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.KeyEventArgs.IsUp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUp As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUp { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUp : bool" Usage="System.Windows.Input.KeyEventArgs.IsUp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Taste, auf die das Ereignis verweist, im nicht gedrückten Zustand ist.</summary>
        <value><see langword="true" />, wenn die Taste nicht gedrückt ist, andernfalls <see langword="false" />.  Es ist kein Standardwert vorhanden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Input.Keyboard>-Klasse stellt auch Informationen über den Zustand der Schlüssel auf der Tastatur bereit.  Die <xref:System.Windows.Input.Keyboard.IsKeyUp%2A>-Methode gibt beispielsweise zurück, ob ein angegebenes ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird überprüft, ob der einem <xref:System.Windows.Input.KeyEventArgs> zugeordnete Schlüssel durch Abrufen des Status der <xref:System.Windows.Input.KeyEventArgs.IsUp%2A>-Eigenschaft aktiv ist.  
  
 [!code-csharp[keyargssnippetsample#KeyEventArgsIsUp](~/samples/snippets/csharp/VS_Snippets_Wpf/KeyArgsSnippetSample/CSharp/Window1.xaml.cs#keyeventargsisup)]
 [!code-vb[keyargssnippetsample#KeyEventArgsIsUp](~/samples/snippets/visualbasic/VS_Snippets_Wpf/KeyArgsSnippetSample/visualbasic/window1.xaml.vb#keyeventargsisup)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.KeyEventHandler" />
        <altmember cref="T:System.Windows.Input.KeyboardEventArgs" />
        <altmember cref="T:System.Windows.Input.KeyboardEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Key">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Key Key { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Input.Key Key" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.KeyEventArgs.Key" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Key As Key" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Key Key { System::Windows::Input::Key get(); };" />
      <MemberSignature Language="F#" Value="member this.Key : System.Windows.Input.Key" Usage="System.Windows.Input.KeyEventArgs.Key" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Key</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die dem Ereignis zugeordnete Taste der Tastatur ab.</summary>
        <value>Die <see cref="T:System.Windows.Input.Key" />, auf die das Ereignis verweist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Windows.Input.KeyEventHandler> erstellt und überprüft, ob der Schlüssel, der der <xref:System.Windows.Input.KeyEventArgs> zugeordnet ist, der <xref:System.Windows.Input.Key.Return> Schlüssel ist.  
  
 [!code-csharp[keydown#KeyDownSample](~/samples/snippets/csharp/VS_Snippets_Wpf/KeyDown/CSharp/Window1.xaml.cs#keydownsample)]
 [!code-vb[keydown#KeyDownSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/KeyDown/VisualBasic/Window1.xaml.vb#keydownsample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.KeyEventHandler" />
        <altmember cref="T:System.Windows.Input.KeyboardEventArgs" />
        <altmember cref="T:System.Windows.Input.KeyboardEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="KeyStates">
      <MemberSignature Language="C#" Value="public System.Windows.Input.KeyStates KeyStates { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Input.KeyStates KeyStates" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.KeyEventArgs.KeyStates" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property KeyStates As KeyStates" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::KeyStates KeyStates { System::Windows::Input::KeyStates get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyStates : System.Windows.Input.KeyStates" Usage="System.Windows.Input.KeyEventArgs.KeyStates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyStates</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Zustand der diesem Ereignis zugeordneten Taste ab.</summary>
        <value>Der Zustand der Taste.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Schlüssel kann sich in den Status "hoch" und "ein-oder ausgeschaltet" oder "nach unten" und "ein/aus" befinden. Aus diesem Grund ist es nicht so einfach, festzustellen, ob es sich um einen Schlüssel handelt, der den <xref:System.Windows.Input.KeyEventArgs.KeyStates%2A> Wert als numerischen Wert überprüft. Stattdessen sollten Sie den Wert überprüfen, indem Sie ihn als Flagenumeration behandeln. Verwenden Sie einen `AND` Vergleich des ersten Bits. Verwenden Sie alternativ die Hilfseigenschaften <xref:System.Windows.Input.KeyEventArgs.IsUp%2A>, <xref:System.Windows.Input.KeyEventArgs.IsDown%2A>und <xref:System.Windows.Input.KeyEventArgs.IsToggled%2A>, um zu bestimmen, ob ein bestimmter Schlüssel ein-oder ausgeschaltet ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird überprüft, ob ein Schlüssel, der einer Instanz von zugeordnet ist, <xref:System.Windows.Input.KeyEventArgs> ist, indem ein bitweiser `AND` Vergleich der <xref:System.Windows.Input.KeyEventArgs.KeyStates%2A> des Schlüssels und des <xref:System.Windows.Input.KeyStates.Down> Enumerationswerts durchgeführt wird.  
  
 [!code-csharp[keyargssnippetsample#KeyEventArgsKeyStatesDown](~/samples/snippets/csharp/VS_Snippets_Wpf/KeyArgsSnippetSample/CSharp/Window1.xaml.cs#keyeventargskeystatesdown)]
 [!code-vb[keyargssnippetsample#KeyEventArgsKeyStatesDown](~/samples/snippets/visualbasic/VS_Snippets_Wpf/KeyArgsSnippetSample/visualbasic/window1.xaml.vb#keyeventargskeystatesdown)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.KeyEventHandler" />
        <altmember cref="T:System.Windows.Input.KeyboardEventArgs" />
        <altmember cref="T:System.Windows.Input.KeyboardEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="SystemKey">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Key SystemKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Input.Key SystemKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.KeyEventArgs.SystemKey" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SystemKey As Key" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Key SystemKey { System::Windows::Input::Key get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemKey : System.Windows.Input.Key" Usage="System.Windows.Input.KeyEventArgs.SystemKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Key</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Taste ab, auf die das Ereignis verweist, wenn die Taste vom System verarbeitet wird.</summary>
        <value>Die <see cref="T:System.Windows.Input.Key" />, auf die das Ereignis verweist.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Input.KeyEventHandler" />
        <altmember cref="T:System.Windows.Input.KeyboardEventArgs" />
        <altmember cref="T:System.Windows.Input.KeyboardEventHandler" />
      </Docs>
    </Member>
  </Members>
</Type>
