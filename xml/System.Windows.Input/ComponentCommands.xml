<Type Name="ComponentCommands" FullName="System.Windows.Input.ComponentCommands">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a0f011ced3ca1c895bf2d583fec2604cd728a48b" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82497475" /></Metadata><TypeSignature Language="C#" Value="public static class ComponentCommands" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ComponentCommands extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.ComponentCommands" />
  <TypeSignature Language="VB.NET" Value="Public Class ComponentCommands" />
  <TypeSignature Language="C++ CLI" Value="public ref class ComponentCommands abstract sealed" />
  <TypeSignature Language="F#" Value="type ComponentCommands = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt einen Standardsatz von komponentenbezogenen Befehlen bereit, die über vordefinierte Schlüsseleingabegesten und <see cref="P:System.Windows.Input.RoutedUICommand.Text" />-Eigenschaften verfügen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Befehle in der <xref:System.Windows.Input.ComponentCommands>-Klasse und Befehle in den anderen Befehls Bibliotheks Klassen, z. b. <xref:System.Windows.Input.ApplicationCommands> und <xref:System.Windows.Input.NavigationCommands>, sollen eine Reihe allgemeiner Befehle darstellen, die Anwendungsprogrammierer häufig treffen.  Die Befehle stellen nur die Instanz des <xref:System.Windows.Input.RoutedCommand> dar, nicht die Implementierungs Logik für den Befehl. Die Implementierungs Logik wird über einen <xref:System.Windows.UIElement.CommandBindings%2A>an den Befehl gebunden. Wenn der <xref:System.Windows.Input.ComponentCommands.MoveLeft%2A>-Befehl z. b. auf einem-Steuerelement (dem Befehls Ziel) ausgeführt wird, kann die Logik, die den <xref:System.Windows.Input.ComponentCommands.MoveLeft%2A>-Befehl ausführt, nicht vom Befehls Ziel bereitgestellt werden, sodass der anwendungswriter für das Schreiben der Logik zuständig ist, die bestimmt, wie das Befehls Ziel den Befehl verarbeitet.  
  
 Viele Steuerelemente bieten jedoch Implementierungs Logik für viele der Befehle in der Befehls Bibliothek.  Die <xref:System.Windows.Controls.TextBox>-Klasse stellt z. b. Logik für den <xref:System.Windows.Input.ApplicationCommands.Paste%2A> Befehl, <xref:System.Windows.Input.ApplicationCommands.Cut%2A> Befehl, <xref:System.Windows.Input.ApplicationCommands.Copy%2A> Befehl, <xref:System.Windows.Input.ApplicationCommands.Undo%2A> Befehl und <xref:System.Windows.Input.ApplicationCommands.Redo%2A> Befehl bereit. Weitere Informationen finden Sie in der-Klassen Dokumentation für bestimmte Steuerelement Klassen.  
  
 Weitere Informationen zu Befehlen und Befehlen finden Sie unter [Befehls Übersicht](~/docs/framework/wpf/advanced/commanding-overview.md).  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Input.MediaCommands" />
    <altmember cref="T:System.Windows.Input.NavigationCommands" />
    <altmember cref="T:System.Windows.Input.ApplicationCommands" />
    <altmember cref="T:System.Windows.Documents.EditingCommands" />
    <altmember cref="T:System.Windows.Input.RoutedCommand" />
    <altmember cref="T:System.Windows.Input.RoutedUICommand" />
    <altmember cref="T:System.Windows.Input.CommandBinding" />
    <altmember cref="T:System.Windows.Input.CommandManager" />
  </Docs>
  <Members>
    <Member MemberName="ExtendSelectionDown">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ExtendSelectionDown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ExtendSelectionDown" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ComponentCommands.ExtendSelectionDown" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExtendSelectionDown As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ExtendSelectionDown { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtendSelectionDown : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Input.ComponentCommands.ExtendSelectionDown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der den Befehl „Auswahl nach unten erweitern“ darstellt.</summary>
        <value>Der Befehl.  
  
 <list type="table"><listheader><term> Standardwerte  
  
 </term><description></description></listheader><item><term> Tastenkombination  
  
 </term><description> UMSCHALT+NACH-UNTEN  
  
 </description></item><item><term> Text der Benutzeroberfläche  
  
 </term><description> ExtendSelectionDown  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl gibt an, dass die Auswahl nach unten erweitert werden soll.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf den Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung als Reaktion auf diesen Befehl die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_ExtendSelectionDown"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="ExtendSelectionDown"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MediaCommands" />
        <altmember cref="T:System.Windows.Input.NavigationCommands" />
        <altmember cref="T:System.Windows.Input.ApplicationCommands" />
        <altmember cref="T:System.Windows.Documents.EditingCommands" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.RoutedUICommand" />
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="ExtendSelectionLeft">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ExtendSelectionLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ExtendSelectionLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ComponentCommands.ExtendSelectionLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExtendSelectionLeft As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ExtendSelectionLeft { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtendSelectionLeft : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Input.ComponentCommands.ExtendSelectionLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der den Befehl „Auswahl nach links erweitern“ darstellt.</summary>
        <value>Der Befehl.  
  
 <list type="table"><listheader><term> Standardwerte  
  
 </term><description></description></listheader><item><term> Tastenkombination  
  
 </term><description> UMSCHALT+NACH-LINKS  
  
 </description></item><item><term> Text der Benutzeroberfläche  
  
 </term><description> ExtendSelectionLeft  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl gibt an, dass die Auswahl auf die linke Seite erweitert werden soll.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf den Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung als Reaktion auf diesen Befehl die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_ExtendSelectionLeft"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="ExtendSelectionLeft"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MediaCommands" />
        <altmember cref="T:System.Windows.Input.NavigationCommands" />
        <altmember cref="T:System.Windows.Input.ApplicationCommands" />
        <altmember cref="T:System.Windows.Documents.EditingCommands" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.RoutedUICommand" />
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="ExtendSelectionRight">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ExtendSelectionRight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ExtendSelectionRight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ComponentCommands.ExtendSelectionRight" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExtendSelectionRight As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ExtendSelectionRight { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtendSelectionRight : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Input.ComponentCommands.ExtendSelectionRight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der den Befehl „Auswahl nach rechts erweitern“ darstellt.</summary>
        <value>Der Befehl.  
  
 <list type="table"><listheader><term> Standardwerte  
  
 </term><description></description></listheader><item><term> Tastenkombination  
  
 </term><description> UMSCHALT+NACH-RECHTS  
  
 </description></item><item><term> Text der Benutzeroberfläche  
  
 </term><description> ExtendSelectionRight  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl gibt an, dass die Auswahl auf die Rechte Seite erweitert werden soll.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf den Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung als Reaktion auf diesen Befehl die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_ExtendSelectionRight"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="ExtendSelectionRight"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MediaCommands" />
        <altmember cref="T:System.Windows.Input.NavigationCommands" />
        <altmember cref="T:System.Windows.Input.ApplicationCommands" />
        <altmember cref="T:System.Windows.Documents.EditingCommands" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.RoutedUICommand" />
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="ExtendSelectionUp">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ExtendSelectionUp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ExtendSelectionUp" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ComponentCommands.ExtendSelectionUp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExtendSelectionUp As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ExtendSelectionUp { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtendSelectionUp : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Input.ComponentCommands.ExtendSelectionUp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der den Befehl „Auswahl nach oben erweitern“ darstellt.</summary>
        <value>Der Befehl.  
  
 <list type="table"><listheader><term> Standardwerte  
  
 </term><description></description></listheader><item><term> Tastenkombination  
  
 </term><description> UMSCHALT+NACH-OBEN  
  
 </description></item><item><term> Text der Benutzeroberfläche  
  
 </term><description> ExtendSelectionUp  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl gibt an, dass die Auswahl nach oben erweitert werden soll.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf den Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung als Reaktion auf diesen Befehl die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_ExtendSelectionUp"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="ExtendSelectionUp"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MediaCommands" />
        <altmember cref="T:System.Windows.Input.NavigationCommands" />
        <altmember cref="T:System.Windows.Input.ApplicationCommands" />
        <altmember cref="T:System.Windows.Documents.EditingCommands" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.RoutedUICommand" />
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="MoveDown">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDown" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ComponentCommands.MoveDown" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDown As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDown { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDown : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Input.ComponentCommands.MoveDown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der den Befehl „Nach unten“ darstellt.</summary>
        <value>Der Befehl.  
  
 <list type="table"><listheader><term> Standardwerte  
  
 </term><description></description></listheader><item><term> Tastenkombination  
  
 </term><description> Nach unten  
  
 </description></item><item><term> Text der Benutzeroberfläche  
  
 </term><description> Nach unten  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl gibt an, dass die Auswahl nach unten erweitert werden soll.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf den Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung als Reaktion auf diesen Befehl die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_MoveDown"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveDown"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MediaCommands" />
        <altmember cref="T:System.Windows.Input.NavigationCommands" />
        <altmember cref="T:System.Windows.Input.ApplicationCommands" />
        <altmember cref="T:System.Windows.Documents.EditingCommands" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.RoutedUICommand" />
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="MoveFocusBack">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveFocusBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveFocusBack" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ComponentCommands.MoveFocusBack" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveFocusBack As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveFocusBack { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveFocusBack : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Input.ComponentCommands.MoveFocusBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der den Befehl „Fokus nach hinten verschieben“ darstellt.</summary>
        <value>Der Befehl.  
  
 <list type="table"><listheader><term> Standardwerte  
  
 </term><description></description></listheader><item><term> Tastenkombination  
  
 </term><description> STRG+NACH-LINKS  
  
 </description></item><item><term> Text der Benutzeroberfläche  
  
 </term><description> MoveFocusBack  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl gibt an, dass die Auswahl rückwärts erweitert werden soll.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf den Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung als Reaktion auf diesen Befehl die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_MoveFocusBack"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveFocusBack"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MediaCommands" />
        <altmember cref="T:System.Windows.Input.NavigationCommands" />
        <altmember cref="T:System.Windows.Input.ApplicationCommands" />
        <altmember cref="T:System.Windows.Documents.EditingCommands" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.RoutedUICommand" />
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="MoveFocusDown">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveFocusDown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveFocusDown" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ComponentCommands.MoveFocusDown" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveFocusDown As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveFocusDown { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveFocusDown : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Input.ComponentCommands.MoveFocusDown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der den Befehl „Fokus nach unten verschieben“ darstellt.</summary>
        <value>Der Befehl.  
  
 <list type="table"><listheader><term> Standardwerte  
  
 </term><description></description></listheader><item><term> Tastenkombination  
  
 </term><description> STRG+NACH-UNTEN  
  
 </description></item><item><term> Text der Benutzeroberfläche  
  
 </term><description> MoveFocusDown  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl gibt an, dass der Fokus erweitert werden soll.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf den Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung als Reaktion auf diesen Befehl die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_MoveFocusDown"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveFocusDown"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MediaCommands" />
        <altmember cref="T:System.Windows.Input.NavigationCommands" />
        <altmember cref="T:System.Windows.Input.ApplicationCommands" />
        <altmember cref="T:System.Windows.Documents.EditingCommands" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.RoutedUICommand" />
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="MoveFocusForward">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveFocusForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveFocusForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ComponentCommands.MoveFocusForward" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveFocusForward As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveFocusForward { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveFocusForward : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Input.ComponentCommands.MoveFocusForward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der den Befehl „Fokus nach vorne verschieben“ darstellt.</summary>
        <value>Der Befehl.  
  
 <list type="table"><listheader><term> Standardwerte  
  
 </term><description></description></listheader><item><term> Tastenkombination  
  
 </term><description> STRG+NACH-RECHTS  
  
 </description></item><item><term> Text der Benutzeroberfläche  
  
 </term><description> MoveFocusForward  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl gibt die Absicht an, den Fokus nach vorne zu verschieben.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf den Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung als Reaktion auf diesen Befehl die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_MoveFocusForward"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveFocusForward"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MediaCommands" />
        <altmember cref="T:System.Windows.Input.NavigationCommands" />
        <altmember cref="T:System.Windows.Input.ApplicationCommands" />
        <altmember cref="T:System.Windows.Documents.EditingCommands" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.RoutedUICommand" />
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="MoveFocusPageDown">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveFocusPageDown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveFocusPageDown" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ComponentCommands.MoveFocusPageDown" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveFocusPageDown As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveFocusPageDown { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveFocusPageDown : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Input.ComponentCommands.MoveFocusPageDown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der den Befehl „Fokus eine Seite nach unten verschieben“ darstellt.</summary>
        <value>Der Befehl.  
  
 <list type="table"><listheader><term> Standardwerte  
  
 </term><description></description></listheader><item><term> Tastenkombination  
  
 </term><description> STRG+BILD-AB  
  
 </description></item><item><term> Text der Benutzeroberfläche  
  
 </term><description> MoveFocusPageDown  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl gibt an, dass der Fokus eine Seite nach unten verschieben soll.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf den Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung als Reaktion auf diesen Befehl die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_MoveFocusPageDown"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveFocusPageDown"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MediaCommands" />
        <altmember cref="T:System.Windows.Input.NavigationCommands" />
        <altmember cref="T:System.Windows.Input.ApplicationCommands" />
        <altmember cref="T:System.Windows.Documents.EditingCommands" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.RoutedUICommand" />
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="MoveFocusPageUp">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveFocusPageUp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveFocusPageUp" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ComponentCommands.MoveFocusPageUp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveFocusPageUp As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveFocusPageUp { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveFocusPageUp : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Input.ComponentCommands.MoveFocusPageUp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der den Befehl „Fokus eine Seite nach oben verschieben“ darstellt.</summary>
        <value>Der Befehl.  
  
 <list type="table"><listheader><term> Standardwerte  
  
 </term><description></description></listheader><item><term> Tastenkombination  
  
 </term><description> STRG+BILD-AUF  
  
 </description></item><item><term> Text der Benutzeroberfläche  
  
 </term><description> MoveFocusPageUp  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl gibt an, dass der Fokus eine Seite nach oben verschoben werden soll.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf den Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung als Reaktion auf diesen Befehl die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_MoveFocusPageUp"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveFocusPageUp"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MediaCommands" />
        <altmember cref="T:System.Windows.Input.NavigationCommands" />
        <altmember cref="T:System.Windows.Input.ApplicationCommands" />
        <altmember cref="T:System.Windows.Documents.EditingCommands" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.RoutedUICommand" />
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="MoveFocusUp">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveFocusUp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveFocusUp" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ComponentCommands.MoveFocusUp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveFocusUp As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveFocusUp { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveFocusUp : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Input.ComponentCommands.MoveFocusUp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der den Befehl „Fokus nach oben verschieben“ darstellt.</summary>
        <value>Der Befehl.  
  
 <list type="table"><listheader><term> Standardwerte  
  
 </term><description></description></listheader><item><term> Tastenkombination  
  
 </term><description> STRG+NACH-OBEN  
  
 </description></item><item><term> Text der Benutzeroberfläche  
  
 </term><description> MoveFocusUp  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl gibt an, dass der Fokus nach oben verschoben werden soll.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf den Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung als Reaktion auf diesen Befehl die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_MoveFocusUp"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveFocusUp"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MediaCommands" />
        <altmember cref="T:System.Windows.Input.NavigationCommands" />
        <altmember cref="T:System.Windows.Input.ApplicationCommands" />
        <altmember cref="T:System.Windows.Documents.EditingCommands" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.RoutedUICommand" />
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="MoveLeft">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ComponentCommands.MoveLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveLeft As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveLeft { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveLeft : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Input.ComponentCommands.MoveLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der den Befehl „Nach links verschieben“ darstellt.</summary>
        <value>Der Befehl.  
  
 <list type="table"><listheader><term> Standardwerte  
  
 </term><description></description></listheader><item><term> Tastenkombination  
  
 </term><description> Links  
  
 </description></item><item><term> Text der Benutzeroberfläche  
  
 </term><description> MoveLeft  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl gibt an, dass die Auswahl nach links verschoben werden soll.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf den Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung als Reaktion auf diesen Befehl die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_MoveLeft"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveLeft"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MediaCommands" />
        <altmember cref="T:System.Windows.Input.NavigationCommands" />
        <altmember cref="T:System.Windows.Input.ApplicationCommands" />
        <altmember cref="T:System.Windows.Documents.EditingCommands" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.RoutedUICommand" />
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="MoveRight">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveRight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveRight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ComponentCommands.MoveRight" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveRight As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveRight { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveRight : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Input.ComponentCommands.MoveRight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der den Befehl "Nach rechts" darstellt.</summary>
        <value>Der Befehl.  
  
 <list type="table"><listheader><term> Standardwerte  
  
 </term><description></description></listheader><item><term> Tastenkombination  
  
 </term><description> Rechts  
  
 </description></item><item><term> Text der Benutzeroberfläche  
  
 </term><description> Nach rechts verschieben  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl gibt an, dass die Auswahl nach rechts verschoben werden soll.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf den Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung als Reaktion auf diesen Befehl die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_MoveRight"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveRight"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MediaCommands" />
        <altmember cref="T:System.Windows.Input.NavigationCommands" />
        <altmember cref="T:System.Windows.Input.ApplicationCommands" />
        <altmember cref="T:System.Windows.Documents.EditingCommands" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.RoutedUICommand" />
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="MoveToEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ComponentCommands.MoveToEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Input.ComponentCommands.MoveToEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der den Befehl „Zum Ende verschieben“ darstellt.</summary>
        <value>Der Befehl.  
  
 <list type="table"><listheader><term> Standardwerte  
  
 </term><description></description></listheader><item><term> Tastenkombination  
  
 </term><description> Ende  
  
 </description></item><item><term> Text der Benutzeroberfläche  
  
 </term><description> MoveToEnd  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl gibt an, dass die Auswahl zum letzten Element verschoben werden soll.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf den Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung als Reaktion auf diesen Befehl die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_MoveToEnd"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveToEnd"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MediaCommands" />
        <altmember cref="T:System.Windows.Input.NavigationCommands" />
        <altmember cref="T:System.Windows.Input.ApplicationCommands" />
        <altmember cref="T:System.Windows.Documents.EditingCommands" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.RoutedUICommand" />
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="MoveToHome">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToHome { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToHome" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ComponentCommands.MoveToHome" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToHome As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToHome { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToHome : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Input.ComponentCommands.MoveToHome" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der den Befehl „Zu Home verschieben“ darstellt.</summary>
        <value>Der Befehl.  
  
 <list type="table"><listheader><term> Standardwerte  
  
 </term><description></description></listheader><item><term> Tastenkombination  
  
 </term><description> Startseite  
  
 </description></item><item><term> Text der Benutzeroberfläche  
  
 </term><description> MoveToHome  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl gibt an, dass die Auswahl auf das erste Element verschoben werden soll.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf den Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung als Reaktion auf diesen Befehl die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_MoveToHome"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveToHome"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MediaCommands" />
        <altmember cref="T:System.Windows.Input.NavigationCommands" />
        <altmember cref="T:System.Windows.Input.ApplicationCommands" />
        <altmember cref="T:System.Windows.Documents.EditingCommands" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.RoutedUICommand" />
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="MoveToPageDown">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToPageDown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToPageDown" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ComponentCommands.MoveToPageDown" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToPageDown As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToPageDown { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToPageDown : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Input.ComponentCommands.MoveToPageDown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der den Befehl „Eine Seite nach unten verschieben“ darstellt.</summary>
        <value>Der Befehl.  
  
 <list type="table"><listheader><term> Standardwerte  
  
 </term><description></description></listheader><item><term> Tastenkombination  
  
 </term><description> BILD-AB  
  
 </description></item><item><term> Text der Benutzeroberfläche  
  
 </term><description> MoveToPageDown  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl gibt an, dass die Auswahl um eine Seite nach unten verschoben werden soll.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf den Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung als Reaktion auf diesen Befehl die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_MoveToPageDown"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveToPageDown"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MediaCommands" />
        <altmember cref="T:System.Windows.Input.NavigationCommands" />
        <altmember cref="T:System.Windows.Input.ApplicationCommands" />
        <altmember cref="T:System.Windows.Documents.EditingCommands" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.RoutedUICommand" />
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="MoveToPageUp">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToPageUp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToPageUp" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ComponentCommands.MoveToPageUp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToPageUp As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToPageUp { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToPageUp : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Input.ComponentCommands.MoveToPageUp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der den Befehl „Eine Seite nach oben verschieben“ darstellt.</summary>
        <value>Der Befehl.  
  
 <list type="table"><listheader><term> Standardwerte  
  
 </term><description></description></listheader><item><term> Tastenkombination  
  
 </term><description> BILD-AUF  
  
 </description></item><item><term> Text der Benutzeroberfläche  
  
 </term><description> MoveToPageUp  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl gibt an, dass die Auswahl um eine Seite nach oben verschoben werden soll.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf den Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung als Reaktion auf diesen Befehl die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_MoveToPageUp"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveToPageUp"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MediaCommands" />
        <altmember cref="T:System.Windows.Input.NavigationCommands" />
        <altmember cref="T:System.Windows.Input.ApplicationCommands" />
        <altmember cref="T:System.Windows.Documents.EditingCommands" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.RoutedUICommand" />
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="MoveUp">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUp" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ComponentCommands.MoveUp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUp As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUp { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUp : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Input.ComponentCommands.MoveUp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der den Befehl „Nach oben“ darstellt.</summary>
        <value>Der Befehl.  
  
 <list type="table"><listheader><term> Standardwerte  
  
 </term><description></description></listheader><item><term> Tastenkombination  
  
 </term><description> Nach oben  
  
 </description></item><item><term> Text der Benutzeroberfläche  
  
 </term><description> Nach oben  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl gibt an, dass die Auswahl nach oben verschoben werden soll.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf den Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung als Reaktion auf diesen Befehl die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_MoveUp"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="MoveUp"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MediaCommands" />
        <altmember cref="T:System.Windows.Input.NavigationCommands" />
        <altmember cref="T:System.Windows.Input.ApplicationCommands" />
        <altmember cref="T:System.Windows.Documents.EditingCommands" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.RoutedUICommand" />
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="ScrollByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ScrollByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ScrollByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ComponentCommands.ScrollByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ScrollByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ScrollByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ScrollByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Input.ComponentCommands.ScrollByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der den Befehl „Bildlauf pro Zeile“ darstellt.</summary>
        <value>Der Befehl.  
  
 <list type="table"><listheader><term> Standardwerte  
  
 </term><description></description></listheader><item><term> Tastenkombination  
  
 </term><description> Keine Tastenkombination definiert  
  
 </description></item><item><term> Text der Benutzeroberfläche  
  
 </term><description> ScrollByLine  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl gibt an, dass ein vertikaler Bildlauf um eine bestimmte Anzahl von Zeilen durchlaufen werden soll.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf den Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung als Reaktion auf diesen Befehl die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_ScrollByLine"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="ScrollByLine"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MediaCommands" />
        <altmember cref="T:System.Windows.Input.NavigationCommands" />
        <altmember cref="T:System.Windows.Input.ApplicationCommands" />
        <altmember cref="T:System.Windows.Documents.EditingCommands" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.RoutedUICommand" />
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="ScrollPageDown">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ScrollPageDown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ScrollPageDown" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ComponentCommands.ScrollPageDown" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ScrollPageDown As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ScrollPageDown { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ScrollPageDown : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Input.ComponentCommands.ScrollPageDown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der den Befehl „Bildlauf eine Seite nach unten“ darstellt.</summary>
        <value>Der Befehl.  
  
 <list type="table"><listheader><term> Standardwerte  
  
 </term><description></description></listheader><item><term> Tastenkombination  
  
 </term><description> BILD-AB  
  
 </description></item><item><term> Text der Benutzeroberfläche  
  
 </term><description> ScrollPageDown  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl gibt an, dass der Bildlauf vertikal um eine Seite nach unten durchlaufen werden soll  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf den Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung als Reaktion auf diesen Befehl die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_ScrollPageDown"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="ScrollPageDown"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MediaCommands" />
        <altmember cref="T:System.Windows.Input.NavigationCommands" />
        <altmember cref="T:System.Windows.Input.ApplicationCommands" />
        <altmember cref="T:System.Windows.Documents.EditingCommands" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.RoutedUICommand" />
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="ScrollPageLeft">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ScrollPageLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ScrollPageLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ComponentCommands.ScrollPageLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ScrollPageLeft As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ScrollPageLeft { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ScrollPageLeft : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Input.ComponentCommands.ScrollPageLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der den Befehl „Bildlauf eine Seite nach links durchführen“ darstellt.</summary>
        <value>Der Befehl.  
  
 <list type="table"><listheader><term> Standardwerte  
  
 </term><description></description></listheader><item><term> Tastenkombination  
  
 </term><description> Keine Tastenkombination definiert  
  
 </description></item><item><term> Text der Benutzeroberfläche  
  
 </term><description> ScrollPageLeft  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl gibt an, dass die Absicht besteht, eine Seite nach Links zu scrollen.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf den Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung als Reaktion auf diesen Befehl die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_ScrollPageLeft"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="ScrollPageLeft"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MediaCommands" />
        <altmember cref="T:System.Windows.Input.NavigationCommands" />
        <altmember cref="T:System.Windows.Input.ApplicationCommands" />
        <altmember cref="T:System.Windows.Documents.EditingCommands" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.RoutedUICommand" />
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="ScrollPageRight">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ScrollPageRight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ScrollPageRight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ComponentCommands.ScrollPageRight" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ScrollPageRight As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ScrollPageRight { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ScrollPageRight : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Input.ComponentCommands.ScrollPageRight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der den Befehl „Bildlauf eine Seite nach rechts durchführen“ darstellt.</summary>
        <value>Der Befehl.  
  
 <list type="table"><listheader><term> Standardwerte  
  
 </term><description></description></listheader><item><term> Tastenkombination  
  
 </term><description> Keine Tastenkombination definiert  
  
 </description></item><item><term> Text der Benutzeroberfläche  
  
 </term><description> ScrollPageRight  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl gibt an, dass die Absicht besteht, eine Seite nach rechts zu scrollen.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf den Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung als Reaktion auf diesen Befehl die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_ScrollPageRight"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="ScrollPageRight"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MediaCommands" />
        <altmember cref="T:System.Windows.Input.NavigationCommands" />
        <altmember cref="T:System.Windows.Input.ApplicationCommands" />
        <altmember cref="T:System.Windows.Documents.EditingCommands" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.RoutedUICommand" />
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="ScrollPageUp">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ScrollPageUp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ScrollPageUp" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ComponentCommands.ScrollPageUp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ScrollPageUp As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ScrollPageUp { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ScrollPageUp : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Input.ComponentCommands.ScrollPageUp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der den Befehl „Bildlauf eine Seite nach oben“ darstellt.</summary>
        <value>Der Befehl.  
  
 <list type="table"><listheader><term> Standardwerte  
  
 </term><description></description></listheader><item><term> Tastenkombination  
  
 </term><description> BILD-AUF  
  
 </description></item><item><term> Text der Benutzeroberfläche  
  
 </term><description> ScrollPageUp  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl gibt an, dass ein vertikaler Bildlauf nach oben durch eine Seite durchführen soll  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf den Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung als Reaktion auf diesen Befehl die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_ScrollPageUp"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="ScrollPageUp"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MediaCommands" />
        <altmember cref="T:System.Windows.Input.NavigationCommands" />
        <altmember cref="T:System.Windows.Input.ApplicationCommands" />
        <altmember cref="T:System.Windows.Documents.EditingCommands" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.RoutedUICommand" />
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="SelectToEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ComponentCommands.SelectToEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Input.ComponentCommands.SelectToEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der den Befehl „Markieren bis Ende“ darstellt.</summary>
        <value>Der Befehl.  
  
 <list type="table"><listheader><term> Standardwerte  
  
 </term><description></description></listheader><item><term> Tastenkombination  
  
 </term><description> UMSCHALT+ENDE  
  
 </description></item><item><term> Text der Benutzeroberfläche  
  
 </term><description> SelectToEnd  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl gibt die Absicht an, die Elemente aus dem aktuellen Element zum letzten Element auszuwählen.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf den Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung als Reaktion auf diesen Befehl die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_SelectToEnd"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="SelectToEnd"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MediaCommands" />
        <altmember cref="T:System.Windows.Input.NavigationCommands" />
        <altmember cref="T:System.Windows.Input.ApplicationCommands" />
        <altmember cref="T:System.Windows.Documents.EditingCommands" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.RoutedUICommand" />
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="SelectToHome">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToHome { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToHome" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ComponentCommands.SelectToHome" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToHome As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToHome { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToHome : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Input.ComponentCommands.SelectToHome" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der den Befehl „Markieren bis Home“ darstellt.</summary>
        <value>Der Befehl.  
  
 <list type="table"><listheader><term> Standardwerte  
  
 </term><description></description></listheader><item><term> Tastenkombination  
  
 </term><description> UMSCHALT+POS1  
  
 </description></item><item><term> Text der Benutzeroberfläche  
  
 </term><description> SelectToHome  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl gibt an, dass die Absicht, die Elemente aus dem aktuellen Element auf das erste Element auszudehnen, erweitert werden soll.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf den Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung als Reaktion auf diesen Befehl die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_SelectToHome"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="SelectToHome"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MediaCommands" />
        <altmember cref="T:System.Windows.Input.NavigationCommands" />
        <altmember cref="T:System.Windows.Input.ApplicationCommands" />
        <altmember cref="T:System.Windows.Documents.EditingCommands" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.RoutedUICommand" />
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="SelectToPageDown">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToPageDown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToPageDown" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ComponentCommands.SelectToPageDown" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToPageDown As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToPageDown { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToPageDown : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Input.ComponentCommands.SelectToPageDown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der den Befehl „Markieren bis eine Seite nach unten“ darstellt.</summary>
        <value>Der Befehl.  
  
 <list type="table"><listheader><term> Standardwerte  
  
 </term><description></description></listheader><item><term> Tastenkombination  
  
 </term><description> UMSCHALT+BILD-AB  
  
 </description></item><item><term> Text der Benutzeroberfläche  
  
 </term><description> SelectToPageDown  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl gibt an, dass die Absicht besteht, eine Seite aus dem aktuellen Element auszuwählen.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf den Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung als Reaktion auf diesen Befehl die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_SelectToPageDown"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="SelectToPageDown"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MediaCommands" />
        <altmember cref="T:System.Windows.Input.NavigationCommands" />
        <altmember cref="T:System.Windows.Input.ApplicationCommands" />
        <altmember cref="T:System.Windows.Documents.EditingCommands" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.RoutedUICommand" />
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="SelectToPageUp">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToPageUp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToPageUp" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.ComponentCommands.SelectToPageUp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToPageUp As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToPageUp { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToPageUp : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Input.ComponentCommands.SelectToPageUp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der den Befehl „Markieren bis eine Seite nach oben“ darstellt.</summary>
        <value>Der Befehl.  
  
 <list type="table"><listheader><term> Standardwerte  
  
 </term><description></description></listheader><item><term> Tastenkombination  
  
 </term><description> UMSCHALT+BILD-AUF  
  
 </description></item><item><term> Text der Benutzeroberfläche  
  
 </term><description> SelectToPageUp  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Befehl gibt die Absicht an, aus dem aktuellen Element eine Seite nach oben auszuwählen.  
  
 Es gibt nicht notwendigerweise eine tatsächliche Implementierung, die auf den Befehl für ein bestimmtes Objekt antwortet. in vielen Fällen ist die Implementierung als Reaktion auf diesen Befehl die Verantwortung des anwendungswriter.  
  
<a name="xamlAttributeUsage_SelectToPageUp"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="SelectToPageUp"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MediaCommands" />
        <altmember cref="T:System.Windows.Input.NavigationCommands" />
        <altmember cref="T:System.Windows.Input.ApplicationCommands" />
        <altmember cref="T:System.Windows.Documents.EditingCommands" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.RoutedUICommand" />
        <altmember cref="T:System.Windows.Input.CommandBinding" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
  </Members>
</Type>
