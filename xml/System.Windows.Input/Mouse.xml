<Type Name="Mouse" FullName="System.Windows.Input.Mouse">
  <Metadata><Meta Name="ms.openlocfilehash" Value="19e41bca7f510ad0a4a7b8c85f346152e2b5b832" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83968954" /></Metadata><TypeSignature Language="C#" Value="public static class Mouse" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Mouse extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.Mouse" />
  <TypeSignature Language="VB.NET" Value="Public Class Mouse" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mouse abstract sealed" />
  <TypeSignature Language="F#" Value="type Mouse = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt das Mausgerät für einen bestimmten Thread dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Input.Mouse>-Klasse stellt Maus bezogene Ereignisse, Methoden und Eigenschaften bereit, die Informationen über den Zustand der Maus bereitstellen.  
  
 Jedes Ereignis, das <xref:System.Windows.Input.Mouse> als angefügtes Ereignis definiert, wird auch von den Basiselement Klassen <xref:System.Windows.UIElement> und <xref:System.Windows.ContentElement> als neues Routing Ereignis wieder verfügbar gemacht. Im Allgemeinen ist es einfacher, Mausereignisse für eine Anwendung auf <xref:System.Windows.UIElement> und <xref:System.Windows.ContentElement>zu verarbeiten, anstatt die <xref:System.Windows.Input.Mouse> Ereignisse zu verwenden. Weitere Informationen finden Sie unter [Übersicht über die Eingabe](/dotnet/framework/wpf/advanced/input-overview).  
  
 Die statischen Member des <xref:System.Windows.Input.Mouse>-Klassen Delegaten an die primäre <xref:System.Windows.Input.MouseDevice> des Eingabe-Managers des aufrufenden Threads.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddGotMouseCaptureHandler">
      <MemberSignature Language="C#" Value="public static void AddGotMouseCaptureHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddGotMouseCaptureHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddGotMouseCaptureHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddGotMouseCaptureHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddGotMouseCaptureHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddGotMouseCaptureHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddGotMouseCaptureHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Fügt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" />-Ereignis hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLostMouseCaptureHandler">
      <MemberSignature Language="C#" Value="public static void AddLostMouseCaptureHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddLostMouseCaptureHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddLostMouseCaptureHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddLostMouseCaptureHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddLostMouseCaptureHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddLostMouseCaptureHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddLostMouseCaptureHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Fügt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" />-Ereignis hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseDownHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseDownHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseDownHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseDownHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseDownHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Fügt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.MouseDown" />-Ereignis hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseEnterHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseEnterHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseEnterHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseEnterHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseEnterHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseEnterHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseEnterHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseEnterHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Fügt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.MouseEnter" />-Ereignis hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseLeaveHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseLeaveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseLeaveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseLeaveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseLeaveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseLeaveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseLeaveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseLeaveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Fügt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.MouseLeave" />-Ereignis hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseMoveHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseMoveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseMoveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseMoveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseMoveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseMoveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseMoveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseMoveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Fügt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.MouseMove" />-Ereignis hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseUpHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseUpHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseUpHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseUpHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseUpHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Fügt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.MouseUp" />-Ereignis hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseWheelHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseWheelHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseWheelEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseWheelHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseWheelEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseWheelHandler(System.Windows.DependencyObject,System.Windows.Input.MouseWheelEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseWheelHandler (element As DependencyObject, handler As MouseWheelEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseWheelHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseWheelEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseWheelHandler : System.Windows.DependencyObject * System.Windows.Input.MouseWheelEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseWheelHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseWheelEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Fügt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.MouseWheel" />-Ereignis hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseDownHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseDownHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseDownHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseDownHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseDownHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Fügt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" />-Ereignis hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseDownOutsideCapturedElementHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseDownOutsideCapturedElementHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseDownOutsideCapturedElementHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseDownOutsideCapturedElementHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseDownOutsideCapturedElementHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseDownOutsideCapturedElementHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseDownOutsideCapturedElementHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseDownOutsideCapturedElementHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Fügt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement" />-Ereignis hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseMoveHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseMoveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseMoveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseMoveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseMoveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseMoveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseMoveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseMoveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Fügt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" />-Ereignis hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseUpHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseUpHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseUpHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseUpHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseUpHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Fügt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" />-Ereignis hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseUpOutsideCapturedElementHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseUpOutsideCapturedElementHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseUpOutsideCapturedElementHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseUpOutsideCapturedElementHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseUpOutsideCapturedElementHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseUpOutsideCapturedElementHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseUpOutsideCapturedElementHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseUpOutsideCapturedElementHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Fügt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement" />-Ereignis hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseWheelHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseWheelHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseWheelEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseWheelHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseWheelEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseWheelHandler(System.Windows.DependencyObject,System.Windows.Input.MouseWheelEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseWheelHandler (element As DependencyObject, handler As MouseWheelEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseWheelHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseWheelEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseWheelHandler : System.Windows.DependencyObject * System.Windows.Input.MouseWheelEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseWheelHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseWheelEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Fügt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" />-Ereignis hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddQueryCursorHandler">
      <MemberSignature Language="C#" Value="public static void AddQueryCursorHandler (System.Windows.DependencyObject element, System.Windows.Input.QueryCursorEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddQueryCursorHandler(class System.Windows.DependencyObject element, class System.Windows.Input.QueryCursorEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddQueryCursorHandler(System.Windows.DependencyObject,System.Windows.Input.QueryCursorEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddQueryCursorHandler (element As DependencyObject, handler As QueryCursorEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddQueryCursorHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::QueryCursorEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddQueryCursorHandler : System.Windows.DependencyObject * System.Windows.Input.QueryCursorEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddQueryCursorHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.QueryCursorEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Fügt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.QueryCursor" />-Ereignis hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Capture">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erfasst Mauseingaben für das angegebene Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Element die Maus erfasst, empfängt es Maus Eingaben, unabhängig davon, ob sich der Cursor innerhalb seines Rahmens befindet.  
  
 Wenn kein <xref:System.Windows.Input.CaptureMode> angegeben ist, wird der Standard <xref:System.Windows.Input.CaptureMode> <xref:System.Windows.Input.CaptureMode.Element>.  
  
 Um die Maus Aufzeichnung freizugeben, wenden Sie <xref:System.Windows.Input.Mouse.Capture%2A> übergeben `null` als das zu erfassende Element an.  
  
 Wenn die Maus aufgezeichnet wird, wenn ein <xref:System.Windows.Input.Mouse.MouseDown> oder <xref:System.Windows.Input.Mouse.MouseUp> Ereignis ausgelöst wird und die Eingabe nicht zum Element unterhalb der Maus geht, werden <xref:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement> und <xref:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement> zuerst ausgelöst.  Dadurch kann das erfasste Element die Erfassung freigeben, bevor die <xref:System.Windows.Input.Mouse.MouseDown>-und <xref:System.Windows.Input.Mouse.MouseUp> Ereignisse weitergeleitet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Capture">
      <MemberSignature Language="C#" Value="public static bool Capture (System.Windows.IInputElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Capture(class System.Windows.IInputElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.Capture(System.Windows.IInputElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Capture (element As IInputElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Capture(System::Windows::IInputElement ^ element);" />
      <MemberSignature Language="F#" Value="static member Capture : System.Windows.IInputElement -&gt; bool" Usage="System.Windows.Input.Mouse.Capture element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.IInputElement" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, für das die Maus erfasst werden soll.</param>
        <summary>Erfasst Mauseingaben für das angegebene Element.</summary>
        <returns><see langword="true" />, wenn das Element die Maus erfassen konnte, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Element die Maus erfasst, empfängt es Maus Eingaben, unabhängig davon, ob sich der Cursor innerhalb seines Rahmens befindet.  
  
 Wenn kein <xref:System.Windows.Input.CaptureMode> angegeben ist, wird der Standard <xref:System.Windows.Input.CaptureMode> <xref:System.Windows.Input.CaptureMode.Element>.  
  
 Um die Maus Aufzeichnung freizugeben, wenden Sie <xref:System.Windows.Input.Mouse.Capture%2A> übergeben `null` als das zu erfassende Element an.  
  
 Wenn die Maus aufgezeichnet wird, wenn ein <xref:System.Windows.Input.Mouse.MouseDown> oder <xref:System.Windows.Input.Mouse.MouseUp> Ereignis ausgelöst wird und die Eingabe nicht zum Element unterhalb der Maus geht, werden <xref:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement> und <xref:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement> zuerst ausgelöst.  Dadurch kann das erfasste Element die Erfassung freigeben, bevor die <xref:System.Windows.Input.Mouse.MouseDown>-und <xref:System.Windows.Input.Mouse.MouseUp> Ereignisse weitergeleitet werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die Maus mit einem bestimmten Element mithilfe der <xref:System.Windows.Input.Mouse.Capture%2A>-Methode erfasst wird.  
  
 [!code-csharp[MouseCaptureSample#MouseCapturSampleCaptureElement](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseCaptureSample/CSharp/Window1.xaml.cs#mousecaptursamplecaptureelement)]
 [!code-vb[MouseCaptureSample#MouseCapturSampleCaptureElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseCaptureSample/visualbasic/window1.xaml.vb#mousecaptursamplecaptureelement)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Capture">
      <MemberSignature Language="C#" Value="public static bool Capture (System.Windows.IInputElement element, System.Windows.Input.CaptureMode captureMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Capture(class System.Windows.IInputElement element, valuetype System.Windows.Input.CaptureMode captureMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.Capture(System.Windows.IInputElement,System.Windows.Input.CaptureMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Capture (element As IInputElement, captureMode As CaptureMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Capture(System::Windows::IInputElement ^ element, System::Windows::Input::CaptureMode captureMode);" />
      <MemberSignature Language="F#" Value="static member Capture : System.Windows.IInputElement * System.Windows.Input.CaptureMode -&gt; bool" Usage="System.Windows.Input.Mouse.Capture (element, captureMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.IInputElement" />
        <Parameter Name="captureMode" Type="System.Windows.Input.CaptureMode" />
      </Parameters>
      <Docs>
        <param name="element">Das Element, für das die Maus erfasst werden soll.</param>
        <param name="captureMode">Die zu verwendende Erfassungsrichtlinie.</param>
        <summary>Erfasst Mauseingaben für das angegebene Element mit dem angegebenen <see cref="T:System.Windows.Input.CaptureMode" />.</summary>
        <returns><see langword="true" />, wenn das Element die Maus erfassen konnte, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Element die Maus erfasst, empfängt es Maus Eingaben, unabhängig davon, ob sich der Cursor innerhalb seines Rahmens befindet.  
  
 Um die Maus Aufzeichnung freizugeben, wenden Sie <xref:System.Windows.Input.Mouse.Capture%2A> übergeben `null` als das zu erfassende Element an.  
  
 Wenn die Maus aufgezeichnet wird, wenn ein <xref:System.Windows.Input.Mouse.MouseDown> oder <xref:System.Windows.Input.Mouse.MouseUp> Ereignis ausgelöst wird und die Eingabe nicht zum Element unterhalb der Maus geht, werden <xref:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement> und <xref:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement> zuerst ausgelöst.  Dadurch kann das erfasste Element die Erfassung freigeben, bevor die <xref:System.Windows.Input.Mouse.MouseDown>-und <xref:System.Windows.Input.Mouse.MouseUp> Ereignisse weitergeleitet werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die Maus mit einem bestimmten Element mithilfe der <xref:System.Windows.Input.Mouse.Capture%2A>-Methode erfasst wird.  
  
 [!code-csharp[MouseCaptureSample#MouseCapturSampleCaptureElement](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseCaptureSample/CSharp/Window1.xaml.cs#mousecaptursamplecaptureelement)]
 [!code-vb[MouseCaptureSample#MouseCapturSampleCaptureElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseCaptureSample/visualbasic/window1.xaml.vb#mousecaptursamplecaptureelement)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Captured">
      <MemberSignature Language="C#" Value="public static System.Windows.IInputElement Captured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.IInputElement Captured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.Captured" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Captured As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::IInputElement ^ Captured { System::Windows::IInputElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Captured : System.Windows.IInputElement" Usage="System.Windows.Input.Mouse.Captured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Element ab, das die Maus erfasst hat.</summary>
        <value>Das Element, das die Maus erfasst hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Element die Maus erfasst, empfängt es Maus Eingaben, unabhängig davon, ob sich der Cursor innerhalb seines Rahmens befindet. Die Maus wird in der Regel nur bei Drag & Drop-Vorgängen aufgezeichnet und behält die Erfassung bei, bis die Drop-Aktion des Drag & Drop-Vorgangs auftritt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie das Element mit der Maus Aufzeichnung abgerufen wird.  
  
 [!code-csharp[mousecapturesample#MouseCaptureMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseCaptureSample/CSharp/Window1.xaml.cs#mousecapturemousecaptured)]
 [!code-vb[mousecapturesample#MouseCaptureMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseCaptureSample/visualbasic/window1.xaml.vb#mousecapturemousecaptured)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DirectlyOver">
      <MemberSignature Language="C#" Value="public static System.Windows.IInputElement DirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.IInputElement DirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.DirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DirectlyOver As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::IInputElement ^ DirectlyOver { System::Windows::IInputElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DirectlyOver : System.Windows.IInputElement" Usage="System.Windows.Input.Mouse.DirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Element ab, über dem sich der Mauszeiger befindet.</summary>
        <value>Das Element, über dem sich der Mauszeiger befindet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Steuerelemente können aus mehreren Elementen bestehen. <xref:System.Windows.Input.Mouse.DirectlyOver%2A> meldet das spezifische Element im zusammengesetzten Steuerelement, über dem sich der Mauszeiger befindet, und nicht das Steuerelement selbst. Abhängig davon, welcher Teil einer <xref:System.Windows.Controls.Button> der Zeiger ist, könnte die <xref:System.Windows.Input.Mouse.DirectlyOver%2A>-Eigenschaft beispielsweise die <xref:System.Windows.Controls.TextBox> der <xref:System.Windows.Controls.ContentControl.Content%2A> Eigenschaft oder des <xref:Microsoft.Windows.Themes.ButtonChrome>melden.  
  
 Verwenden Sie die <xref:System.Windows.IInputElement.IsMouseOver%2A>-Eigenschaft auf <xref:System.Windows.UIElement> und <xref:System.Windows.ContentElement>, um zu bestimmen, ob sich die Maus über einem Element befindet, das seine visuellen untergeordneten Elemente oder Steuerelement-Zusammensetzung-Elemente enthält.  
  
 Wenn ein Element über die Maus Aufzeichnung verfügt, wird der Mauszeiger unabhängig von der Position des Mauszeigers direkt über das Element betrachtet.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.IsMouseOver" />
        <altmember cref="P:System.Windows.UIElement.IsMouseDirectlyOver" />
      </Docs>
    </Member>
    <Member MemberName="GetIntermediatePoints">
      <MemberSignature Language="C#" Value="public static int GetIntermediatePoints (System.Windows.IInputElement relativeTo, System.Windows.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetIntermediatePoints(class System.Windows.IInputElement relativeTo, valuetype System.Windows.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.GetIntermediatePoints(System.Windows.IInputElement,System.Windows.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIntermediatePoints (relativeTo As IInputElement, points As Point()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetIntermediatePoints(System::Windows::IInputElement ^ relativeTo, cli::array &lt;System::Windows::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="static member GetIntermediatePoints : System.Windows.IInputElement * System.Windows.Point[] -&gt; int" Usage="System.Windows.Input.Mouse.GetIntermediatePoints (relativeTo, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.Windows.IInputElement" />
        <Parameter Name="points" Type="System.Windows.Point[]" />
      </Parameters>
      <Docs>
        <param name="relativeTo">Die Elemente, zu denen die <paramref name="points" /> in Beziehung stehen.</param>
        <param name="points">Ein Array von -Objekten.</param>
        <summary>Ruft bis zu 64 frühere Koordinaten des Mauszeigers seit dem letzten Mausbewegungsereignis ab.</summary>
        <returns>Die Anzahl der zurückgegebenen Punkte.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPosition">
      <MemberSignature Language="C#" Value="public static System.Windows.Point GetPosition (System.Windows.IInputElement relativeTo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Point GetPosition(class System.Windows.IInputElement relativeTo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.GetPosition(System.Windows.IInputElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPosition (relativeTo As IInputElement) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Point GetPosition(System::Windows::IInputElement ^ relativeTo);" />
      <MemberSignature Language="F#" Value="static member GetPosition : System.Windows.IInputElement -&gt; System.Windows.Point" Usage="System.Windows.Input.Mouse.GetPosition relativeTo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.Windows.IInputElement" />
      </Parameters>
      <Docs>
        <param name="relativeTo">Der Koordinatenbereich, in dem die Position der Maus berechnet werden soll.</param>
        <summary>Ruft die Position der Maus relativ zu einem angegebenen Element ab.</summary>
        <returns>Die Position der Maus relativ zum <paramref name="relativeTo" />-Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Position des Mauszeigers wird relativ zum angegebenen Element berechnet, wobei die obere linke Ecke des Elements der Ursprungs Punkt (0, 0) ist.  
  
 Bei Drag & Drop-Vorgängen kann die Position der Maus nicht zuverlässig durch <xref:System.Windows.Input.Mouse.GetPosition%2A>bestimmt werden. Dies liegt daran [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)], dass die Steuerung der Maus (z. & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; & # 160; a Verwenden Sie stattdessen die folgenden Ansätze:  
  
-   Ruft die <xref:System.Windows.DragEventArgs.GetPosition%2A>-Methode des <xref:System.Windows.DragEventArgs> auf, der an die Zieh Ereignisse (<xref:System.Windows.ContentElement.DragEnter>, <xref:System.Windows.ContentElement.DragOver>, <xref:System.Windows.ContentElement.DragLeave>) übermittelt wird.  
  
-   Rufen Sie [GetCursor](/windows/win32/api/winuser/nf-winuser-getcursorpos)mithilfe von P/aufrufen auf.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie <xref:System.Windows.Input.Mouse.GetPosition%2A> verwendet wird, um die Position des Mauszeigers zu bestimmen.  Die Position des Mauszeigers wird in einer <xref:System.Windows.Point> Struktur gespeichert.  Die <xref:System.Windows.Point.X%2A>-und <xref:System.Windows.Point.Y%2A> Werte des <xref:System.Windows.Point> Objekts werden in einer <xref:System.Windows.Controls.TextBox>angezeigt.  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsPositionMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetspositionmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsPositionMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetspositionmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Input.MouseEventArgs.GetPosition(System.Windows.IInputElement)" />
      </Docs>
    </Member>
    <Member MemberName="GotMouseCapture">
      <MemberSignature Language="C#" Value="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" />
      <MemberSignature Language="ILAsm" Value="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.GotMouseCapture" />
      <MemberSignature Language="VB.NET" Value="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" />
      <MemberSignature Language="F#" Value="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" Usage="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tritt auf, wenn ein Element die Maus erfasst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Element die Maus erfasst, empfängt es Maus Eingaben, unabhängig davon, ob sich der Cursor innerhalb seines Rahmens befindet.  
  
 Dies ist ein angefügtes Ereignis. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementiert angefügte Ereignisse als Routing Ereignisse. Bei angefügten Ereignissen handelt es sich im Grunde um ein [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sprach Konzept für Verweise auf Ereignisse, die für Objekte behandelt werden können, die dieses Ereignis nicht definieren, das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] erweitert wird, indem auch das Ereignis zum Durchlaufen einer Route aktiviert wird. Angefügte Ereignisse haben im Code keine Syntax für die direkte Handhabung. zum Anfügen von Handlern für ein Routing Ereignis im Code verwenden Sie eine angegebene Add *-Handlermethode. Weitere Informationen finden Sie unter [Übersicht über angefügte Ereignisse](/dotnet/framework/wpf/advanced/attached-events-overview).  
  
 Aufgrund des bubblingerroutings kann das tatsächliche Element, das Capture hat, ein untergeordnetes Element sein, nicht notwendigerweise das Element, an das der Ereignishandler tatsächlich angefügt wird. Überprüfen Sie die <xref:System.Windows.RoutedEventArgs.Source%2A> in den Ereignis Argumenten, um das eigentliche Element zu bestimmen, das über die Maus Aufzeichnung verfügt.  
  
<a name="routedEventInfo_GotMouseCapture"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Input.Mouse.GotMouseCaptureEvent>|  
|Routing Strategie|Blasen|  
|Delegat|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   Es ist kein entsprechendes tunnelingereignis definiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.GotMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.GotMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet das angefügte <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" />-Ereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Routing Ereignis Bezeichner werden erstellt, wenn Routing Ereignisse registriert werden, und das Ergebnis wird als Feld in der Klasse gespeichert, die das Routing Ereignis registriert. Diese Bezeichner enthalten einen identifizierenden Namen, den Besitzertyp, den Handlertyp, die Routing Strategie und eine hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie verwenden diese Bezeichner häufig als Parameter für Ereignis System Methoden, um ein bestimmtes Routing Ereignis zu identifizieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftButton">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState LeftButton { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState LeftButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.LeftButton" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LeftButton As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState LeftButton { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.LeftButton : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.LeftButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Zustand der linken Maustaste ab.</summary>
        <value>Der Zustand der linken Maustaste.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie bestimmen können, ob die linke Maustaste gedrückt wird, indem Sie überprüfen, ob der Zustand des <xref:System.Windows.Input.Mouse.LeftButton%2A> gleich dem <xref:System.Windows.Input.MouseButtonState> Enumerationswert <xref:System.Windows.Input.MouseButtonState.Pressed>ist.  Wenn die Schaltfläche gedrückt wird, wird eine Methode aufgerufen, die die Elemente im Beispiel anzeigt.  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetLeftButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetleftbuttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetLeftButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetleftbuttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="LostMouseCapture">
      <MemberSignature Language="C#" Value="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" />
      <MemberSignature Language="ILAsm" Value="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.LostMouseCapture" />
      <MemberSignature Language="VB.NET" Value="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" />
      <MemberSignature Language="F#" Value="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" Usage="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tritt auf, wenn ein Element keine Mauseingaben mehr erfasst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Element die Maus erfasst, empfängt es Maus Eingaben, unabhängig davon, ob sich der Cursor innerhalb seines Rahmens befindet. T  
  
 Dies ist ein angefügtes Ereignis. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementiert angefügte Ereignisse als Routing Ereignisse. Bei angefügten Ereignissen handelt es sich im Grunde um ein [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sprach Konzept für Verweise auf Ereignisse, die für Objekte behandelt werden können, die dieses Ereignis nicht definieren, das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] erweitert wird, indem auch das Ereignis zum Durchlaufen einer Route aktiviert wird. Angefügte Ereignisse haben im Code keine Syntax für die direkte Handhabung. zum Anfügen von Handlern für ein Routing Ereignis im Code verwenden Sie eine angegebene Add *-Handlermethode. Weitere Informationen finden Sie unter [Übersicht über angefügte Ereignisse](/dotnet/framework/wpf/advanced/attached-events-overview).  
  
 Aufgrund des bubblingerroutings könnte das eigentliche Element, das die Erfassung verliert, ein untergeordnetes Element sein, nicht notwendigerweise das Element, an das der Ereignishandler tatsächlich angefügt wird. Überprüfen Sie die <xref:System.Windows.RoutedEventArgs.Source%2A> in den Ereignis Argumenten, um das eigentliche Element zu ermitteln, das Capture verloren hat.  
  
<a name="routedEventInfo_LostMouseCapture"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Input.Mouse.LostMouseCaptureEvent>|  
|Routing Strategie|Blasen|  
|Delegat|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   Es ist kein entsprechendes tunnelingereignis definiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.LostMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.LostMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet das angefügte <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" />-Ereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Routing Ereignis Bezeichner werden erstellt, wenn Routing Ereignisse registriert werden, und das Ergebnis wird als Feld in der Klasse gespeichert, die das Routing Ereignis registriert. Diese Bezeichner enthalten einen identifizierenden Namen, den Besitzertyp, den Handlertyp, die Routing Strategie und eine hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie verwenden diese Bezeichner häufig als Parameter für Ereignis System Methoden, um ein bestimmtes Routing Ereignis zu identifizieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MiddleButton">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState MiddleButton { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState MiddleButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.MiddleButton" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MiddleButton As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState MiddleButton { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.MiddleButton : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.MiddleButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Zustand der mittleren Maustaste ab.</summary>
        <value>Der Zustand der mittleren Maustaste.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie bestimmt wird, ob die mittlere Maustaste gedrückt wird, indem überprüft wird, ob der Zustand des <xref:System.Windows.Input.Mouse.MiddleButton%2A> gleich dem <xref:System.Windows.Input.MouseButtonState> Enumerationswert <xref:System.Windows.Input.MouseButtonState.Pressed>ist.  Wenn die Schaltfläche gedrückt wird, wird eine Methode aufgerufen, die die Elemente im Beispiel anzeigt.  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetMiddleButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetmiddlebuttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetMiddleButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetmiddlebuttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="see AddMouseDownHandler, and RemoveMouseDownHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseDownHandler, and RemoveMouseDownHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseDown" />
      <MemberSignature Language="VB.NET" Value="see AddMouseDownHandler, and RemoveMouseDownHandler" />
      <MemberSignature Language="F#" Value="see AddMouseDownHandler, and RemoveMouseDownHandler" Usage="see AddMouseDownHandler, and RemoveMouseDownHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tritt auf, wenn eine Maustaste gedrückt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu ermitteln, welche Maustaste gedrückt wurde, überprüfen Sie die <xref:System.Windows.Input.MouseButtonEventArgs.ChangedButton%2A>-Eigenschaft in der <xref:System.Windows.Input.MouseButtonEventArgs> an den Handler übergebenen.  
  
 Dies ist ein angefügtes Ereignis. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementiert angefügte Ereignisse als Routing Ereignisse. Bei angefügten Ereignissen handelt es sich im Grunde um ein [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sprach Konzept für Verweise auf Ereignisse, die für Objekte behandelt werden können, die dieses Ereignis nicht definieren, das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] erweitert wird, indem auch das Ereignis zum Durchlaufen einer Route aktiviert wird. Angefügte Ereignisse haben im Code keine Syntax für die direkte Handhabung. zum Anfügen von Handlern für ein Routing Ereignis im Code verwenden Sie eine angegebene Add *-Handlermethode. Weitere Informationen finden Sie unter [Übersicht über angefügte Ereignisse](/dotnet/framework/wpf/advanced/attached-events-overview).  
  
 Das [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Framework baut auf diesem angefügten Ereignis auf, indem es als zwei verschiedene [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Ereignisse auf <xref:System.Windows.UIElement> und <xref:System.Windows.ContentElement>angezeigt wird: <xref:System.Windows.UIElement.MouseLeftButtonDown> und <xref:System.Windows.UIElement.MouseRightButtonDown>. Diese Implementierungen behandeln das zugrunde liegende <xref:System.Windows.Input.Mouse.MouseDown> Ereignis und lesen die Argumente des Ereignisses, um zu bestimmen, ob die linke oder die Rechte Maustaste beteiligt war. Für eine drei-Schaltflächen-Maus gibt es keine Ereignis Unterstützung auf Frameworkebene für die Schaltfläche Center. Verwenden Sie das <xref:System.Windows.Input.Mouse.MouseDown>-Ereignis, und überprüfen Sie den <xref:System.Windows.Input.MouseEventArgs.MiddleButton%2A> Status in den Ereignis Argumenten.  
  
> [!IMPORTANT]
>  Einige <xref:System.Windows.ContentElement> abgeleitete Klassen, die über Steuerungs ähnliches Verhalten verfügen, z. b. <xref:System.Windows.Documents.Hyperlink>, haben möglicherweise eine inhärente Klassen Behandlung für Maustasten Ereignisse. Das Ereignis mit der linken Maustaste auf das Ereignis ist das wahrscheinlichste Ereignis, um eine Klassen Behandlung in einem-Steuerelement zu erhalten. Die Klassen Behandlung markiert häufig das zugrunde liegende <xref:System.Windows.Input.Mouse>-Klassen Ereignis als behandelt. Wenn das Ereignis als behandelt markiert ist, werden andere Instanzhandler, die diesem Element zugeordnet sind, normalerweise nicht ausgelöst. Alle anderen Klassen-oder Instanzhandler, die an Elemente in der Blasen Richtung an den Stamm in der UI-Struktur angefügt werden, werden normalerweise nicht ausgelöst.  
  
 Sie können das Problem beheben, das im vorangehenden wichtigen Hinweis beschrieben wird, und dennoch <xref:System.Windows.UIElement.MouseDown> Ereignisse für die linken Maustaste auf eine abgeleitete Klasse empfangen, die eine Klassen Behandlung bietet, indem Sie eine der folgenden Lösungen verwenden:  
  
-   Anfügen von Handlern für das <xref:System.Windows.UIElement.PreviewMouseDown>-Ereignis, das von den-Steuerelementen nicht als behandelt markiert ist. Da es sich hierbei um ein Vorschau Ereignis handelt, beginnt die Route im Stammverzeichnis und wird zum-Steuerelement.  
  
-   Registrieren Sie einen Handler im Steuerelement, indem Sie <xref:System.Windows.UIElement.AddHandler%2A> aufrufen und die Signatur Option auswählen, mit der Handler Ereignisse überwachen können, auch wenn Sie in den Routing Ereignisdaten bereits als behandelt markiert sind.  
  
 Bei gerouteten Ereignissen, die mit der Maus in Beziehung stehen, sollten Sie darauf achten, wie oder wann Sie behandelt werden. Die Schwierigkeit, die richtigen Entscheidungen zu treffen, ob übergeordnete Elemente auch über eine bestimmte Maus Aktion informiert werden sollten, ist tatsächlich der Grund, warum das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Framework das Modell ausgewählt hat, mit dem das zugrunde liegende mousegereignis als [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Ereignisse entlang der Route angezeigt werden soll. Ähnliche Probleme sind bei der Tunnelung von Mausereignissen aufgetreten.  Sollten Sie das-Ereignis behandeln und nicht von weiteren untergeordneten Elementen in der Quelle behandelt werden, und wie würde sich dies auf die Zusammenführung eines Steuer Elements auswirken, bei dem die zusammengesetzten Elemente möglicherweise erwartete Maus Verhalten aufweisen?  
  
<a name="routedEventInfo_MouseDown"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Input.Mouse.MouseDownEvent>|  
|Routing Strategie|Blasen|  
|Delegat|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   Das entsprechende tunnelingereignis ist <xref:System.Windows.Input.Mouse.PreviewMouseDown>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet das angefügte <see cref="E:System.Windows.Input.Mouse.MouseDown" />-Ereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Routing Ereignis Bezeichner werden erstellt, wenn Routing Ereignisse registriert werden, und das Ergebnis wird als Feld in der Klasse gespeichert, die das Routing Ereignis registriert. Diese Bezeichner enthalten einen identifizierenden Namen, den Besitzertyp, den Handlertyp, die Routing Strategie und eine hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie verwenden diese Bezeichner häufig als Parameter für Ereignis System Methoden, um ein bestimmtes Routing Ereignis zu identifizieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="see AddMouseEnterHandler, and RemoveMouseEnterHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseEnterHandler, and RemoveMouseEnterHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="see AddMouseEnterHandler, and RemoveMouseEnterHandler" />
      <MemberSignature Language="F#" Value="see AddMouseEnterHandler, and RemoveMouseEnterHandler" Usage="see AddMouseEnterHandler, and RemoveMouseEnterHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tritt auf, wenn der Mauszeiger in die Grenzen eines Elements eintritt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist ein angefügtes Ereignis. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementiert angefügte Ereignisse als Routing Ereignisse. Bei angefügten Ereignissen handelt es sich im Grunde um ein [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sprach Konzept für Verweise auf Ereignisse, die für Objekte behandelt werden können, die dieses Ereignis nicht definieren, das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] erweitert wird, indem auch das Ereignis zum Durchlaufen einer Route aktiviert wird. Angefügte Ereignisse haben im Code keine Syntax für die direkte Handhabung. zum Anfügen von Handlern für ein Routing Ereignis im Code verwenden Sie eine angegebene Add *-Handlermethode. Weitere Informationen finden Sie unter [Übersicht über angefügte Ereignisse](/dotnet/framework/wpf/advanced/attached-events-overview).  
  
 Dieses Ereignis verwendet die Routing Strategie für die direkte Ereignisverarbeitung. Direkt geroutete Ereignisse werden nicht auf einer Route ausgelöst (Sie werden nur in dem Element behandelt, für das Sie ausgelöst werden).  Sie ermöglichen jedoch andere Aspekte von Routing Ereignis Verhaltensweisen, wie z. b. Ereignis Trigger in Stilen.  
  
 Obwohl dieses Ereignis verwendet wird, um zu verfolgen, wann die Maus in ein Element eintritt, meldet es auch, dass sich die <xref:System.Windows.UIElement.IsMouseOver%2A>-Eigenschaft von `false` in `true` für dieses Element geändert hat.  
  
<a name="routedEventInfo_MouseEnter"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Input.Mouse.MouseEnterEvent>|  
|Routing Strategie|Direkt|  
|Delegat|<xref:System.Windows.Input.MouseEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet das angefügte <see cref="E:System.Windows.Input.Mouse.MouseEnter" />-Ereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Routing Ereignis Bezeichner werden erstellt, wenn Routing Ereignisse registriert werden, und das Ergebnis wird als Feld in der Klasse gespeichert, die das Routing Ereignis registriert. Diese Bezeichner enthalten einen identifizierenden Namen, den Besitzertyp, den Handlertyp, die Routing Strategie und eine hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie verwenden diese Bezeichner häufig als Parameter für Ereignis System Methoden, um ein bestimmtes Routing Ereignis zu identifizieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" />
      <MemberSignature Language="F#" Value="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" Usage="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tritt auf, wenn der Mauszeiger die Grenzen eines Elements verlässt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist ein angefügtes Ereignis. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementiert angefügte Ereignisse als Routing Ereignisse. Bei angefügten Ereignissen handelt es sich im Grunde um ein [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sprach Konzept für Verweise auf Ereignisse, die für Objekte behandelt werden können, die dieses Ereignis nicht definieren, das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] erweitert wird, indem auch das Ereignis zum Durchlaufen einer Route aktiviert wird. Angefügte Ereignisse haben im Code keine Syntax für die direkte Handhabung. zum Anfügen von Handlern für ein Routing Ereignis im Code verwenden Sie eine angegebene Add *-Handlermethode. Weitere Informationen finden Sie unter [Übersicht über angefügte Ereignisse](/dotnet/framework/wpf/advanced/attached-events-overview).  
  
 Dieses Ereignis verwendet die Routing Strategie für die direkte Ereignisverarbeitung. Direkte Routing Ereignisse folgen keiner Route (Sie werden nur in dem Element behandelt, für das Sie ausgelöst werden).  Sie ermöglichen jedoch andere Aspekte von Routing Ereignis Verhaltensweisen, wie z. b. Ereignis Trigger in Stilen.  
  
 Obwohl dieses Ereignis verwendet wird, um zu verfolgen, wann die Maus ein Element verlässt, meldet es auch, dass der Wert der <xref:System.Windows.UIElement.IsMouseOver%2A>-Eigenschaft von `true` in `false` in diesem Element geändert wurde.  
  
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Input.Mouse.MouseLeaveEvent>|  
|Routing Strategie|Direkt|  
|Delegat|<xref:System.Windows.Input.MouseEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet das angefügte <see cref="E:System.Windows.Input.Mouse.MouseLeave" />-Ereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Routing Ereignis Bezeichner werden erstellt, wenn Routing Ereignisse registriert werden, und das Ergebnis wird als Feld in der Klasse gespeichert, die das Routing Ereignis registriert. Diese Bezeichner enthalten einen identifizierenden Namen, den Besitzertyp, den Handlertyp, die Routing Strategie und eine hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie verwenden diese Bezeichner häufig als Parameter für Ereignis System Methoden, um ein bestimmtes Routing Ereignis zu identifizieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="see AddMouseMoveHandler, and RemoveMouseMoveHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseMoveHandler, and RemoveMouseMoveHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseMove" />
      <MemberSignature Language="VB.NET" Value="see AddMouseMoveHandler, and RemoveMouseMoveHandler" />
      <MemberSignature Language="F#" Value="see AddMouseMoveHandler, and RemoveMouseMoveHandler" Usage="see AddMouseMoveHandler, and RemoveMouseMoveHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tritt auf, wenn sich die Position des Mauszeigers ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist ein angefügtes Ereignis. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementiert angefügte Ereignisse als Routing Ereignisse. Bei angefügten Ereignissen handelt es sich im Grunde um ein [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sprach Konzept für Verweise auf Ereignisse, die für Objekte behandelt werden können, die dieses Ereignis nicht definieren, das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] erweitert wird, indem auch das Ereignis zum Durchlaufen einer Route aktiviert wird. Angefügte Ereignisse haben im Code keine Syntax für die direkte Handhabung. zum Anfügen von Handlern für ein Routing Ereignis im Code verwenden Sie eine angegebene Add *-Handlermethode. Weitere Informationen finden Sie unter [Übersicht über angefügte Ereignisse](/dotnet/framework/wpf/advanced/attached-events-overview).  
  
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Input.Mouse.MouseMoveEvent>|  
|Routing Strategie|Blasen|  
|Delegat|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   Das entsprechende tunnelingereignis ist <xref:System.Windows.Input.Mouse.PreviewMouseMove>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet das angefügte <see cref="E:System.Windows.Input.Mouse.MouseMove" />-Ereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Routing Ereignis Bezeichner werden erstellt, wenn Routing Ereignisse registriert werden, und das Ergebnis wird als Feld in der Klasse gespeichert, die das Routing Ereignis registriert. Diese Bezeichner enthalten einen identifizierenden Namen, den Besitzertyp, den Handlertyp, die Routing Strategie und eine hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie verwenden diese Bezeichner häufig als Parameter für Ereignis System Methoden, um ein bestimmtes Routing Ereignis zu identifizieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="see AddMouseUpHandler, and RemoveMouseUpHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseUpHandler, and RemoveMouseUpHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseUp" />
      <MemberSignature Language="VB.NET" Value="see AddMouseUpHandler, and RemoveMouseUpHandler" />
      <MemberSignature Language="F#" Value="see AddMouseUpHandler, and RemoveMouseUpHandler" Usage="see AddMouseUpHandler, and RemoveMouseUpHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tritt auf, wenn eine Maustaste losgelassen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Welche Maustaste losgelassen wurde, wird durch Überprüfen der Argumente des Ereignisses festgelegt.  
  
 Dies ist ein angefügtes Ereignis. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementiert angefügte Ereignisse als Routing Ereignisse. Bei angefügten Ereignissen handelt es sich im Grunde um ein [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sprach Konzept für Verweise auf Ereignisse, die für Objekte behandelt werden können, die dieses Ereignis nicht definieren, das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] erweitert wird, indem auch das Ereignis zum Durchlaufen einer Route aktiviert wird. Angefügte Ereignisse haben im Code keine Syntax für die direkte Handhabung. zum Anfügen von Handlern für ein Routing Ereignis im Code verwenden Sie eine angegebene Add *-Handlermethode. Weitere Informationen finden Sie unter [Übersicht über angefügte Ereignisse](/dotnet/framework/wpf/advanced/attached-events-overview).  
  
 Das [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Framework baut auf diesem angefügten Ereignis auf, indem es als zwei verschiedene [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Ereignisse auf <xref:System.Windows.UIElement>angezeigt wird: <xref:System.Windows.UIElement.MouseLeftButtonUp> und <xref:System.Windows.UIElement.MouseRightButtonUp>. Diese Implementierungen behandeln das zugrunde liegende <xref:System.Windows.Input.Mouse.MouseUp> Ereignis und lesen die Argumente des Ereignisses, um zu bestimmen, ob die linke oder die Rechte Maustaste beteiligt war. Für drei Schaltflächen gibt es keine Ereignis Unterstützung auf Frameworkebene für die Schaltfläche "Center", und Sie sollten das <xref:System.Windows.Input.Mouse.MouseUp>-Ereignis verwenden und auf die Schaltfläche "Center-Schaltfläche" in den Ereignis Argumenten überprüfen.  
  
 Bei gerouteten Ereignissen, die mit der Maus in Beziehung stehen, sollten Sie darauf achten, wie oder wann Sie behandelt werden. Die Schwierigkeit, die richtigen Entscheidungen zu treffen, ob übergeordnete Elemente auch über eine bestimmte Maus Aktion informiert werden sollten, ist tatsächlich der Grund, warum das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Framework das Modell ausgewählt hat, bei dem das zugrunde liegende <xref:System.Windows.Input.Mouse> Routing Ereignis als [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Ereignisse entlang der Route angezeigt werden soll.  
  
 Ähnliche Probleme sind bei der Tunnelung von Mausereignissen aufgetreten.  Sollten Sie das-Ereignis behandeln und es nicht mehr von untergeordneten Elementen für die Quelle behandelt werden, und wie würde sich dies auf die Zusammensetzung in einem Steuerelement auswirken, bei dem die zusammengesetzten Elemente möglicherweise erwartete Maus Verhalten aufweisen?  
  
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Input.Mouse.MouseUpEvent>|  
|Routing Strategie|Blasen|  
|Delegat|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
 Das entsprechende tunnelingereignis ist <xref:System.Windows.Input.Mouse.PreviewMouseUp>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet das angefügte <see cref="E:System.Windows.Input.Mouse.MouseUp" />-Ereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Routing Ereignis Bezeichner werden erstellt, wenn Routing Ereignisse registriert werden, und das Ergebnis wird als Feld in der Klasse gespeichert, die das Routing Ereignis registriert. Diese Bezeichner enthalten einen identifizierenden Namen, den Besitzertyp, den Handlertyp, die Routing Strategie und eine hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie verwenden diese Bezeichner häufig als Parameter für Ereignis System Methoden, um ein bestimmtes Routing Ereignis zu identifizieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="see AddMouseWheelHandler, and RemoveMouseWheelHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseWheelHandler, and RemoveMouseWheelHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="see AddMouseWheelHandler, and RemoveMouseWheelHandler" />
      <MemberSignature Language="F#" Value="see AddMouseWheelHandler, and RemoveMouseWheelHandler" Usage="see AddMouseWheelHandler, and RemoveMouseWheelHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tritt auf, wenn das Mausrad bewegt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Fokus oder die Maus Erfassung haben Vorrang vor der Position des Mauszeigers.  Wenn Sie dieses Ereignis von einem fokussierten oder erfassten Element erhalten, befindet sich der Mauszeiger möglicherweise auf einem anderen Element zu diesem Zeitpunkt.  
  
 Dies ist ein angefügtes Ereignis. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementiert angefügte Ereignisse als Routing Ereignisse. Bei angefügten Ereignissen handelt es sich im Grunde um ein [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sprach Konzept für Verweise auf Ereignisse, die für Objekte behandelt werden können, die dieses Ereignis nicht definieren, das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] erweitert wird, indem auch das Ereignis zum Durchlaufen einer Route aktiviert wird. Angefügte Ereignisse haben im Code keine Syntax für die direkte Handhabung. zum Anfügen von Handlern für ein Routing Ereignis im Code verwenden Sie eine angegebene Add *-Handlermethode. Weitere Informationen finden Sie unter [Übersicht über angefügte Ereignisse](/dotnet/framework/wpf/advanced/attached-events-overview).  
  
<a name="routedEventInfo_MouseWheel"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Input.Mouse.MouseWheelEvent>|  
|Routing Strategie|Blasen|  
|Delegat|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   Das entsprechende tunnelingereignis ist <xref:System.Windows.Input.Mouse.PreviewMouseWheel>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheelDeltaForOneLine">
      <MemberSignature Language="C#" Value="public const int MouseWheelDeltaForOneLine = 120;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MouseWheelDeltaForOneLine = (120)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseWheelDeltaForOneLine" />
      <MemberSignature Language="VB.NET" Value="Public Const MouseWheelDeltaForOneLine As Integer  = 120" />
      <MemberSignature Language="C++ CLI" Value="public: int MouseWheelDeltaForOneLine = 120;" />
      <MemberSignature Language="F#" Value="val mutable MouseWheelDeltaForOneLine : int" Usage="System.Windows.Input.Mouse.MouseWheelDeltaForOneLine" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>120</MemberValue>
      <Docs>
        <summary>Stellt die Anzahl der Einheiten dar, die das Mausrad gedreht werden muss, um eine Zeile zu scrollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im aktuellen [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]ist der Wert dieses Felds 120. Der Zweck der offen setzung der Felder besteht darin, dass es Anbietern möglich ist, in Zukunft präzisere, leicht zu erschließenden mausräder zu erstellen. Es wird erwartet, dass ein solches Gerät mehr Nachrichten pro Drehung sendet, aber mit einem kleineren Wert in jeder Nachricht. Um diese Möglichkeit zu unterstützen, sollten Sie entweder die eingehenden Delta Werte hinzufügen, bis die <xref:System.Windows.Input.Mouse.MouseWheelDeltaForOneLine> Menge erreicht ist (sodass Sie für eine Delta Rotation dieselbe Antwort erhalten), oder wenn Sie Teil Zeilen als Reaktion auf häufigere Nachrichten scrollen. Sie können auch Ihre eigene Bildlauf-Granularität auswählen und Deltas Ihrer Wahl ansammeln, bis dieses Delta erreicht ist, oder möglicherweise auf benutzergesteuerte Systemparameter für die Maus Empfindlichkeit verweisen und diese an Mausrad-Delta Schwellenwerte extra zieren.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseWheelEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet das angefügte <see cref="E:System.Windows.Input.Mouse.MouseWheel" />-Ereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Routing Ereignis Bezeichner werden erstellt, wenn Routing Ereignisse registriert werden, und das Ergebnis wird als Feld in der Klasse gespeichert, die das Routing Ereignis registriert. Diese Bezeichner enthalten einen identifizierenden Namen, den Besitzertyp, den Handlertyp, die Routing Strategie und eine hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie verwenden diese Bezeichner häufig als Parameter für Ereignis System Methoden, um ein bestimmtes Routing Ereignis zu identifizieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverrideCursor">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.Cursor OverrideCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.Cursor OverrideCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.OverrideCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property OverrideCursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::Cursor ^ OverrideCursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OverrideCursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.Input.Mouse.OverrideCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Cursor für die gesamte Anwendung ab oder legt diesen fest.</summary>
        <value>Der überschreibende Cursor oder <see langword="null" />, wenn der <see cref="P:System.Windows.Input.Mouse.OverrideCursor" /> nicht festgelegt ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Windows.Input.Cursor>, für den <xref:System.Windows.Input.Mouse.OverrideCursor%2A> festgelegt ist, wird auf die gesamte Anwendung angewendet.  
  
 Legen Sie <xref:System.Windows.Input.Mouse.OverrideCursor%2A> auf `null`fest, um das Überschreibungs <xref:System.Windows.Input.Cursor>zu löschen.  
  
 Wenn Sie <xref:System.Windows.Input.Mouse.OverrideCursor%2A> auf <xref:System.Windows.Input.Cursors.None%2A> festlegen, wird der Mauszeiger nicht angezeigt, aber Mausereignisse werden weiterhin verarbeitet.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt einen Ereignishandler für eine <xref:System.Windows.Controls.RadioButton>, die verwendet wird, um den Gültigkeitsbereich einer Cursor Änderung zwischen einem einzelnen Element und der gesamten Anwendung zu wechseln.  Wenn das Steuerelement, das das Ereignis ausgelöst hat, der `rbScopeElement`<xref:System.Windows.Controls.RadioButton>ist, wird ein Flag, das den Gültigkeitsbereich der Cursor Änderung angibt, festgelegt und <xref:System.Windows.Input.Mouse.OverrideCursor%2A> auf `null`festgelegt.  Wenn das Steuerelement, das das Ereignis ausgelöst hat, der `rbScopeApplication`<xref:System.Windows.Controls.RadioButton>ist, wird ein Flag, das den Gültigkeitsbereich der Cursor Änderung angibt, festgelegt und <xref:System.Windows.Input.Mouse.OverrideCursor%2A> auf die <xref:System.Windows.FrameworkElement.Cursor%2A>-Eigenschaft des <xref:System.Windows.Controls.Border> Steuer Elements mit dem Namen `DisplayArea`festgelegt.  
  
 [!code-csharp[cursors#CursorsSampleOverrideCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#cursorssampleoverridecursor)]
 [!code-vb[cursors#CursorsSampleOverrideCursor](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#cursorssampleoverridecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDown">
      <MemberSignature Language="C#" Value="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseDown" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" Usage="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tritt auf, wenn eine Maustaste gedrückt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Welche Maustaste gedrückt wurde, wird durch Überprüfen der Argumente des Ereignisses festgelegt. Dabei handelt es sich um ein angefügtes Ereignis (mit tunnelingrouting-Strategie), das durch die Syntax angefügter Ereignisse durch vorhandene [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] Elemente, die Eingaben annehmen, bestimmt wird.  
  
 Dies ist ein angefügtes Ereignis. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementiert angefügte Ereignisse als Routing Ereignisse. Bei angefügten Ereignissen handelt es sich im Grunde um ein [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sprach Konzept für Verweise auf Ereignisse, die für Objekte behandelt werden können, die dieses Ereignis nicht definieren, das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] erweitert wird, indem auch das Ereignis zum Durchlaufen einer Route aktiviert wird. Angefügte Ereignisse haben im Code keine Syntax für die direkte Handhabung. zum Anfügen von Handlern für ein Routing Ereignis im Code verwenden Sie eine angegebene Add *-Handlermethode. Weitere Informationen finden Sie unter [Übersicht über angefügte Ereignisse](/dotnet/framework/wpf/advanced/attached-events-overview).  
  
 Das [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Framework baut auf diesem angefügten Ereignis auf, indem es als zwei verschiedene [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Ereignisse auf <xref:System.Windows.UIElement>angezeigt wird: <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> und <xref:System.Windows.UIElement.PreviewMouseRightButtonDown>. Diese Implementierungen behandeln das zugrunde liegende <xref:System.Windows.Input.Mouse.PreviewMouseDown> Ereignis und lesen die Argumente des Ereignisses, um zu bestimmen, ob die linke oder die Rechte Maustaste beteiligt war. Für drei Schaltflächen gibt es keine Ereignis Unterstützung auf Frameworkebene für die Schaltfläche "Center", und Sie sollten das <xref:System.Windows.Input.Mouse.PreviewMouseDown>-Ereignis verwenden und auf die Schaltfläche "Center-Schaltfläche" in den Ereignis Argumenten überprüfen.  
  
 Bei gerouteten Ereignissen, die mit der Maus in Beziehung stehen, sollten Sie darauf achten, wie oder wann Sie behandelt werden. Das Behandeln des Ereignisses in der Nähe des Stamms und dessen Behandlung durch ein untergeordnetes Element in der Quelle eignet sich möglicherweise nicht für zusammengesetzte Steuerelemente, bei denen die zusammengesetzten Elemente möglicherweise erwartete Maus Verhalten aufweisen. Die Schwierigkeit, die richtigen Entscheidungen zu treffen, ob andere Elemente auch über eine bestimmte Maus Aktion informiert werden sollten, ist tatsächlich der Grund, warum das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Framework das Modell ausgewählt hat, bei dem das zugrunde liegende <xref:System.Windows.Input.Mouse> Routing Ereignis als [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Ereignisse entlang der Route angezeigt werden soll.  
  
<a name="routedEventInfo_PreviewMouseDown"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Input.Mouse.PreviewMouseDownEvent>|  
|Routing Strategie|Tunneling|  
|Delegat|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   Das entsprechende Bubblingereignis ist <xref:System.Windows.Input.Mouse.MouseDown>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet das angefügte <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" />-Ereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Routing Ereignis Bezeichner werden erstellt, wenn Routing Ereignisse registriert werden, und das Ergebnis wird als Feld in der Klasse gespeichert, die das Routing Ereignis registriert. Diese Bezeichner enthalten einen identifizierenden Namen, den Besitzertyp, den Handlertyp, die Routing Strategie und eine hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie verwenden diese Bezeichner häufig als Parameter für Ereignis System Methoden, um ein bestimmtes Routing Ereignis zu identifizieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownOutsideCapturedElement">
      <MemberSignature Language="C#" Value="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" Usage="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tritt auf, wenn die primäre Maustaste außerhalb des Elements gedrückt wird, das Mausereignisse erfasst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist ein angefügtes Ereignis. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementiert angefügte Ereignisse als Routing Ereignisse. Bei angefügten Ereignissen handelt es sich im Grunde um ein [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sprach Konzept für Verweise auf Ereignisse, die für Objekte behandelt werden können, die dieses Ereignis nicht definieren, das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] erweitert wird, indem auch das Ereignis zum Durchlaufen einer Route aktiviert wird. Angefügte Ereignisse haben im Code keine Syntax für die direkte Handhabung. zum Anfügen von Handlern für ein Routing Ereignis im Code verwenden Sie eine angegebene Add *-Handlermethode. Weitere Informationen finden Sie unter [Übersicht über angefügte Ereignisse](/dotnet/framework/wpf/advanced/attached-events-overview).  
  
 Dieses Ereignis wird für Basiselemente nicht wieder angezeigt. Es ist hauptsächlich von Bedeutung, Autoren zu steuern, die versuchen, die Maus Aufzeichnung und Maus Eingaben innerhalb ihrer Steuerelement Komposition abzugleichen.  
  
<a name="routedEventInfo_PreviewMouseDownOutsideCaptureElement"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElementEvent>|  
|Routing Strategie|Tunneling|  
|Delegat|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownOutsideCapturedElementEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownOutsideCapturedElementEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownOutsideCapturedElementEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElementEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDownOutsideCapturedElementEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDownOutsideCapturedElementEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseDownOutsideCapturedElementEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElementEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet das angefügte <see cref="E:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement" />-Ereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Routing Ereignis Bezeichner werden erstellt, wenn Routing Ereignisse registriert werden, und das Ergebnis wird als Feld in der Klasse gespeichert, die das Routing Ereignis registriert. Diese Bezeichner enthalten einen identifizierenden Namen, den Besitzertyp, den Handlertyp, die Routing Strategie und eine hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie verwenden diese Bezeichner häufig als Parameter für Ereignis System Methoden, um ein bestimmtes Routing Ereignis zu identifizieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMove">
      <MemberSignature Language="C#" Value="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseMove" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" Usage="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tritt auf, wenn der Mauszeiger über ein Steuerelement bewegt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis tritt auf, wenn der Mauszeiger in den Element Begrenzungen neu verschoben wird, und wenn der Mauszeiger bewegt wird, während er sich noch in den Element Begrenzungen befindet.  
  
 Dies ist ein angefügtes Ereignis. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementiert angefügte Ereignisse als Routing Ereignisse. Bei angefügten Ereignissen handelt es sich im Grunde um ein [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sprach Konzept für Verweise auf Ereignisse, die für Objekte behandelt werden können, die dieses Ereignis nicht definieren, das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] erweitert wird, indem auch das Ereignis zum Durchlaufen einer Route aktiviert wird. Angefügte Ereignisse haben im Code keine Syntax für die direkte Handhabung. zum Anfügen von Handlern für ein Routing Ereignis im Code verwenden Sie eine angegebene Add *-Handlermethode. Weitere Informationen finden Sie unter [Übersicht über angefügte Ereignisse](/dotnet/framework/wpf/advanced/attached-events-overview).  
  
<a name="routedEventInfo_PreviewMouseMove"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Input.Mouse.PreviewMouseMoveEvent>|  
|Routing Strategie|Tunneling|  
|Delegat|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   Das entsprechende Bubblingereignis ist <xref:System.Windows.Input.Mouse.MouseMove>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet das angefügte <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" />-Ereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Routing Ereignis Bezeichner werden erstellt, wenn Routing Ereignisse registriert werden, und das Ergebnis wird als Feld in der Klasse gespeichert, die das Routing Ereignis registriert. Diese Bezeichner enthalten einen identifizierenden Namen, den Besitzertyp, den Handlertyp, die Routing Strategie und eine hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie verwenden diese Bezeichner häufig als Parameter für Ereignis System Methoden, um ein bestimmtes Routing Ereignis zu identifizieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUp">
      <MemberSignature Language="C#" Value="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseUp" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" Usage="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tritt auf, wenn eine Maustaste losgelassen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Welche Maustaste losgelassen wurde, wird durch Überprüfen der Argumente des Ereignisses festgelegt.  
  
 Dies ist ein angefügtes Ereignis. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementiert angefügte Ereignisse als Routing Ereignisse. Bei angefügten Ereignissen handelt es sich im Grunde um ein [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sprach Konzept für Verweise auf Ereignisse, die für Objekte behandelt werden können, die dieses Ereignis nicht definieren, das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] erweitert wird, indem auch das Ereignis zum Durchlaufen einer Route aktiviert wird. Angefügte Ereignisse haben im Code keine Syntax für die direkte Handhabung. zum Anfügen von Handlern für ein Routing Ereignis im Code verwenden Sie eine angegebene Add *-Handlermethode. Weitere Informationen finden Sie unter [Übersicht über angefügte Ereignisse](/dotnet/framework/wpf/advanced/attached-events-overview).  
  
 Das [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] Framework baut auf diesem angefügten Ereignis auf, indem es als zwei verschiedene [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] Ereignisse auf <xref:System.Windows.UIElement>angezeigt wird: <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> und <xref:System.Windows.UIElement.PreviewMouseRightButtonUp>. Diese Implementierungen behandeln das zugrunde liegende <xref:System.Windows.Input.Mouse.PreviewMouseUp> Ereignis und lesen die Argumente des Ereignisses, um zu bestimmen, ob die linke oder die Rechte Maustaste beteiligt war. Für drei Schaltflächen gibt es keine Ereignis Unterstützung auf Frameworkebene für die Schaltfläche "Center", und Sie sollten das <xref:System.Windows.Input.Mouse.PreviewMouseUp>-Ereignis verwenden und auf die Schaltfläche "Center-Schaltfläche" in den Ereignis Argumenten überprüfen.  
  
 Bei gerouteten Ereignissen, die mit der Maus in Beziehung stehen, sollten Sie darauf achten, wie oder wann Sie behandelt werden. Die Behandlung des Ereignisses in der Nähe des Stamms und nicht die Verarbeitung durch ein untergeordnetes Element in der Quelle ist möglicherweise nicht für zusammengesetzte Steuerelemente geeignet, bei denen die zusammengesetzten Elemente möglicherweise erwartete Maus Verhalten aufweisen. Die Schwierigkeit, die richtigen Entscheidungen zu treffen, ob andere Elemente auch über eine bestimmte Maus Aktion informiert werden sollten, ist tatsächlich der Grund, warum das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Framework das Modell ausgewählt hat, bei dem das zugrunde liegende <xref:System.Windows.Input.Mouse> Routing Ereignis als [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] Ereignisse entlang der Route angezeigt werden soll.  
  
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Input.Mouse.PreviewMouseUpEvent>|  
|Routing Strategie|Tunneling|  
|Delegat|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   Das entsprechende Bubblingereignis ist <xref:System.Windows.Input.Mouse.MouseUp>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet das angefügte <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" />-Ereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Routing Ereignis Bezeichner werden erstellt, wenn Routing Ereignisse registriert werden, und das Ergebnis wird als Feld in der Klasse gespeichert, die das Routing Ereignis registriert. Diese Bezeichner enthalten einen identifizierenden Namen, den Besitzertyp, den Handlertyp, die Routing Strategie und eine hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie verwenden diese Bezeichner häufig als Parameter für Ereignis System Methoden, um ein bestimmtes Routing Ereignis zu identifizieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpOutsideCapturedElement">
      <MemberSignature Language="C#" Value="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" Usage="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tritt auf, wenn die primäre Maustaste außerhalb des Elements losgelassen wird, das Mausereignisse erfasst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist ein angefügtes Ereignis. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementiert angefügte Ereignisse als Routing Ereignisse. Bei angefügten Ereignissen handelt es sich im Grunde um ein [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sprach Konzept für Verweise auf Ereignisse, die für Objekte behandelt werden können, die dieses Ereignis nicht definieren, das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] erweitert wird, indem auch das Ereignis zum Durchlaufen einer Route aktiviert wird. Angefügte Ereignisse haben im Code keine Syntax für die direkte Handhabung. zum Anfügen von Handlern für ein Routing Ereignis im Code verwenden Sie eine angegebene Add *-Handlermethode. Weitere Informationen finden Sie unter [Übersicht über angefügte Ereignisse](/dotnet/framework/wpf/advanced/attached-events-overview).  
  
 Dieses Ereignis wird für Basiselemente nicht wieder angezeigt. Es ist hauptsächlich von Bedeutung, Autoren zu steuern, die versuchen, die Maus Aufzeichnung und Maus Eingaben innerhalb ihrer Steuerelement Komposition abzugleichen.  
  
<a name="routedEventInfo_PreviewMouseUpOutsideCaptureElement"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElementEvent>|  
|Routing Strategie|Tunneling|  
|Delegat|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   Es ist kein entsprechendes bubblindereignis vorhanden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpOutsideCapturedElementEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpOutsideCapturedElementEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpOutsideCapturedElementEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElementEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseUpOutsideCapturedElementEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseUpOutsideCapturedElementEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseUpOutsideCapturedElementEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElementEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet das angefügte <see cref="E:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement" />-Ereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Routing Ereignis Bezeichner werden erstellt, wenn Routing Ereignisse registriert werden, und das Ergebnis wird als Feld in der Klasse gespeichert, die das Routing Ereignis registriert. Diese Bezeichner enthalten einen identifizierenden Namen, den Besitzertyp, den Handlertyp, die Routing Strategie und eine hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie verwenden diese Bezeichner häufig als Parameter für Ereignis System Methoden, um ein bestimmtes Routing Ereignis zu identifizieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheel">
      <MemberSignature Language="C#" Value="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseWheel" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" Usage="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tritt auf, wenn das Mausrad bewegt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Fokus oder die Maus Erfassung haben Vorrang vor der Position des Mauszeigers. Wenn Sie dieses Ereignis von einem fokussierten oder erfassten Element erhalten, ist der Mauszeiger daher möglicherweise zu einem anderen Element zu diesem Zeitpunkt.  
  
 Dies ist ein angefügtes Ereignis. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementiert angefügte Ereignisse als Routing Ereignisse. Bei angefügten Ereignissen handelt es sich im Grunde um ein [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sprach Konzept für Verweise auf Ereignisse, die für Objekte behandelt werden können, die dieses Ereignis nicht definieren, das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] erweitert wird, indem auch das Ereignis zum Durchlaufen einer Route aktiviert wird. Angefügte Ereignisse haben im Code keine Syntax für die direkte Handhabung. zum Anfügen von Handlern für ein Routing Ereignis im Code verwenden Sie eine angegebene Add *-Handlermethode. Weitere Informationen finden Sie unter [Übersicht über angefügte Ereignisse](/dotnet/framework/wpf/advanced/attached-events-overview).  
  
<a name="routedEventInfo_PreviewMouseWheel"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Input.Mouse.PreviewMouseWheelEvent>|  
|Routing Strategie|Tunneling|  
|Delegat|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   Das entsprechende Bubblingereignis ist <xref:System.Windows.Input.Mouse.MouseWheel>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet das angefügte <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" />-Ereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Routing Ereignis Bezeichner werden erstellt, wenn Routing Ereignisse registriert werden, und das Ergebnis wird als Feld in der Klasse gespeichert, die das Routing Ereignis registriert. Diese Bezeichner enthalten einen identifizierenden Namen, den Besitzertyp, den Handlertyp, die Routing Strategie und eine hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie verwenden diese Bezeichner häufig als Parameter für Ereignis System Methoden, um ein bestimmtes Routing Ereignis zu identifizieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrimaryDevice">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseDevice PrimaryDevice { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.MouseDevice PrimaryDevice" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.PrimaryDevice" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property PrimaryDevice As MouseDevice" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseDevice ^ PrimaryDevice { System::Windows::Input::MouseDevice ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PrimaryDevice : System.Windows.Input.MouseDevice" Usage="System.Windows.Input.Mouse.PrimaryDevice" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseDevice</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das primäre Mausgerät ab.</summary>
        <value>Das Gerät.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft unterstützt die Windows Presentation Foundation-Infrastruktur und ist nicht für die direkte Verwendung im Code vorgesehen.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseDevice" />
      </Docs>
    </Member>
    <Member MemberName="QueryCursor">
      <MemberSignature Language="C#" Value="see AddQueryCursorHandler, and RemoveQueryCursorHandler" />
      <MemberSignature Language="ILAsm" Value="see AddQueryCursorHandler, and RemoveQueryCursorHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.QueryCursor" />
      <MemberSignature Language="VB.NET" Value="see AddQueryCursorHandler, and RemoveQueryCursorHandler" />
      <MemberSignature Language="F#" Value="see AddQueryCursorHandler, and RemoveQueryCursorHandler" Usage="see AddQueryCursorHandler, and RemoveQueryCursorHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tritt auf, wenn der aktuelle Mauszeiger von einem Element abgefragt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist ein angefügtes Ereignis. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementiert angefügte Ereignisse als Routing Ereignisse. Bei angefügten Ereignissen handelt es sich im Grunde um ein [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sprach Konzept für Verweise auf Ereignisse, die für Objekte behandelt werden können, die dieses Ereignis nicht definieren, das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] erweitert wird, indem auch das Ereignis zum Durchlaufen einer Route aktiviert wird. Angefügte Ereignisse haben im Code keine Syntax für die direkte Handhabung. zum Anfügen von Handlern für ein Routing Ereignis im Code verwenden Sie eine angegebene Add *-Handlermethode. Weitere Informationen finden Sie unter [Übersicht über angefügte Ereignisse](/dotnet/framework/wpf/advanced/attached-events-overview).  
  
<a name="routedEventInfo_Querycursor"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Input.Mouse.QueryCursorEvent>|  
|Routing Strategie|Blasen|  
|Delegat|<xref:System.Windows.Input.QueryCursorEventHandler>|  
  
 Es ist kein entsprechendes tunnelingereignis definiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursorEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryCursorEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryCursorEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.QueryCursorEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryCursorEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryCursorEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable QueryCursorEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.QueryCursorEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet das angefügte <see cref="E:System.Windows.Input.Mouse.QueryCursor" />-Ereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Routing Ereignis Bezeichner werden erstellt, wenn Routing Ereignisse registriert werden, und das Ergebnis wird als Feld in der Klasse gespeichert, die das Routing Ereignis registriert. Diese Bezeichner enthalten einen identifizierenden Namen, den Besitzertyp, den Handlertyp, die Routing Strategie und eine hilfsprogrammmethode zum Hinzufügen von Besitzern für das Ereignis. Sie verwenden diese Bezeichner häufig als Parameter für Ereignis System Methoden, um ein bestimmtes Routing Ereignis zu identifizieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveGotMouseCaptureHandler">
      <MemberSignature Language="C#" Value="public static void RemoveGotMouseCaptureHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveGotMouseCaptureHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveGotMouseCaptureHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveGotMouseCaptureHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveGotMouseCaptureHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveGotMouseCaptureHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveGotMouseCaptureHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Entfernt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveLostMouseCaptureHandler">
      <MemberSignature Language="C#" Value="public static void RemoveLostMouseCaptureHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveLostMouseCaptureHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveLostMouseCaptureHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveLostMouseCaptureHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveLostMouseCaptureHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveLostMouseCaptureHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveLostMouseCaptureHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Entfernt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseDownHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseDownHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseDownHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseDownHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseDownHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Entfernt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.MouseDown" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseEnterHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseEnterHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseEnterHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseEnterHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseEnterHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseEnterHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseEnterHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseEnterHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Entfernt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.MouseEnter" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseLeaveHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseLeaveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseLeaveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseLeaveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseLeaveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseLeaveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseLeaveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseLeaveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Entfernt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.MouseLeave" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseMoveHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseMoveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseMoveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseMoveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseMoveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseMoveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseMoveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseMoveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Entfernt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.MouseMove" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseUpHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseUpHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseUpHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseUpHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseUpHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Entfernt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.MouseUp" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseWheelHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseWheelHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseWheelEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseWheelHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseWheelEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseWheelHandler(System.Windows.DependencyObject,System.Windows.Input.MouseWheelEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseWheelHandler (element As DependencyObject, handler As MouseWheelEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseWheelHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseWheelEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseWheelHandler : System.Windows.DependencyObject * System.Windows.Input.MouseWheelEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseWheelHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseWheelEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Entfernt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.MouseWheel" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseDownHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseDownHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseDownHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseDownHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseDownHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Entfernt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseDownOutsideCapturedElementHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseDownOutsideCapturedElementHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseDownOutsideCapturedElementHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseDownOutsideCapturedElementHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseDownOutsideCapturedElementHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseDownOutsideCapturedElementHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseDownOutsideCapturedElementHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseDownOutsideCapturedElementHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Entfernt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseMoveHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseMoveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseMoveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseMoveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseMoveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseMoveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseMoveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseMoveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Entfernt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseUpHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseUpHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseUpHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseUpHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseUpHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Entfernt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseUpOutsideCapturedElementHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseUpOutsideCapturedElementHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseUpOutsideCapturedElementHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseUpOutsideCapturedElementHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseUpOutsideCapturedElementHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseUpOutsideCapturedElementHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseUpOutsideCapturedElementHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseUpOutsideCapturedElementHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Entfernt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseWheelHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseWheelHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseWheelEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseWheelHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseWheelEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseWheelHandler(System.Windows.DependencyObject,System.Windows.Input.MouseWheelEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseWheelHandler (element As DependencyObject, handler As MouseWheelEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseWheelHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseWheelEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseWheelHandler : System.Windows.DependencyObject * System.Windows.Input.MouseWheelEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseWheelHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseWheelEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Entfernt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveQueryCursorHandler">
      <MemberSignature Language="C#" Value="public static void RemoveQueryCursorHandler (System.Windows.DependencyObject element, System.Windows.Input.QueryCursorEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveQueryCursorHandler(class System.Windows.DependencyObject element, class System.Windows.Input.QueryCursorEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveQueryCursorHandler(System.Windows.DependencyObject,System.Windows.Input.QueryCursorEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveQueryCursorHandler (element As DependencyObject, handler As QueryCursorEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveQueryCursorHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::QueryCursorEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveQueryCursorHandler : System.Windows.DependencyObject * System.Windows.Input.QueryCursorEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveQueryCursorHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.QueryCursorEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das dieses Ereignis überwacht.</param>
        <param name="handler">Der Ereignishandler.</param>
        <summary>Entfernt einen Handler für das angefügte <see cref="E:System.Windows.Input.Mouse.QueryCursor" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightButton">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState RightButton { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState RightButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.RightButton" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RightButton As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState RightButton { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.RightButton : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.RightButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Zustand der rechten Maustaste ab.</summary>
        <value>Der Zustand der rechten Maustaste.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie bestimmen können, ob die Rechte Maustaste gedrückt ist, indem Sie überprüfen, ob der Zustand des <xref:System.Windows.Input.Mouse.RightButton%2A> gleich dem <xref:System.Windows.Input.MouseButtonState> Enumerationswert <xref:System.Windows.Input.MouseButtonState.Pressed>ist.  Wenn die Schaltfläche gedrückt wird, wird eine Methode aufgerufen, die die Elemente im Beispiel anzeigt.  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetRightButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetrightbuttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetRightButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetrightbuttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="SetCursor">
      <MemberSignature Language="C#" Value="public static bool SetCursor (System.Windows.Input.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetCursor(class System.Windows.Input.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.SetCursor(System.Windows.Input.Cursor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetCursor (cursor As Cursor) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetCursor(System::Windows::Input::Cursor ^ cursor);" />
      <MemberSignature Language="F#" Value="static member SetCursor : System.Windows.Input.Cursor -&gt; bool" Usage="System.Windows.Input.Mouse.SetCursor cursor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cursor" Type="System.Windows.Input.Cursor" />
      </Parameters>
      <Docs>
        <param name="cursor">Der Cursor, auf den der Mauszeiger festgelegt werden soll.</param>
        <summary>Legt den Mauszeiger auf den angegebenen <see cref="T:System.Windows.Input.Cursor" /> fest.</summary>
        <returns><see langword="true" />, wenn der Mauszeiger festgelegt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der festgelegte Cursor gilt nicht für ein bestimmtes Element, sondern für die gesamte Anwendung.  Wenn also nach dem Festlegen des Cursors der Mauszeiger über ein Objekt bewegt wird, das den Cursor festlegt, wird der Cursor erneut geändert.  
  
 Um den Mauszeiger auf eine bestimmte <xref:System.Windows.Input.Cursor> zu erzwingen und diese <xref:System.Windows.Input.Cursor> für alle Elemente zu erzwingen, legen Sie die Eigenschaft <xref:System.Windows.Input.Mouse.OverrideCursor%2A> fest.  
  
 Um den Cursor für ein bestimmtes Element festzulegen, verwenden Sie die <xref:System.Windows.FrameworkElement.Cursor%2A>-Eigenschaft entweder in <xref:System.Windows.FrameworkElement> oder <xref:System.Windows.FrameworkContentElement>.  Weitere Informationen zu den Basiselementen finden Sie unter [Übersicht über Basiselemente](/dotnet/framework/wpf/advanced/base-elements-overview).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.Cursors" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="Synchronize">
      <MemberSignature Language="C#" Value="public static void Synchronize ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Synchronize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.Synchronize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Synchronize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Synchronize();" />
      <MemberSignature Language="F#" Value="static member Synchronize : unit -&gt; unit" Usage="System.Windows.Input.Mouse.Synchronize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erzwingt das Neusynchronisieren der Maus.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Input.MouseDevice" />
        <altmember cref="M:System.Windows.Input.Mouse.Synchronize" />
      </Docs>
    </Member>
    <Member MemberName="UpdateCursor">
      <MemberSignature Language="C#" Value="public static void UpdateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UpdateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.UpdateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UpdateCursor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UpdateCursor();" />
      <MemberSignature Language="F#" Value="static member UpdateCursor : unit -&gt; unit" Usage="System.Windows.Input.Mouse.UpdateCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erzwingt die Aktualisierung des Mauszeigers.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="XButton1">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState XButton1 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState XButton1" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.XButton1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property XButton1 As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState XButton1 { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.XButton1 : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.XButton1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Zustand der ersten erweiterten Maustaste ab.</summary>
        <value>Der Zustand der ersten erweiterten Maustaste.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie bestimmt wird, ob die erste erweiterte Maustaste gedrückt wird, indem überprüft wird, ob der Status von <xref:System.Windows.Input.Mouse.XButton1%2A> gleich dem <xref:System.Windows.Input.MouseButtonState> Enumerationswert <xref:System.Windows.Input.MouseButtonState.Pressed>ist.  Wenn die Schaltfläche gedrückt wird, wird eine Methode aufgerufen, die die Elemente im Beispiel anzeigt.  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetX1ButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetx1buttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetX1ButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetx1buttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="XButton2">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState XButton2 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState XButton2" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.XButton2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property XButton2 As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState XButton2 { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.XButton2 : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.XButton2" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Zustand der zweiten erweiterten Maustaste ab.</summary>
        <value>Der Zustand der zweiten erweiterten Maustaste.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie bestimmt wird, ob die zweite erweiterte Maustaste gedrückt wird, indem überprüft wird, ob der Status von <xref:System.Windows.Input.Mouse.XButton2%2A> gleich dem <xref:System.Windows.Input.MouseButtonState> Enumerationswert <xref:System.Windows.Input.MouseButtonState.Pressed>ist.  Wenn die Schaltfläche gedrückt wird, wird eine Methode aufgerufen, die die Elemente im Beispiel anzeigt.  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetX2ButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetx2buttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetX2ButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetx2buttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
  </Members>
</Type>
