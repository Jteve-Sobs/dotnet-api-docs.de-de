<Type Name="SecureString" FullName="System.Security.SecureString">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a1b83b7cb358be3a46e68daac29ed99f5f5e062e" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36527814" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SecureString : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed SecureString extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Security.SecureString" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SecureString&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecureString sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type SecureString = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Security.SecureString</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt Text dar, der vertraulich behandelt werden soll, etwa durch Löschen aus dem Arbeitsspeicher des Computers, wenn er nicht mehr benötigt wird. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.SecureString> ist ein String-Typ, der ein Maß an Sicherheit bietet. Sie versucht, Sie sollten nicht potenziell vertrauliche Zeichenfolgen in Prozessspeicher als nur-Text gespeichert.  (Informationen zu Einschränkungen finden Sie jedoch die [wie sicher SecureString ist?](#HowSecure) Abschnitt.) Der Wert einer Instanz von <xref:System.Security.SecureString> wird automatisch geschützt mithilfe eines Mechanismus, durch die zugrunde liegende Plattform unterstützt, wenn die Instanz initialisiert wird oder wenn der Wert geändert wird. Ihre Anwendung kann Rendern die Instanz als unveränderlich und zu verhindern, dass weitere Änderungen durch Aufrufen der <xref:System.Security.SecureString.MakeReadOnly%2A> Methode.  
  
 Die maximale Länge von einer <xref:System.Security.SecureString> Instanz beträgt 65.536 Zeichen.  
  
> [!IMPORTANT]
>  Dieser Typ implementiert die <xref:System.IDisposable> Schnittstelle. Wenn Sie mit einer Instanz des Typs abgeschlossen haben, sollten Sie es entweder direkt oder indirekt freigeben. Aufrufen, um den Typ direkt zu verwerfen, dessen <xref:System.IDisposable.Dispose%2A> Methode in einer `try` / `catch` Block. Um es indirekt freizugeben, verwenden Sie ein Sprachkonstrukt z. B. `using` (in c#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt "Verwenden eines Objekts, implementiert IDisposable" in der <xref:System.IDisposable> Thema zur Schnittstelle.  
  
 Die <xref:System.Security.SecureString> Klasse und ihre Member sind nicht für COM sichtbar. Weitere Informationen finden Sie unter <xref:System.Runtime.InteropServices.ComVisibleAttribute>.  
  
 In diesem Abschnitt  
  
 [Eine Zeichenfolge im Vergleich. SecureString](#vsString)   
 [SecureString-Vorgänge](#Ops)   
 [SecureString und interop](#interop)   
 [Wie sicher SecureString ist?](#HowSecure)  
  
<a name="vsString"></a>   
## <a name="string-versus-securestring"></a>Zeichenfolge im Vergleich zu SecureString  
 Eine Instanz von der <xref:System.String?displayProperty=nameWithType> Klasse ist unveränderlich und kann, wenn nicht mehr benötigt wird, nicht programmgesteuert für die Garbagecollection geplant werden; d. h. die Instanz ist schreibgeschützt, nachdem es erstellt, und es ist nicht möglich, um vorherzusagen, wann die Instanz gestellt werden aus dem Computerspeicher gelöscht. Da <xref:System.String?displayProperty=nameWithType> Instanzen sind unveränderlich, Vorgänge, die angezeigt werden, um die Änderung einer vorhandenen Instanz tatsächlich erstellt eine Kopie davon zu bearbeiten. Daher, wenn ein <xref:System.String> -Objekt sicherheitsrelevante Informationen wie Kennwörter, Kreditkartennummern oder persönliche Daten enthält, besteht das Risiko, das die Informationen konnte offen gelegt werden, nachdem es verwendet wird, da die Anwendung die Daten aus dem Computerspeicher löschen kann .  
  
 Ein <xref:System.Security.SecureString> Objekt ähnelt einem <xref:System.String> -Objekt, da es einen Textwert besitzt. Allerdings den Wert des einem <xref:System.Security.SecureString> Objekt im Speicher festgesetzt ist, kann einen Schutzmechanismus verwenden, z. B. Verschlüsselung, von dem zugrunde liegenden Betriebssystem bereitgestellten geändert werden kann, bis die Anwendung als schreibgeschützt markiert und kann aus dem Computerspeicher gelöscht werden durch die aufrufende Anwendung die <xref:System.Security.SecureString.Dispose%2A> Methode oder durch den Garbage Collector von .NET Framework.  
  
 Eine Erläuterung der Einschränkungen von der <xref:System.Security.SecureString> Klasse, finden Sie unter der [wie sicher SecureString ist?](#HowSecure) Abschnitt.  
  
 [Zurück zum Anfang](#top)  
  
<a name="Ops"></a>   
## <a name="securestring-operations"></a>SecureString-Vorgänge  
 Die <xref:System.Security.SecureString> Klasse enthält Elemente, mit denen Sie die folgenden Schritte ausführen können:  
  
 Instanziieren einer <xref:System.Security.SecureString> Objekt  
 Instanziieren Sie ein <xref:System.Security.SecureString> Objekt durch Aufrufen der parameterlose Konstruktor.  
  
 Hinzufügen von Zeichen zu einem <xref:System.Security.SecureString> Objekt  
 Sie können ein einzelnes Zeichen zu einem Zeitpunkt zum Hinzufügen einer <xref:System.Security.SecureString> Objekt durch Aufrufen seiner <xref:System.Security.SecureString.AppendChar%2A> oder <xref:System.Security.SecureString.InsertAt%2A> Methode.  
  
> [!IMPORTANT]
>  Ein <xref:System.Security.SecureString> Objekt sollte nie konstruiert werden, aus einer <xref:System.String>, da bereits unterliegt die sensiblen Daten in den Arbeitsspeicher Persistenz folgen, der die unveränderliche <xref:System.String> Klasse. Die beste Methode zum Erstellen einer <xref:System.Security.SecureString> Objekt ist von einer nicht verwalteten Zeichen zur Zeit-Quelle, wie z. B. die <xref:System.Console.ReadKey%2A?displayProperty=nameWithType> Methode.  
  
 Entfernen von Zeichen aus einer <xref:System.Security.SecureString> Objekt  
 Sie können ein einzelnes Zeichen ersetzen, durch Aufrufen der <xref:System.Security.SecureString.SetAt%2A> -Methode, entfernen Sie ein einzelnes Zeichen durch Aufrufen der <xref:System.Security.SecureString.RemoveAt%2A> -Methode, oder entfernen Sie alle Zeichen aus der <xref:System.Security.SecureString> Instanz durch Aufrufen der <xref:System.Security.SecureString.Clear%2A> Methode.  
  
 Stellen Sie die <xref:System.Security.SecureString> Objekt ohne Schreibzugriff  
 Nachdem Sie die Zeichenfolge definiert haben, die <xref:System.Security.SecureString> -Objekt darstellt, rufen Sie die <xref:System.Security.SecureString.MakeReadOnly%2A> Methode, um die Zeichenfolge schreibgeschützt machen.  
  
 Abrufen von Informationen über die <xref:System.Security.SecureString> Objekt  
 Die <xref:System.Security.SecureString> -Klasse verfügt über nur zwei Member, die Informationen über die Zeichenfolge bereitstellen: die <xref:System.Security.SecureString.Length%2A> Eigenschaft, die die Anzahl der in der Zeichenfolge; UTF16-codierte Codeeinheiten angibt und die <xref:System.Security.SecureString.IsReadOnly%2A>, Methode, die angibt, ob die Instanz schreibgeschützt.  
  
 Zugewiesene Arbeitsspeicher freigegeben die <xref:System.Security.SecureString> Instanz  
 Da <xref:System.Security.SecureString> implementiert die <xref:System.IDisposable> -Schnittstelle, Sie ihren Arbeitsspeicher freigeben, durch Aufrufen der <xref:System.Security.SecureString.Dispose%2A> Methode.  
  
 Die <xref:System.Security.SecureString> -Klasse verfügt über keine Elemente, die zu überprüfen, vergleichen oder konvertieren Sie den Wert von einem <xref:System.Security.SecureString>. Das fehlen solcher Member hilft dabei, den Wert der Instanz vor versehentlicher oder böswilliger Verfügbarmachung zu schützen. Verwenden Sie geeignete Member der der <xref:System.Runtime.InteropServices.Marshal?displayProperty=nameWithType> Klasse, z. B. die <xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A> Methode, um den Wert der Bearbeiten einer <xref:System.Security.SecureString> Objekt.  
  
 Der .NET Framework-Klassenbibliothek verwendet <xref:System.Security.SecureString> Instanzen auf folgende Weise:  
  
-   Bereitstellen von Kennwortinformationen an einen Prozess mithilfe der <xref:System.Diagnostics.ProcessStartInfo> -Struktur oder durch den Aufruf einer Überladung von der <xref:System.Diagnostics.Process.Start%2A?displayProperty=nameWithType> Methode, die einen Parameter vom Typ <xref:System.Security.SecureString>.  
  
-   Kennwort Netzwerk durch Aufrufen von Anmeldeinformationen eine <xref:System.Net.NetworkCredential> Klassenkonstruktor, die einen vom Typ Parameter <xref:System.Security.SecureString> oder mithilfe der <xref:System.Net.NetworkCredential.SecurePassword%2A?displayProperty=nameWithType> Eigenschaft.  
  
-   Bereitstellen von Kennwortinformationen für SQL Server-Authentifizierung durch Aufrufen der <xref:System.Data.SqlClient.SqlCredential.%23ctor%2A?displayProperty=nameWithType> Konstruktor oder das Abrufen des Werts der <xref:System.Data.SqlClient.SqlCredential.Password%2A?displayProperty=nameWithType> Eigenschaft.  
  
-   Eine Zeichenfolge an nicht verwalteten Code übergeben. Weitere Informationen finden Sie unter der [SecureString und Interop-](#interop) Abschnitt.  
  
 [Zurück zum Anfang](#top)  
  
<a name="interop"></a>   
## <a name="securestring-and-interop"></a>SecureString und interop  
 Da das Betriebssystem nicht direkt unterstützt <xref:System.Security.SecureString>, müssen Sie den Wert der konvertieren die <xref:System.Security.SecureString> Objekt in den erforderlichen String-Datentyp, bevor Sie die Zeichenfolge an einer nativen Methode übergeben.  Die <xref:System.Runtime.InteropServices.Marshal> -Klasse verfügt über fünf Methoden, die dazu:  
  
-   <xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A?displayProperty=nameWithType>, welche konvertiert die <xref:System.Security.SecureString> string-Wert, um eine binäre Zeichenfolge (BSTR), die von COM erkannt  
  
-   <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A?displayProperty=nameWithType> und <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A?displayProperty=nameWithType>, welche Kopie der <xref:System.Security.SecureString> string-Wert in eine ANSI-Zeichenfolge in nicht verwalteten Speicher.  
  
-   <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A?displayProperty=nameWithType> und <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A?displayProperty=nameWithType>, welche Kopie der <xref:System.Security.SecureString> Zeichenfolgenwert, der eine Unicode-Zeichenfolge in nicht verwalteten Speicher.  
  
 Jede dieser Methoden erstellt eine Klartext-Zeichenfolge in nicht verwalteten Speicher. Es obliegt dem Entwickler zu 0 (null) und freigegeben werden, sobald es nicht mehr benötigt wird. Jede Zeichenfolgenmethoden für die Konvertierung und Arbeitsspeicher-Zuordnung verfügt über eine entsprechende Methode auf 0 (null) und den belegten Speicher freizugeben:  
  
|Zuordnung und Konvertierung-Methode|0 (null) und free-Methode|  
|--------------------------------------|--------------------------|  
|<xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A?displayProperty=nameWithType>|<xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A?displayProperty=nameWithType>|  
|<xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A?displayProperty=nameWithType>|<xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A?displayProperty=nameWithType>|  
|<xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A?displayProperty=nameWithType>|<xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A?displayProperty=nameWithType>|  
|<xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A?displayProperty=nameWithType>|<xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A?displayProperty=nameWithType>|  
|<xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A?displayProperty=nameWithType>|<xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A?displayProperty=nameWithType>|  
  
 [Zurück zum Anfang](#top)  
  
<a name="HowSecure"></a>   
## <a name="how-secure-is-securestring"></a>Wie sicher SecureString ist?  
 Wenn ordnungsgemäß erstellt eine <xref:System.Security.SecureString> Instanz bietet mehr Datenschutz als eine <xref:System.String>. Beim Erstellen einer Zeichenfolge aus einer Quelle Zeichen zur Zeit <xref:System.String> erstellt mehrere Zwischenspeicher im Arbeitsspeicher, wohingegen <xref:System.Security.SecureString> nur eine einzelne Instanz erstellt.  Garbagecollection <xref:System.String> Objekte ist nicht deterministisch. Da der Speicher nicht fixiert ist, der Garbage Collector wird Stellen Sie außerdem zusätzliche Kopien <xref:System.String> Werte beim Verschieben und Komprimieren von Arbeitsspeicher. Im Gegensatz dazu belegte Arbeitsspeicher einen <xref:System.Security.SecureString> Objekt fixiert ist, und, dass der Arbeitsspeicher freigegeben werden kann, durch Aufrufen der <xref:System.Security.SecureString.Dispose%2A> Methode.  
  
 Obwohl Daten, in gespeichert eine <xref:System.Security.SecureString> Instanz ist sicherer als die Daten in eine <xref:System.String> Instanz ist, stehen Sie verfügen über umfassende Einschränkungen auf wie sicher eine <xref:System.Security.SecureString> Instanz ist. Dazu gehören:  
  
 Plattform  
 Auf dem Windows-Betriebssystem, den Inhalt des eine <xref:System.Security.SecureString> interne Zeichenarray Instanz verschlüsselt werden. Allerdings ist Verschlüsselung aufgrund fehlender-APIs oder schlüsselverwaltung Probleme, nicht auf allen Plattformen verfügbar. Aufgrund dieser plattformabhängigkeit <xref:System.Security.SecureString> der internen Speicherung für nicht-Windows-Plattform nicht verschlüsselt. Andere Techniken werden auf diesen Plattformen verwendet, um zusätzlichen Schutz zu bieten.
  
 Dauer  
 Auch wenn die <xref:System.Security.SecureString> Implementierung ist der Verschlüsselung nutzen, die nur-Text zugeordneten der <xref:System.Security.SecureString> Instanz möglicherweise zu verschiedenen Zeiten verfügbar gemacht werden:  
  
-   Da Windows eine sichere Zeichenfolge Implementierung auf Betriebssystemebene keine anbietet, noch von .NET Framework auf den Wert für die sichere Zeichenfolge in die nur-Text-Darstellung zu konvertieren, um sie zu verwenden.  
  
-   Wenn der Wert der sicheren Zeichenfolge geändert wird, indem Methoden wie z. B. <xref:System.Security.SecureString.AppendChar%2A> oder <xref:System.Security.SecureString.RemoveAt%2A>, müssen entschlüsselt werden kann (d. h. das konvertierte zurück nur-Text), geändert, und klicken Sie dann erneut verschlüsselt.  
  
-   Wenn die sichere Zeichenfolge in eine Interop-Aufrufen verwendet wird, muss er in eine ANSI-Zeichenfolge, eine Unicode-Zeichenfolge oder eine binäre Zeichenfolge (BSTR) konvertiert werden. Weitere Informationen finden Sie unter der [SecureString und Interop-](#interop) Abschnitt.  
  
 Das Zeitintervall für die die <xref:System.Security.SecureString> des Instanzwert wird verfügbar gemacht wird lediglich im Vergleich zur gekürzt der <xref:System.String> Klasse.  
  
 Speicher im Vergleich zur Verwendung  
 Allgemeiner gesagt ist der <xref:System.Security.SecureString> Klasse definiert einen Speichermechanismus für Zeichenfolgenwerte, die geschützt oder vertraulich werden soll. Außerhalb von .NET Framework selbst unterstützt keinen Mechanismus für die Verwendung jedoch <xref:System.Security.SecureString>. Dies bedeutet, dass die sichere Zeichenfolge in eine verwendbare Form (in der Regel ein Formular Klartext) konvertiert werden muss, die von ihrem Ziel erkannt werden können und Entschlüsselung sowie die Konvertierung in Benutzerspeicherplatz erfolgen müssen.  
  
 Insgesamt <xref:System.Security.SecureString> ist sicherer als <xref:System.String> , da diese Option der Offenlegung von vertraulichen Zeichenfolgendaten beschränkt. Allerdings können diese Zeichenfolgen weiterhin verfügbar gemacht werden, Prozess oder Vorgang, der Zugriff auf den unformatierten Speicher, z. B. von einem bösartigen Prozess auf dem Hostcomputer, ein Speicherabbild für den Prozess oder eine Auslagerungsdatei für Benutzer angezeigt werden kann. Anstatt <xref:System.Security.SecureString> um Kennwörter zu schützen, der die empfohlene Alternative ist ein nicht transparentes Handle, um Anmeldeinformationen zu verwenden, die außerhalb des Prozesses gespeichert sind.  
  
 [Zurück zum Anfang](#top)  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie eine <xref:System.Security.SecureString> sichern Sie das Kennwort eines Benutzers zur Verwendung als Anmeldeinformationen für einen neuen Prozess zu starten.  
  
 [!code-csharp[System.Security.SecureString.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/cs/ctor4.cs#4)]
 [!code-vb[System.Security.SecureString.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/vb/ctor4.vb#4)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />
    <altmember cref="T:System.Runtime.InteropServices.Marshal" />
    <altmember cref="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
    <altmember cref="T:System.IDisposable" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.SecureString" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SecureString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SecureString();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.SecureString" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird den Standardwert (oder parameterlosen) Konstruktor zum Instanziieren einer neuen <xref:System.Security.SecureString> Objekt. Er ruft dann die <xref:System.Security.SecureString.AppendChar%2A> Methode, um ein Array von Zeichen hinzugefügt.  
  
 [!code-cpp[System.Security.SecureString.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/cpp/Ctor2.cpp#2)]
 [!code-csharp[System.Security.SecureString.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/cs/Ctor2.cs#2)]
 [!code-vb[System.Security.SecureString.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/vb/ctor2.vb#2)]  
  
 Das folgende Beispiel erstellt eine <xref:System.Security.SecureString> Objekt aus dem Wert des einem <xref:System.String> Objekt.  
  
 [!code-cpp[System.Security.SecureString.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/cpp/Ctor3.cpp#3)]
 [!code-csharp[System.Security.SecureString.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/cs/Ctor3.cs#3)]
 [!code-vb[System.Security.SecureString.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.SecureString.Ctor/vb/Ctor3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Schützen oder Aufheben des Schutzes für den Wert dieser Instanz ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.NotSupportedException">Diese Operation wird auf dieser Plattform nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SecureString (char* value, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.#ctor(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SecureString(char* value, int length);" />
      <MemberSignature Language="F#" Value="new System.Security.SecureString : nativeptr&lt;char&gt; * int -&gt; System.Security.SecureString" Usage="new System.Security.SecureString (value, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ein Zeiger auf ein Array von <see cref="T:System.Char" />-Objekten.</param>
        <param name="length">Die Anzahl der Elemente von <c>value</c>, die in die neue Instanz eingeschlossen werden sollen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.SecureString" />-Klasse aus einem Unterarray von <see cref="T:System.Char" />-Objekten.  Dieser Konstruktor ist nicht CLS-kompatibel. Die CLS-kompatible Alternative ist <see cref="M:System.Security.SecureString.#ctor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert die neue <xref:System.Security.SecureString> Objekt, das die Anzahl der Zeichen in `value` gemäß `length`; der Wert der Instanz wird dann verschlüsselt.  
  
 Dieser Konstruktor ist in c# ist nur im Kontext der unsicheren Code definiert.  
  
   
  
## Examples  
 Das folgende Beispiel instanziiert einen neuen <xref:System.Security.SecureString> -Objekt durch Übergeben des Konstruktors einen Zeiger auf ein Zeichenarray.  
  
 [!code-cpp[System.Security.SecureString.Ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.security.securestring.ctor2/cpp/ctor1.cpp#1)]
 [!code-csharp[System.Security.SecureString.Ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.security.securestring.ctor2/cs/ctor1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> ist kleiner als 0 (null) oder größer als 65.536.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Schützen oder Aufheben des Schutzes für den Wert dieser sicheren Zeichenfolge ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.NotSupportedException">Diese Operation wird auf dieser Plattform nicht unterstützt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="AppendChar">
      <MemberSignature Language="C#" Value="public void AppendChar (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendChar(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.AppendChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendChar (c As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendChar(char c);" />
      <MemberSignature Language="F#" Value="member this.AppendChar : char -&gt; unit" Usage="secureString.AppendChar c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptions</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Ein Zeichen, das an diese sichere Zeichenfolge angefügt werden soll.</param>
        <summary>Fügt am Ende der aktuellen sicheren Zeichenfolge ein Zeichen an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Implementierung einen Schutzmechanismus, z. B. Verschlüsselung verwendet ist der Wert dieser sicheren Zeichenfolge, ggf. ungeschützten; `c` angefügt ist, und klicken Sie dann der neue Wert, der die sichere Zeichenfolge erneut geschützt wird.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie die <xref:System.Security.SecureString.AppendChar%2A>, <xref:System.Security.SecureString.InsertAt%2A>, <xref:System.Security.SecureString.RemoveAt%2A>, <xref:System.Security.SecureString.SetAt%2A>, und <xref:System.Security.SecureString.Clear%2A> Methoden Auswirkungen auf den Wert des einem <xref:System.Security.SecureString> Objekt.  
  
 [!code-cpp[SecureString.xAt#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xAt/CPP/SecureString.xAt.cpp#1)]
 [!code-csharp[SecureString.xAt#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xAt/CS/xat.cs#1)]
 [!code-vb[SecureString.xAt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xAt/VB/xat.vb#1)]  
  
 Im folgende Beispiel wird veranschaulicht, wie die <xref:System.Security.SecureString.AppendChar%2A> und <xref:System.Security.SecureString.RemoveAt%2A> Methoden können verwendet werden, um die Zeichen in einem Kennwort zu erfassen.  
  
 [!code-cpp[SecureString.xChar#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xChar/CPP/SecureString.xChar.cpp#1)]
 [!code-csharp[SecureString.xChar#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xChar/CS/xchar.cs#1)]
 [!code-vb[SecureString.xChar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xChar/VB/xchar.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Diese sichere Zeichenfolge wurde bereits verworfen.</exception>
        <exception cref="T:System.InvalidOperationException">Diese sichere Zeichenfolge ist schreibgeschützt.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Beim Ausführen dieses Vorgangs überschreitet diese sichere Zeichenfolge die Länge von 65.536 Zeichen.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Schützen oder Aufheben des Schutzes für den Wert dieser sicheren Zeichenfolge ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="secureString.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht den Wert der aktuellen sicheren Zeichenfolge.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Arbeitsspeicher des Computers mit dem Wert dieser sicheren Zeichenfolge wird mit Nullen beschrieben, und klicken Sie dann die Länge des Werts dieser sicheren Zeichenfolge auf 0 (null) festgelegt ist.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie die <xref:System.Security.SecureString.AppendChar%2A>, <xref:System.Security.SecureString.InsertAt%2A>, <xref:System.Security.SecureString.RemoveAt%2A>, <xref:System.Security.SecureString.SetAt%2A>, und <xref:System.Security.SecureString.Clear%2A> Methoden Auswirkungen auf den Wert des einem <xref:System.Security.SecureString> Objekt.  
  
 [!code-cpp[SecureString.xAt#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xAt/CPP/SecureString.xAt.cpp#1)]
 [!code-csharp[SecureString.xAt#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xAt/CS/xat.cs#1)]
 [!code-vb[SecureString.xAt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xAt/VB/xat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Diese sichere Zeichenfolge wurde bereits verworfen.</exception>
        <exception cref="T:System.InvalidOperationException">Diese sichere Zeichenfolge ist schreibgeschützt.</exception>
        <altmember cref="P:System.Security.SecureString.Length" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Security.SecureString Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.SecureString Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As SecureString" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::SecureString ^ Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; System.Security.SecureString" Usage="secureString.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecureString</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine Kopie der aktuellen sicheren Zeichenfolge.</summary>
        <returns>Ein Duplikat dieser sicheren Zeichenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Instanz von einem <xref:System.Security.SecureString> ist als schreibgeschützt gekennzeichnet, die Kopie dieser Instanz ist nicht schreibgeschützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Diese sichere Zeichenfolge wurde bereits verworfen.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Schützen oder Aufheben des Schutzes für den Wert dieser sicheren Zeichenfolge ist ein Fehler aufgetreten.</exception>
        <altmember cref="M:System.Security.SecureString.MakeReadOnly" />
        <altmember cref="M:System.Security.SecureString.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="secureString.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle vom aktuellen <see cref="T:System.Security.SecureString" />-Objekt verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Security.SecureString.Dispose%2A> -Methode schreibt binäre Nullen (0), um den belegten Speicher mit dem Wert dieses <xref:System.Security.SecureString> -Objekt, und klicken Sie dann den reservierten Speicher frei.  
  
 Weitere Informationen finden Sie unter [Garbage Collection](~/docs/standard/garbage-collection/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertAt">
      <MemberSignature Language="C#" Value="public void InsertAt (int index, char c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertAt(int32 index, char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.InsertAt(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertAt (index As Integer, c As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertAt(int index, char c);" />
      <MemberSignature Language="F#" Value="member this.InsertAt : int * char -&gt; unit" Usage="secureString.InsertAt (index, c)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptions</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">Die Indexposition, an der der <c>c</c>-Parameter eingefügt wird.</param>
        <param name="c">Das einzufügende Zeichen.</param>
        <summary>Fügt in dieser sicheren Zeichenfolge an der angegebenen Indexposition ein Zeichen ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Index ist nullbasiert. das erste Zeichen in dieser sicheren Zeichenfolge wird an die Indexposition 0 (null).  
  
 Wenn die Implementierung einen Schutzmechanismus, z. B. Verschlüsselung verwendet ist der Wert der sicheren Zeichenfolge ist, sofern vorhanden, ungeschützten; `c` wird an der angegebenen Indexposition; eingefügt und dann der neue Wert erneut geschützt wird. Die <xref:System.Security.SecureString.InsertAt%2A> -Methode ergibt die gleichen Ergebnisse wie die <xref:System.Security.SecureString.AppendChar%2A> -Methode, die am Ende einer sicheren Zeichenfolge ein Zeichen einfügt der `index` Parameter <xref:System.Security.SecureString.InsertAt%2A> festgelegt ist, auf die Länge dieser Instanz.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie die <xref:System.Security.SecureString.AppendChar%2A>, <xref:System.Security.SecureString.InsertAt%2A>, <xref:System.Security.SecureString.RemoveAt%2A>, <xref:System.Security.SecureString.SetAt%2A>, und <xref:System.Security.SecureString.Clear%2A> Methoden Auswirkungen auf den Wert des einem <xref:System.Security.SecureString> Objekt.  
  
 [!code-cpp[SecureString.xAt#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xAt/CPP/SecureString.xAt.cpp#1)]
 [!code-csharp[SecureString.xAt#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xAt/CS/xat.cs#1)]
 [!code-vb[SecureString.xAt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xAt/VB/xat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Diese sichere Zeichenfolge wurde bereits verworfen.</exception>
        <exception cref="T:System.InvalidOperationException">Diese sichere Zeichenfolge ist schreibgeschützt.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die Länge dieser sicheren Zeichenfolge.  Oder:  Durch das Ausführen dieses Vorgangs überschreitet diese sichere Zeichenfolge die Länge von 65.536 Zeichen.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Schützen oder Aufheben des Schutzes für den Wert dieser sicheren Zeichenfolge ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Function IsReadOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsReadOnly();" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : unit -&gt; bool" Usage="secureString.IsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt an, ob diese sichere Zeichenfolge als schreibgeschützt markiert ist.</summary>
        <returns>
          <see langword="true" />, wenn diese sichere Zeichenfolge schreibgeschützt ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nachdem eine Instanz von <xref:System.Security.SecureString> RuntimeCompatibility schreibgeschützt sind und von der <xref:System.Security.SecureString.MakeReadOnly%2A> -Methode, jeder Versuch zum Ändern des Werts, der die Instanz löst eine <xref:System.InvalidOperationException>. Verwenden der <xref:System.Security.SecureString.IsReadOnly%2A> Methode zum Testen, ob eine <xref:System.Security.SecureString> schreibgeschützt ist, bevor Sie versuchen, diese zu ändern.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Diese sichere Zeichenfolge wurde bereits verworfen.</exception>
        <altmember cref="M:System.Security.SecureString.MakeReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Security.SecureString.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Security.SecureString.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Zeichen in der aktuellen sicheren Zeichenfolge ab.</summary>
        <value>Die Anzahl von <see cref="T:System.Char" />-Objekten in dieser sicheren Zeichenfolge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Security.SecureString.Length%2A> Eigenschaft gibt die Anzahl der <xref:System.Char> Objekte in dieser Instanz, die nicht die Anzahl von Unicode-Zeichen. Ein Unicode-Zeichen dargestellt werden kann, von mehreren <xref:System.Char> Objekt.  
  
 Die maximale Länge von einer <xref:System.Security.SecureString> Instanz beträgt 65.536 Zeichen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Diese sichere Zeichenfolge wurde bereits verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeReadOnly">
      <MemberSignature Language="C#" Value="public void MakeReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MakeReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.MakeReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub MakeReadOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MakeReadOnly();" />
      <MemberSignature Language="F#" Value="member this.MakeReadOnly : unit -&gt; unit" Usage="secureString.MakeReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legt den Textwert dieser sicheren Zeichenfolge als schreibgeschützt fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Initialisiert den Textwert einer Instanz von der <xref:System.Security.SecureString> -Klasse mit der <xref:System.Security.SecureString.%23ctor%2A> Konstruktoren auf, und ändern Sie den Wert mit der <xref:System.Security.SecureString.Clear%2A>, <xref:System.Security.SecureString.RemoveAt%2A>, <xref:System.Security.SecureString.SetAt%2A>, <xref:System.Security.SecureString.InsertAt%2A>, und <xref:System.Security.SecureString.AppendChar%2A> Methoden.  
  
 Nachdem Sie die letzten Änderungen vorgenommen haben, verwenden Sie die <xref:System.Security.SecureString.MakeReadOnly%2A> Methode, um den Wert der Instanz unveränderlich (schreibgeschützt). Nachdem der Wert als schreibgeschützt markiert ist, werden weitere Versuche, löst das Ändern einer <xref:System.InvalidOperationException>.  
  
 Die Auswirkung des Aufrufs einer <xref:System.Security.SecureString.MakeReadOnly%2A> wird dauerhaft ausgeführt, da die <xref:System.Security.SecureString> Klasse bietet keine Möglichkeit, die sichere Zeichenfolge erneut geändert werden kann. Verwenden der <xref:System.Security.SecureString.IsReadOnly%2A> Methode zu testen, ob eine Instanz von <xref:System.Security.SecureString> ist schreibgeschützt.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie die <xref:System.Security.SecureString.AppendChar%2A> und <xref:System.Security.SecureString.RemoveAt%2A> Methoden können verwendet werden, um die Zeichen in einem Kennwort zu erfassen. Nachdem das Kennwort gesammelt wird, ist es schreibgeschützt festgelegt.  
  
 [!code-cpp[SecureString.xChar#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xChar/CPP/SecureString.xChar.cpp#1)]
 [!code-csharp[SecureString.xChar#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xChar/CS/xchar.cs#1)]
 [!code-vb[SecureString.xChar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xChar/VB/xchar.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Diese sichere Zeichenfolge wurde bereits verworfen.</exception>
        <altmember cref="M:System.Security.SecureString.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="member this.RemoveAt : int -&gt; unit" Usage="secureString.RemoveAt index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptions</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Die Indexposition eines Zeichens in dieser sicheren Zeichenfolge.</param>
        <summary>Entfernt das Zeichen an der angegebenen Indexposition aus dieser sicheren Zeichenfolge.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Index ist nullbasiert. das erste Zeichen in dieser Instanz ist Indexposition 0 (null).  
  
 Wenn die Implementierung einen Schutzmechanismus, z. B. Verschlüsselung verwendet ist der Wert dieser sicheren Zeichenfolge, ggf. ungeschützten; das Zeichen an der angegebenen Indexposition entfernt wird. der neue Wert wird dann erneut geschützt.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie die <xref:System.Security.SecureString.AppendChar%2A>, <xref:System.Security.SecureString.InsertAt%2A>, <xref:System.Security.SecureString.RemoveAt%2A>, <xref:System.Security.SecureString.SetAt%2A>, und <xref:System.Security.SecureString.Clear%2A> Methoden Auswirkungen auf den Wert des einem <xref:System.Security.SecureString> Objekt.  
  
 [!code-cpp[SecureString.xAt#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xAt/CPP/SecureString.xAt.cpp#1)]
 [!code-csharp[SecureString.xAt#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xAt/CS/xat.cs#1)]
 [!code-vb[SecureString.xAt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xAt/VB/xat.vb#1)]  
  
 Im folgende Beispiel wird veranschaulicht, wie die <xref:System.Security.SecureString.AppendChar%2A> und <xref:System.Security.SecureString.RemoveAt%2A> Methoden können verwendet werden, um die Zeichen in einem Kennwort zu erfassen.  
  
 [!code-cpp[SecureString.xChar#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xChar/CPP/SecureString.xChar.cpp#1)]
 [!code-csharp[SecureString.xChar#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xChar/CS/xchar.cs#1)]
 [!code-vb[SecureString.xChar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xChar/VB/xchar.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Diese sichere Zeichenfolge wurde bereits verworfen.</exception>
        <exception cref="T:System.InvalidOperationException">Diese sichere Zeichenfolge ist schreibgeschützt.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null), größer als die Länge der sicheren Zeichenfolge oder gleich der Länge dieser Zeichenfolge.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Schützen oder Aufheben des Schutzes für den Wert dieser sicheren Zeichenfolge ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAt">
      <MemberSignature Language="C#" Value="public void SetAt (int index, char c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAt(int32 index, char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecureString.SetAt(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAt (index As Integer, c As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAt(int index, char c);" />
      <MemberSignature Language="F#" Value="member this.SetAt : int * char -&gt; unit" Usage="secureString.SetAt (index, c)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.SecureString</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptions</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">Die Indexposition eines vorhandenen Zeichens in dieser sicheren Zeichenfolge</param>
        <param name="c">Ein Zeichen, das das vorhandene Zeichen ersetzt.</param>
        <summary>Ersetzt das an der angegebenen Indexposition vorhandene Zeichen durch ein anderes Zeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Index ist nullbasiert. das erste Zeichen in dieser Instanz ist Indexposition 0 (null).  
  
 Wenn die Implementierung einen Schutzmechanismus, z. B. Verschlüsselung verwendet ist der Wert der sicheren Zeichenfolge ist, sofern vorhanden, ungeschützten; `c` der angegebenen Indexposition; zugewiesen ist und Sie dann der neue Wert erneut geschützt wird.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie die <xref:System.Security.SecureString.AppendChar%2A>, <xref:System.Security.SecureString.InsertAt%2A>, <xref:System.Security.SecureString.RemoveAt%2A>, <xref:System.Security.SecureString.SetAt%2A>, und <xref:System.Security.SecureString.Clear%2A> Methoden Auswirkungen auf den Wert des einem <xref:System.Security.SecureString> Objekt.  
  
 [!code-cpp[SecureString.xAt#1](~/samples/snippets/cpp/VS_Snippets_CLR/SecureString.xAt/CPP/SecureString.xAt.cpp#1)]
 [!code-csharp[SecureString.xAt#1](~/samples/snippets/csharp/VS_Snippets_CLR/SecureString.xAt/CS/xat.cs#1)]
 [!code-vb[SecureString.xAt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SecureString.xAt/VB/xat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Diese sichere Zeichenfolge wurde bereits verworfen.</exception>
        <exception cref="T:System.InvalidOperationException">Diese sichere Zeichenfolge ist schreibgeschützt.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null), größer als die Länge der sicheren Zeichenfolge oder gleich der Länge dieser Zeichenfolge.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Beim Schützen oder Aufheben des Schutzes für den Wert dieser sicheren Zeichenfolge ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
  </Members>
</Type>