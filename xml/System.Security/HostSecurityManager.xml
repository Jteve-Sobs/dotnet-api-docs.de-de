<Type Name="HostSecurityManager" FullName="System.Security.HostSecurityManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2f5072944fea77b9ab7ac154830830e96acc250e" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73385378" /></Metadata><TypeSignature Language="C#" Value="public class HostSecurityManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit HostSecurityManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Security.HostSecurityManager" />
  <TypeSignature Language="VB.NET" Value="Public Class HostSecurityManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class HostSecurityManager" />
  <TypeSignature Language="F#" Value="type HostSecurityManager = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ermöglicht die Steuerung und die Anpassung des Sicherheitsverhaltens für Anwendungsdomänen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie einen neuen <xref:System.AppDomain>erstellen, fragt der Common Language Runtime den <xref:System.AppDomainManager> auf das vorhanden sein einer <xref:System.Security.HostSecurityManager>ab, die an Sicherheitsentscheidungen für den <xref:System.AppDomain>beteiligt ist.  Host Anbieter sollten einen Host Sicherheits-Manager implementieren, der von der <xref:System.Security.HostSecurityManager>-Klasse erbt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine sehr einfache Implementierung eines <xref:System.Security.HostSecurityManager>.  
  
 [!code-csharp[System.Security.HostSecurityManager#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#1)]
 [!code-vb[System.Security.HostSecurityManager#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Diese Klasse kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">für vollständige Vertrauenswürdigkeit für Vererber. Diese Klasse kann von teilweise vertrauenswürdigem Code nicht geerbt werden.</permission>
    <block subset="none" type="overrides"><para>Einige Member einer <see cref="T:System.Security.HostSecurityManager" /> werden immer dann aufgerufen, wenn eine Assembly entweder implizit oder explizit geladen wird. Die Methoden <see cref="M:System.Security.HostSecurityManager.ProvideAssemblyEvidence(System.Reflection.Assembly,System.Security.Policy.Evidence)" /> und <see cref="M:System.Security.HostSecurityManager.ProvideAppDomainEvidence(System.Security.Policy.Evidence)" /> dürfen keine Assemblys laden, da dies dazu führt, dass die Member des <see cref="T:System.Security.HostSecurityManager" /> rekursiv aufgerufen werden. Um Zirkel Verweise zu vermeiden, sollten Sie neue Klassen Instanzen erstellen, die dazu führen können, dass Assemblys entweder implizit oder explizit im Konstruktor einer Klasse geladen werden, die von <see cref="T:System.Security.HostSecurityManager" />abgeleitet ist.</para></block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HostSecurityManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HostSecurityManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.HostSecurityManager" />-Klasse.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">für vollständige Vertrauenswürdigkeit für Vererber. Dieser Member kann nicht von teilweise vertrauenswürdigem Code geerbt werden.</permission>
        <block subset="none" type="overrides"><para>Erstellen Sie Instanzen von Klassen, die bewirken können, dass Assemblys in diesem Konstruktor explizit oder implizit geladen werden.  Der Get-Accessor für die <see cref="P:System.Security.HostSecurityManager.DomainPolicy" />-Eigenschaft und die <see cref="M:System.Security.HostSecurityManager.ProvideAssemblyEvidence(System.Reflection.Assembly,System.Security.Policy.Evidence)" />-und <see cref="M:System.Security.HostSecurityManager.ProvideAppDomainEvidence(System.Security.Policy.Evidence)" />-Methoden werden immer dann aufgerufen, wenn eine Assembly geladen wird und das anschließende Laden von Assemblys zirkuläre Verweise verursacht.</para></block>
      </Docs>
    </Member>
    <Member MemberName="DetermineApplicationTrust">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.ApplicationTrust DetermineApplicationTrust (System.Security.Policy.Evidence applicationEvidence, System.Security.Policy.Evidence activatorEvidence, System.Security.Policy.TrustManagerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.ApplicationTrust DetermineApplicationTrust(class System.Security.Policy.Evidence applicationEvidence, class System.Security.Policy.Evidence activatorEvidence, class System.Security.Policy.TrustManagerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.DetermineApplicationTrust(System.Security.Policy.Evidence,System.Security.Policy.Evidence,System.Security.Policy.TrustManagerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DetermineApplicationTrust (applicationEvidence As Evidence, activatorEvidence As Evidence, context As TrustManagerContext) As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::ApplicationTrust ^ DetermineApplicationTrust(System::Security::Policy::Evidence ^ applicationEvidence, System::Security::Policy::Evidence ^ activatorEvidence, System::Security::Policy::TrustManagerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member DetermineApplicationTrust : System.Security.Policy.Evidence * System.Security.Policy.Evidence * System.Security.Policy.TrustManagerContext -&gt; System.Security.Policy.ApplicationTrust&#xA;override this.DetermineApplicationTrust : System.Security.Policy.Evidence * System.Security.Policy.Evidence * System.Security.Policy.TrustManagerContext -&gt; System.Security.Policy.ApplicationTrust" Usage="hostSecurityManager.DetermineApplicationTrust (applicationEvidence, activatorEvidence, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="applicationEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="activatorEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="context" Type="System.Security.Policy.TrustManagerContext" />
      </Parameters>
      <Docs>
        <param name="applicationEvidence">Der Beweis für die zu aktivierende Anwendung.</param>
        <param name="activatorEvidence">Optional der Beweis für die aktivierende Anwendungsdomäne.</param>
        <param name="context">Der Vertrauenskontext.</param>
        <summary>Bestimmt, ob eine Anwendung ausgeführt werden soll.</summary>
        <returns>Ein Objekt, das Vertrauensinformationen zur Anwendung enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden. Die Basis Implementierung ruft den Anwendungs Sicherheits-Manager auf, um zu bestimmen, ob die Anwendung ausgeführt werden soll.  
  
 Die Basis Implementierung verwendet nicht den activatornachweis. Eine überschriebene Implementierung könnte jedoch mithilfe des activatorevidence den Sicherheitsnachweis der Anwendungsdomäne ermitteln, die versucht, die Anwendung zu aktivieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie die <xref:System.Security.HostSecurityManager.DetermineApplicationTrust%2A>-Methode für einen benutzerdefinierten Hostsicherheits-Manager überschreiben. Dieses Beispiel ist Teil eines größeren Beispiels, das für die <xref:System.Security.HostSecurityManager>-Klasse bereitgestellt wird.  
  
 [!code-csharp[System.Security.HostSecurityManager#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#3)]
 [!code-vb[System.Security.HostSecurityManager#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="applicationEvidence" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Im Anwendungsbeweis konnte kein <see cref="T:System.Runtime.Hosting.ActivationArguments" />-Objekt gefunden werden.  
  
- oder - 
Die <see cref="P:System.Runtime.Hosting.ActivationArguments.ActivationContext" />-Eigenschaft in den Aktivierungsargumenten ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Security.Policy.ApplicationTrust" />-Berechtigungssatz enthält nicht den vom <see cref="T:System.ActivationContext" /> angegebenen Mindestanforderungssatz.</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainPolicy">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.PolicyLevel DomainPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.PolicyLevel DomainPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Security.HostSecurityManager.DomainPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DomainPolicy As PolicyLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::PolicyLevel ^ DomainPolicy { System::Security::Policy::PolicyLevel ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainPolicy : System.Security.Policy.PolicyLevel" Usage="System.Security.HostSecurityManager.DomainPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete and will be removed in a future release of the .NET Framework. See https://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.PolicyLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse die Sicherheitsrichtlinie für die aktuelle Anwendungsdomäne ab.</summary>
        <value>Die Sicherheitsrichtlinie für die aktuelle Anwendungsdomäne. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft kann in einer abgeleiteten Klasse überschrieben werden. Die Basisimplementierung gibt immer `null` zurück.  
  
 Diese Eigenschaft wird zur <xref:System.AppDomain> Erstellungszeit aufgerufen. Es ermöglicht einem Host, eine Richtlinie für die aktuelle <xref:System.AppDomain>bereitzustellen.  Eine Richtlinien Ebene besteht aus den folgenden Elementen:  
  
-   Eine Reihe von Code Gruppen, die in einer Struktur mit einem einzelnen Stamm angeordnet sind.  
  
-   Ein Satz von benannten Berechtigungs Sätzen, auf die von den Code Gruppen verwiesen wird, um Berechtigungen anzugeben, die für Code erteilt werden sollen, der zur Codegruppe gehört.  
  
-   Eine Liste vollständig vertrauenswürdiger Assemblys.  
  
> [!IMPORTANT]
>  Wichtige Implementierungs Informationen finden Sie in den Hinweisen zu Vererbung für die <xref:System.Security.HostSecurityManager>-Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode verwendet eine Richtlinie für die Codezugriffssicherheit (Code Access Security, CAS), die im [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] veraltet ist. Um die CAS-Richtlinie für Kompatibilität mit früheren Versionen von .NET Framework zu aktivieren, verwenden Sie das [&lt;legacyCasPolicy&gt;-Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="Flags">
      <MemberSignature Language="C#" Value="public virtual System.Security.HostSecurityManagerOptions Flags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.HostSecurityManagerOptions Flags" />
      <MemberSignature Language="DocId" Value="P:System.Security.HostSecurityManager.Flags" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Flags As HostSecurityManagerOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::HostSecurityManagerOptions Flags { System::Security::HostSecurityManagerOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.Flags : System.Security.HostSecurityManagerOptions" Usage="System.Security.HostSecurityManager.Flags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.HostSecurityManagerOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Flag ab, das die den Host betreffenden Komponenten für Sicherheitsrichtlinien darstellt.</summary>
        <value>Einer der Enumerationswerte, der die Komponenten der Sicherheitsrichtlinie angibt. Die Standardeinstellung ist <see cref="F:System.Security.HostSecurityManagerOptions.AllFlags" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft kann in einer abgeleiteten Klasse überschrieben werden. Die Basisimplementierung gibt immer <xref:System.Security.HostSecurityManagerOptions.AllFlags> zurück.  
  
 Der abgeleitete Host kann den Wert dieser Eigenschaft ändern, wenn nur eine Teilmenge der <xref:System.Security.HostSecurityManagerOptions> von Interesse ist.  Die möglichen Teilmengen enthalten None, den abgelehnten Satz, die Richtlinien Ebene und den Assemblybeweis.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie die <xref:System.Security.HostSecurityManager.Flags%2A>-Eigenschaft für einen benutzerdefinierten Hostsicherheits-Manager überschreiben. Dieses Beispiel ist Teil eines größeren Beispiels, das für die <xref:System.Security.HostSecurityManager>-Klasse bereitgestellt wird.  
  
 [!code-csharp[System.Security.HostSecurityManager#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#2)]
 [!code-vb[System.Security.HostSecurityManager#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateAppDomainEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.EvidenceBase GenerateAppDomainEvidence (Type evidenceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.EvidenceBase GenerateAppDomainEvidence(class System.Type evidenceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GenerateAppDomainEvidence(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GenerateAppDomainEvidence (evidenceType As Type) As EvidenceBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::EvidenceBase ^ GenerateAppDomainEvidence(Type ^ evidenceType);" />
      <MemberSignature Language="F#" Value="abstract member GenerateAppDomainEvidence : Type -&gt; System.Security.Policy.EvidenceBase&#xA;override this.GenerateAppDomainEvidence : Type -&gt; System.Security.Policy.EvidenceBase" Usage="hostSecurityManager.GenerateAppDomainEvidence evidenceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.EvidenceBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidenceType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="evidenceType">Der Beweistyp.</param>
        <summary>Fordert einen bestimmten Beweistyp für die Anwendungsdomäne an.</summary>
        <returns>Der angeforderte Anwendungsdomänenbeweis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden. Die Basis Implementierung gibt `null`zurück.  
  
 Der Common Language Runtime ruft diese Methode auf, wenn der Beweis des angegebenen Typs für die aktuelle <xref:System.AppDomain>benötigt wird. Der zurückgegebene Wert wird als vom Host bereitgestellter Beweis verwendet und in der <xref:System.AppDomain.Evidence%2A>-Auflistung der <xref:System.AppDomain.CurrentDomain%2A>-Eigenschaft gespeichert. Sie können die <xref:System.Security.Policy.Evidence.GetAssemblyEvidence%2A?displayProperty=nameWithType>-Methode verwenden, um den generierten Beweis aus der Auflistung abzurufen.  
  
 Um einen Rückruf für diese Methode zu erhalten, müssen Hosts das <xref:System.Security.HostSecurityManagerOptions.HostAppDomainEvidence>-Flag in der <xref:System.Security.HostSecurityManager.Flags%2A>-Eigenschaft angeben.  
  
 Mit dieser Methode zum Generieren von beweisen können Hosts die Beweis Generierung für eine <xref:System.AppDomain> verzögern, bis der Beweis benötigt wird. In der .NET Framework Version 3,5 und früheren Versionen war es erforderlich, <xref:System.AppDomain> Beweise zur Ladezeit bereitzustellen, indem die <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A>-Methode überschrieben wurde. Es wird empfohlen, <xref:System.Security.HostSecurityManager.GenerateAppDomainEvidence%2A> zur Bereitstellung von beweisen zu verwenden, anstatt <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A>zu überschreiben.  
  
 Die <xref:System.Security.HostSecurityManager.GenerateAppDomainEvidence%2A>-Methode wird nur für die Typen von beweisen aufgerufen, die der Host in der Überschreibung der <xref:System.Security.HostSecurityManager.GetHostSuppliedAppDomainEvidenceTypes%2A>-Methode angegeben hat.  
  
 Der Rückgabewert `null` gibt an, dass der Host keinen Beweis dieses bestimmten Typs generieren kann.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie die <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A>-Methode für einen benutzerdefinierten Hostsicherheits-Manager überschreiben. Dieses Beispiel ist Teil eines größeren Beispiels, das für die <xref:System.Security.HostSecurityManager>-Klasse bereitgestellt wird.  
  
 [!code-csharp[System.Security.HostSecurityManager#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#6)]
 [!code-vb[System.Security.HostSecurityManager#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateAssemblyEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.EvidenceBase GenerateAssemblyEvidence (Type evidenceType, System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.EvidenceBase GenerateAssemblyEvidence(class System.Type evidenceType, class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GenerateAssemblyEvidence(System.Type,System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::EvidenceBase ^ GenerateAssemblyEvidence(Type ^ evidenceType, System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="abstract member GenerateAssemblyEvidence : Type * System.Reflection.Assembly -&gt; System.Security.Policy.EvidenceBase&#xA;override this.GenerateAssemblyEvidence : Type * System.Reflection.Assembly -&gt; System.Security.Policy.EvidenceBase" Usage="hostSecurityManager.GenerateAssemblyEvidence (evidenceType, assembly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.EvidenceBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidenceType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="evidenceType">Der Beweistyp.</param>
        <param name="assembly">Die Zielassembly.</param>
        <summary>Fordert einen bestimmten Beweistyp für die Assembly an.</summary>
        <returns>Der angeforderte Assemblybeweis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden. Die Basis Implementierung gibt `null`zurück.  
  
 Der Common Language Runtime ruft diese Methode auf, wenn der Beweis des angegebenen Typs für die aktuelle Assembly benötigt wird. Der zurückgegebene Wert wird als vom Host bereitgestellter Beweis verwendet und in der <xref:System.Reflection.Assembly.Evidence%2A>-Eigenschaft gespeichert. Sie können die <xref:System.Security.Policy.Evidence.GetAssemblyEvidence%2A?displayProperty=nameWithType>-Methode verwenden, um den generierten Beweis von der <xref:System.Reflection.Assembly.Evidence%2A>-Eigenschaft abzurufen.  
  
 Um einen Rückruf für diese Methode zu erhalten, müssen Hosts das <xref:System.Security.HostSecurityManagerOptions.HostAssemblyEvidence>-Flag in der <xref:System.Security.HostSecurityManager.Flags%2A>-Eigenschaft angeben.  
  
 Mit dieser Methode zum Generieren von beweisen können Hosts die Beweis Generierung für eine <xref:System.AppDomain> verzögern, bis der Beweis benötigt wird. In den .NET Framework 3,5 und früheren Versionen war es erforderlich, <xref:System.AppDomain> Beweise zur Ladezeit bereitzustellen, indem die <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A>-Methode überschrieben wurde. Es wird empfohlen, <xref:System.Security.HostSecurityManager.GenerateAssemblyEvidence%2A> zur Bereitstellung von beweisen zu verwenden, anstatt <xref:System.Security.HostSecurityManager.ProvideAssemblyEvidence%2A>zu überschreiben.  
  
 Die <xref:System.Security.HostSecurityManager.GenerateAssemblyEvidence%2A>-Methode wird nur für die Typen von beweisen aufgerufen, die der Host in der Überschreibung der <xref:System.Security.HostSecurityManager.GetHostSuppliedAssemblyEvidenceTypes%2A>-Methode angegeben hat.  
  
 Der Rückgabewert `null` gibt an, dass der Host keinen Beweis dieses bestimmten Typs generieren kann.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHostSuppliedAppDomainEvidenceTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetHostSuppliedAppDomainEvidenceTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetHostSuppliedAppDomainEvidenceTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GetHostSuppliedAppDomainEvidenceTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHostSuppliedAppDomainEvidenceTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetHostSuppliedAppDomainEvidenceTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetHostSuppliedAppDomainEvidenceTypes : unit -&gt; Type[]&#xA;override this.GetHostSuppliedAppDomainEvidenceTypes : unit -&gt; Type[]" Usage="hostSecurityManager.GetHostSuppliedAppDomainEvidenceTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bestimmt, welchen Beweistyp der Host für die Anwendungsdomäne bereitstellen kann, wenn dies angefordert wird.</summary>
        <returns>Ein Array mit Beweistypen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden. Die Basis Implementierung gibt `null`zurück.  
  
 Die von dieser Methode zurückgegebenen Typen bestimmen, ob die <xref:System.Security.HostSecurityManager.GenerateAppDomainEvidence%2A>-Methode wieder in aufgerufen wird. Wenn ein Typ in dieser Liste vorhanden ist, bedeutet dies nicht, dass der Host in der Lage sein muss, diesen Beweis zu generieren, aber dies ist möglicherweise möglich. Aus diesem Grund empfiehlt es sich, die Typen in dieser Liste zu überschreiten, anstatt Sie unter anzugeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHostSuppliedAssemblyEvidenceTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetHostSuppliedAssemblyEvidenceTypes (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetHostSuppliedAssemblyEvidenceTypes(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GetHostSuppliedAssemblyEvidenceTypes(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetHostSuppliedAssemblyEvidenceTypes(System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="abstract member GetHostSuppliedAssemblyEvidenceTypes : System.Reflection.Assembly -&gt; Type[]&#xA;override this.GetHostSuppliedAssemblyEvidenceTypes : System.Reflection.Assembly -&gt; Type[]" Usage="hostSecurityManager.GetHostSuppliedAssemblyEvidenceTypes assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="assembly">Die Zielassembly.</param>
        <summary>Bestimmt, welche Beweistypen der Host für die Assembly bereitstellen kann, wenn dies angefordert wird.</summary>
        <returns>Ein Array mit Beweistypen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden. Die Basis Implementierung gibt `null`zurück.  
  
 Die von dieser Methode zurückgegebenen Typen bestimmen, ob die <xref:System.Security.HostSecurityManager.GenerateAssemblyEvidence%2A>-Methode wieder in aufgerufen wird. Wenn ein Typ in dieser Liste vorhanden ist, bedeutet dies nicht, dass der Host in der Lage sein muss, diesen Beweis zu generieren, aber dies ist möglicherweise möglich. Aus diesem Grund empfiehlt es sich, die Typen in dieser Liste zu überschreiten, anstatt Sie unter anzugeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProvideAppDomainEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence ProvideAppDomainEvidence (System.Security.Policy.Evidence inputEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.Evidence ProvideAppDomainEvidence(class System.Security.Policy.Evidence inputEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.ProvideAppDomainEvidence(System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ProvideAppDomainEvidence (inputEvidence As Evidence) As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::Evidence ^ ProvideAppDomainEvidence(System::Security::Policy::Evidence ^ inputEvidence);" />
      <MemberSignature Language="F#" Value="abstract member ProvideAppDomainEvidence : System.Security.Policy.Evidence -&gt; System.Security.Policy.Evidence&#xA;override this.ProvideAppDomainEvidence : System.Security.Policy.Evidence -&gt; System.Security.Policy.Evidence" Usage="hostSecurityManager.ProvideAppDomainEvidence inputEvidence" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="inputEvidence">Zusätzlicher Beweis, der dem <see cref="T:System.AppDomain" />-Beweis hinzugefügt werden soll.</param>
        <summary>Stellt den Anwendungsdomänenbeweis für eine Assembly bereit, die derzeit geladen wird.</summary>
        <returns>Der Beweis, der für die <see cref="T:System.AppDomain" /> verwendet werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann in einer abgeleiteten Klasse überschrieben werden.  
  
 Diese Methode wird immer dann aufgerufen, wenn ein <xref:System.AppDomain> Objekt erstellt wird. Der `inputEvidence`-Parameter ist der berechnete Beweis aus dem Common Language Runtime. Die Host Implementierung kann den Beweis erweitern oder reduzieren. Der Rückgabewert ist der Beweis, der für die Anwendungsdomäne verwendet werden soll.  Die Basis Implementierung gibt immer das Beweis Objekt zurück, das als `inputEvidence`-Parameter übergeben wird.  
  
> [!IMPORTANT]
>  Wichtige Implementierungs Informationen finden Sie in den Hinweisen zu Vererbung für die <xref:System.Security.HostSecurityManager>-Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProvideAssemblyEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence ProvideAssemblyEvidence (System.Reflection.Assembly loadedAssembly, System.Security.Policy.Evidence inputEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.Evidence ProvideAssemblyEvidence(class System.Reflection.Assembly loadedAssembly, class System.Security.Policy.Evidence inputEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.ProvideAssemblyEvidence(System.Reflection.Assembly,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ProvideAssemblyEvidence (loadedAssembly As Assembly, inputEvidence As Evidence) As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::Evidence ^ ProvideAssemblyEvidence(System::Reflection::Assembly ^ loadedAssembly, System::Security::Policy::Evidence ^ inputEvidence);" />
      <MemberSignature Language="F#" Value="abstract member ProvideAssemblyEvidence : System.Reflection.Assembly * System.Security.Policy.Evidence -&gt; System.Security.Policy.Evidence&#xA;override this.ProvideAssemblyEvidence : System.Reflection.Assembly * System.Security.Policy.Evidence -&gt; System.Security.Policy.Evidence" Usage="hostSecurityManager.ProvideAssemblyEvidence (loadedAssembly, inputEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loadedAssembly" Type="System.Reflection.Assembly" />
        <Parameter Name="inputEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="loadedAssembly">Die geladene Assembly.</param>
        <param name="inputEvidence">Zusätzlicher Beweis, der dem Assemblybeweis hinzugefügt werden soll.</param>
        <summary>Stellt den Assemblybeweis für eine Assembly bereit, die derzeit geladen wird.</summary>
        <returns>Der Beweis, der für die Assembly verwendet werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann in einer abgeleiteten Klasse überschrieben werden.  
  
 Diese Methode wird immer dann aufgerufen, wenn eine Assembly entweder implizit oder explizit geladen wird. Die über gebenden Parameter sind die Assembly, die geladen wird, und der berechnete Beweis aus der Common Language Runtime. Die Host Implementierung kann den Beweis erweitern oder reduzieren. Der Rückgabewert ist der Beweis, der für die Assembly verwendet werden soll.  Die Basis Implementierung gibt immer das Beweis Objekt zurück, das als `inputEvidence`-Parameter übergeben wird.  
  
> [!IMPORTANT]
>  Wichtige Implementierungs Informationen finden Sie in den Hinweisen zu Vererbung für die <xref:System.Security.HostSecurityManager>-Klasse.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie die <xref:System.Security.HostSecurityManager.ProvideAssemblyEvidence%2A>-Methode für einen benutzerdefinierten Hostsicherheits-Manager überschreiben. Dieses Beispiel ist Teil eines größeren Beispiels, das für die <xref:System.Security.HostSecurityManager>-Klasse bereitgestellt wird.  
  
 [!code-csharp[System.Security.HostSecurityManager#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#5)]
 [!code-vb[System.Security.HostSecurityManager#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolvePolicy">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.PermissionSet ResolvePolicy(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.ResolvePolicy(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::PermissionSet ^ ResolvePolicy(System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member ResolvePolicy : System.Security.Policy.Evidence -&gt; System.Security.PermissionSet&#xA;override this.ResolvePolicy : System.Security.Policy.Evidence -&gt; System.Security.PermissionSet" Usage="hostSecurityManager.ResolvePolicy evidence" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">Der Beweissatz, der zum Auswerten der Richtlinie verwendet wird.</param>
        <summary>Bestimmt, welche Berechtigungen Code auf Basis der angegebenen Beweise gewährt werden.</summary>
        <returns>Der Berechtigungssatz, der vom Sicherheitssystem erteilt werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft die Sicherheitsrichtlinien-Engine auf und stellt ihr den angegebenen Beweis bereit. Das Ergebnis wird durch die Sicherheitsrichtlinie bestimmt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="evidence" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
