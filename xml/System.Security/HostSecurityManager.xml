<Type Name="HostSecurityManager" FullName="System.Security.HostSecurityManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="552db181ba304ec8c296f0663128a32b4d42a5a4" />
    <Meta Name="ms.sourcegitcommit" Value="c0c07dbd19cd7017243f9ac36915755f79bc8da6" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/27/2018" />
    <Meta Name="ms.locfileid" Value="52381636" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HostSecurityManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit HostSecurityManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Security.HostSecurityManager" />
  <TypeSignature Language="VB.NET" Value="Public Class HostSecurityManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class HostSecurityManager" />
  <TypeSignature Language="F#" Value="type HostSecurityManager = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ermöglicht die Steuerung und die Anpassung des Sicherheitsverhaltens für Anwendungsdomänen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Erstellen einer neuen <xref:System.AppDomain>, die common Language Runtime-Abfragen die <xref:System.AppDomainManager> das Vorhandensein einer <xref:System.Security.HostSecurityManager>, jedes an den Entscheidungen der Sicherheit für die <xref:System.AppDomain>.  Hosten von Anbietern sollten implementieren einen Hostsicherheits-Manager, die von erbt die <xref:System.Security.HostSecurityManager> Klasse.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine einfache Implementierung einer <xref:System.Security.HostSecurityManager>.  
  
 [!code-csharp[System.Security.HostSecurityManager#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#1)]
 [!code-vb[System.Security.HostSecurityManager#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Diese Klasse kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">für volle Vertrauenswürdigkeit für erben. Diese Klasse kann nicht von teilweise vertrauenswürdigem Code nicht geerbt werden.</permission>
    <block subset="none" type="overrides">
      <para>Einige Mitglieder einer <see cref="T:System.Security.HostSecurityManager" /> werden aufgerufen, wenn eine Assembly entweder implizit oder explizit geladen wird. Die <see cref="M:System.Security.HostSecurityManager.ProvideAssemblyEvidence(System.Reflection.Assembly,System.Security.Policy.Evidence)" /> und <see cref="M:System.Security.HostSecurityManager.ProvideAppDomainEvidence(System.Security.Policy.Evidence)" /> Methoden müssen keine Assemblys laden, da auf diese Weise den Membern der führt der <see cref="T:System.Security.HostSecurityManager" /> rekursiv aufgerufen wird. Um Zirkelverweise zu vermeiden, erstellen Sie neue Instanzen von Klassen, die dazu führen, Assemblys geladen dass können, entweder implizit oder explizit im Konstruktor einer Klasse werden, die von abgeleitet <see cref="T:System.Security.HostSecurityManager" />.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HostSecurityManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HostSecurityManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.HostSecurityManager" />-Klasse.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">für volle Vertrauenswürdigkeit für erben. Dieser Member kann nicht von teilweise vertrauenswürdigem Code nicht vererbt werden.</permission>
        <block subset="none" type="overrides">
          <para>Erstellen Sie Instanzen von Klassen, die Assemblys, die entweder explizit oder implizit geladen werden, die in diesem Konstruktor verursachen können.  Der Get-Accessor für die <see cref="P:System.Security.HostSecurityManager.DomainPolicy" /> Eigenschaft und die <see cref="M:System.Security.HostSecurityManager.ProvideAssemblyEvidence(System.Reflection.Assembly,System.Security.Policy.Evidence)" /> und <see cref="M:System.Security.HostSecurityManager.ProvideAppDomainEvidence(System.Security.Policy.Evidence)" /> Methoden werden aufgerufen, wenn eine Assembly geladen wird, und deren nachfolgende Laden von Assemblys dazu, Zirkuläre Verweise dass führt.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DetermineApplicationTrust">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.ApplicationTrust DetermineApplicationTrust (System.Security.Policy.Evidence applicationEvidence, System.Security.Policy.Evidence activatorEvidence, System.Security.Policy.TrustManagerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.ApplicationTrust DetermineApplicationTrust(class System.Security.Policy.Evidence applicationEvidence, class System.Security.Policy.Evidence activatorEvidence, class System.Security.Policy.TrustManagerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.DetermineApplicationTrust(System.Security.Policy.Evidence,System.Security.Policy.Evidence,System.Security.Policy.TrustManagerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DetermineApplicationTrust (applicationEvidence As Evidence, activatorEvidence As Evidence, context As TrustManagerContext) As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::ApplicationTrust ^ DetermineApplicationTrust(System::Security::Policy::Evidence ^ applicationEvidence, System::Security::Policy::Evidence ^ activatorEvidence, System::Security::Policy::TrustManagerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member DetermineApplicationTrust : System.Security.Policy.Evidence * System.Security.Policy.Evidence * System.Security.Policy.TrustManagerContext -&gt; System.Security.Policy.ApplicationTrust&#xA;override this.DetermineApplicationTrust : System.Security.Policy.Evidence * System.Security.Policy.Evidence * System.Security.Policy.TrustManagerContext -&gt; System.Security.Policy.ApplicationTrust" Usage="hostSecurityManager.DetermineApplicationTrust (applicationEvidence, activatorEvidence, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="applicationEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="activatorEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="context" Type="System.Security.Policy.TrustManagerContext" />
      </Parameters>
      <Docs>
        <param name="applicationEvidence">Der Beweis für die zu aktivierende Anwendung.</param>
        <param name="activatorEvidence">Optional der Beweis für die aktivierende Anwendungsdomäne.</param>
        <param name="context">Der Vertrauenskontext.</param>
        <summary>Bestimmt, ob eine Anwendung ausgeführt werden soll.</summary>
        <returns>Ein Objekt, das Vertrauensinformationen zur Anwendung enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden. Die grundlegende Implementierung ruft den Anwendungsmanager Sicherheit, um festzustellen, ob die Anwendung ausgeführt werden soll.  
  
 Die basisimplementierung verwendet nicht den Aktivator-Beweisen. Allerdings kann eine überschriebene Implementierung den Aktivator-Beweisen verwenden, um zu bestimmen, den Sicherheitsbeweis für die Anwendungsdomäne, es wird versucht, die die Anwendung zu aktivieren.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Überschreiben der <xref:System.Security.HostSecurityManager.DetermineApplicationTrust%2A> -Methode für einen benutzerdefinierten Host-Sicherheits-Manager. In diesem Beispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Security.HostSecurityManager> Klasse.  
  
 [!code-csharp[System.Security.HostSecurityManager#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#3)]
 [!code-vb[System.Security.HostSecurityManager#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="applicationEvidence" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Im Anwendungsbeweis konnte kein <see cref="T:System.Runtime.Hosting.ActivationArguments" />-Objekt gefunden werden.  
  
- oder -  
Die <see cref="P:System.Runtime.Hosting.ActivationArguments.ActivationContext" />-Eigenschaft in den Aktivierungsargumenten ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Security.Policy.ApplicationTrust" />-Berechtigungssatz enthält nicht den vom <see cref="T:System.ActivationContext" /> angegebenen Mindestanforderungssatz.</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainPolicy">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.PolicyLevel DomainPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.PolicyLevel DomainPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Security.HostSecurityManager.DomainPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DomainPolicy As PolicyLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::PolicyLevel ^ DomainPolicy { System::Security::Policy::PolicyLevel ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainPolicy : System.Security.Policy.PolicyLevel" Usage="System.Security.HostSecurityManager.DomainPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.PolicyLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse die Sicherheitsrichtlinie für die aktuelle Anwendungsdomäne ab.</summary>
        <value>Die Sicherheitsrichtlinie für die aktuelle Anwendungsdomäne. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft kann in einer abgeleiteten Klasse überschrieben werden. Die Basisimplementierung gibt immer `null` zurück.  
  
 Diese Eigenschaft wird aufgerufen, an <xref:System.AppDomain> Zeitpunkt der Erstellung. Es kann ein Host Geben Sie eine Richtlinie für die aktuelle <xref:System.AppDomain>.  Eine Ebene der Richtlinie besteht aus den folgenden:  
  
-   Eine Reihe von Codegruppen, die in einer einzelnen Stammstruktur organisiert werden.  
  
-   Ein Satz von benannten Berechtigungssätzen, die durch die Codegruppen an Berechtigungen zur Codegruppe gehörenden Codegruppe verwiesen wird.  
  
-   Eine Liste der vollständig vertrauenswürdigen Assemblys.  
  
> [!IMPORTANT]
>  Siehe die Hinweise für Vererber für die <xref:System.Security.HostSecurityManager> -Klasse für wichtige Implementierungsinformationen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode verwendet eine Richtlinie für die Codezugriffssicherheit (Code Access Security, CAS), die im [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] veraltet ist. Um die CAS-Richtlinie für Kompatibilität mit früheren Versionen von .NET Framework zu aktivieren, verwenden Sie das [&lt;legacyCasPolicy&gt;-Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="Flags">
      <MemberSignature Language="C#" Value="public virtual System.Security.HostSecurityManagerOptions Flags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.HostSecurityManagerOptions Flags" />
      <MemberSignature Language="DocId" Value="P:System.Security.HostSecurityManager.Flags" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Flags As HostSecurityManagerOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::HostSecurityManagerOptions Flags { System::Security::HostSecurityManagerOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.Flags : System.Security.HostSecurityManagerOptions" Usage="System.Security.HostSecurityManager.Flags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.HostSecurityManagerOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Flag ab, das die den Host betreffenden Komponenten für Sicherheitsrichtlinien darstellt.</summary>
        <value>Einer der Enumerationswerte, der die Komponenten der Sicherheitsrichtlinie angibt. Der Standardwert ist <see cref="F:System.Security.HostSecurityManagerOptions.AllFlags" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft kann in einer abgeleiteten Klasse überschrieben werden. Die Basisimplementierung gibt immer <xref:System.Security.HostSecurityManagerOptions.AllFlags> zurück.  
  
 Der abgeleitete Host kann den Wert dieser Eigenschaft, wenn nur eine Teilmenge der Ändern der <xref:System.Security.HostSecurityManagerOptions> relevant ist.  Die möglichen Teilmengen sind none, der verweigerte Berechtigungssatz, der Richtlinienebene und Assemblybeweis.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Überschreiben der <xref:System.Security.HostSecurityManager.Flags%2A> -Eigenschaft für einen benutzerdefinierten Host-Sicherheits-Manager. In diesem Beispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Security.HostSecurityManager> Klasse.  
  
 [!code-csharp[System.Security.HostSecurityManager#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#2)]
 [!code-vb[System.Security.HostSecurityManager#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateAppDomainEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.EvidenceBase GenerateAppDomainEvidence (Type evidenceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.EvidenceBase GenerateAppDomainEvidence(class System.Type evidenceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GenerateAppDomainEvidence(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GenerateAppDomainEvidence (evidenceType As Type) As EvidenceBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::EvidenceBase ^ GenerateAppDomainEvidence(Type ^ evidenceType);" />
      <MemberSignature Language="F#" Value="abstract member GenerateAppDomainEvidence : Type -&gt; System.Security.Policy.EvidenceBase&#xA;override this.GenerateAppDomainEvidence : Type -&gt; System.Security.Policy.EvidenceBase" Usage="hostSecurityManager.GenerateAppDomainEvidence evidenceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.EvidenceBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidenceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="evidenceType">Der Beweistyp.</param>
        <summary>Fordert einen bestimmten Beweistyp für die Anwendungsdomäne an.</summary>
        <returns>Der angeforderte Anwendungsdomänenbeweis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden. Gibt die basisimplementierung `null`.  
  
 Die common Language Runtime ruft diese Methode auf, wenn Beweis vom angegebenen Typ, für die aktuelle benötigt wird <xref:System.AppDomain>. Der zurückgegebene Wert dient als Host bereitgestellten Beweise und befindet sich in der <xref:System.AppDomain.Evidence%2A> Auflistung von der <xref:System.AppDomain.CurrentDomain%2A> Eigenschaft. Sie können die <xref:System.Security.Policy.Evidence.GetAssemblyEvidence%2A?displayProperty=nameWithType> Methode, um den generierten Beweis aus der Auflistung abzurufen.  
  
 Um einen Rückruf, der diese Methode zu erhalten, müssen die Hosts angeben den <xref:System.Security.HostSecurityManagerOptions.HostAppDomainEvidence> -flag in der <xref:System.Security.HostSecurityManager.Flags%2A> Eigenschaft.  
  
 Diese Methode zum Generieren von Beweise ermöglicht Hosts das Verzögern der Generierung von Beweisen für eine <xref:System.AppDomain> bis der Beweis benötigt wird. In der .NET Framework, Version 3.5 und früheren Versionen war es erforderlich, geben Sie <xref:System.AppDomain> Beweise zur Ladezeit durch Überschreiben der <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A> Methode. Wir empfehlen die Verwendung <xref:System.Security.HostSecurityManager.GenerateAppDomainEvidence%2A> zum Bereitstellen von Beweisen anstelle von <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A>.  
  
 Die <xref:System.Security.HostSecurityManager.GenerateAppDomainEvidence%2A> Methode zurückgerufen nur für Typen von Beweisen, die der Host, überschreiben angegeben hat die <xref:System.Security.HostSecurityManager.GetHostSuppliedAppDomainEvidenceTypes%2A> Methode.  
  
 Der Rückgabewert `null` gibt an, dass der Host keinen Beweis dieses bestimmten Typs generieren kann.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Überschreiben der <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A> -Methode für einen benutzerdefinierten Host-Sicherheits-Manager. In diesem Beispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Security.HostSecurityManager> Klasse.  
  
 [!code-csharp[System.Security.HostSecurityManager#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#6)]
 [!code-vb[System.Security.HostSecurityManager#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateAssemblyEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.EvidenceBase GenerateAssemblyEvidence (Type evidenceType, System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.EvidenceBase GenerateAssemblyEvidence(class System.Type evidenceType, class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GenerateAssemblyEvidence(System.Type,System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::EvidenceBase ^ GenerateAssemblyEvidence(Type ^ evidenceType, System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="abstract member GenerateAssemblyEvidence : Type * System.Reflection.Assembly -&gt; System.Security.Policy.EvidenceBase&#xA;override this.GenerateAssemblyEvidence : Type * System.Reflection.Assembly -&gt; System.Security.Policy.EvidenceBase" Usage="hostSecurityManager.GenerateAssemblyEvidence (evidenceType, assembly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.EvidenceBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidenceType" Type="System.Type" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="evidenceType">Der Beweistyp.</param>
        <param name="assembly">Die Zielassembly.</param>
        <summary>Fordert einen bestimmten Beweistyp für die Assembly an.</summary>
        <returns>Der angeforderte Assemblybeweis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden. Gibt die basisimplementierung `null`.  
  
 Die common Language Runtime ruft diese Methode auf, wenn Beweise, des angegebenen Typs für die aktuelle Assembly benötigt wird. Der zurückgegebene Wert dient als Host bereitgestellten Beweise und befindet sich in der <xref:System.Reflection.Assembly.Evidence%2A> Eigenschaft. Sie können die <xref:System.Security.Policy.Evidence.GetAssemblyEvidence%2A?displayProperty=nameWithType> Methode zum Abrufen des generierte Beweis, aus der <xref:System.Reflection.Assembly.Evidence%2A> Eigenschaft.  
  
 Um einen Rückruf, der diese Methode zu erhalten, müssen die Hosts angeben den <xref:System.Security.HostSecurityManagerOptions.HostAssemblyEvidence> -flag in der <xref:System.Security.HostSecurityManager.Flags%2A> Eigenschaft.  
  
 Diese Methode zum Generieren von Beweise ermöglicht Hosts das Verzögern der Generierung von Beweisen für eine <xref:System.AppDomain> bis der Beweis benötigt wird. In der .NET Framework 3.5 und früher, war es erforderlich, geben Sie <xref:System.AppDomain> Beweise zur Ladezeit durch Überschreiben der <xref:System.Security.HostSecurityManager.ProvideAppDomainEvidence%2A> Methode. Wir empfehlen die Verwendung <xref:System.Security.HostSecurityManager.GenerateAssemblyEvidence%2A> zum Bereitstellen von Beweisen anstelle von <xref:System.Security.HostSecurityManager.ProvideAssemblyEvidence%2A>.  
  
 Die <xref:System.Security.HostSecurityManager.GenerateAssemblyEvidence%2A> Methode zurückgerufen nur für Typen von Beweisen, die der Host, überschreiben angegeben hat die <xref:System.Security.HostSecurityManager.GetHostSuppliedAssemblyEvidenceTypes%2A> Methode.  
  
 Der Rückgabewert `null` gibt an, dass der Host keinen Beweis dieses bestimmten Typs generieren kann.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHostSuppliedAppDomainEvidenceTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetHostSuppliedAppDomainEvidenceTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetHostSuppliedAppDomainEvidenceTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GetHostSuppliedAppDomainEvidenceTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHostSuppliedAppDomainEvidenceTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetHostSuppliedAppDomainEvidenceTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetHostSuppliedAppDomainEvidenceTypes : unit -&gt; Type[]&#xA;override this.GetHostSuppliedAppDomainEvidenceTypes : unit -&gt; Type[]" Usage="hostSecurityManager.GetHostSuppliedAppDomainEvidenceTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bestimmt, welchen Beweistyp der Host für die Anwendungsdomäne bereitstellen kann, wenn dies angefordert wird.</summary>
        <returns>Ein Array mit Beweistypen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden. Gibt die basisimplementierung `null`.  
  
 Die Typen, die von dieser Methode zurückgegebene zu bestimmen, ob die <xref:System.Security.HostSecurityManager.GenerateAppDomainEvidence%2A> Methode zurückgerufen. Das Vorhandensein eines Typs in dieser Liste bedeutet, dass der Host zum Generieren dieser Beweistyp werden muss, aber es möglicherweise nicht auf. Aus diesem Grund empfiehlt es sich um übermäßige angeben, anstatt Sie zu unter-Angeben der Typen in dieser Liste.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHostSuppliedAssemblyEvidenceTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetHostSuppliedAssemblyEvidenceTypes (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetHostSuppliedAssemblyEvidenceTypes(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.GetHostSuppliedAssemblyEvidenceTypes(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetHostSuppliedAssemblyEvidenceTypes(System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="abstract member GetHostSuppliedAssemblyEvidenceTypes : System.Reflection.Assembly -&gt; Type[]&#xA;override this.GetHostSuppliedAssemblyEvidenceTypes : System.Reflection.Assembly -&gt; Type[]" Usage="hostSecurityManager.GetHostSuppliedAssemblyEvidenceTypes assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly">Die Zielassembly.</param>
        <summary>Bestimmt, welche Beweistypen der Host für die Assembly bereitstellen kann, wenn dies angefordert wird.</summary>
        <returns>Ein Array mit Beweistypen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden. Gibt die basisimplementierung `null`.  
  
 Die Typen, die von dieser Methode zurückgegebene zu bestimmen, ob die <xref:System.Security.HostSecurityManager.GenerateAssemblyEvidence%2A> Methode zurückgerufen. Das Vorhandensein eines Typs in dieser Liste bedeutet, dass der Host zum Generieren dieser Beweistyp werden muss, aber es möglicherweise nicht auf. Aus diesem Grund empfiehlt es sich um übermäßige angeben, anstatt Sie zu unter-Angeben der Typen in dieser Liste.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProvideAppDomainEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence ProvideAppDomainEvidence (System.Security.Policy.Evidence inputEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.Evidence ProvideAppDomainEvidence(class System.Security.Policy.Evidence inputEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.ProvideAppDomainEvidence(System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ProvideAppDomainEvidence (inputEvidence As Evidence) As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::Evidence ^ ProvideAppDomainEvidence(System::Security::Policy::Evidence ^ inputEvidence);" />
      <MemberSignature Language="F#" Value="abstract member ProvideAppDomainEvidence : System.Security.Policy.Evidence -&gt; System.Security.Policy.Evidence&#xA;override this.ProvideAppDomainEvidence : System.Security.Policy.Evidence -&gt; System.Security.Policy.Evidence" Usage="hostSecurityManager.ProvideAppDomainEvidence inputEvidence" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="inputEvidence">Zusätzlicher Beweis, der dem <see cref="T:System.AppDomain" />-Beweis hinzugefügt werden soll.</param>
        <summary>Stellt den Anwendungsdomänenbeweis für eine Assembly bereit, die derzeit geladen wird.</summary>
        <returns>Der Beweis, der für die <see cref="T:System.AppDomain" /> verwendet werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann in einer abgeleiteten Klasse überschrieben werden.  
  
 Diese Methode wird aufgerufen, wenn ein <xref:System.AppDomain> Objekt erstellt wird. Die `inputEvidence` -Parameter ist der berechnete Beweis aus der common Language Runtime. Die hostimplementierung können erweitern oder reduzieren Sie die Beweise. Der Rückgabewert ist der Beweis für die Anwendungsdomäne verwendet werden.  Die grundlegende Implementierung gibt immer Beweisobjekts als übergeben die `inputEvidence` Parameter.  
  
> [!IMPORTANT]
>  Siehe die Hinweise für Vererber für die <xref:System.Security.HostSecurityManager> -Klasse für wichtige Implementierungsinformationen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProvideAssemblyEvidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence ProvideAssemblyEvidence (System.Reflection.Assembly loadedAssembly, System.Security.Policy.Evidence inputEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Policy.Evidence ProvideAssemblyEvidence(class System.Reflection.Assembly loadedAssembly, class System.Security.Policy.Evidence inputEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.ProvideAssemblyEvidence(System.Reflection.Assembly,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ProvideAssemblyEvidence (loadedAssembly As Assembly, inputEvidence As Evidence) As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Policy::Evidence ^ ProvideAssemblyEvidence(System::Reflection::Assembly ^ loadedAssembly, System::Security::Policy::Evidence ^ inputEvidence);" />
      <MemberSignature Language="F#" Value="abstract member ProvideAssemblyEvidence : System.Reflection.Assembly * System.Security.Policy.Evidence -&gt; System.Security.Policy.Evidence&#xA;override this.ProvideAssemblyEvidence : System.Reflection.Assembly * System.Security.Policy.Evidence -&gt; System.Security.Policy.Evidence" Usage="hostSecurityManager.ProvideAssemblyEvidence (loadedAssembly, inputEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loadedAssembly" Type="System.Reflection.Assembly" />
        <Parameter Name="inputEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="loadedAssembly">Die geladene Assembly.</param>
        <param name="inputEvidence">Zusätzlicher Beweis, der dem Assemblybeweis hinzugefügt werden soll.</param>
        <summary>Stellt den Assemblybeweis für eine Assembly bereit, die derzeit geladen wird.</summary>
        <returns>Der Beweis, der für die Assembly verwendet werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann in einer abgeleiteten Klasse überschrieben werden.  
  
 Diese Methode wird aufgerufen, wenn eine Assembly entweder implizit oder explizit geladen wird. Die übergebenen Parameter sind die Assembly geladen wird und die berechneten Beweis, aus der common Language Runtime. Die hostimplementierung können erweitern oder reduzieren Sie die Beweise. Der Rückgabewert ist der Beweis für die Assembly verwendet werden.  Die grundlegende Implementierung gibt immer Beweisobjekts als übergeben die `inputEvidence` Parameter.  
  
> [!IMPORTANT]
>  Siehe die Hinweise für Vererber für die <xref:System.Security.HostSecurityManager> -Klasse für wichtige Implementierungsinformationen.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Überschreiben der <xref:System.Security.HostSecurityManager.ProvideAssemblyEvidence%2A> -Methode für einen benutzerdefinierten Host-Sicherheits-Manager. In diesem Beispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Security.HostSecurityManager> Klasse.  
  
 [!code-csharp[System.Security.HostSecurityManager#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.HostSecurityManager/CS/customsecuritymanager.cs#5)]
 [!code-vb[System.Security.HostSecurityManager#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.HostSecurityManager/VB/customsecuritymanager.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolvePolicy">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.PermissionSet ResolvePolicy(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.HostSecurityManager.ResolvePolicy(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::PermissionSet ^ ResolvePolicy(System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member ResolvePolicy : System.Security.Policy.Evidence -&gt; System.Security.PermissionSet&#xA;override this.ResolvePolicy : System.Security.Policy.Evidence -&gt; System.Security.PermissionSet" Usage="hostSecurityManager.ResolvePolicy evidence" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">Der Beweissatz, der zum Auswerten der Richtlinie verwendet wird.</param>
        <summary>Bestimmt, welche Berechtigungen Code auf Basis der angegebenen Beweise gewährt werden.</summary>
        <returns>Der Berechtigungssatz, der vom Sicherheitssystem erteilt werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft das Sicherheitsrichtlinienmodul, die mit dem angegebenen Beweis. Das Ergebnis wird durch die Sicherheitsrichtlinie bestimmt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="evidence" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>