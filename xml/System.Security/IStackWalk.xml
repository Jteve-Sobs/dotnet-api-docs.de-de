<Type Name="IStackWalk" FullName="System.Security.IStackWalk">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3e6233b8c576453e76b9b76c40cfb723247251ed" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83950206" /></Metadata><TypeSignature Language="C#" Value="public interface IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.IStackWalk" />
  <TypeSignature Language="VB.NET" Value="Public Interface IStackWalk" />
  <TypeSignature Language="C++ CLI" Value="public interface class IStackWalk" />
  <TypeSignature Language="F#" Value="type IStackWalk = interface" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System.Security.Permissions" FromVersion="4.0.2.0" To="System.Runtime.Extensions" ToVersion="4.2.1.0" FrameworkAlternate="dotnet-plat-ext-3.0;netcore-3.0" />
    <TypeForwarding From="System.Security.Permissions" FromVersion="4.0.3.0" To="System.Runtime.Extensions" ToVersion="4.2.2.0" FrameworkAlternate="dotnet-plat-ext-3.1" />
    <TypeForwarding From="System.Security.Permissions" FromVersion="5.0.0.0" To="System.Runtime.Extensions" ToVersion="4.2.1.0" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0" />
    <TypeForwarding From="System.Runtime.Extensions" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Security.Permissions" FromVersion="4.0.3.0" To="System.Runtime.Extensions" ToVersion="4.2.1.0" FrameworkAlternate="netcore-3.1" />
  </TypeForwardingChain>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="9d1fd-101">Verwaltet den Stackwalk, der bestimmt, ob alle Aufrufer in der Aufrufliste über die erforderlichen Berechtigungen für den Zugriff auf eine geschützte Ressource verfügen.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-101">Manages the stack walk that determines whether all callers in the call stack have the required permissions to access a protected resource.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d1fd-102">Teilweise vertrauenswürdiger Code stellt immer ein Sicherheitsrisiko dar.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-102">Partially trusted code always presents a security risk.</span></span> <span data-ttu-id="9d1fd-103">Manchmal kann Sie bearbeitet werden, um Aktionen im Namen von schädlichem Code auszuführen, der nicht über die Berechtigung für den Zugriff auf eine Ressource verfügt.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-103">It can sometimes be manipulated to perform actions on behalf of malicious code that does not have permission to access a resource.</span></span> <span data-ttu-id="9d1fd-104">Auf diese Weise kann bösartiger Code einen höheren Sicherheits Zugriff erreichen als zulässig.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-104">In this way, malicious code can achieve higher security access than it should be allowed.</span></span>  
  
 <span data-ttu-id="9d1fd-105">Der Common Language Runtime hilft, verwalteten Code vor diesen Angriffen zu schützen, indem ein Stapel Durchlauf für alle Aufrufe ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-105">The common language runtime helps protect managed code from these attacks by running a stack walk on all calls.</span></span> <span data-ttu-id="9d1fd-106">Der Stapel Durchlauf erfordert, dass der gesamte Code in der aufrufsstapel Berechtigung für den Zugriff auf eine geschützte Ressource hat.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-106">The stack walk requires that all code in the call stack has permission to access a protected resource.</span></span> <span data-ttu-id="9d1fd-107">Da sich der Code, der den Angriff versucht, immer irgendwo in der aufrufsstapel befindet, ist er nicht in der Lage, seine eigenen Sicherheits Berechtigungen zu überschreiten.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-107">Because the code attempting the attack will always be somewhere in the call stack, it will be unable to exceed its own security permissions.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Assert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Assert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Assert();" />
      <MemberSignature Language="F#" Value="abstract member Assert : unit -&gt; unit" Usage="iStackWalk.Assert " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9d1fd-108">Bestätigt, dass der aufrufende Code auf die durch das aktuelle Berechtigungsobjekt identifizierte Ressource zugreifen kann, selbst wenn Aufrufern einer höheren Ebene in der Aufrufliste keine Berechtigung für den Zugriff auf die Ressource erteilt wurde.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-108">Asserts that the calling code can access the resource identified by the current permission object, even if callers higher in the stack have not been granted permission to access the resource.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d1fd-109">Durch Aufrufen von <xref:System.Security.IStackWalk.Assert%2A> wird die Berechtigungsüberprüfung für Aufrufer in der Aufruf Listen-aufrufenden</span><span class="sxs-lookup"><span data-stu-id="9d1fd-109">Calling <xref:System.Security.IStackWalk.Assert%2A> stops the permission check on callers higher in the call stack.</span></span> <span data-ttu-id="9d1fd-110">Auch wenn diese Aufrufer nicht über die erforderlichen Berechtigungen verfügen, können Sie weiterhin auf Ressourcen zugreifen.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-110">Therefore, even if these callers do not have the requisite permissions, they can still access resources.</span></span> <span data-ttu-id="9d1fd-111">Eine-Assertion ist nur wirksam, wenn der Code, der aufruft <xref:System.Security.IStackWalk.Assert%2A> die Sicherheitsüberprüfung für die Berechtigung übergibt, die Sie bestätigt.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-111">An assertion is effective only if the code that calls <xref:System.Security.IStackWalk.Assert%2A> passes the security check for the permission that it is asserting.</span></span>  
  
 <span data-ttu-id="9d1fd-112">Ein Aufruf von <xref:System.Security.IStackWalk.Assert%2A> wird wirksam, bis der aufrufende Code an seinen Aufrufer zurückgegeben wird oder wenn ein nachfolgender Aufruf von <xref:System.Security.IStackWalk.Assert%2A> die vorherige Assertionen als unwirksam rendert</span><span class="sxs-lookup"><span data-stu-id="9d1fd-112">A call to <xref:System.Security.IStackWalk.Assert%2A> is effective until the calling code returns to its caller or until a subsequent call to <xref:System.Security.IStackWalk.Assert%2A> renders the previous assertion ineffective.</span></span> <span data-ttu-id="9d1fd-113">Außerdem entfernt <xref:System.Security.CodeAccessPermission.RevertAssert%2A> oder <xref:System.Security.CodeAccessPermission.RevertAll%2A> eine ausstehende <xref:System.Security.IStackWalk.Assert%2A>.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-113">Also, <xref:System.Security.CodeAccessPermission.RevertAssert%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> removes a pending <xref:System.Security.IStackWalk.Assert%2A>.</span></span>  
  
 <span data-ttu-id="9d1fd-114"><xref:System.Security.IStackWalk.Assert%2A> wird für eine nicht erteilte Berechtigung ignoriert, da eine Anforderung für diese Berechtigung nicht erfolgreich ist.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-114"><xref:System.Security.IStackWalk.Assert%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="9d1fd-115">Wenn der Code, der sich in der Aufruf Stapel befindet, jedoch <xref:System.Security.IStackWalk.Demand%2A> für diese Berechtigung aufruft, wird eine <xref:System.Security.SecurityException> ausgelöst, wenn der Stapel Durchlauf den Code erreicht, der versucht hat, <xref:System.Security.IStackWalk.Assert%2A>aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-115">However, if code lower on the call stack calls <xref:System.Security.IStackWalk.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.IStackWalk.Assert%2A>.</span></span> <span data-ttu-id="9d1fd-116">Dies liegt daran, dass dem Code, der <xref:System.Security.IStackWalk.Assert%2A> aufgerufen hat, nicht die Berechtigung erteilt wurde, obwohl er versucht hat, ihn zu <xref:System.Security.IStackWalk.Assert%2A>.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-116">This happens because the code that called <xref:System.Security.IStackWalk.Assert%2A> has not been granted the permission, even though it tried to <xref:System.Security.IStackWalk.Assert%2A> it.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="9d1fd-117">Da durch das Aufrufen von <xref:System.Security.IStackWalk.Assert%2A> die Anforderung entfernt wird, dass sämtlichen Code in der Aufruf Kette die Berechtigung zum Zugriff auf die angegebene Ressource erteilt werden muss, können Sicherheitslücken entstehen, wenn Sie falsch oder nicht ordnungsgemäß verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-117">Because calling <xref:System.Security.IStackWalk.Assert%2A> removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security vulnerabilities if used incorrectly or inappropriately.</span></span> <span data-ttu-id="9d1fd-118">Daher sollte Sie mit großer Vorsicht verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-118">Therefore, it should be used with great caution.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="9d1fd-119">Der aufrufende Code verfügt nicht über <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-119">The calling code does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</span></span></exception>
        <related type="Article" href="/dotnet/framework/misc/using-the-assert-method"><span data-ttu-id="9d1fd-120">Verwenden der Assert-Methode</span><span class="sxs-lookup"><span data-stu-id="9d1fd-120">Using the Assert Method</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Demand();" />
      <MemberSignature Language="F#" Value="abstract member Demand : unit -&gt; unit" Usage="iStackWalk.Demand " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9d1fd-121">Ermittelt zur Laufzeit, ob allen Aufrufern in der Aufrufliste die vom aktuellen Berechtigungsobjekt angegebene Berechtigung erteilt wurde.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-121">Determines at run time whether all callers in the call stack have been granted the permission specified by the current permission object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d1fd-122">Diese Methode wird normalerweise von sicheren Bibliotheken verwendet, um sicherzustellen, dass Aufrufer über die Berechtigung verfügen, auf eine Ressource zuzugreifen</span><span class="sxs-lookup"><span data-stu-id="9d1fd-122">This method is typically used by secure libraries to ensure that callers have permission to access a resource.</span></span> <span data-ttu-id="9d1fd-123">Beispielsweise ruft eine File-Klasse in einer sicheren Klassenbibliothek <xref:System.Security.IStackWalk.Demand%2A> für die erforderliche <xref:System.Security.Permissions.FileIOPermission> auf, bevor ein vom Aufrufer angeforderter Datei Vorgang durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-123">For example, a file class in a secure class library calls <xref:System.Security.IStackWalk.Demand%2A> for the necessary <xref:System.Security.Permissions.FileIOPermission> before performing a file operation requested by the caller.</span></span>  
  
 <span data-ttu-id="9d1fd-124">Die Berechtigungen des Codes, der diese Methode aufruft, werden nicht untersucht. die Überprüfung beginnt mit dem unmittelbaren Aufrufer dieses Codes und geht im Stapel nach oben.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-124">The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack.</span></span> <span data-ttu-id="9d1fd-125"><xref:System.Security.IStackWalk.Demand%2A> ist nur erfolgreich, wenn keine <xref:System.Security.SecurityException> ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-125"><xref:System.Security.IStackWalk.Demand%2A> succeeds only if no <xref:System.Security.SecurityException> is raised.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="9d1fd-126">Ein in der Aufrufliste höher eingestufter Aufrufer hat nicht die durch das aktuelle Berechtigungsobjekt angegebene Berechtigung.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-126">A caller higher in the call stack does not have the permission specified by the current permission object.</span></span>  
  
<span data-ttu-id="9d1fd-127">Oder</span><span class="sxs-lookup"><span data-stu-id="9d1fd-127">-or-</span></span> 
<span data-ttu-id="9d1fd-128">Ein Aufrufer in der Aufrufliste hat <see cref="M:System.Security.IStackWalk.Deny" /> für das aktuelle Berechtigungsobjekt aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-128">A caller in the call stack has called <see cref="M:System.Security.IStackWalk.Deny" /> on the current permission object.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Deny" />
      <MemberSignature Language="VB.NET" Value="Public Sub Deny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Deny();" />
      <MemberSignature Language="F#" Value="abstract member Deny : unit -&gt; unit" Usage="iStackWalk.Deny " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9d1fd-129">Bewirkt einen Fehler bei jeder <see cref="M:System.Security.IStackWalk.Demand" /> für das aktuelle Objekt, das den aufrufenden Code durchläuft.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-129">Causes every <see cref="M:System.Security.IStackWalk.Demand" /> for the current object that passes through the calling code to fail.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d1fd-130">Diese Methode verhindert, dass Aufrufer in der Aufruf Listen über den Code, der diese Methode aufruft, auf die geschützte Ressource zugreift, auch wenn diesen Aufrufern Berechtigungen für den Zugriff auf die Ressource erteilt wurden.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-130">This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it.</span></span> <span data-ttu-id="9d1fd-131">Die-aufrufsstapel wird in der Regel so dargestellt, dass Sie in der aufrufsstapel-Methode weiter unten aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-131">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 <span data-ttu-id="9d1fd-132"><xref:System.Security.IStackWalk.Deny%2A> können die Haftung des Programmierers einschränken oder versehentliche Sicherheitsrisiken verhindern, da dadurch verhindert wird, dass die Methode, die <xref:System.Security.IStackWalk.Deny%2A> aufruft, für den Zugriff auf die durch die verweigerte Berechtigung geschützte Ressource verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-132"><xref:System.Security.IStackWalk.Deny%2A> can limit the liability of the programmer or help prevent accidental security vulnerabilities because it helps prevent the method that calls <xref:System.Security.IStackWalk.Deny%2A> from being used to access the resource protected by the denied permission.</span></span> <span data-ttu-id="9d1fd-133">Wenn eine Methode <xref:System.Security.IStackWalk.Deny%2A> für eine Berechtigung aufruft und eine <xref:System.Security.IStackWalk.Demand%2A> für diese Berechtigung von einem Aufrufer in der Aufruf Listen unteren aufgerufen wird, schlägt diese Sicherheitsüberprüfung fehl, wenn die <xref:System.Security.IStackWalk.Deny%2A>erreicht wird.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-133">If a method calls <xref:System.Security.IStackWalk.Deny%2A> on a permission, and if a <xref:System.Security.IStackWalk.Demand%2A> for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the <xref:System.Security.IStackWalk.Deny%2A>.</span></span>  
  
 <span data-ttu-id="9d1fd-134"><xref:System.Security.IStackWalk.Deny%2A> wird für eine nicht erteilte Berechtigung ignoriert, da eine Anforderung für diese Berechtigung nicht erfolgreich ist.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-134"><xref:System.Security.IStackWalk.Deny%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="9d1fd-135">Diese Methode kann nicht überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-135">You cannot override this method.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub PermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PermitOnly();" />
      <MemberSignature Language="F#" Value="abstract member PermitOnly : unit -&gt; unit" Usage="iStackWalk.PermitOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9d1fd-136">Bewirkt, dass es bei allen <see cref="M:System.Security.IStackWalk.Demand" /> für alle den aufrufenden Code durchlaufenden Objekte (mit Ausnahme des aktuellen Objekts) zu einem Fehler kommt, selbst wenn übergeordnetem Code in der Aufrufliste die Berechtigung für den Zugriff auf andere Ressourcen gewährt wurde.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-136">Causes every <see cref="M:System.Security.IStackWalk.Demand" /> for all objects except the current one that passes through the calling code to fail, even if code higher in the call stack has been granted permission to access other resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d1fd-137"><xref:System.Security.IStackWalk.PermitOnly%2A> ähnelt <xref:System.Security.IStackWalk.Deny%2A>, da beide dazu führen, dass Stapel Spaziergänge fehlschlagen, wenn Sie andernfalls erfolgreich verlaufen.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-137"><xref:System.Security.IStackWalk.PermitOnly%2A> is similar to <xref:System.Security.IStackWalk.Deny%2A>, in that both cause stack walks to fail when they would otherwise succeed.</span></span> <span data-ttu-id="9d1fd-138">Der Unterschied besteht darin, dass <xref:System.Security.IStackWalk.Deny%2A> Berechtigungen angibt, die dazu führen, dass der Stapel Durchlauf fehlschlägt, <xref:System.Security.IStackWalk.PermitOnly%2A> jedoch die einzigen Berechtigungen angibt, die nicht dazu führen, dass der Stapel Durchlauf fehlschlägt.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-138">The difference is that <xref:System.Security.IStackWalk.Deny%2A> specifies permissions that will cause the stack walk to fail, but <xref:System.Security.IStackWalk.PermitOnly%2A> specifies the only permissions that do not cause the stack walk to fail.</span></span> <span data-ttu-id="9d1fd-139">Aufrufen Sie diese Methode, um sicherzustellen, dass der Code nur für den Zugriff auf die angegebenen Ressourcen verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-139">Call this method to ensure that your code can be used to access only the specified resources.</span></span>  
  
 <span data-ttu-id="9d1fd-140"><xref:System.Security.IStackWalk.PermitOnly%2A> wird für eine nicht erteilte Berechtigung ignoriert, da eine Anforderung für diese Berechtigung nicht erfolgreich ist.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-140"><xref:System.Security.IStackWalk.PermitOnly%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="9d1fd-141">Wenn der Code jedoch später in der Aufruf Stapel <xref:System.Security.IStackWalk.Demand%2A> für diese Berechtigung aufruft, wird eine <xref:System.Security.SecurityException> ausgelöst, wenn der Stapel Durchlauf den Code erreicht, der versucht hat, <xref:System.Security.IStackWalk.PermitOnly%2A>aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-141">However, if code lower on the call stack later calls <xref:System.Security.IStackWalk.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.IStackWalk.PermitOnly%2A>.</span></span> <span data-ttu-id="9d1fd-142">Dies liegt daran, dass dem Code, der <xref:System.Security.IStackWalk.PermitOnly%2A> aufgerufen hat, nicht die Berechtigung erteilt wurde, auch wenn er <xref:System.Security.IStackWalk.PermitOnly%2A> für diese Berechtigung aufgerufen hat.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-142">This is because the code that called <xref:System.Security.IStackWalk.PermitOnly%2A> has not been granted the permission, even though it called <xref:System.Security.IStackWalk.PermitOnly%2A> for that permission.</span></span> <span data-ttu-id="9d1fd-143">Die-aufrufsstapel wird in der Regel so dargestellt, dass Sie in der aufrufsstapel-Methode weiter unten aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="9d1fd-143">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
