<Type Name="SecurityManager" FullName="System.Security.SecurityManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="51b52be500a5be1b9b263e9528638a7f09b2cb2a" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30500684" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class SecurityManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed SecurityManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Security.SecurityManager" />
  <TypeSignature Language="VB.NET" Value="Public Class SecurityManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityManager abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt den Hauptzugriffspunkt für Klassen dar, die mit dem Sicherheitssystem kommunizieren. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sicherheit stellt Methoden zum Zugreifen auf und bearbeiten die Konfiguration der Sicherheit bereit. Sie können Instanzen erstellen <xref:System.Security.SecurityManager>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CheckExecutionRights">
      <MemberSignature Language="C#" Value="public static bool CheckExecutionRights { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CheckExecutionRights" />
      <MemberSignature Language="DocId" Value="P:System.Security.SecurityManager.CheckExecutionRights" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CheckExecutionRights As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CheckExecutionRights { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob Code für die Ausführung über <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> verfügen muss, oder legt diesen Wert fest.</summary>
        <value>
          <see langword="true" />, wenn Code für die Ausführung über <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> verfügen muss, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft ist `false`, dies gilt auch für Code ohne <xref:System.Security.Permissions.SecurityPermissionFlag.Execution> ausführen können. Überprüfen der Ausführung ist teuer und kann die Vorteile der verzögerten richtlinienauflösung beseitigen. Diese Eigenschaft dient der Ausführung Überprüfen bei Bedarf deaktivieren.  
  
 Eine Änderung an dieser Eigenschaft wird nicht beibehalten, bis <xref:System.Security.SecurityManager.SavePolicy%2A> aufgerufen wird. Neue Prozesse werden nicht von der Änderung betroffen werden, bis sie in der Registrierung persistent ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Code, der diese Methode aufruft, hat keine <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Fähigkeit zum Ändern der Richtlinie. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThreadRequiresSecurityContextCapture">
      <MemberSignature Language="C#" Value="public static bool CurrentThreadRequiresSecurityContextCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CurrentThreadRequiresSecurityContextCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CurrentThreadRequiresSecurityContextCapture () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CurrentThreadRequiresSecurityContextCapture();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bestimmt, ob der aktuelle Thread eine Erfassung des Sicherheitskontexts erfordert, wenn der Sicherheitszustand des Threads zu einem späteren Zeitpunkt neu erstellt werden muss.</summary>
        <returns>
          <see langword="false" />, wenn der Stapel keine teilweise vertrauenswürdigen Anwendungsdomänen, keine teilweise vertrauenswürdigen Assemblys und keine zurzeit aktiven <see cref="M:System.Security.CodeAccessPermission.PermitOnly" />-Modifizierer oder <see cref="M:System.Security.CodeAccessPermission.Deny" />-Modifizierer enthält, <see langword="true" />, wenn die Common Language Runtime nicht garantieren kann, dass der Stapel keines dieser Elemente enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture%2A> -Methode auf, bevor Sie vertrauliche Daten zwischenzuspeichern, die nach der erfolgreichen sicherheitsforderungen abgerufen werden.  
  
 Wenn die <xref:System.Security.CodeAccessPermission.Assert%2A> -Methode aufgerufen wurde höher auf dem Stapel, die Daten sollten nicht zwischengespeichert werden, ohne die entsprechenden Sicherheitskontext zu erfassen. Andernfalls, vertrauliche Daten, die unter abgerufen werden ein <xref:System.Security.CodeAccessPermission.Assert%2A> möglicherweise verfügbar, d. h. code nicht mehr ausgeführt werden, mit denen <xref:System.Security.CodeAccessPermission.Assert%2A> vorhanden.  
  
> [!IMPORTANT]
>  Der Rückgabewert ist zuverlässig, nur bei `false`, was bedeutet, dass der Thread nicht auf eine Erfassung des Sicherheitskontexts erfordern garantiert ist. Die Methode kann "true" zurückgeben, wenn eine Erfassung des Sicherheitskontexts nicht erforderlich ist, Sicherheitsrisiken vermeiden.  
  
 <xref:System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture%2A> ist als sicherheitskritisch, da der Hauptverwendungszweck ist, gibt an, dass der Code, sie sicherheitsrelevante und überwacht werden muss, vermeiden Sie unnötige Sicherheitskontext erfasst.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetStandardSandbox">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet GetStandardSandbox (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet GetStandardSandbox(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.GetStandardSandbox(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ GetStandardSandbox(System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">Der Hostbeweis, der einem Berechtigungssatz zugeordnet werden soll.</param>
        <summary>Ruft einen Berechtigungssatz ab, der einer Anwendung mit dem angegebenen Beweis sicher gewährt werden kann.</summary>
        <returns>Ein Berechtigungssatz, der für die Anwendung mit dem angegebenen Beweis verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  In der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], der Host im Beweis `evidence` darf <xref:System.Security.Policy.Zone?displayProperty=nameWithType> Beweis.  
>   
>  Die folgende Tabelle zeigt die Berechtigungssätze, die für jede Zone zurückgegeben werden.  
  
|Zone|Berechtigungssatz|  
|----------|--------------------|  
|<xref:System.Security.SecurityZone.MyComputer>|`FullTrust`|  
|<xref:System.Security.SecurityZone.Intranet>|`LocalIntranet`|  
|<xref:System.Security.SecurityZone.Trusted>|`Internet`|  
|<xref:System.Security.SecurityZone.Internet>|`Internet`|  
|<xref:System.Security.SecurityZone.Untrusted>|Keiner|  
|<xref:System.Security.SecurityZone.NoZone>|Keiner|  
  
 Anderer Beweis, z. B. <xref:System.Security.Policy.Url> oder <xref:System.Security.Policy.Site>, angesehen werden kann.  
  
 Der zurückgegebene Berechtigungssatz kann in einer Sandbox verwendet werden, um die Anwendung auszuführen. Beachten Sie, dass diese Methode gibt keinen Richtlinie, sondern einen Host hilft zu bestimmen, ob der Berechtigungssatz, der von einer Anwendung angefordert angemessen ist. Diese Methode kann verwendet werden, eine Zone in einer Sandbox zuordnen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Security.SecurityManager.GetStandardSandbox%2A> Methode, um die Berechtigung zu erhalten, die für eine Sandbox-Anwendung festgelegt. Weitere Informationen zum Ausführen einer Anwendung in einem Sandkasten finden Sie unter [Vorgehensweise: Ausführen von teilweise vertrauenswürdigen Code in einem Sandkasten](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).  
  
 [!code-csharp[sandboxingApis#1](~/samples/snippets/csharp/VS_Snippets_CLR/SandboxingAPIs/CS/program.cs#1)]
 [!code-vb[sandboxingApis#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SandboxingAPIs/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="evidence" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetZoneAndOrigin">
      <MemberSignature Language="C#" Value="public static void GetZoneAndOrigin (out System.Collections.ArrayList zone, out System.Collections.ArrayList origin);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetZoneAndOrigin([out] class System.Collections.ArrayList&amp; zone, [out] class System.Collections.ArrayList&amp; origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.GetZoneAndOrigin(System.Collections.ArrayList@,System.Collections.ArrayList@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetZoneAndOrigin (ByRef zone As ArrayList, ByRef origin As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetZoneAndOrigin([Runtime::InteropServices::Out] System::Collections::ArrayList ^ % zone, [Runtime::InteropServices::Out] System::Collections::ArrayList ^ % origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="zone" Type="System.Collections.ArrayList&amp;" RefType="out" />
        <Parameter Name="origin" Type="System.Collections.ArrayList&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="zone">Ein Ausgabeparameter, der ein <see cref="T:System.Collections.ArrayList" /> von gewährten <see cref="P:System.Security.Permissions.ZoneIdentityPermissionAttribute.Zone" />-Objekten enthält.</param>
        <param name="origin">Ein Ausgabeparameter, der ein <see cref="T:System.Collections.ArrayList" /> von gewährten <see cref="T:System.Security.Permissions.UrlIdentityPermission" />-Objekten enthält.</param>
        <summary>Ruft für die aktuelle Assembly die gewährten Berechtigungssätze für die Zonenidentität und die URL-Identität ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die empfohlene Alternative für diese Methode ist die Verwendung den URL und die Zeitzone Beweis für die derzeit ausgeführte Assembly Aufrufen <xref:System.Security.SecurityManager.ResolvePolicy%2A> für jeden Beweis. Die zurückgegebenen Berechtigungssätze der <xref:System.Security.SecurityManager.ResolvePolicy%2A> Aufrufe zu identifizieren, die Berechtigungen für den ausgeführten Assembly basierend auf seinem Zone und die Ursprungs-URL.  
  
> [!NOTE]
>  Dieser Member stellt einen Linkaufruf für den öffentlichen ECMA-Schlüssel, der keinem gültigen kryptografischen Schlüssel jedoch einen Pseudoschlüssel ist. In .NET Framework ist der Linkaufruf für den ECMA-Pseudo-Schlüssel automatisch in einen Linkaufruf für den öffentlichen Microsoft-Schlüssel konvertiert. Die Sicherheitsausnahme basiert auf den öffentlichen Schlüssel von Microsoft, nicht in den ECMA-Pseudo-Schlüssel.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Fehler bei der Anforderung für <see cref="T:System.Security.Permissions.StrongNameIdentityPermission" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsGranted">
      <MemberSignature Language="C#" Value="public static bool IsGranted (System.Security.IPermission perm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsGranted(class System.Security.IPermission perm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.IsGranted(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsGranted (perm As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsGranted(System::Security::IPermission ^ perm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="perm" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="perm">Die Berechtigung, für die getestet werden soll, ob sie diesem Aufrufer erteilt wurde.</param>
        <summary>Bestimmt, ob dem Aufrufer eine Berechtigung erteilt wird.</summary>
        <returns>
          <see langword="true" />, wenn die dem Aufrufer erteilten Berechtigungen die Berechtigung <paramref name="perm" /> einschließen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erteilen von Berechtigungen wird bestimmt, von der Richtlinie und unterscheidet sich von einer Anforderung unterliegen überschreibt, z. B. eine Assertion. Darüber hinaus <xref:System.Security.SecurityManager.IsGranted%2A> überprüft nur die Erteilung der aufrufende Codeassembly unabhängig von anderen Aufrufer für den Stapel.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPolicyLevelFromFile">
      <MemberSignature Language="C#" Value="public static System.Security.Policy.PolicyLevel LoadPolicyLevelFromFile (string path, System.Security.PolicyLevelType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Policy.PolicyLevel LoadPolicyLevelFromFile(string path, valuetype System.Security.PolicyLevelType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadPolicyLevelFromFile (path As String, type As PolicyLevelType) As PolicyLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Policy::PolicyLevel ^ LoadPolicyLevelFromFile(System::String ^ path, System::Security::PolicyLevelType type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.PolicyLevel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="type" Type="System.Security.PolicyLevelType" />
      </Parameters>
      <Docs>
        <param name="path">Der physische Dateipfad zu einer Datei mit Informationen zur Sicherheitsrichtlinie.</param>
        <param name="type">Einer der Enumerationswerte, der den Typ der zu ladenden Richtlinienebene angibt.</param>
        <summary>Lädt einen <see cref="T:System.Security.Policy.PolicyLevel" /> aus der angegebenen Datei.</summary>
        <returns>Die geladene Richtlinienebene.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die durch den <paramref name="path" />-Parameter angezeigte Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.Security.SecurityException">Der Code, der diese Methode aufruft, hat keine <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.  
  
 - oder -   
  
 Der Code, der diese Methode aufruft, hat keine <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.  
  
 - oder -   
  
 Der Code, der diese Methode aufruft, hat keine <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.  
  
 - oder -   
  
 Der Code, der diese Methode aufruft, hat keine <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</exception>
        <exception cref="T:System.NotSupportedException">Diese Methode verwendet eine Richtlinie für die Codezugriffssicherheit (Code Access Security, CAS), die im [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] veraltet ist. Um die CAS-Richtlinie für Kompatibilität mit früheren Versionen von .NET Framework zu aktivieren, verwenden Sie das [&lt;legacyCasPolicy&gt;-Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Fähigkeit zum Anzeigen und Ändern von Richtlinien. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Zum Lesen und Schreiben von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadPolicyLevelFromString">
      <MemberSignature Language="C#" Value="public static System.Security.Policy.PolicyLevel LoadPolicyLevelFromString (string str, System.Security.PolicyLevelType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Policy.PolicyLevel LoadPolicyLevelFromString(string str, valuetype System.Security.PolicyLevelType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.LoadPolicyLevelFromString(System.String,System.Security.PolicyLevelType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadPolicyLevelFromString (str As String, type As PolicyLevelType) As PolicyLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Policy::PolicyLevel ^ LoadPolicyLevelFromString(System::String ^ str, System::Security::PolicyLevelType type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.PolicyLevel</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="type" Type="System.Security.PolicyLevelType" />
      </Parameters>
      <Docs>
        <param name="str">Die XML-Darstellung einer Sicherheitsrichtlinienebene in derselben Form, in der diese in einer Konfigurationsdatei angezeigt wird.</param>
        <param name="type">Einer der Enumerationswerte, der den Typ der zu ladenden Richtlinienebene angibt.</param>
        <summary>Lädt <see cref="T:System.Security.Policy.PolicyLevel" /> aus der angegebenen Zeichenfolge.</summary>
        <returns>Die geladene Richtlinienebene.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="str" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="str" />-Parameter ist ungültig.</exception>
        <exception cref="T:System.Security.SecurityException">Der Code, der diese Methode aufruft, hat keine <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Fähigkeit zum Anzeigen und Ändern von Richtlinien. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <Member MemberName="PolicyHierarchy">
      <MemberSignature Language="C#" Value="public static System.Collections.IEnumerator PolicyHierarchy ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IEnumerator PolicyHierarchy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.PolicyHierarchy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PolicyHierarchy () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IEnumerator ^ PolicyHierarchy();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt einen Enumerator für den Zugriff auf die Hierarchie der Sicherheitsrichtlinien basierend auf Ebenen bereit, z.B. auf Ebene der Computerrichtlinien oder der Benutzerrichtlinien.</summary>
        <returns>Ein Enumerator für <see cref="T:System.Security.Policy.PolicyLevel" />-Objekte, aus denen sich die Hierarchie der Sicherheitsrichtlinien zusammensetzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der zurückgegebene Enumerator stellt aufeinander folgenden <xref:System.Security.Policy.PolicyLevel> Objekte, die die Richtlinie für die jeweilige darstellen (Computer, Benutzer, Unternehmen, die Anwendungsdomäne) Ebene der Hierarchie. Diese Objekte sind die live Richtlinienobjekte; ändern diese Objekte kann unvorhersehbare Folgen haben.  
  
 Minimale Richtlinienhierarchie besteht aus einer Computerebene, ein Enterprise-Ebene und eine Benutzerebene. Allerdings kann die Hierarchie zusätzliche Ebenen enthalten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode verwendet eine Richtlinie für die Codezugriffssicherheit (Code Access Security, CAS), die im [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] veraltet ist. Um die CAS-Richtlinie für Kompatibilität mit früheren Versionen von .NET Framework zu aktivieren, verwenden Sie das [&lt;legacyCasPolicy&gt;-Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
        <exception cref="T:System.Security.SecurityException">Der Code, der diese Methode aufruft, hat keine <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Fähigkeit zum Anzeigen und Ändern von Richtlinien. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolvePolicy">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt die für Code zu erteilenden Berechtigungen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolvePolicy">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet ResolvePolicy(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ ResolvePolicy(System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">Der Beweissatz, der zum Auswerten der Richtlinie verwendet wird.</param>
        <summary>Bestimmt, welche Berechtigungen Code auf Basis der angegebenen Beweise gewährt werden.</summary>
        <returns>Der Satz von Berechtigungen, die vom Sicherheitssystem gewährt werden können.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft das Sicherheitsrichtlinienmodul zum Nachweis der Identität des aufrufenden Codes bereitstellen. Das Ergebnis wird durch die Sicherheitsrichtlinie bestimmt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode verwendet eine Richtlinie für die Codezugriffssicherheit (Code Access Security, CAS), die im [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] veraltet ist. Um die CAS-Richtlinie für Kompatibilität mit früheren Versionen von .NET Framework zu aktivieren, verwenden Sie das [&lt;legacyCasPolicy&gt;-Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolvePolicy">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence[] evidences);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet ResolvePolicy(class System.Security.Policy.Evidence[] evidences) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ResolvePolicy (evidences As Evidence()) As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ ResolvePolicy(cli::array &lt;System::Security::Policy::Evidence ^&gt; ^ evidences);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidences" Type="System.Security.Policy.Evidence[]" />
      </Parameters>
      <Docs>
        <param name="evidences">Ein Array von Beweisobjekten, die zum Auswerten der Richtlinie verwendet werden.</param>
        <summary>Bestimmt, welche Berechtigungen Code auf Basis der angegebenen Beweise gewährt werden.</summary>
        <returns>Der Satz von Berechtigungen, der für alle bereitgestellten Beweis geeignet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft das Sicherheitsrichtlinienmodul, bietet es ein Array von <xref:System.Security.Policy.Evidence> Objekte. Der zurückgegebene Berechtigungssatz stellt nur die Berechtigungen, die für jeden Beweis im Array gelten. Diese Berechtigungen sind entweder entspricht, oder eine Teilmenge der Berechtigungen, die Richtlinie auf jedem einzelnen Beweis erteilt haben, würden. Diese Methode verhält sich, als ob Sie eine Schnittmenge, auf dem die Ergebnisse ausgeführt haben der Richtlinie auf jedem der Auflösung der <xref:System.Security.Policy.Evidence> Objekte im Array.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode verwendet eine Richtlinie für die Codezugriffssicherheit (Code Access Security, CAS), die im [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] veraltet ist. Um die CAS-Richtlinie für Kompatibilität mit früheren Versionen von .NET Framework zu aktivieren, verwenden Sie das [&lt;legacyCasPolicy&gt;-Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolvePolicy">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence, System.Security.PermissionSet reqdPset, System.Security.PermissionSet optPset, System.Security.PermissionSet denyPset, out System.Security.PermissionSet denied);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet ResolvePolicy(class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet reqdPset, class System.Security.PermissionSet optPset, class System.Security.PermissionSet denyPset, [out] class System.Security.PermissionSet&amp; denied) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ ResolvePolicy(System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ reqdPset, System::Security::PermissionSet ^ optPset, System::Security::PermissionSet ^ denyPset, [Runtime::InteropServices::Out] System::Security::PermissionSet ^ % denied);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="reqdPset" Type="System.Security.PermissionSet" />
        <Parameter Name="optPset" Type="System.Security.PermissionSet" />
        <Parameter Name="denyPset" Type="System.Security.PermissionSet" />
        <Parameter Name="denied" Type="System.Security.PermissionSet&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="evidence">Der Beweissatz, der zum Auswerten der Richtlinie verwendet wird.</param>
        <param name="reqdPset">Die erforderlichen Berechtigungen, die der Code zur Ausführung benötigt.</param>
        <param name="optPset">Die optionalen Berechtigungen, die bei Gewährung verwendet werden, jedoch nicht zur Ausführung des Codes erforderlich sind.</param>
        <param name="denyPset">Die verweigerten Berechtigungen, die auch dann dem Code nie gewährt werden müssen, wenn die Richtlinie dies zulässt.</param>
        <param name="denied">Ein Ausgabeparameter, der den Satz nicht gewährter Berechtigungen enthält.</param>
        <summary>Bestimmt, welche Berechtigungen Code auf Basis der angegebenen Beweise und der Anforderungen gewährt werden.</summary>
        <returns>Der Satz von Berechtigungen, die vom Sicherheitssystem gewährt werden würden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft das Sicherheitsrichtlinienmodul, bietet es Nachweis der Identität des aufrufenden Codes und den Berechtigungssatz des Codes Anforderungen. Das Ergebnis wird durch die Sicherheitsrichtlinie bestimmt. Diese Methode gibt den Satz von Berechtigungen, die vom Sicherheitssystem gewährt werden, und gibt den Satz von Berechtigungen, die als Ausgabeparameter verweigert werden würde. Die effektivsten gewährten Berechtigungen sind in gewährten Berechtigungssatzes, die nicht in der verweigerten Gruppe sind.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode verwendet eine Richtlinie für die Codezugriffssicherheit (Code Access Security, CAS), die im [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] veraltet ist. Um die CAS-Richtlinie für Kompatibilität mit früheren Versionen von .NET Framework zu aktivieren, verwenden Sie das [&lt;legacyCasPolicy&gt;-Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
        <exception cref="T:System.Security.Policy.PolicyException">Die Richtlinie gewährt nicht die vom <paramref name="reqdPset" />-Parameter angegebenen minimal erforderlichen Berechtigungen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolvePolicyGroups">
      <MemberSignature Language="C#" Value="public static System.Collections.IEnumerator ResolvePolicyGroups (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IEnumerator ResolvePolicyGroups(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolvePolicyGroups(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IEnumerator ^ ResolvePolicyGroups(System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">Der Beweissatz, anhand dessen die Richtlinie ausgewertet wird.</param>
        <summary>Ruft eine Sammlung von Codegruppen ab, die dem angegebenen Beweis entsprechen.</summary>
        <returns>Eine Enumeration des Satzes von Codegruppen, die dem Beweis entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nützlich, bei der Analyse von Funktionsweise eine angegebene Richtlinienkonfiguration mit bestimmten Arten von Beweisen.  
  
 Von allen anwendbaren Ebenen der Hierarchie der übereinstimmenden Codegruppen zurückgegeben der `evidence` Parameter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode verwendet eine Richtlinie für die Codezugriffssicherheit (Code Access Security, CAS), die im [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] veraltet ist. Um die CAS-Richtlinie für Kompatibilität mit früheren Versionen von .NET Framework zu aktivieren, verwenden Sie das [&lt;legacyCasPolicy&gt;-Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveSystemPolicy">
      <MemberSignature Language="C#" Value="public static System.Security.PermissionSet ResolveSystemPolicy (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.PermissionSet ResolveSystemPolicy(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.ResolveSystemPolicy(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::PermissionSet ^ ResolveSystemPolicy(System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">Der Beweissatz, der zum Auswerten der Richtlinie verwendet wird.</param>
        <summary>Legt fest, welche Berechtigungen Code aufgrund der angegebenen Beweise erteilt werden, und schließt dabei die Richtlinie für die <see cref="T:System.AppDomain" />-Ebene aus.</summary>
        <returns>Der Satz von Berechtigungen, die vom Sicherheitssystem gewährt werden können.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft die Security Policy-Engine und Nachweis der Identität des aufrufenden Codes erhalten. Das Ergebnis wird bestimmt durch die Sicherheitsrichtlinie "System" und alle <xref:System.AppDomain> Richtlinie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode verwendet eine Richtlinie für die Codezugriffssicherheit (Code Access Security, CAS), die im [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] veraltet ist. Um die CAS-Richtlinie für Kompatibilität mit früheren Versionen von .NET Framework zu aktivieren, verwenden Sie das [&lt;legacyCasPolicy&gt;-Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
      </Docs>
    </Member>
    <Member MemberName="SavePolicy">
      <MemberSignature Language="C#" Value="public static void SavePolicy ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SavePolicy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.SavePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SavePolicy ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SavePolicy();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Speichert den geänderten Zustand der Sicherheitsrichtlinie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode speichert die Richtlinie aus, wie vom <xref:System.Security.SecurityManager.PolicyHierarchy%2A>, <xref:System.Security.Policy.PolicyLevel>, und andere Klassen diese Konfiguration dar, der Sicherheitsrichtlinie. Wenn diese Methode aufgerufen wird, wird an die Richtlinienobjekte vorgenommenen Änderungen werden nicht gespeichert und wirken sich nicht auf nachfolgende Anwendung ausgeführt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode verwendet eine Richtlinie für die Codezugriffssicherheit (Code Access Security, CAS), die im [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] veraltet ist. Um die CAS-Richtlinie für Kompatibilität mit früheren Versionen von .NET Framework zu aktivieren, verwenden Sie das [&lt;legacyCasPolicy&gt;-Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
        <exception cref="T:System.Security.SecurityException">Der Code, der diese Methode aufruft, hat keine <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Fähigkeit zum Ändern der Richtlinie. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SavePolicyLevel">
      <MemberSignature Language="C#" Value="public static void SavePolicyLevel (System.Security.Policy.PolicyLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SavePolicyLevel(class System.Security.Policy.PolicyLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.SecurityManager.SavePolicyLevel(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SavePolicyLevel (level As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SavePolicyLevel(System::Security::Policy::PolicyLevel ^ level);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="level">Das zu speichernde Richtlinienebenenobjekt.</param>
        <summary>Speichert eine geänderte, mit <see cref="M:System.Security.SecurityManager.LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)" /> geladene Sicherheitsrichtlinienebene.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Security.Policy.PolicyLevel> wird am gleichen Speicherort, an dem es geladen, gespeichert werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Code, der diese Methode aufruft, hat keine <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <exception cref="T:System.NotSupportedException">Diese Methode verwendet eine Richtlinie für die Codezugriffssicherheit (Code Access Security, CAS), die im [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] veraltet ist. Um die CAS-Richtlinie für Kompatibilität mit früheren Versionen von .NET Framework zu aktivieren, verwenden Sie das [&lt;legacyCasPolicy&gt;-Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Fähigkeit zum Ändern der Richtlinie. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityEnabled">
      <MemberSignature Language="C#" Value="public static bool SecurityEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SecurityEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Security.SecurityManager.SecurityEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SecurityEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SecurityEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The security manager cannot be turned off on MS runtime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Sicherheit aktiviert ist, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn die Sicherheit aktiviert ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird verwendet, durch die [Caspol.exe (Code Access Security Policy-Tool)](~/docs/framework/tools/caspol-exe-code-access-security-policy-tool.md)  
  
 `-security` (`-s`) Option aus, um die codebasierte Sicherheit zu deaktivieren.  
  
 <xref:System.Security.SecurityManager.SecurityEnabled%2A> bietet eine Möglichkeit für Administratoren zur Codezugriffssicherheit zu deaktivieren. Wenn die Codezugriffssicherheit deaktiviert ist, werden alle Codezugriffsforderungen erfolgreich ausgeführt. Effektiv, dadurch wird der gesamte Code gewährt `FullTrust`. Deaktivieren der Codezugriffssicherheit das Sicherheitssystem umgangen, sodass Code ausführen, kann etwas bessere Leistung als das entsprechende Security Policy erteilen `FullTrust` für den gesamten Code. Diese Eigenschaft wird mit der rollenbasierten Sicherheit nicht deaktiviert; aus diesem Grund <xref:System.Security.Permissions.PrincipalPermission> Anforderungen sind davon nicht betroffen.  
  
> [!CAUTION]
>  Das Deaktivieren der Codezugriffssicherheit macht das System anfällig gegenüber Angriffen von böswilligem Code wie Viren und Würmern. Deaktivieren der Codezugriffssicherheit blockiert nicht automatisch verwalteten Code in irgendeiner Weise ausgeführt werden. IT nur Ursachen von verwaltetem Code ohne Einschränkung durch die Code Access Security-System ausgeführt, und sollte nur mit größter Vorsicht vorgenommen werden. Das Deaktivieren der Sicherheit auf zusätzliche liegt der Leistungsgewinn sollte nur vorgenommen werden, wenn andere Sicherheitsmaßnahmen ergriffen wurden, um die Sicherheit des Systems zu schützen. Beispiele für solche Sicherheitsmaßnahmen sind u. a. das Trennen von Verbindungen mit öffentlichen Netzwerken und die physikalische Sicherung von Computern.  
  
 Eine Änderung an dieser Eigenschaft wird nicht beibehalten, in der Registrierung erst <xref:System.Security.SecurityManager.SavePolicy%2A> aufgerufen wird. Neue Prozesse werden nicht von der Änderung betroffen werden, bis sie in der Registrierung persistent ist. Ändern des Werts dieser Eigenschaft in einem laufenden Prozess ändert nicht notwendigerweise den Zustand wie erwartet. Um sicherzustellen, dass Änderungen übernommen wurden, rufen Sie <xref:System.Security.SecurityManager.SavePolicy%2A> und einen neuen Prozess zu starten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Code, der diese Methode aufruft, hat keine <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Fähigkeit zum Ändern der Richtlinie. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>