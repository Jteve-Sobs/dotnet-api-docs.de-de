<Type Name="BuildRequestDataFlags" FullName="Microsoft.Build.Execution.BuildRequestDataFlags">
  <Metadata><Meta Name="ms.openlocfilehash" Value="07d660d9d347f6d88d66447c5dad20784203a17a" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86623599" /></Metadata><TypeSignature Language="C#" Value="public enum BuildRequestDataFlags" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed BuildRequestDataFlags extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Build.Execution.BuildRequestDataFlags" />
  <TypeSignature Language="VB.NET" Value="Public Enum BuildRequestDataFlags" />
  <TypeSignature Language="C++ CLI" Value="public enum class BuildRequestDataFlags" />
  <TypeSignature Language="F#" Value="type BuildRequestDataFlags = " />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Build</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>15.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Flags]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Flags&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="cbe51-101">Flags, die zusätzliche Steuerung über die Buildanforderung bereitstellen</span><span class="sxs-lookup"><span data-stu-id="cbe51-101">Flags providing additional control over the build request</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks 

<span data-ttu-id="cbe51-102">Das- `IgnoreExistingProjectState` Flag wird nur für die Fälle bereitgestellt, in denen der Client weiß, dass die neue Buildanforderung nicht vom Projektzustand abhängt, der von einer vorherigen Anforderung generiert wurde.</span><span class="sxs-lookup"><span data-stu-id="cbe51-102">The `IgnoreExistingProjectState` flag is provided only for those cases where the client knows that the new build request does not depend on the project state generated by a previous request.</span></span> <span data-ttu-id="cbe51-103">Wenn Sie dieses Flag festlegen, kann dies zu einer Leistungssteigerung bei nicht kompatiblen Knoten Affinitäten führt, da MSBuild andernfalls den Projektstatus von einem Knoten zu einem anderen serialisieren muss.</span><span class="sxs-lookup"><span data-stu-id="cbe51-103">Setting this flag can provide a performance boost in the case of incompatible node affinities, because MSBuild would otherwise have to serialize the project state from one node to another.</span></span> <span data-ttu-id="cbe51-104">Das Serialisieren des Projekt Zustands kann abhängig von der Datenmenge, die das Projekt zuvor generiert hat, teuer sein.</span><span class="sxs-lookup"><span data-stu-id="cbe51-104">Serializing the project state can be expensive, depending on the amount of data the project has previously generated.</span></span>  
  
<span data-ttu-id="cbe51-105">Das `IgnoreExistingProjectState` Flag hat keine Auswirkungen auf die Ziel Ergebnisse. Wenn also eine vorherige Anforderung ein Ziel erstellt hat, wird das Ziel von der neuen Anforderung nicht neu erstellt.</span><span class="sxs-lookup"><span data-stu-id="cbe51-105">The `IgnoreExistingProjectState` flag has no effect on target results, so if a previous request has built a target, the new request will not rebuild the target.</span></span> <span data-ttu-id="cbe51-106">Darüber hinaus werden keine der Projekt Zustands Mutationen, die als Folge des zuvor Erstellungs Ziels aufgetreten sind, erneut angewendet.</span><span class="sxs-lookup"><span data-stu-id="cbe51-106">Additionally, none of the project state mutations which occurred as a consequence of previously building that target will be reapplied.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ClearCachesAfterBuild">
      <MemberSignature Language="C#" Value="ClearCachesAfterBuild" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Execution.BuildRequestDataFlags ClearCachesAfterBuild = int32(8)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Execution.BuildRequestDataFlags.ClearCachesAfterBuild" />
      <MemberSignature Language="VB.NET" Value="ClearCachesAfterBuild" />
      <MemberSignature Language="C++ CLI" Value="ClearCachesAfterBuild" />
      <MemberSignature Language="F#" Value="ClearCachesAfterBuild = 8" Usage="Microsoft.Build.Execution.BuildRequestDataFlags.ClearCachesAfterBuild" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.BuildRequestDataFlags</ReturnType>
      </ReturnValue>
      <MemberValue>8</MemberValue>
      <Docs>
        <summary><span data-ttu-id="cbe51-107">Wenn dieses Flag vorhanden ist, werden Caches einschließlich <see cref="T:Microsoft.Build.Evaluation.ProjectRootElementCacheBase" /> nach Abschluss der Buildanforderung gelöscht.</span><span class="sxs-lookup"><span data-stu-id="cbe51-107">When this flag is present, caches including the <see cref="T:Microsoft.Build.Evaluation.ProjectRootElementCacheBase" /> will be cleared after the build request completes.</span></span>  <span data-ttu-id="cbe51-108">Wird verwendet, wenn bekannt ist, dass die Buildanforderung viele Zustände verändert, wie z. B. die Wiederherstellung von Paketen oder die Generierung von Teilen des Importgraphen.</span><span class="sxs-lookup"><span data-stu-id="cbe51-108">This is used when the build request is known to modify a lot of state such as restoring packages or generating parts of the import graph.</span></span></summary>
      </Docs>
    </Member>
    <Member MemberName="IgnoreExistingProjectState">
      <MemberSignature Language="C#" Value="IgnoreExistingProjectState" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Execution.BuildRequestDataFlags IgnoreExistingProjectState = int32(4)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Execution.BuildRequestDataFlags.IgnoreExistingProjectState" />
      <MemberSignature Language="VB.NET" Value="IgnoreExistingProjectState" />
      <MemberSignature Language="C++ CLI" Value="IgnoreExistingProjectState" />
      <MemberSignature Language="F#" Value="IgnoreExistingProjectState = 4" Usage="Microsoft.Build.Execution.BuildRequestDataFlags.IgnoreExistingProjectState" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.BuildRequestDataFlags</ReturnType>
      </ReturnValue>
      <MemberValue>4</MemberValue>
      <Docs>
        <summary><span data-ttu-id="cbe51-109">Wenn dieses Flag vorhanden ist und das Projekt zuvor in einem Knoten erstellt wurde, dessen Affinität mit der für diese Anforderung erforderlichen Affinität nicht kompatibel ist, ignorieren wir den Projektzustand (aber nicht die Zielergebnisse), der zuvor generiert wurde.</span><span class="sxs-lookup"><span data-stu-id="cbe51-109">When this flag is present and the project has previously been built on a node whose affinity is incompatible with the affinity this request requires, we will ignore the project state (but not target results) that were previously generated.</span></span></summary>
        <remarks><span data-ttu-id="cbe51-110">Dies ist normalerweise kein Gewünschtes Verhalten.</span><span class="sxs-lookup"><span data-stu-id="cbe51-110">This usually is not desired behavior.</span></span>  <span data-ttu-id="cbe51-111">Sie wird nur für die Fälle bereitgestellt, in denen der Client weiß, dass die neue Buildanforderung nicht vom Projektzustand abhängt, der von einer vorherigen Anforderung generiert wurde.</span><span class="sxs-lookup"><span data-stu-id="cbe51-111">It is only provided for those cases where the client knows that the new build request does not depend on project state generated by a previous request.</span></span>  <span data-ttu-id="cbe51-112">Wenn Sie dieses Flag festlegen, kann dies zu einer Leistungssteigerung bei nicht kompatiblen Knoten Affinitäten führt, da MSBuild andernfalls den Projektstatus von einem Knoten zu einem anderen serialisieren müsste. Dies kann in Abhängigkeit von der Menge der Daten, die das Projekt zuvor generiert hat, teuer sein.</span><span class="sxs-lookup"><span data-stu-id="cbe51-112">Setting this flag can provide a performance boost in the case of incompatible node affinities, as MSBuild would otherwise have to serialize the project state from one node to another, which may be expensive depending on how much data the project previously generated.</span></span>
            
<span data-ttu-id="cbe51-113">Dieses Flag hat keine Auswirkungen auf die Ziel Ergebnisse. Wenn also bereits eine vorherige Anforderung ein Ziel erstellt hat, wird die neue Anforderung nicht neu erstellt (und es werden auch keine der Projekt Zustands Mutationen erstellt, die zuvor als Folge der Erstellung dieses Ziels aufgetreten sind).</span><span class="sxs-lookup"><span data-stu-id="cbe51-113">This flag has no effect on target results, so if a previous request already built a target, the new request will not re-build that target (nor will any of the project state mutations which previously occurred as a consequence of building that target be re-applied.)</span></span></remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreMissingEmptyAndInvalidImports">
      <MemberSignature Language="C#" Value="IgnoreMissingEmptyAndInvalidImports" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Execution.BuildRequestDataFlags IgnoreMissingEmptyAndInvalidImports = int32(64)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Execution.BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports" />
      <MemberSignature Language="VB.NET" Value="IgnoreMissingEmptyAndInvalidImports" />
      <MemberSignature Language="C++ CLI" Value="IgnoreMissingEmptyAndInvalidImports" />
      <MemberSignature Language="F#" Value="IgnoreMissingEmptyAndInvalidImports = 64" Usage="Microsoft.Build.Execution.BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.BuildRequestDataFlags</ReturnType>
      </ReturnValue>
      <MemberValue>64</MemberValue>
      <Docs>
        <summary><span data-ttu-id="cbe51-114">Wenn dieses Flag vorhanden ist, ignorieren Projekte, die während der Erstellung des Builds geladen werden, fehlende Importe (<see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreMissingImports" /> und <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreInvalidImports" />).</span><span class="sxs-lookup"><span data-stu-id="cbe51-114">When this flag is present, projects loaded during build will ignore missing imports (<see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreMissingImports" /> and <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreInvalidImports" />).</span></span>
<span data-ttu-id="cbe51-115">Dies ist besonders nützlich während einer Wiederherstellung, da einige Importe aus Paketen stammen könnten, die noch nicht wiederhergestellt wurden.</span><span class="sxs-lookup"><span data-stu-id="cbe51-115">This is especially useful during a restore since some imports might come from packages that haven't been restored yet.</span></span></summary>
      </Docs>
    </Member>
    <Member MemberName="None">
      <MemberSignature Language="C#" Value="None" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Execution.BuildRequestDataFlags None = int32(0)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Execution.BuildRequestDataFlags.None" />
      <MemberSignature Language="VB.NET" Value="None" />
      <MemberSignature Language="C++ CLI" Value="None" />
      <MemberSignature Language="F#" Value="None = 0" Usage="Microsoft.Build.Execution.BuildRequestDataFlags.None" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.BuildRequestDataFlags</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary><span data-ttu-id="cbe51-116">Keine Flags.</span><span class="sxs-lookup"><span data-stu-id="cbe51-116">No flags.</span></span></summary>
      </Docs>
    </Member>
    <Member MemberName="ProvideProjectStateAfterBuild">
      <MemberSignature Language="C#" Value="ProvideProjectStateAfterBuild" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Execution.BuildRequestDataFlags ProvideProjectStateAfterBuild = int32(2)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild" />
      <MemberSignature Language="VB.NET" Value="ProvideProjectStateAfterBuild" />
      <MemberSignature Language="C++ CLI" Value="ProvideProjectStateAfterBuild" />
      <MemberSignature Language="F#" Value="ProvideProjectStateAfterBuild = 2" Usage="Microsoft.Build.Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.BuildRequestDataFlags</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary><span data-ttu-id="cbe51-117">Wenn dieses Flag vorhanden ist, enthält das <see cref="T:Microsoft.Build.Execution.BuildResult" />, das als Antwort auf diese Anforderung ausgegeben wird, <see cref="P:Microsoft.Build.Execution.BuildResult.ProjectStateAfterBuild" />.</span><span class="sxs-lookup"><span data-stu-id="cbe51-117">When this flag is present, the <see cref="T:Microsoft.Build.Execution.BuildResult" /> issued in response to this request will include <see cref="P:Microsoft.Build.Execution.BuildResult.ProjectStateAfterBuild" />.</span></span></summary>
      </Docs>
    </Member>
    <Member MemberName="ProvideSubsetOfStateAfterBuild">
      <MemberSignature Language="C#" Value="ProvideSubsetOfStateAfterBuild" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Execution.BuildRequestDataFlags ProvideSubsetOfStateAfterBuild = int32(32)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Execution.BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild" />
      <MemberSignature Language="VB.NET" Value="ProvideSubsetOfStateAfterBuild" />
      <MemberSignature Language="C++ CLI" Value="ProvideSubsetOfStateAfterBuild" />
      <MemberSignature Language="F#" Value="ProvideSubsetOfStateAfterBuild = 32" Usage="Microsoft.Build.Execution.BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.BuildRequestDataFlags</ReturnType>
      </ReturnValue>
      <MemberValue>32</MemberValue>
      <Docs>
        <summary><span data-ttu-id="cbe51-118">Wenn dieses Flag vorhanden ist, enthält das als Antwort auf diese Anforderung ausgestellte <see cref="T:Microsoft.Build.Execution.BuildResult" /> einen <see cref="P:Microsoft.Build.Execution.BuildResult.ProjectStateAfterBuild" />, der NUR die explizit angeforderten Eigenschaften, Elemente und Metadaten enthält.</span><span class="sxs-lookup"><span data-stu-id="cbe51-118">When this flag is present, the <see cref="T:Microsoft.Build.Execution.BuildResult" /> issued in response to this request will include a <see cref="P:Microsoft.Build.Execution.BuildResult.ProjectStateAfterBuild" /> that includes ONLY the explicitly-requested properties, items, and metadata.</span></span></summary>
      </Docs>
    </Member>
    <Member MemberName="ReplaceExistingProjectInstance">
      <MemberSignature Language="C#" Value="ReplaceExistingProjectInstance" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Execution.BuildRequestDataFlags ReplaceExistingProjectInstance = int32(1)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Execution.BuildRequestDataFlags.ReplaceExistingProjectInstance" />
      <MemberSignature Language="VB.NET" Value="ReplaceExistingProjectInstance" />
      <MemberSignature Language="C++ CLI" Value="ReplaceExistingProjectInstance" />
      <MemberSignature Language="F#" Value="ReplaceExistingProjectInstance = 1" Usage="Microsoft.Build.Execution.BuildRequestDataFlags.ReplaceExistingProjectInstance" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.BuildRequestDataFlags</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary><span data-ttu-id="cbe51-119">Wenn dieses Flag vorhanden ist, wird die vorhandene ProjectInstance im Build durch dieses ersetzt.</span><span class="sxs-lookup"><span data-stu-id="cbe51-119">When this flag is present, the existing ProjectInstance in the build will be replaced by this one.</span></span></summary>
      </Docs>
    </Member>
    <Member MemberName="SkipNonexistentTargets">
      <MemberSignature Language="C#" Value="SkipNonexistentTargets" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Execution.BuildRequestDataFlags SkipNonexistentTargets = int32(16)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Execution.BuildRequestDataFlags.SkipNonexistentTargets" />
      <MemberSignature Language="VB.NET" Value="SkipNonexistentTargets" />
      <MemberSignature Language="C++ CLI" Value="SkipNonexistentTargets" />
      <MemberSignature Language="F#" Value="SkipNonexistentTargets = 16" Usage="Microsoft.Build.Execution.BuildRequestDataFlags.SkipNonexistentTargets" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.BuildRequestDataFlags</ReturnType>
      </ReturnValue>
      <MemberValue>16</MemberValue>
      <Docs>
        <summary><span data-ttu-id="cbe51-120">Wenn dieses Flag vorhanden ist, werden die Ziele auf oberster Ebene in der Buildanforderung übersprungen, sofern diese Ziele nicht im zu erstellenden Projekt definiert sind.</span><span class="sxs-lookup"><span data-stu-id="cbe51-120">When this flag is present, the top level target(s) in the build request will be skipped if those targets are not defined in the Project to build.</span></span> <span data-ttu-id="cbe51-121">Dies gilt nur für diese Buildanforderung (wenn ein anderes Ziel das „fehlende Ziel“ an einer anderen Stelle aufruft, führt dies nach wie vor zu einem Fehler).</span><span class="sxs-lookup"><span data-stu-id="cbe51-121">This only applies to this build request (if another target calls the "missing target" at any other point this will still result in an error).</span></span></summary>
      </Docs>
    </Member>
  </Members>
</Type>
