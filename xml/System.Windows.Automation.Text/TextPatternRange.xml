<Type Name="TextPatternRange" FullName="System.Windows.Automation.Text.TextPatternRange">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="04b05150fd153351bd0d4d4a5be88cb75ea6b5f8" />
    <Meta Name="ms.sourcegitcommit" Value="9dda17222b9f7d3edf130133bfb1370d5b410a4b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="09/22/2018" />
    <Meta Name="ms.locfileid" Value="46616847" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TextPatternRange" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextPatternRange extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Automation.Text.TextPatternRange" />
  <TypeSignature Language="VB.NET" Value="Public Class TextPatternRange" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextPatternRange" />
  <TypeSignature Language="F#" Value="type TextPatternRange = class" />
  <AssemblyInfo>
    <AssemblyName>UIAutomationClient</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt einen Abschnitt fortlaufenden Texts in einem <see cref="T:System.Windows.Automation.TextPattern" />-Container dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Automation.Text.TextPatternRange> darstellen kann, eine Einfügemarke, eine Teilmenge oder aller der Text in einem <xref:System.Windows.Automation.TextPattern> Container.  
  
 Ein <xref:System.Windows.Automation.Text.TextPatternRange> werden ungültig, wenn eine der folgenden Bedingungen zutrifft: der Text in die <xref:System.Windows.Automation.TextPattern> Container Änderungen aufgrund einer Benutzeraktivität, oder die <xref:System.Windows.Automation.ValuePattern.SetValue%2A> -Methode der <xref:System.Windows.Automation.ValuePattern> wird verwendet, um den Wert des Texts in der programmgesteuertzuändern<xref:System.Windows.Automation.TextPattern> Container.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Automation.Provider.ITextRangeProvider" />
    <related type="Article" href="~/docs/framework/ui-automation/ui-automation-control-patterns-overview.md">Übersicht über Steuerelementmuster für Benutzeroberflächenautomatisierung</related>
    <related type="Article" href="~/docs/framework/ui-automation/ui-automation-control-patterns-for-clients.md">Steuerelementmuster für Benutzeroberflächenautomatisierung für Clients</related>
  </Docs>
  <Members>
    <Member MemberName="AddToSelection">
      <MemberSignature Language="C#" Value="public void AddToSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.AddToSelection" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddToSelection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddToSelection();" />
      <MemberSignature Language="F#" Value="member this.AddToSelection : unit -&gt; unit" Usage="textPatternRange.AddToSelection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fügt Elemente zur Auflistung markierter Textbereiche in einem Textcontainer hinzu, der mehrere, nicht zusammenhängende Auswahlbereiche unterstützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Einfügemarke bewegt sich in den Bereich der neuen Auswahl.  
  
 Einen degenerierten Textbereich bereitstellen Verschiebt die Einfügemarke.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wenn der Textanbieter mehrere, nicht zusammenhängende Auswahlbereiche nicht unterstützt (z. B. muss <see cref="P:System.Windows.Automation.TextPattern.SupportedTextSelection" /> den Wert <see langword="Multiple" /> aufweisen).</exception>
        <altmember cref="M:System.Windows.Automation.Text.TextPatternRange.Select" />
        <altmember cref="M:System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection" />
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Text.TextPatternRange Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.Text.TextPatternRange Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As TextPatternRange" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::Text::TextPatternRange ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Automation.Text.TextPatternRange" Usage="textPatternRange.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Text.TextPatternRange</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen neuen <see cref="T:System.Windows.Automation.Text.TextPatternRange" /> ab, der mit dem ursprünglichen <see cref="T:System.Windows.Automation.Text.TextPatternRange" /> identisch ist und dessen sämtliche Eigenschaften erbt.</summary>
        <returns>Der neue Textbereich. Ein NULL-Verweis (<see langword="Nothing" /> in Visual Basic) wird nie zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alternativ dazu erstellen Sie ein neues <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> aus der <xref:System.Windows.Automation.TextPattern> und verschieben Sie die beiden Endpunkte mit den Endpunkten des ursprünglichen Textbereichs entspricht.  
  
 Der neue Bereich kann aus der ursprünglichen unabhängig voneinander bearbeitet werden.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1060](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1060)]  
  
 [!code-vb[UIATextPattern_snip#2060](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2060)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <altmember cref="M:System.Windows.Automation.TextPattern.RangeFromChild(System.Windows.Automation.AutomationElement)" />
        <altmember cref="M:System.Windows.Automation.TextPattern.RangeFromPoint(System.Windows.Point)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public bool Compare (System.Windows.Automation.Text.TextPatternRange range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Compare(class System.Windows.Automation.Text.TextPatternRange range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Compare(System.Windows.Automation.Text.TextPatternRange)" />
      <MemberSignature Language="VB.NET" Value="Public Function Compare (range As TextPatternRange) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Compare(System::Windows::Automation::Text::TextPatternRange ^ range);" />
      <MemberSignature Language="F#" Value="member this.Compare : System.Windows.Automation.Text.TextPatternRange -&gt; bool" Usage="textPatternRange.Compare range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Windows.Automation.Text.TextPatternRange" />
      </Parameters>
      <Docs>
        <param name="range">Ein Textbereich für den Vergleich.</param>
        <summary>Gibt einen <see cref="T:System.Boolean" />-Wert zurück, der angibt, ob der Textabschnitt (<see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" />-Endpunkt bis <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" />-Endpunkt) mit einem anderen Textabschnitt identisch ist.</summary>
        <returns>
          <see langword="true" />, wenn beide Textabschnitte identisch sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1061](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1061)]  
  
 [!code-vb[UIATextPattern_snip#2061](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2061)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wenn der zu vergleichende Bereich nicht vom gleichen Textanbieter stammt.</exception>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="CompareEndpoints">
      <MemberSignature Language="C#" Value="public int CompareEndpoints (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextPatternRange targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareEndpoints(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, class System.Windows.Automation.Text.TextPatternRange targetRange, valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareEndpoints (endpoint As TextPatternRangeEndpoint, targetRange As TextPatternRange, targetEndpoint As TextPatternRangeEndpoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareEndpoints(System::Windows::Automation::Text::TextPatternRangeEndpoint endpoint, System::Windows::Automation::Text::TextPatternRange ^ targetRange, System::Windows::Automation::Text::TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="F#" Value="member this.CompareEndpoints : System.Windows.Automation.Text.TextPatternRangeEndpoint * System.Windows.Automation.Text.TextPatternRange * System.Windows.Automation.Text.TextPatternRangeEndpoint -&gt; int" Usage="textPatternRange.CompareEndpoints (endpoint, targetRange, targetEndpoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="targetRange" Type="System.Windows.Automation.Text.TextPatternRange" />
        <Parameter Name="targetEndpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Parameters>
      <Docs>
        <param name="endpoint">Der <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" />-Endpunkt oder der <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" />-Endpunkt des Aufrufers.</param>
        <param name="targetRange">Der Zielbereich für den Vergleich.</param>
        <param name="targetEndpoint">Der <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" />-Endpunkt oder der <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" />-Endpunkt des Ziels.</param>
        <summary>Gibt ein <see cref="T:System.Int32" /> zurück, das angibt, ob zwei Textbereiche identische Endpunkte besitzen.</summary>
        <returns>Gibt einen negativen Wert zurück, wenn der Endpunkt des Aufrufers im Text vor dem Zielendpunkt liegt.  
  
Gibt 0 (null) zurück, wenn der Endpunkt des Aufrufers an derselben Position wie der Zielendpunkt liegt.  
  
Gibt einen positiven Wert zurück, wenn der Endpunkt des Aufrufers im Text nach dem Zielendpunkt liegt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch die Anfangs- und Endposition Endpunkte für den gleichen Textbereich vergleichen können Sie ermitteln, wenn ein Textbereich degenerierte ist oder die Endpunkte in der Reihenfolge der logischen Textfluss sind.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1062](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1062)]  
  
 [!code-vb[UIATextPattern_snip#2062](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2062)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wenn der Bereich ein NULL-Verweis (<see langword="Nothing" /> in Visual Basic) ist.</exception>
        <exception cref="T:System.ArgumentException">Wenn der Bereich aus einem anderen Container stammt.</exception>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="ExpandToEnclosingUnit">
      <MemberSignature Language="C#" Value="public void ExpandToEnclosingUnit (System.Windows.Automation.Text.TextUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExpandToEnclosingUnit(valuetype System.Windows.Automation.Text.TextUnit unit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExpandToEnclosingUnit (unit As TextUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExpandToEnclosingUnit(System::Windows::Automation::Text::TextUnit unit);" />
      <MemberSignature Language="F#" Value="member this.ExpandToEnclosingUnit : System.Windows.Automation.Text.TextUnit -&gt; unit" Usage="textPatternRange.ExpandToEnclosingUnit unit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
      </Parameters>
      <Docs>
        <param name="unit">Die Texteinheit.</param>
        <summary>Erweitert den Textbereich auf die angegebene <see cref="T:System.Windows.Automation.Text.TextUnit" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es bleibt unverändert, wenn der Bereich bereits eine genaue Anzahl der angegebenen Einheiten.  
  
 In der Reihenfolge für die <xref:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit%2A> Methode erfolgreich ausgeführt wird eine Sequenz von Aktionen im Hintergrund ausgeführt.  
  
1.  Der Textbereich ist normalisiert; also wird der Textbereich auf einen degenerierten Bereich am reduziert die <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> Endpunkt vornehmen der <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> -Endpunkt überflüssig. Dieser Schritt ist erforderlich, um Mehrdeutigkeit in Situationen, in denen ein Textbereich umfasst `unit` Grenzen, z. B. "{die U} RL [ https://www.microsoft.com/ ](https://www.microsoft.com/) ist in den Text eingebettet", "{" und "}" werden der Text Endpunkte des Textbereichs.  
  
2.  Der resultierende Bereich wird im <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> zurück an den Anfang der angeforderten `unit`-Grenze verschoben.  
  
3.  Der Bereich wird um die angeforderte Anzahl von <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>-Grenzen nach vorne oder nach hinten im `unit` verschoben.  
  
4.  Anschließend wird der Bereich von einem degenerierten Bereichszustand erweitert, indem der <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End>-Endpunkt um eine angeforderte `unit`-Grenze verschoben wird.  
  
 ![Bereichsberichtigung durch Move und ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "Bereichsberichtigung durch Move und ExpandToEnclosingUnit")  
Beispiele für die Anpassung eines Textbereichs für Move() und ExpandToEnclosingUnit()  
  
> [!NOTE]
>  Diese Schritte sind erforderlich, da es üblich, dass eine Sprachausgabe eine vollständigen Worts, den Satz oder die gesamte Absatz an der Einfügemarke oder virtuellen Cursorposition zu lesen ist.  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit%2A> berücksichtigt ausgeblendeten und sichtbaren Text. Der Benutzeroberflächenautomatisierungs-Client sehen die <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> für die Sichtbarkeit von Text.  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit%2A> verzögert die nächste größten <xref:System.Windows.Automation.Text.TextUnit> unterstützten If der angegebenen <xref:System.Windows.Automation.Text.TextUnit> wird vom Steuerelement nicht unterstützt.  
  
 Die Reihenfolge, von der kleinsten Einheit aufsteigend, sind unten aufgeführt.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1063](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1063)]  
  
 [!code-vb[UIATextPattern_snip#2063](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2063)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="FindAttribute">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Text.TextPatternRange FindAttribute (System.Windows.Automation.AutomationTextAttribute attribute, object value, bool backward);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.Text.TextPatternRange FindAttribute(class System.Windows.Automation.AutomationTextAttribute attribute, object value, bool backward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.FindAttribute(System.Windows.Automation.AutomationTextAttribute,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAttribute (attribute As AutomationTextAttribute, value As Object, backward As Boolean) As TextPatternRange" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::Text::TextPatternRange ^ FindAttribute(System::Windows::Automation::AutomationTextAttribute ^ attribute, System::Object ^ value, bool backward);" />
      <MemberSignature Language="F#" Value="member this.FindAttribute : System.Windows.Automation.AutomationTextAttribute * obj * bool -&gt; System.Windows.Automation.Text.TextPatternRange" Usage="textPatternRange.FindAttribute (attribute, value, backward)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Text.TextPatternRange</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Windows.Automation.AutomationTextAttribute" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="backward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attribute">Das zu suchende Attribut.</param>
        <param name="value">Der zu suchende Attributwert. Dieser Wert mit dem für das Attribut angegebenen Typ übereinstimmen.</param>
        <param name="backward">
          <see langword="true" />, wenn statt dem ersten der letzte vorhandene Textbereich zurückgegeben werden soll, andernfalls <see langword="false" />.</param>
        <summary>Gibt den Teil des Textbereichs zurück, der den angegebenen Attributwert aufweist.</summary>
        <returns>Ein Textbereich mit einem entsprechenden Attribut und Attributwert, andernfalls NULL (<see langword="Nothing" /> in Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es wird keine Differenzierung zwischen verborgenen und sichtbaren Text. Benutzeroberflächenautomatisierungs-Clients können <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> Text Sichtbarkeit zu überprüfen.  
  
> [!NOTE]
>  Verwendung <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> um das gesamte Dokument zu suchen.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1064](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1064)]  
  
 [!code-vb[UIATextPattern_snip#2064](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2064)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Automation.TextPattern" />
      </Docs>
    </Member>
    <Member MemberName="FindText">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Text.TextPatternRange FindText (string text, bool backward, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.Text.TextPatternRange FindText(string text, bool backward, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.FindText(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindText (text As String, backward As Boolean, ignoreCase As Boolean) As TextPatternRange" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::Text::TextPatternRange ^ FindText(System::String ^ text, bool backward, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="member this.FindText : string * bool * bool -&gt; System.Windows.Automation.Text.TextPatternRange" Usage="textPatternRange.FindText (text, backward, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Text.TextPatternRange</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="backward" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="text">Die zu suchende Textzeichenfolge.</param>
        <param name="backward">
          <see langword="true" />, wenn statt dem ersten der letzte vorhandene Textbereich zurückgegeben werden soll, andernfalls <see langword="false" />.</param>
        <param name="ignoreCase">
          <see langword="true" />, wenn die Groß-/Kleinschreibung ignoriert werden soll, andernfalls <see langword="false" />.</param>
        <summary>Gibt den Teil des Textbereichs zurück, der den angegebenen Text enthält.</summary>
        <returns>Ein Textbereich, der mit dem angegebenen Text übereinstimmt, andernfalls NULL (<see langword="Nothing" /> in Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es wird keine Differenzierung zwischen verborgenen und sichtbaren Text. Benutzeroberflächenautomatisierungs-Clients können <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> Text Sichtbarkeit zu überprüfen.  
  
> [!NOTE]
>  Verwendung <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> um das gesamte Dokument zu suchen.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1065](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1065)]  
  
 [!code-vb[UIATextPattern_snip#2065](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2065)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Automation.TextPattern" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeValue">
      <MemberSignature Language="C#" Value="public object GetAttributeValue (System.Windows.Automation.AutomationTextAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetAttributeValue(class System.Windows.Automation.AutomationTextAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(System.Windows.Automation.AutomationTextAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttributeValue (attribute As AutomationTextAttribute) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetAttributeValue(System::Windows::Automation::AutomationTextAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="member this.GetAttributeValue : System.Windows.Automation.AutomationTextAttribute -&gt; obj" Usage="textPatternRange.GetAttributeValue attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Windows.Automation.AutomationTextAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Das Textattribut.</param>
        <summary>Gibt den Wert des angegebenen Attributs für den gesamten Textbereich zurück.</summary>
        <returns>Gibt den Wert des angegebenen Attributs zurück. Zum Beispiel gibt „GetAttributeValue(TextPattern.FontNameAttribute)“ eine Zeichenfolge zurück, die den Schriftartnamen für den Textbereich darstellt, sofern dieser eindeutig ist, während „GetAttributeValue(TextPattern.IsItalicAttribute)“ einen booleschen Wert zurückgibt.  
  
Gibt <see cref="F:System.Windows.Automation.TextPattern.MixedAttributeValue" /> zurück, wenn sich der Wert des angegebenen Attributs im Verlauf des Textbereichs ändert.  
  
Gibt <see cref="F:System.Windows.Automation.AutomationElement.NotSupported" /> zurück, wenn das angegebene Attribut vom Anbieter oder Steuerelement nicht unterstützt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es wird keine Differenzierung zwischen verborgenen und sichtbaren Text. Benutzeroberflächenautomatisierungs-Clients können <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> Text Sichtbarkeit zu überprüfen.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1066](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1066)]  
  
 [!code-vb[UIATextPattern_snip#2066](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2066)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wenn das angegebene Attribut nicht gültig ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBoundingRectangles">
      <MemberSignature Language="C#" Value="public System.Windows.Rect[] GetBoundingRectangles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect[] GetBoundingRectangles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBoundingRectangles () As Rect()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Windows::Rect&gt; ^ GetBoundingRectangles();" />
      <MemberSignature Language="F#" Value="member this.GetBoundingRectangles : unit -&gt; System.Windows.Rect[]" Usage="textPatternRange.GetBoundingRectangles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft für jede vollständig oder teilweise sichtbare Textzeile in einem Textbereich eine Auflistung von umgebenden Rechtecken ab.</summary>
        <returns>Ein Array von umgebenden Rechtecken für jede vollständige oder unvollständige Textzeile in einem Textbereich.  
  
Ein leeres Array für einen degenerierten Textbereich.  
  
Ein leeres Array für einen Textbereich mit Bildschirmkoordinaten, die vollständig außerhalb des Bildschirms liegen, sich durch einen Bildlauf außerhalb des sichtbaren Bereichs befinden oder von einem überlappenden Fenster verdeckt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1067](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1067)]  
  
 [!code-vb[UIATextPattern_snip#2067](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2067)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChildren">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.AutomationElement[] GetChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.AutomationElement[] GetChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetChildren" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildren () As AutomationElement()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Windows::Automation::AutomationElement ^&gt; ^ GetChildren();" />
      <MemberSignature Language="F#" Value="member this.GetChildren : unit -&gt; System.Windows.Automation.AutomationElement[]" Usage="textPatternRange.GetChildren " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.AutomationElement[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine Auflistung aller eingebetteten Objekte ab, die innerhalb des Textbereichs liegen.</summary>
        <returns>Eine Auflistung aller untergeordneten Objekte, die innerhalb des Bereichs liegen. Untergeordnete Elemente, die sich mit dem Bereich überlappen, von diesem jedoch nicht vollständig umschlossen sind, werden in der Auflistung ebenfalls aufgeführt.  
  
Gibt eine leere Auflistung zurück, wenn keine untergeordneten Objekte vorhanden sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#StartTarget](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#starttarget)]
 [!code-vb[UIATextPattern_snip#StartTarget](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#starttarget)]  
[!code-csharp[UIATextPattern_snip#GetTextElement](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#gettextelement)]
[!code-vb[UIATextPattern_snip#GetTextElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#gettextelement)]  
[!code-csharp[UIATextPattern_snip#GetEmbeddedObjects](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#getembeddedobjects)]
[!code-vb[UIATextPattern_snip#GetEmbeddedObjects](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#getembeddedobjects)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnclosingElement">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.AutomationElement GetEnclosingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.AutomationElement GetEnclosingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnclosingElement () As AutomationElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::AutomationElement ^ GetEnclosingElement();" />
      <MemberSignature Language="F#" Value="member this.GetEnclosingElement : unit -&gt; System.Windows.Automation.AutomationElement" Usage="textPatternRange.GetEnclosingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.AutomationElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt das innerste <see cref="T:System.Windows.Automation.AutomationElement" /> zurück, das den Textbereich einschließt.</summary>
        <returns>Das innerste Element, das den Aufrufer einschließt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die einschließende <xref:System.Windows.Automation.AutomationElement>, i. d. r. der Textanbieter, der den Textbereich bereitstellt. Wenn der Textanbieter jedoch untergeordnete Elemente unterstützt, z. B. Tabellen oder Links, kann das umschließende Element ein Nachfolgerelement des Textanbieters darstellen.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1069](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1069)]  
  
 [!code-vb[UIATextPattern_snip#2069](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2069)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetText">
      <MemberSignature Language="C#" Value="public string GetText (int maxLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetText(int32 maxLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetText(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetText (maxLength As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetText(int maxLength);" />
      <MemberSignature Language="F#" Value="member this.GetText : int -&gt; string" Usage="textPatternRange.GetText maxLength" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxLength">Die maximale Länge der zurückzugebenden Zeichenfolge. Verwenden Sie <c>–1</c>, wenn keine Grenze erforderlich ist.</param>
        <summary>Gibt den reinen Text des Textbereichs zurück.</summary>
        <returns>Der reine Text des Textbereichs, möglicherweise an der angegebenen <paramref name="maxLength" /> abgeschnitten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Automation.Text.TextPatternRange.GetText%2A> berücksichtigt ausgeblendeten und sichtbaren Text. Der Benutzeroberflächenautomatisierungs-Client sehen die <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> für die Sichtbarkeit von Text.  
  
 Wenn `maxLength` ist größer als die Länge des Textabschnitts des Aufrufers, werden die zurückgegebene Zeichenfolge den nur-Text des Textbereichs.  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.GetText%2A> wird nicht durch die Reihenfolge der Endpunkte in den Textfluss beeinflusst. den Text wird zwischen die Start- und Endpunkte des Textbereichs in der Reihenfolge der logischen Text Fluss immer zurückgegeben.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1070](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1070)]  
  
 [!code-vb[UIATextPattern_snip#2070](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2070)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wenn <paramref name="maxLength" /> kleiner als -1 ist.</exception>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public int Move (System.Windows.Automation.Text.TextUnit unit, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Move(valuetype System.Windows.Automation.Text.TextUnit unit, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Move(System.Windows.Automation.Text.TextUnit,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Move (unit As TextUnit, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Move(System::Windows::Automation::Text::TextUnit unit, int count);" />
      <MemberSignature Language="F#" Value="member this.Move : System.Windows.Automation.Text.TextUnit * int -&gt; int" Usage="textPatternRange.Move (unit, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="unit">Die Grenze der Texteinheit.</param>
        <param name="count">Die Anzahl von Texteinheiten, um die der Textbereich verschoben werden soll. Bei einem positiven Wert wird der Textbereich vorwärts verschoben, bei einem negativen Wert wird der Textbereich rückwärts verschoben. Der Wert 0 (null) hat keine Auswirkungen.</param>
        <summary>Verschiebt den Textbereich um die festgelegte Anzahl von Texteinheiten.</summary>
        <returns>Die Anzahl von Einheiten, um die der Textbereich tatsächlich verschoben wurde. Diese kann unterhalb der angeforderten Anzahl liegen, wenn einer der neuen Textbereichsendpunkte größer oder kleiner als der jeweilige <see cref="P:System.Windows.Automation.TextPattern.DocumentRange" />-Endpunkt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Inhalt eines Textbereichs durchlaufen werden muss, ist eine Reihe von Hintergrundschritten erforderlich, um die <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> -Methode erfolgreich auszuführen.  
  
1.  Der Textbereich ist normalisiert. Dies bedeutet, dass dieser auf einen degenerierten Bereich am <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> -Endpunkt reduziert ist, wodurch der <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> -Endpunkt überflüssig wird. Dieser Schritt ist erforderlich, um Mehrdeutigkeit in Situationen, in denen ein Textbereich umfasst `unit` Grenzen, z. B. "{die U} RL [ https://www.microsoft.com/ ](https://www.microsoft.com/) ist in den Text eingebettet", "{" und "}" werden der Text Endpunkte des Textbereichs.  
  
2.  Der resultierende Bereich wird im <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> zurück an den Anfang der angeforderten `unit`-Grenze verschoben.  
  
3.  Der Bereich wird um die angeforderte Anzahl von <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>-Grenzen nach vorne oder nach hinten im `unit` verschoben.  
  
4.  Anschließend wird der Bereich von einem degenerierten Bereichszustand erweitert, indem der <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End>-Endpunkt um eine angeforderte `unit`-Grenze verschoben wird.  
  
 ![Bereichsberichtigung durch Move und ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "Bereichsberichtigung durch Move und ExpandToEnclosingUnit")  
Beispiele für die Anpassung eines Textbereichs für Move() und ExpandToEnclosingUnit()  
  
 Der Textinhalt (oder innere Text) eines Textcontainers und ein eingebettetes Objekt, z. B. ein Link oder eine Tabellenzelle, werden in der Steuerelementansicht und der Inhaltsansicht der [!INCLUDE[TLA2#tla_uiautomation](~/includes/tla2sharptla-uiautomation-md.md)]-Struktur als einzelner, kontinuierlicher Textstream verfügbar gemacht, Objektgrenzen werden dabei ignoriert.  Wenn ein Benutzeroberflächenautomatisierungs-Client den Text abruft, um ihn zu lesen, zu interpretieren oder zu analysieren, sollte der Textbereich auf bestimmte Fälle überprüft werden, z. B. auf Tabellen mit Textinhalt oder andere eingebettete Objekte. Dies kann erreicht werden, durch den Aufruf <xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A> zum Abrufen einer <xref:System.Windows.Automation.AutomationElement> für jedes Objekt und dem anschließenden Aufrufen eingebettete <xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> um einen Textbereich für jedes Element zu erhalten. Dies erfolgt rekursiv, bis der gesamte Textinhalt abgerufen wurde.  
  
 ![Textbereiche von eingebetteten Objekten. ] (~/add/media/uia-textpattern-embeddedobjecttextranges.png "Von eingebetteten Objekten umfasste Textbereiche.")  
Beispiel für einen Textstream mit eingebetteten Objekten und deren Bereichsabschnitten  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> berücksichtigt ausgeblendeten und sichtbaren Text. Der Benutzeroberflächenautomatisierungs-Client sehen die <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> für die Sichtbarkeit von Text.  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> verzögert die nächste größten <xref:System.Windows.Automation.Text.TextUnit> unterstützten If der angegebenen <xref:System.Windows.Automation.Text.TextUnit> wird vom Steuerelement nicht unterstützt.  
  
 Die Reihenfolge, von der kleinsten Einheit aufsteigend, sind unten aufgeführt.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
> [!NOTE]
>  Der Text wird nicht in keiner Weise geändert, wie der Bereich des Texts lediglich einen anderen Teil des Texts umfasst.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#StartTarget](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#starttarget)]
 [!code-vb[UIATextPattern_snip#StartTarget](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#starttarget)]  
[!code-csharp[UIATextPattern_snip#GetTextElement](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#gettextelement)]
[!code-vb[UIATextPattern_snip#GetTextElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#gettextelement)]  
[!code-csharp[UIATextPattern_snip#MoveSelection](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#moveselection)]
[!code-vb[UIATextPattern_snip#MoveSelection](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#moveselection)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="MoveEndpointByRange">
      <MemberSignature Language="C#" Value="public void MoveEndpointByRange (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextPatternRange targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveEndpointByRange(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, class System.Windows.Automation.Text.TextPatternRange targetRange, valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveEndpointByRange (endpoint As TextPatternRangeEndpoint, targetRange As TextPatternRange, targetEndpoint As TextPatternRangeEndpoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveEndpointByRange(System::Windows::Automation::Text::TextPatternRangeEndpoint endpoint, System::Windows::Automation::Text::TextPatternRange ^ targetRange, System::Windows::Automation::Text::TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="F#" Value="member this.MoveEndpointByRange : System.Windows.Automation.Text.TextPatternRangeEndpoint * System.Windows.Automation.Text.TextPatternRange * System.Windows.Automation.Text.TextPatternRangeEndpoint -&gt; unit" Usage="textPatternRange.MoveEndpointByRange (endpoint, targetRange, targetEndpoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="targetRange" Type="System.Windows.Automation.Text.TextPatternRange" />
        <Parameter Name="targetEndpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Parameters>
      <Docs>
        <param name="endpoint">Der zu verschiebende Endpunkt.</param>
        <param name="targetRange">Ein anderer Bereich vom gleichen Textanbieter.</param>
        <param name="targetEndpoint">Ein Endpunkt des anderen Bereichs.</param>
        <summary>Verschiebt einen Endpunkt eines Textbereichs an den angegebenen Endpunkt eines zweiten Textbereichs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieser Endpunkt wird ebenfalls verschoben, sodass ein degenerierter Bereich, und stellen Sie sicher, die richtige Reihenfolge der Endpunkte der verschobene Endpunkt überschreitet den anderen Endpunkt für den gleichen Textbereich (d. h. <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> ist immer kleiner als oder gleich <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End>).  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1072](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1072)]  
  
 [!code-vb[UIATextPattern_snip#2072](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2072)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveEndpointByUnit">
      <MemberSignature Language="C#" Value="public int MoveEndpointByUnit (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextUnit unit, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 MoveEndpointByUnit(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, valuetype System.Windows.Automation.Text.TextUnit unit, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveEndpointByUnit (endpoint As TextPatternRangeEndpoint, unit As TextUnit, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int MoveEndpointByUnit(System::Windows::Automation::Text::TextPatternRangeEndpoint endpoint, System::Windows::Automation::Text::TextUnit unit, int count);" />
      <MemberSignature Language="F#" Value="member this.MoveEndpointByUnit : System.Windows.Automation.Text.TextPatternRangeEndpoint * System.Windows.Automation.Text.TextUnit * int -&gt; int" Usage="textPatternRange.MoveEndpointByUnit (endpoint, unit, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="endpoint">Der zu verschiebende Endpunkt.</param>
        <param name="unit">Die zu verschiebende Texteinheit.</param>
        <param name="count">Die Anzahl der Einheiten, um die verschoben werden sollen. Eine positive Anzahl verschiebt den Endpunkt vorwärts. Eine negative Anzahl verschiebt diesen rückwärts. Der Anzahl 0 (null) hat keine Auswirkungen.</param>
        <summary>Verschiebt einen Endpunkt des Textbereichs um die festgelegte Anzahl von <see cref="T:System.Windows.Automation.Text.TextUnit" />-Einheiten innerhalb des Dokumentbereichs.</summary>
        <returns>Die Anzahl von Einheiten, um die der Endpunkt tatsächlich verschoben wurde. Diese kann kleiner als die angeforderte Anzahl sein, wenn beim Verschieben des Endpunkts der Anfang bzw. das Ende des Dokuments erreicht wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Inhalt eines Textbereichs durchlaufen werden muss, ist eine Reihe von Hintergrundschritten erforderlich, um die <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> -Methode erfolgreich auszuführen.  
  
1.  Der Textbereich ist normalisiert. Dies bedeutet, dass dieser auf einen degenerierten Bereich am <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> -Endpunkt reduziert ist, wodurch der <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> -Endpunkt überflüssig wird. Dieser Schritt ist erforderlich, um Mehrdeutigkeit in Situationen, in denen ein Textbereich umfasst `unit` Grenzen, z. B. "{die U} RL [ https://www.microsoft.com/ ](https://www.microsoft.com/) ist in den Text eingebettet", "{" und "}" werden der Text Endpunkte des Textbereichs.  
  
2.  Der resultierende Bereich wird im <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> zurück an den Anfang der angeforderten `unit`-Grenze verschoben.  
  
3.  Anschließend wird der Bereich von einem degenerierten Bereichszustand erweitert, indem der <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End>-Endpunkt um eine angeforderte `unit`-Grenze verschoben wird.  
  
 ![Bereichsberichtigung durch Move und ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "Bereichsberichtigung durch Move und ExpandToEnclosingUnit")  
Beispiele für die Anpassung eines Textbereichs für Move() und ExpandToEnclosingUnit()  
  
 Der Textinhalt (oder innere Text) eines Textcontainers und ein eingebettetes Objekt, z. B. ein Link oder eine Tabellenzelle, werden in der Steuerelementansicht und der Inhaltsansicht der [!INCLUDE[TLA2#tla_uiautomation](~/includes/tla2sharptla-uiautomation-md.md)]-Struktur als einzelner, kontinuierlicher Textstream verfügbar gemacht, Objektgrenzen werden dabei ignoriert.  Wenn ein Benutzeroberflächenautomatisierungs-Client den Text abruft, um ihn zu lesen, zu interpretieren oder zu analysieren, sollte der Textbereich auf bestimmte Fälle überprüft werden, z. B. auf Tabellen mit Textinhalt oder andere eingebettete Objekte. Dies kann erreicht werden, durch den Aufruf <xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A> zum Abrufen einer <xref:System.Windows.Automation.AutomationElement> für jedes Objekt und dem anschließenden Aufrufen eingebettete <xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> um einen Textbereich für jedes Element zu erhalten. Dies erfolgt rekursiv, bis der gesamte Textinhalt abgerufen wurde.  
  
 ![Textbereiche von eingebetteten Objekten. ] (~/add/media/uia-textpattern-embeddedobjecttextranges.png "Von eingebetteten Objekten umfasste Textbereiche.")  
Beispiel für einen Textstream mit eingebetteten Objekten und deren Bereichsabschnitten  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit%2A> verzögert die nächste größten <xref:System.Windows.Automation.Text.TextUnit> unterstützten If der angegebenen <xref:System.Windows.Automation.Text.TextUnit> wird vom Steuerelement nicht unterstützt.  
  
 Die Reihenfolge, von der kleinsten Einheit aufsteigend, sind unten aufgeführt.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1073](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1073)]  
  
 [!code-vb[UIATextPattern_snip#2073](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2073)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveFromSelection">
      <MemberSignature Language="C#" Value="public void RemoveFromSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveFromSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveFromSelection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveFromSelection();" />
      <MemberSignature Language="F#" Value="member this.RemoveFromSelection : unit -&gt; unit" Usage="textPatternRange.RemoveFromSelection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt einen markierten Textabschnitt, der dem <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" />-Endpunkt und dem <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" />-Endpunkt des aufrufenden Textbereichs entspricht, aus einer vorhandenen Auflistung markierter Textbereiche in einem Textcontainer, der mehrere, nicht zusammenhängende Auswahlbereiche unterstützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Texteinfügemarke wechselt in den Bereich der entfernten Markierung.  
  
 Einen degenerierten Textbereich bereitstellt, wird die Einfügemarke verschoben werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wenn der Textanbieter mehrere, nicht zusammenhängende Auswahlbereiche nicht unterstützt (z. B. muss <see cref="P:System.Windows.Automation.TextPattern.SupportedTextSelection" /> den Wert <see langword="Multiple" /> aufweisen).</exception>
        <altmember cref="M:System.Windows.Automation.Text.TextPatternRange.Select" />
        <altmember cref="M:System.Windows.Automation.Text.TextPatternRange.AddToSelection" />
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="ScrollIntoView">
      <MemberSignature Language="C#" Value="public void ScrollIntoView (bool alignToTop);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollIntoView(bool alignToTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollIntoView (alignToTop As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollIntoView(bool alignToTop);" />
      <MemberSignature Language="F#" Value="member this.ScrollIntoView : bool -&gt; unit" Usage="textPatternRange.ScrollIntoView alignToTop" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alignToTop" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="alignToTop">
          <see langword="true" />, wenn im Textsteuerelement ein Bildlauf so durchgeführt werden soll, dass der Textbereich am oberen Rand des Anzeigebereichs ausgerichtet ist, <see langword="false" />, wenn der Bereich am unteren Rand des Anzeigebereichs ausgerichtet werden soll.</param>
        <summary>Bewirkt, dass im Textsteuerelement ein vertikaler Bildlauf durchgeführt wird, bis der Textbereich im Anzeigebereich sichtbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Automation.Text.TextPatternRange.ScrollIntoView%2A> berücksichtigt ausgeblendeten und sichtbaren Text. Der Benutzeroberflächenautomatisierungs-Client sehen die <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> für die Sichtbarkeit von Text. Wenn der Textbereich ausgeblendet ist, wird im Textsteuerelement Bildläufe durchgeführt werden, nur, wenn die ausgeblendete Text einen Anker im Sichtbereich.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1074](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1074)]  
  
 [!code-vb[UIATextPattern_snip#2074](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2074)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wenn Bildläufe vom Steuerelement nicht unterstützt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Select" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select();" />
      <MemberSignature Language="F#" Value="member this.Select : unit -&gt; unit" Usage="textPatternRange.Select " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Markiert Text im Textsteuerelement entsprechend dem <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" />-Endpunkt und dem <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" />-Endpunkt des Textbereichs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein degenerierten Textbereich angegeben wird, wechselt die Einfügemarke in die <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> Endpunkt des Textbereichs.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1075](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1075)]  
  
 [!code-vb[UIATextPattern_snip#2075](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2075)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Tritt auf, wenn die Textauswahl nicht vom Textsteuerelement unterstützt wird.</exception>
        <altmember cref="M:System.Windows.Automation.Text.TextPatternRange.AddToSelection" />
        <altmember cref="M:System.Windows.Automation.SelectionItemPattern.RemoveFromSelection" />
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="TextPattern">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.TextPattern TextPattern { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Automation.TextPattern TextPattern" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Automation.Text.TextPatternRange.TextPattern" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TextPattern As TextPattern" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Automation::TextPattern ^ TextPattern { System::Windows::Automation::TextPattern ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TextPattern : System.Windows.Automation.TextPattern" Usage="System.Windows.Automation.Text.TextPatternRange.TextPattern" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.TextPattern</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Windows.Automation.TextPattern" /> ab, das dem Textbereich zugeordnet ist.</summary>
        <value>Der Textanbieter.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1076](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1076)]  
  
 [!code-vb[UIATextPattern_snip#2076](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2076)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>