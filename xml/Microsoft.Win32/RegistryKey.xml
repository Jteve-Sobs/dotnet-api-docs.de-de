<Type Name="RegistryKey" FullName="Microsoft.Win32.RegistryKey">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f12d6b5694266f2353c22c7a207ab1162de17894" /><Meta Name="ms.sourcegitcommit" Value="95e24aee1283af2f120fc5da4b0bdc0712ab698f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/06/2019" /><Meta Name="ms.locfileid" Value="65156018" /></Metadata><TypeSignature Language="C#" Value="public sealed class RegistryKey : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed RegistryKey extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.RegistryKey" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class RegistryKey&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class RegistryKey sealed : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type RegistryKey = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen Knoten auf Schlüsselebene in der Windows-Registrierung dar. Diese Klasse ist eine Kapselung der Registrierung.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um eine Instanz des <xref:Microsoft.Win32.RegistryKey>, verwenden Sie eine der statischen Elemente der der <xref:Microsoft.Win32.Registry> Klasse.  
  
 Die Registrierung fungiert als zentrales Repository der Informationen für das Betriebssystem und Anwendungen auf einem Computer. Die Registrierung in einem hierarchischen Format, das basierend auf einer logischen Anordnung von der darin gespeicherten Elementen angeordnet ist (finden Sie unter <xref:Microsoft.Win32.Registry> für die grundlegende Elemente in dieser Hierarchie). Wählen Sie den entsprechenden Speicherort basierend auf dem Typ des zu speichernden Informationen zum Speichern von Informationen in der Registrierung. Achten Sie darauf, um zu vermeiden, Löschen von Informationen, die von anderen Anwendungen erstellt werden, da dies dazu führen, diese Anwendungen dass kann zu unerwartetem Verhalten, und kann auch eine negative Auswirkung auf Ihre eigene Anwendung.  
  
> [!IMPORTANT]
>  Dieser Typ implementiert die <xref:System.IDisposable>-Schnittstelle. Nach Abschluss der Verwendung sollten Sie den Typ entweder direkt oder indirekt löschen. Zum direkten Löschen des Typs rufen Sie seine <xref:System.IDisposable.Dispose%2A>-Methode in einem `try`/`catch`-Block auf. Zum indirekten Löschen verwenden Sie ein Sprachkonstrukt wie `using` (in C#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt „Verwenden eines Objekts, das IDisposable implementiert“ des Themas „Die <xref:System.IDisposable>-Schnittstelle“.  
  
 Registrierungsschlüssel werden die Grundelemente einer Organisation in der Registrierung und Ordner im Datei-Explorer verglichen werden können. Ein bestimmter Schlüssel kann Unterschlüssel zu haben, wie ein Ordner, Unterordner haben kann. Jeder Schlüssel kann gelöscht werden, solange der Benutzer die entsprechenden Berechtigungen hat dazu aus, und der Schlüssel kein Basis-Schlüssel ist oder auf der Ebene direkt unter die Basisschlüssel. Jeder Schlüssel kann auch mehrere Werte, die zugeordnet (ein Wert kann in einer Datei verglichen werden), die verwendet werden, zum Speichern der Informationen – z. B. Informationen zu einer Anwendung, die auf dem Computer installiert haben. Jeder Wert enthält eine bestimmte Information, der abgerufen oder aktualisiert, wenn erforderlich. Sie können z. B. Erstellen einer <xref:Microsoft.Win32.RegistryKey> Ihres Unternehmens, unter dem Schlüssel HKEY_LOCAL_MACHINE\Software, und klicken Sie dann einen Unterschlüssel für jede Anwendung, die Ihr Unternehmen erstellt. Jeder Unterschlüssel enthält die Informationen für diese Anwendung, z. B. farbeinstellungen, Bildschirmposition und Größe oder Erweiterungen erkannt.  
  
 Beachten Sie, dass in der Registrierung gespeicherten Informationen für andere Anwendungen und Benutzer verfügbar ist, und daher nicht verwendet werden soll, sicherheitsrelevante Daten oder Informationen zu wichtigen Anwendungen zu speichern.  
  
> [!CAUTION]
>  Machen Sie nicht <xref:Microsoft.Win32.RegistryKey> Objekte so, dass ein schädliches Programm kann Tausende von bedeutungslosen Unterschlüsseln erstellen oder Schlüssel/Wert-Paare. Lassen Sie Aufrufer beliebige Schlüssel oder Werte eingeben zu, z. B. nicht.  
  
 Ab der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], die Länge eines Registrierungsschlüssels ist nicht mehr auf 255 Zeichen beschränkt.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht einen Unterschlüssel unter HKEY_CURRENT_USER erstellen, dessen Inhalt bearbeiten und löschen Sie dann auf den Unterschlüssel.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.Registry" />
    <altmember cref="T:Microsoft.Win32.RegistryHive" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="registryKey.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt den Schlüssel und schreibt diesen auf den Datenträger weg, sofern der Inhalt verändert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen dieser Methode für die Systemschlüssel wird keine Auswirkung zu haben, da Systemschlüssel niemals geschlossen werden.  
  
 Diese Methode bewirkt nichts, wenn Sie es in einer Instanz von Aufrufen `RegistryKey` , die bereits geschlossen wurde.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:Microsoft.Win32.RegistryKey> Klasse.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.Win32.RegistryKey.Flush" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateSubKey">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen neuen Unterschlüssel oder öffnet einen vorhandenen Unterschlüssel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey subkey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subkey">Name oder Pfad des zu erstellenden oder zu öffnenden Unterschlüssels. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Erstellt einen neuen Unterschlüssel oder öffnet einen vorhandenen Unterschlüssel für Schreibzugriff.</summary>
        <returns>Der neu erstellte Unterschlüssel oder <see langword="null" />, wenn bei dem Vorgang ein Fehler aufgetreten ist. Wenn eine Zeichenfolge der Länge 0 (null) für <paramref name="subkey" /> angegeben ist, wird das aktuelle <see cref="T:Microsoft.Win32.RegistryKey" />-Objekt zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um diese Aktion auszuführen, muss der Benutzer die Berechtigung, die auf dieser Ebene und darunter in der Registrierungshierarchie verfügen.  
  
> [!CAUTION]
>  Machen Sie nicht <xref:Microsoft.Win32.RegistryKey> Objekte so, dass ein schädliches Programm kann Tausende von bedeutungslosen Unterschlüsseln erstellen oder Schlüssel/Wert-Paare. Lassen Sie Aufrufer beliebige Schlüssel oder Werte eingeben zu, z. B. nicht.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht einen Unterschlüssel unter HKEY_CURRENT_USER erstellen, dessen Inhalt bearbeiten und löschen Sie dann auf den Unterschlüssel.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="subkey" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Erstellen oder Öffnen des Registrierungsschlüssels.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> auf dem diese Methode aufgerufen wird, wird geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> kann nicht geschrieben werden, z. B., dass es nicht als Schlüssel schreibgeschützt geöffnet wurde, oder der Benutzer verfügt nicht über die erforderlichen Zugriffsrechte.</exception>
        <exception cref="T:System.IO.IOException">Die Schachtelungsebene überschreitet 510.  
  
- oder -  
Ein Systemfehler ist aufgetreten. Möglicherweise wurde der Schlüssel gelöscht, oder es wurde versucht, einen Schlüssel im <see cref="F:Microsoft.Win32.Registry.LocalMachine" />-Stamm zu erstellen.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">für die Möglichkeit, den angegebenen Registrierungsschlüssel zu ändern, falls vorhanden, oder die Möglichkeit, zu dem Registrierungsschlüssel zu erstellen ist es nicht bereits vorhanden. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Bei den Zugriff auf den angegebenen Registrierungsschlüssel, wenn handelt es sich um eine remote-Schlüssel. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, permissionCheck As RegistryKeyPermissionCheck) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, permissionCheck)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="subkey">Name oder Pfad des zu erstellenden oder zu öffnenden Unterschlüssels. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="permissionCheck">Einer der Enumerationswerte, der angibt, ob der Schlüssel für Lesezugriff oder für Lese-/Schreibzugriff geöffnet wird.</param>
        <summary>Erstellt einen neuen Unterschlüssel oder öffnet einen vorhandenen Unterschlüssel für Schreibzugriff unter Verwendung der angegebenen Berechtigungsprüfungsoption.</summary>
        <returns>Der neu erstellte Unterschlüssel oder <see langword="null" />, wenn bei dem Vorgang ein Fehler aufgetreten ist. Wenn eine Zeichenfolge der Länge 0 (null) für <paramref name="subkey" /> angegeben ist, wird das aktuelle <see cref="T:Microsoft.Win32.RegistryKey" />-Objekt zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um diese Aktion auszuführen, muss der Benutzer die Berechtigung, die auf dieser Ebene und darunter in der Registrierungshierarchie verfügen.  
  
> [!CAUTION]
>  Machen Sie nicht <xref:Microsoft.Win32.RegistryKey> Objekte so, dass ein schädliches Programm kann Tausende von bedeutungslosen Unterschlüsseln erstellen oder Schlüssel/Wert-Paare. Lassen Sie Aufrufer beliebige Schlüssel oder Werte eingeben zu, z. B. nicht.  
  
 Zum Verwenden der <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> -Methode, benötigen Sie eine Instanz von der <xref:Microsoft.Win32.RegistryKey> Klasse. Um eine Instanz des <xref:Microsoft.Win32.RegistryKey>, verwenden Sie eine der statischen Elemente der der <xref:Microsoft.Win32.Registry> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="subkey" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Erstellen oder Öffnen des Registrierungsschlüssels.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="permissionCheck" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> auf dem diese Methode aufgerufen wird, wird geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der aktuelle <see cref="T:Microsoft.Win32.RegistryKey" /> kann nicht bearbeitet werden. Möglicherweise wurde der Schlüssel schreibgeschützt geöffnet, oder der Benutzer verfügt nicht über die erforderlichen Zugriffsrechte.</exception>
        <exception cref="T:System.IO.IOException">Die Schachtelungsebene überschreitet 510.  
  
- oder -  
Ein Systemfehler ist aufgetreten. Möglicherweise wurde der Schlüssel gelöscht, oder es wurde versucht, einen Schlüssel im <see cref="F:Microsoft.Win32.Registry.LocalMachine" />-Stamm zu erstellen.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">für die Möglichkeit, den angegebenen Registrierungsschlüssel zu ändern, falls vorhanden, oder die Möglichkeit, zu dem Registrierungsschlüssel zu erstellen ist es nicht bereits vorhanden. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Bei den Zugriff auf den angegebenen Registrierungsschlüssel, wenn handelt es sich um eine remote-Schlüssel. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, writable As Boolean) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, bool writable);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * bool -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, writable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="writable" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="subkey">Name oder Pfad des zu erstellenden oder zu öffnenden Unterschlüssels. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="writable"><see langword="true" />, um anzugeben, dass der neue Unterschlüssel bearbeitet werden kann, andernfalls <see langword="false" />.</param>
        <summary>Erstellt einen neuen Unterschlüssel oder öffnet einen vorhandenen Unterschlüssel mit dem angegebenen Zugriffsmodus. Verfügbar ab .NET Framework 4.6.</summary>
        <returns>Der neu erstellte Unterschlüssel oder <see langword="null" />, wenn bei dem Vorgang ein Fehler aufgetreten ist. Wenn eine Zeichenfolge der Länge 0 (null) für <paramref name="subkey" /> angegeben ist, wird das aktuelle <see cref="T:Microsoft.Win32.RegistryKey" />-Objekt zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um diese Aktion auszuführen, muss der Benutzer die Berechtigung, die auf dieser Ebene und darunter in der Registrierungshierarchie verfügen.  
  
> [!CAUTION]
>  Machen Sie nicht <xref:Microsoft.Win32.RegistryKey> Objekte so, dass ein schädliches Programm kann Tausende von bedeutungslosen Unterschlüsseln erstellen oder Schlüssel/Wert-Paare. Lassen Sie Aufrufer beliebige Schlüssel oder Werte eingeben zu, z. B. nicht.  
  
 Zum Verwenden der <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A> -Methode, benötigen Sie eine Instanz von der <xref:Microsoft.Win32.RegistryKey> Klasse. Um eine Instanz des <xref:Microsoft.Win32.RegistryKey>, verwenden Sie eine der statischen Elemente der der <xref:Microsoft.Win32.Registry> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="subkey" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Erstellen oder Öffnen des Registrierungsschlüssels.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Auf den aktuellen <see cref="T:Microsoft.Win32.RegistryKey" /> ist kein Schreibzugriff möglich. Möglicherweise wurde der Schlüssel schreibgeschützt geöffnet, oder der Benutzer verfügt nicht über die erforderlichen Zugriffsrechte.</exception>
        <exception cref="T:System.IO.IOException">Die Schachtelungsebene überschreitet 510.  
  
- oder -  
Ein Systemfehler ist aufgetreten. Möglicherweise wurde der Schlüssel gelöscht, oder es wurde versucht, einen Schlüssel im <see cref="F:Microsoft.Win32.Registry.LocalMachine" />-Stamm zu erstellen.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, System.Security.AccessControl.RegistrySecurity registrySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, class System.Security.AccessControl.RegistrySecurity registrySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,System.Security.AccessControl.RegistrySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, System::Security::AccessControl::RegistrySecurity ^ registrySecurity);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck * System.Security.AccessControl.RegistrySecurity -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, permissionCheck, registrySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="registrySecurity" Type="System.Security.AccessControl.RegistrySecurity" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="subkey">Name oder Pfad des zu erstellenden oder zu öffnenden Unterschlüssels. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="permissionCheck">Einer der Enumerationswerte, der angibt, ob der Schlüssel für Lesezugriff oder für Lese-/Schreibzugriff geöffnet wird.</param>
        <param name="registrySecurity">Die Zugriffssteuerungssicherheit für den neuen Schlüssel.</param>
        <summary>Erstellt einen neuen Unterschlüssel oder öffnet einen vorhandenen Unterschlüssel für Schreibzugriff unter Verwendung der angegebenen Berechtigungsprüfungsoption und der Registrierungssicherheit.</summary>
        <returns>Der neu erstellte Unterschlüssel oder <see langword="null" />, wenn bei dem Vorgang ein Fehler aufgetreten ist. Wenn eine Zeichenfolge der Länge 0 (null) für <paramref name="subkey" /> angegeben ist, wird das aktuelle <see cref="T:Microsoft.Win32.RegistryKey" />-Objekt zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A> Methode erstellt einen Registrierungsschlüssel, die die Zugriffssteuerung, die gemäß der `registrySecurity` Parameter. Die <xref:Microsoft.Win32.RegistryKey> zurückgegebene Objekt steht für den Registrierungsschlüssel, aber dieses Objekt ist nicht eingeschränkt, indem Sie die Zugriffssteuerung, angegeben der `registrySecurity` Parameter.  
  
 Wenn `permissionCheck` ist <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>, der Schlüssel für Lese-/Schreibzugriff geöffnet wird. Wenn `permissionCheck` ist <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType>, wird der Schlüssel für den Lesezugriff geöffnet.  
  
 Für die Abwärtskompatibilität wird zum Lesen und schreiben, wenn der Schlüssel geöffnet `permissionCheck` ist <xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType> und der übergeordnete Schlüssel verfügt auch über <xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType>. Wenn der übergeordnete Schlüssel eine anderen Einstellung verfügt, wird Lese-/Schreibstatus durch Einstellung des übergeordneten Schlüssels gesteuert.  
  
 Um diese Aktion auszuführen, muss der Benutzer die Berechtigungen auf dieser Ebene und darunter in der Registrierungshierarchie verfügen.  
  
> [!CAUTION]
>  Machen Sie nicht <xref:Microsoft.Win32.RegistryKey> Objekte so, dass ein schädliches Programm kann Tausende von bedeutungslosen Unterschlüsseln erstellen oder Schlüssel/Wert-Paare. Lassen Sie Aufrufer beliebige Schlüssel oder Werte eingeben zu, z. B. nicht.  
  
 Zum Verwenden der <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> -Methode, benötigen Sie eine Instanz von der <xref:Microsoft.Win32.RegistryKey> Klasse. Um eine Instanz des <xref:Microsoft.Win32.RegistryKey>, verwenden Sie eine der statischen Elemente der der <xref:Microsoft.Win32.Registry> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="subkey" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Erstellen oder Öffnen des Registrierungsschlüssels.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="permissionCheck" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> auf dem diese Methode aufgerufen wird, wird geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Auf den aktuellen <see cref="T:Microsoft.Win32.RegistryKey" /> ist kein Schreibzugriff möglich. Möglicherweise wurde der Schlüssel schreibgeschützt geöffnet, oder der Benutzer verfügt nicht über die erforderlichen Zugriffsrechte.</exception>
        <exception cref="T:System.IO.IOException">Die Schachtelungsebene überschreitet 510.  
  
- oder -  
Ein Systemfehler ist aufgetreten. Möglicherweise wurde der Schlüssel gelöscht, oder es wurde versucht, einen Schlüssel im <see cref="F:Microsoft.Win32.Registry.LocalMachine" />-Stamm zu erstellen.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">für die Möglichkeit, den angegebenen Registrierungsschlüssel zu ändern, falls vorhanden, oder die Möglichkeit, zu dem Registrierungsschlüssel zu erstellen ist es nicht bereits vorhanden. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Bei den Zugriff auf den angegebenen Registrierungsschlüssel, wenn handelt es sich um eine remote-Schlüssel. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, bool writable, Microsoft.Win32.RegistryOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, bool writable, valuetype Microsoft.Win32.RegistryOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,System.Boolean,Microsoft.Win32.RegistryOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, writable As Boolean, options As RegistryOptions) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, bool writable, Microsoft::Win32::RegistryOptions options);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * bool * Microsoft.Win32.RegistryOptions -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, writable, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="writable" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="Microsoft.Win32.RegistryOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="subkey">Name oder Pfad des zu erstellenden oder zu öffnenden Unterschlüssels. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="writable"><see langword="true" />, um anzugeben, dass der neue Unterschlüssel bearbeitet werden kann, andernfalls <see langword="false" />.</param>
        <param name="options">Die zu verwendende Registrierungsoption.</param>
        <summary>Erstellt einen neuen Unterschlüssel oder öffnet einen vorhandenen Unterschlüssel mit dem angegebenen Zugriffsmodus. Verfügbar ab .NET Framework 4.6.</summary>
        <returns>Der neu erstellte Unterschlüssel oder <see langword="null" />, wenn bei dem Vorgang ein Fehler aufgetreten ist. Wenn eine Zeichenfolge der Länge 0 (null) für <paramref name="subkey" /> angegeben ist, wird das aktuelle <see cref="T:Microsoft.Win32.RegistryKey" />-Objekt zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um diese Aktion auszuführen, muss der Benutzer die Berechtigung, die auf dieser Ebene und darunter in der Registrierungshierarchie verfügen.  
  
> [!CAUTION]
>  Machen Sie nicht <xref:Microsoft.Win32.RegistryKey> Objekte so, dass ein schädliches Programm kann Tausende von bedeutungslosen Unterschlüsseln erstellen oder Schlüssel/Wert-Paare. Lassen Sie Aufrufer beliebige Schlüssel oder Werte eingeben zu, z. B. nicht.  
  
 Zum Verwenden der <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A> -Methode, benötigen Sie eine Instanz von der <xref:Microsoft.Win32.RegistryKey> Klasse. Um eine Instanz des <xref:Microsoft.Win32.RegistryKey>, verwenden Sie eine der statischen Elemente der der <xref:Microsoft.Win32.Registry> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="subkey" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> gibt keine gültige Option an.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Erstellen oder Öffnen des Registrierungsschlüssels.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Auf den aktuellen <see cref="T:Microsoft.Win32.RegistryKey" /> ist kein Schreibzugriff möglich. Möglicherweise wurde der Schlüssel schreibgeschützt geöffnet, oder der Benutzer verfügt nicht über die erforderlichen Zugriffsrechte.</exception>
        <exception cref="T:System.IO.IOException">Die Schachtelungsebene überschreitet 510.  
  
- oder -  
Ein Systemfehler ist aufgetreten. Möglicherweise wurde der Schlüssel gelöscht, oder es wurde versucht, einen Schlüssel im <see cref="F:Microsoft.Win32.Registry.LocalMachine" />-Stamm zu erstellen.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, Microsoft.Win32.RegistryOptions options);" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype Microsoft.Win32.RegistryOptions options) cil managed" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,Microsoft.Win32.RegistryOptions)" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, Microsoft.Win32.RegistryOptions registryOptions);" FrameworkAlternate="netcore-2.0;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype Microsoft.Win32.RegistryOptions registryOptions) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, Microsoft::Win32::RegistryOptions registryOptions);" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;dotnet-plat-ext-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, permissionCheck As RegistryKeyPermissionCheck, options As RegistryOptions) As RegistryKey" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck * Microsoft.Win32.RegistryOptions -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, permissionCheck, registryOptions)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, permissionCheck As RegistryKeyPermissionCheck, options As RegistryOptions) As RegistryKey" FrameworkAlternate="netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, Microsoft::Win32::RegistryOptions options);" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck * Microsoft.Win32.RegistryOptions -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, permissionCheck, options)" FrameworkAlternate="netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,Microsoft.Win32.RegistryOptions)" FrameworkAlternate="netframework-4.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="registryOptions" Type="Microsoft.Win32.RegistryOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
        <Parameter Name="options" Type="Microsoft.Win32.RegistryOptions" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="subkey">Name oder Pfad des zu erstellenden oder zu öffnenden Unterschlüssels.</param>
        <param name="permissionCheck">Einer der Enumerationswerte, der angibt, ob der Schlüssel für Lesezugriff oder für Lese-/Schreibzugriff geöffnet wird.</param>
        <param name="registryOptions">Die zu verwendende Registrierungsoption, z. B. zum Erstellen eines temporären Schlüssels.</param>
        <param name="options">Die zu verwendende Registrierungsoption, z. B. zum Erstellen eines temporären Schlüssels.</param>
        <summary>Erstellt oder öffnet einen Unterschlüssel für Schreibzugriff unter Verwendung der angegebenen Berechtigungsprüfungs- und Registrierungsoptionen.</summary>
        <returns>Der neu erstellte Unterschlüssel oder <see langword="null" />, wenn bei dem Vorgang ein Fehler aufgetreten ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abrufen des aktuellen <xref:Microsoft.Win32.RegistryKey> Objekt, geben Sie eine leere Zeichenfolge ("") für `subkey`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="subkey" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Die aktuelle <see cref="T:Microsoft.Win32.RegistryKey" /> -Objekt ist geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Die aktuelle <see cref="T:Microsoft.Win32.RegistryKey" /> Objekt nicht geschrieben werden kann, z. B. es nicht als Schlüssel schreibgeschützt geöffnet wurde oder der Benutzer verfügt nicht über die erforderlichen Zugriffsrechte.</exception>
        <exception cref="T:System.IO.IOException">Die Schachtelungsebene überschreitet 510.  
  
- oder -  
Ein Systemfehler ist aufgetreten, z. B. Löschen der Schlüssel oder ein Versuch zum Erstellen eines Schlüssels in der <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> Stamm.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Erstellen oder Öffnen des Registrierungsschlüssels.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, Microsoft.Win32.RegistryOptions registryOptions, System.Security.AccessControl.RegistrySecurity registrySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype Microsoft.Win32.RegistryOptions registryOptions, class System.Security.AccessControl.RegistrySecurity registrySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,Microsoft.Win32.RegistryOptions,System.Security.AccessControl.RegistrySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, Microsoft::Win32::RegistryOptions registryOptions, System::Security::AccessControl::RegistrySecurity ^ registrySecurity);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck * Microsoft.Win32.RegistryOptions * System.Security.AccessControl.RegistrySecurity -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, permissionCheck, registryOptions, registrySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="registryOptions" Type="Microsoft.Win32.RegistryOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="registrySecurity" Type="System.Security.AccessControl.RegistrySecurity" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="subkey">Name oder Pfad des zu erstellenden oder zu öffnenden Unterschlüssels.</param>
        <param name="permissionCheck">Einer der Enumerationswerte, der angibt, ob der Schlüssel für Lesezugriff oder für Lese-/Schreibzugriff geöffnet wird.</param>
        <param name="registryOptions">Die zu verwendende Registrierungsoption.</param>
        <param name="registrySecurity">Die Zugriffssteuerungssicherheit für den neuen Unterschlüssel.</param>
        <summary>Erstellt oder öffnet einen Unterschlüssel für Schreibzugriff unter Verwendung der angegebenen Berechtigungsprüfungsoption, Registrierungsoption und Registrierungssicherheit.</summary>
        <returns>Der neu erstellte Unterschlüssel oder <see langword="null" />, wenn bei dem Vorgang ein Fehler aufgetreten ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abrufen des aktuellen <xref:Microsoft.Win32.RegistryKey> Objekt, geben Sie eine leere Zeichenfolge ("") für `subkey`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="subkey" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Die aktuelle <see cref="T:Microsoft.Win32.RegistryKey" /> -Objekt ist geschlossen. Geschlossene Schlüssel können nicht zugegriffen werden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Die aktuelle <see cref="T:Microsoft.Win32.RegistryKey" /> Objekt nicht geschrieben werden kann, z. B. es nicht als Schlüssel schreibgeschützt geöffnet wurde oder der Benutzer verfügt nicht über die erforderlichen Zugriffsrechte.</exception>
        <exception cref="T:System.IO.IOException">Die Schachtelungsebene überschreitet 510.  
  
- oder -  
Ein Systemfehler ist aufgetreten, z. B. Löschen der Schlüssel oder ein Versuch zum Erstellen eines Schlüssels in der <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> Stamm.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Erstellen oder Öffnen des Registrierungsschlüssels.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteSubKey">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löscht den angegebenen Unterschlüssel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteSubKey">
      <MemberSignature Language="C#" Value="public void DeleteSubKey (string subkey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKey(string subkey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKey (subkey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKey(System::String ^ subkey);" />
      <MemberSignature Language="F#" Value="member this.DeleteSubKey : string -&gt; unit" Usage="registryKey.DeleteSubKey subkey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subkey">Der Name des zu löschenden Unterschlüssels. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Löscht den angegebenen Unterschlüssel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie zum Löschen untergeordnete Unterschlüssel <xref:Microsoft.Win32.RegistryKey.DeleteSubKeyTree%2A>.  
  
 Beim Löschen von Registrierungsschlüsseln vorsichtig.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie <xref:Microsoft.Win32.RegistryKey.DeleteSubKey%2A>.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#5](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source2.cpp#5)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#5](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source2.cs#5)]
 [!code-vb[Microsoft.Win32.RegistryKey2#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <paramref name="subkey" /> besitzt untergeordnete Unterschlüssel.</exception>
        <exception cref="T:System.ArgumentException">Die <paramref name="subkey" /> -Parameter gibt keinen gültigen Registrierungsschlüssel</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="subkey" /> ist gleich <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt nicht die erforderlichen Berechtigungen zum Löschen des Schlüssels.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> bearbeitet wird, ist geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer besitzt nicht die notwendigen Registrierungsrechte.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">für die Möglichkeit, den angegebenen Registrierungsschlüssel zu ändern. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Bei den Zugriff auf den angegebenen Registrierungsschlüssel, wenn handelt es sich um eine remote-Schlüssel. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="DeleteSubKey">
      <MemberSignature Language="C#" Value="public void DeleteSubKey (string subkey, bool throwOnMissingSubKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKey(string subkey, bool throwOnMissingSubKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKey (subkey As String, throwOnMissingSubKey As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKey(System::String ^ subkey, bool throwOnMissingSubKey);" />
      <MemberSignature Language="F#" Value="member this.DeleteSubKey : string * bool -&gt; unit" Usage="registryKey.DeleteSubKey (subkey, throwOnMissingSubKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="throwOnMissingSubKey" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="subkey">Der Name des zu löschenden Unterschlüssels. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="throwOnMissingSubKey">Gibt an, ob eine Ausnahme ausgelöst werden soll, wenn der angegebene Unterschlüssel nicht gefunden werden kann. Wenn dieses Argument <see langword="true" /> und der angegebene Unterschlüssel nicht vorhanden ist, wird eine Ausnahme ausgelöst. Wenn dieses Argument <see langword="false" /> und der angegebene Unterschlüssel nicht vorhanden ist, findet keine Aktion statt.</param>
        <summary>Löscht den angegebenen Unterschlüssel und gibt an, ob eine Ausnahme ausgelöst wird, wenn der Unterschlüssel nicht gefunden wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie zum Löschen untergeordnete Unterschlüssel <xref:Microsoft.Win32.RegistryKey.DeleteSubKeyTree%2A>.  
  
 Beim Löschen von Registrierungsschlüsseln vorsichtig.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="subkey" /> hat untergeordnete Unterschlüssel.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="subkey" /> Gibt keinen gültigen Registrierungsschlüssel, und <paramref name="throwOnMissingSubKey" /> ist <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="subkey" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt nicht die erforderlichen Berechtigungen zum Löschen des Schlüssels.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> bearbeitet wird, ist geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer besitzt nicht die notwendigen Registrierungsrechte.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">für die Möglichkeit, den angegebenen Registrierungsschlüssel zu ändern. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Bei den Zugriff auf den angegebenen Registrierungsschlüssel, wenn handelt es sich um eine remote-Schlüssel. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteSubKeyTree">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löscht einen Unterschlüssel und untergeordnete Unterschlüssel rekursiv, mit optionaler Ausnahmebehandlung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteSubKeyTree">
      <MemberSignature Language="C#" Value="public void DeleteSubKeyTree (string subkey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKeyTree(string subkey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKeyTree (subkey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKeyTree(System::String ^ subkey);" />
      <MemberSignature Language="F#" Value="member this.DeleteSubKeyTree : string -&gt; unit" Usage="registryKey.DeleteSubKeyTree subkey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subkey">Der zu löschende Unterschlüssel. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Löscht einen Unterschlüssel und alle untergeordneten Unterschlüssel rekursiv.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen die entsprechenden Berechtigungen zum Löschen des Unterschlüssels und der Struktur.  
  
> [!CAUTION]
>  Löschen einen bestimmten Schlüssel entfernt alle Einträge unter dem Schlüssel in der Struktur. Es wird keine Warnung bereitgestellt werden. Wenn Sie einen Unterschlüssel löschen nur, wenn keine untergeordneten Unterschlüssel, verwenden Sie möchten die <xref:Microsoft.Win32.RegistryKey.DeleteSubKey%2A> Methode.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:Microsoft.Win32.RegistryKey> Klasse.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="subkey" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wird versucht, löschen, eine Stammstruktur zu erstellen.  
  
- oder -  
 <paramref name="subkey" /> Gibt keinen gültigen Registrierungsunterschlüssel an.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler ist aufgetreten.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt nicht die erforderlichen Berechtigungen zum Löschen des Schlüssels.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> bearbeitet wird, ist geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer besitzt nicht die notwendigen Registrierungsrechte.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">für die Möglichkeit, den angegebenen Registrierungsschlüssel zu ändern. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Bei den Zugriff auf den angegebenen Registrierungsschlüssel, wenn handelt es sich um eine remote-Schlüssel. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
      </Docs>
    </Member>
    <Member MemberName="DeleteSubKeyTree">
      <MemberSignature Language="C#" Value="public void DeleteSubKeyTree (string subkey, bool throwOnMissingSubKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKeyTree(string subkey, bool throwOnMissingSubKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKeyTree (subkey As String, throwOnMissingSubKey As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKeyTree(System::String ^ subkey, bool throwOnMissingSubKey);" />
      <MemberSignature Language="F#" Value="member this.DeleteSubKeyTree : string * bool -&gt; unit" Usage="registryKey.DeleteSubKeyTree (subkey, throwOnMissingSubKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnMissingSubKey" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="subkey">Der Name des zu löschenden Unterschlüssels. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="throwOnMissingSubKey">Gibt an, ob eine Ausnahme ausgelöst werden soll, wenn der angegebene Unterschlüssel nicht gefunden werden kann. Wenn dieses Argument <see langword="true" /> und der angegebene Unterschlüssel nicht vorhanden ist, wird eine Ausnahme ausgelöst. Wenn dieses Argument <see langword="false" /> und der angegebene Unterschlüssel nicht vorhanden ist, findet keine Aktion statt.</param>
        <summary>Löscht den angegebenen Unterschlüssel und untergeordnete Unterschlüssel rekursiv und gibt an, ob eine Ausnahme ausgelöst wird, wenn der Unterschlüssel nicht gefunden wird.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Es wurde versucht, den Stammhive der Struktur zu löschen.  
  
- oder -  
 <paramref name="subkey" /> Gibt keinen gültigen Registrierungsunterschlüssel, und <paramref name="throwOnMissingSubKey" /> ist <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="subkey" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> ist geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer besitzt nicht die notwendigen Registrierungsrechte.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt nicht die erforderlichen Berechtigungen zum Löschen des Schlüssels.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">für die Möglichkeit, den angegebenen Registrierungsschlüssel zu ändern. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Bei den Zugriff auf den angegebenen Registrierungsschlüssel, wenn handelt es sich um eine remote-Schlüssel. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löscht den angegebenen Wert aus diesem Schlüssel und löst eine Ausnahme aus, wenn der Wert nicht gefunden wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteValue">
      <MemberSignature Language="C#" Value="public void DeleteValue (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteValue(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteValue (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteValue(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.DeleteValue : string -&gt; unit" Usage="registryKey.DeleteValue name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu löschenden Werts.</param>
        <summary>Löscht den angegebenen Wert aus diesem Schlüssel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Windows 95, Windows 98, Windows 98 Second Edition und Windows Millennium Edition, angeben, die eine leere Zeichenfolge für die `name` Parameter löscht nicht den Standardwert.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:Microsoft.Win32.RegistryKey> Klasse.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#3](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#3)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#3](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#3)]
 [!code-vb[Microsoft.Win32.RegistryKey2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist kein gültiger Verweis auf einen Wert.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt nicht die erforderlichen Berechtigungen zum Löschen des Werts.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> bearbeitet wird, ist geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> schreibgeschützt ist, das manipuliert wird.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">für die Möglichkeit, den angegebenen Registrierungsschlüssel zu löschen. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
      </Docs>
    </Member>
    <Member MemberName="DeleteValue">
      <MemberSignature Language="C#" Value="public void DeleteValue (string name, bool throwOnMissingValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteValue(string name, bool throwOnMissingValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteValue (name As String, throwOnMissingValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteValue(System::String ^ name, bool throwOnMissingValue);" />
      <MemberSignature Language="F#" Value="member this.DeleteValue : string * bool -&gt; unit" Usage="registryKey.DeleteValue (name, throwOnMissingValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnMissingValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu löschenden Werts.</param>
        <param name="throwOnMissingValue">Gibt an, ob eine Ausnahme ausgelöst werden soll, wenn der angegebene Wert nicht gefunden werden kann. Wenn dieses Argument <see langword="true" /> ist und der angegebene Wert nicht vorhanden ist, wird eine Ausnahme ausgelöst. Wenn dieses Argument <see langword="false" /> ist und der angegebene Wert nicht vorhanden ist, findet keine Aktion statt.</param>
        <summary>Löscht den angegebenen Wert aus diesem Schlüssel und gibt an, ob eine Ausnahme ausgelöst wird, wenn der Wert nicht gefunden wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `throwOnMissingValue` ist `false`, es gibt keine Möglichkeit, festzustellen, ob der Löschvorgang erfolgreich war, dass danach versucht, Zugriff auf den Wert einfach gelöscht. Daher vorsichtig, wenn Sie Werte aus der Registrierung auf diese Weise löschen.  
  
 Für Windows 95, Windows 98, Windows 98 Second Edition und Windows Millennium Edition, angeben, die eine leere Zeichenfolge für die `name` Parameter löscht nicht den Standardwert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist kein gültiger Verweis auf einen Wert und <paramref name="throwOnMissingValue" /> ist <see langword="true" />.  
  
- oder -  
 <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt nicht die erforderlichen Berechtigungen zum Löschen des Werts.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> bearbeitet wird, ist geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> schreibgeschützt ist, das manipuliert wird.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">für die Möglichkeit, den angegebenen Registrierungsschlüssel zu löschen. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="registryKey.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:Microsoft.Win32.RegistryKey" />-Klasse verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie `Dispose` auf, wenn Sie <xref:Microsoft.Win32.RegistryKey> nicht mehr benötigen. Die `Dispose`-Methode bewirkt, dass <xref:Microsoft.Win32.RegistryKey> nicht mehr verwendet werden kann. Nach dem Aufruf `Dispose`, Sie müssen alle Verweise auf Freigeben der <xref:Microsoft.Win32.RegistryKey> , damit der Garbage Collector den Arbeitsspeicher freigeben kann, die die <xref:Microsoft.Win32.RegistryKey> belegt wurde.  
  
 Weitere Informationen finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Rufen Sie immer `Dispose` auf, bevor Sie den letzten Verweis auf das <xref:Microsoft.Win32.RegistryKey> freigeben. Andernfalls bleiben die verwendeten Ressourcen reserviert, bis die Garbage Collection die <xref:Microsoft.Win32.RegistryKey>-Methode des `Finalize`-Objekts aufruft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~RegistryKey ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!RegistryKey ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="registryKey.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt den Schlüssel, und ihn auf die Festplatte geschrieben, wenn der Inhalt verändert wurde.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="registryKey.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schreibt alle Attribute des angegebenen geöffneten Registrierungsschlüssels in die Registrierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es ist nicht notwendig, `Flush` , Änderungen an einem Schlüssel zu schreiben. Registrierungsänderungen werden geleert, wenn auf dem Datenträger die Registrierung verwendet die verzögerte Arbeitstabelle. Die verzögerte Speicherung erfolgt automatisch und regelmäßig nach einem vom System angegebenen Zeitintervall. Registrierungsänderungen werden ebenfalls geleert, auf dem Datenträger am System heruntergefahren wird.  
  
 Im Gegensatz zu <xref:Microsoft.Win32.RegistryKey.Close%2A>, `Flush` Funktion gibt nur, wenn alle Daten in die Registrierung geschrieben wurde.  
  
 Die `Flush` Funktion möglicherweise auch Teile oder alle anderen Schlüssel schreiben. Häufiges Aufrufen dieser Funktion lassen sich auf eine negative Auswirkung auf die Leistung einer Anwendung aus.  
  
 Eine Anwendung sollte nur aufrufen `Flush` , wenn es absolut sein muss sicher, dass die registrierungsänderungen aufgezeichnet werden auf dem Datenträger. Im allgemeinen `Flush` selten, wenn überhaupt, verwendet werden müssen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.Win32.RegistryKey.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FromHandle">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen Registrierungsschlüssel aus einem angegebenen Handle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromHandle">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey FromHandle (Microsoft.Win32.SafeHandles.SafeRegistryHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey FromHandle(class Microsoft.Win32.SafeHandles.SafeRegistryHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.FromHandle(Microsoft.Win32.SafeHandles.SafeRegistryHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHandle (handle As SafeRegistryHandle) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ FromHandle(Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ handle);" />
      <MemberSignature Language="F#" Value="static member FromHandle : Microsoft.Win32.SafeHandles.SafeRegistryHandle -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.FromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeRegistryHandle" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="handle">Das Handle für den Registrierungsschlüssel.</param>
        <summary>Erstellt einen Registrierungsschlüssel aus einem angegebenen Handle.</summary>
        <returns>Ein Registrierungsschlüssel.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="handle" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer besitzt nicht die notwendigen Registrierungsrechte.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt nicht die erforderlichen Berechtigungen zum Ausführen dieser Aktion.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Bei den Zugriff auf den angegebenen Registrierungsschlüssel, wenn handelt es sich um eine remote-Schlüssel. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="FromHandle">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey FromHandle (Microsoft.Win32.SafeHandles.SafeRegistryHandle handle, Microsoft.Win32.RegistryView view);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey FromHandle(class Microsoft.Win32.SafeHandles.SafeRegistryHandle handle, valuetype Microsoft.Win32.RegistryView view) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.FromHandle(Microsoft.Win32.SafeHandles.SafeRegistryHandle,Microsoft.Win32.RegistryView)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHandle (handle As SafeRegistryHandle, view As RegistryView) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ FromHandle(Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ handle, Microsoft::Win32::RegistryView view);" />
      <MemberSignature Language="F#" Value="static member FromHandle : Microsoft.Win32.SafeHandles.SafeRegistryHandle * Microsoft.Win32.RegistryView -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.FromHandle (handle, view)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeRegistryHandle" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="view" Type="Microsoft.Win32.RegistryView" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="handle">Das Handle für den Registrierungsschlüssel.</param>
        <param name="view">Die zu verwendende Registrierungsansicht.</param>
        <summary>Erstellt einen Registrierungsschlüssel aus einem angegebenen Handle und einer Registrierungsansichtseinstellung.</summary>
        <returns>Ein Registrierungsschlüssel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `view` Parameter für diese Methode wird in nachfolgenden Vorgängen ist z. B. beim Öffnen von Unterschlüsseln verwendet.  
  
 Wenn `view` ist <xref:Microsoft.Win32.RegistryView.Registry64> aber der Computer eine 32-Bit-Betriebssystem ausgeführt wird, wird der zurückgegebene Schlüssel verwendet die <xref:Microsoft.Win32.RegistryView.Registry32> anzeigen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="view" /> ist ungültig.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="handle" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer besitzt nicht die notwendigen Registrierungsrechte.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt nicht die erforderlichen Berechtigungen zum Ausführen dieser Aktion.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Bei den Zugriff auf den angegebenen Registrierungsschlüssel, wenn handelt es sich um eine remote-Schlüssel. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die Zugriffssteuerungssicherheit für den aktuellen Registrierungsschlüssel zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.RegistrySecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.RegistrySecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As RegistrySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::RegistrySecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.RegistrySecurity" Usage="registryKey.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.RegistrySecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Zugriffssteuerungssicherheit für den aktuellen Registrierungsschlüssel zurück.</summary>
        <returns>Ein Objekt, das die Zugriffssteuerungsberechtigungen für den durch den aktuellen <see cref="T:Microsoft.Win32.RegistryKey" /> dargestellten Registrierungsschlüssel beschreibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überladung dieser Methode entspricht dem Aufrufen der <xref:Microsoft.Win32.RegistryKey.GetAccessControl%28System.Security.AccessControl.AccessControlSections%29> methodenüberladung mit die bitweise Kombination der folgenden Flags: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, und <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>. Sie können diese Überladung verwenden, um nach anderen Berechtigungen zu suchen.  
  
 Der Benutzer <xref:System.Security.AccessControl.RegistryRights.ReadPermissions?displayProperty=nameWithType> verfügen, um diese Methode aufzurufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt nicht die erforderlichen Berechtigungen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> bearbeitet wird, ist geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Schlüssel wurde gelöscht.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.RegistrySecurity GetAccessControl (System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.RegistrySecurity GetAccessControl(valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetAccessControl(System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl (includeSections As AccessControlSections) As RegistrySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::RegistrySecurity ^ GetAccessControl(System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.RegistrySecurity" Usage="registryKey.GetAccessControl includeSections" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.RegistrySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="includeSections">Eine bitweise Kombination von Enumerationswerten, die den Typ der abzurufenden Sicherheitsinformationen angeben.</param>
        <summary>Gibt die angegebenen Abschnitte der Zugriffssteuerungssicherheit für den aktuellen Registrierungsschlüssel zurück.</summary>
        <returns>Ein Objekt, das die Zugriffssteuerungsberechtigungen für den durch den aktuellen <see cref="T:Microsoft.Win32.RegistryKey" /> dargestellten Registrierungsschlüssel beschreibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Geben Sie zum Anfordern der derzeit für Benutzer gewährten Zugriffsberechtigungen die bitweise Kombination der folgenden Flags: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, und <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>. Alternativ können Sie die <xref:Microsoft.Win32.RegistryKey.GetAccessControl> methodenüberladung, die genau diese Kombination von Werten angibt.  
  
 Der Benutzer <xref:System.Security.AccessControl.RegistryRights.ReadPermissions?displayProperty=nameWithType> verfügen, um diese Methode aufzurufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt nicht die erforderlichen Berechtigungen.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> bearbeitet wird, ist geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Schlüssel wurde gelöscht.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSubKeyNames">
      <MemberSignature Language="C#" Value="public string[] GetSubKeyNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetSubKeyNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSubKeyNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetSubKeyNames();" />
      <MemberSignature Language="F#" Value="member this.GetSubKeyNames : unit -&gt; string[]" Usage="registryKey.GetSubKeyNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein Array von Zeichenfolgen mit den Namen aller Unterschlüssel ab.</summary>
        <returns>Ein Array von Zeichenfolgen, das die Namen der Unterschlüssel des aktuellen Schlüssels enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nicht rekursiv suchen-Namen. Es gibt die Namen auf der Basis-Ebene, die von dem es aufgerufen wurde.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:Microsoft.Win32.RegistryKey> Klasse.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt nicht die erforderlichen Berechtigungen zum Lesen aus dem Schlüssel.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> bearbeitet wird, ist geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer besitzt nicht die notwendigen Registrierungsrechte.</exception>
        <exception cref="T:System.IO.IOException">Ein Systemfehler ist aufgetreten, z. B. der aktuelle Schlüssel gelöscht wurde.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">die Möglichkeit, die aus der Registrierung gelesen werden soll. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Wert ab, der dem angegebenen Namen zugeordnet ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetValue : string -&gt; obj" Usage="registryKey.GetValue name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des abzurufenden Werts. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Ruft den Wert ab, der dem angegebenen Namen zugeordnet ist. Gibt <see langword="null" /> zurück, wenn das Name-Wert-Paar in der Registrierung nicht vorhanden ist.</summary>
        <returns>Der <paramref name="name" /> zugeordnete Wert oder <see langword="null" />, wenn <paramref name="name" /> nicht gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ein Registrierungsschlüssel kann ein Wert sein, die nicht mit einem beliebigen Namen zugeordnet ist. Wenn es sich bei diesen unbenannten Wert in den Registrierungs-Editor angezeigt wird, wird die Zeichenfolge "(Standard)" anstelle eines Namens angezeigt. Um diesen unbenannten Wert abzurufen, geben Sie entweder `null` oder eine leere Zeichenfolge ("") für `name`.  
  
 Wenn die <xref:Microsoft.Win32.RegistryKey.GetValue%2A> Methode ruft die Werte der erweiterbaren Zeichenfolge ab (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), erweitert er Umgebungszeichenfolgen mit Daten aus der lokalen Umgebung. Um erweiterbare Zeichenfolgenwerte aus der Registrierung auf einem Remotecomputer abzurufen, verwenden die <xref:Microsoft.Win32.RegistryKey.GetValue%28System.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueOptions%29> -methodenüberladung, um anzugeben, dass Sie nicht, dass Umgebungszeichenfolgen erweitert möchten.  
  
> [!NOTE]
>  Wenn Sie ein Wert mit der erweiterbaren verweisen auf Umgebungsvariablen als Zeichenfolge gespeichert wurde (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>), und nicht als erweiterbare Zeichenfolge (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), <xref:Microsoft.Win32.RegistryKey.GetValue%2A> nicht erweitert. Können Sie eine solche Zeichenfolge erweitern, nachdem sie durch den Aufruf abgerufen wurde die <xref:System.Environment.ExpandEnvironmentVariables%2A> Methode.  
  
> [!NOTE]
>  Die empfohlene Methode zum Abrufen von Daten aus der <xref:Microsoft.Win32.Registry.PerformanceData> Schlüssel ist die Verwendung der <xref:System.Diagnostics.PerformanceCounter> Klasse anstelle der <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType> Methode.  
>   
>  <xref:Microsoft.Win32.RegistryKey.GetValue%2A> Beim Lesen von Werten des Typs REG_NONE oder REG_LINK unterstützt nicht.  In beiden Fällen den Standardwert (`null`) anstelle des tatsächlichen Werts zurückgegeben.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Testschlüssel und fügt Werte unterschiedliche Datentypen auf den Schlüssel. Im Beispiel liest Name/Wert-Paare, und zeigt sie an der Konsole mit der <xref:Microsoft.Win32.RegistryKey.GetValueKind%2A> Methode, um die entsprechenden Datentypen für die Registrierung abzurufen.  
  
 [!code-cpp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt nicht die erforderlichen Berechtigungen zum Lesen aus dem Registrierungsschlüssel.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> enthält, die die angegebene Wert ist geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <exception cref="T:System.IO.IOException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> enthält, die die angegebene Wert zum Löschen gekennzeichnet wurde.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer besitzt nicht die notwendigen Registrierungsrechte.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">aus der Registrierung zu lesen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Um einen Registrierungsschlüssel vom Typ REG_EXPAND_SZ zu lesen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="Overload:Microsoft.Win32.RegistryKey.SetValue" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (string name, object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(string name, object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValue(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (name As String, defaultValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::String ^ name, System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="member this.GetValue : string * obj -&gt; obj" Usage="registryKey.GetValue (name, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des abzurufenden Werts. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="defaultValue">Der zurückzugebende Wert, wenn <paramref name="name" /> nicht vorhanden ist.</param>
        <summary>Ruft den Wert ab, der dem angegebenen Namen zugeordnet ist. Wenn der Name nicht gefunden wird, wird der von Ihnen bereitgestellte Standardwert zurückgegeben.</summary>
        <returns>Der <paramref name="name" /> zugeordnete Wert mit allen eingebetteten Umgebungsvariablen, die nicht erweitert wurden, oder <paramref name="defaultValue" />, wenn <paramref name="name" /> nicht gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung der <xref:Microsoft.Win32.RegistryKey.GetValue%2A> den Fall abzudecken, in dem ein Name noch nicht vorhanden ist – z. B. beim ersten Ihrer Anwendung ausgeführt wird. Wenn Sie diese Überladung aufrufen, verwenden Sie die `defaultValue` Parameter zum Angeben des Werts zurückgegeben, wenn `name` ist nicht vorhanden.  
  
> [!NOTE]
>  Ein Registrierungsschlüssel kann ein Wert sein, die nicht mit einem beliebigen Namen zugeordnet ist. Wenn es sich bei diesen unbenannten Wert in den Registrierungs-Editor angezeigt wird, wird die Zeichenfolge "(Standard)" anstelle eines Namens angezeigt. Um diesen unbenannten Wert abzurufen, geben Sie entweder `null` oder eine leere Zeichenfolge ("") für `name`.  
  
 Wenn die <xref:Microsoft.Win32.RegistryKey.GetValue%2A> Methode ruft die Werte der erweiterbaren Zeichenfolge ab (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), erweitert er Umgebungszeichenfolgen mit Daten aus der lokalen Umgebung. Um erweiterbare Zeichenfolgenwerte aus der Registrierung auf einem Remotecomputer abzurufen, verwenden die <xref:Microsoft.Win32.RegistryKey.GetValue%2A> -Überladung verwenden, um anzugeben, dass Sie nicht, dass Umgebungszeichenfolgen erweitert möchten.  
  
> [!NOTE]
>  Wenn Sie ein Wert mit der erweiterbaren verweisen auf Umgebungsvariablen als Zeichenfolge gespeichert wurde (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>), und nicht als erweiterbare Zeichenfolge (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), wird die <xref:Microsoft.Win32.RegistryKey.GetValue%2A> Methode nicht erweitert. Können Sie eine solche Zeichenfolge erweitern, nachdem sie durch den Aufruf abgerufen wurde die <xref:System.Environment.ExpandEnvironmentVariables%2A> Methode.  
  
> [!NOTE]
>  Die empfohlene Methode zum Abrufen von Daten aus der <xref:Microsoft.Win32.Registry.PerformanceData> Schlüssel ist die Verwendung der <xref:System.Diagnostics.PerformanceCounter> Klasse anstelle der <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType> Methode.  
>   
>  <xref:Microsoft.Win32.RegistryKey.GetValue%2A> Beim Lesen von Werten des Typs REG_NONE oder REG_LINK unterstützt nicht.  In beiden Fällen den Standardwert (`null`) anstelle des tatsächlichen Werts zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Testschlüssel mit einem Wert erstellt und ruft diesen Wert. Anschließend wird im Beispiel versucht, die einen nicht vorhandenen Wert aus dem Schlüssel abzurufen. In diesem Fall die <xref:Microsoft.Win32.RegistryKey.GetValue%2A> Methode gibt den angegebenen Standardwert zurück.  
  
 [!code-cpp[Classic RegistryKey.GetValue Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic RegistryKey.GetValue Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RegistryKey.GetValue Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic RegistryKey.GetValue Example/CS/source.cs#1)]
 [!code-vb[Classic RegistryKey.GetValue Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic RegistryKey.GetValue Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt nicht die erforderlichen Berechtigungen zum Lesen aus dem Registrierungsschlüssel.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> enthält, die die angegebene Wert ist geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <exception cref="T:System.IO.IOException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> enthält, die die angegebene Wert zum Löschen gekennzeichnet wurde.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer besitzt nicht die notwendigen Registrierungsrechte.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">aus der Registrierung zu lesen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Um einen Registrierungsschlüssel vom Typ REG_EXPAND_SZ zu lesen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="Overload:Microsoft.Win32.RegistryKey.SetValue" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (string name, object defaultValue, Microsoft.Win32.RegistryValueOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(string name, object defaultValue, valuetype Microsoft.Win32.RegistryValueOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValue(System.String,System.Object,Microsoft.Win32.RegistryValueOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (name As String, defaultValue As Object, options As RegistryValueOptions) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::String ^ name, System::Object ^ defaultValue, Microsoft::Win32::RegistryValueOptions options);" />
      <MemberSignature Language="F#" Value="member this.GetValue : string * obj * Microsoft.Win32.RegistryValueOptions -&gt; obj" Usage="registryKey.GetValue (name, defaultValue, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="defaultValue" Type="System.Object" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="Microsoft.Win32.RegistryValueOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des abzurufenden Werts. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="defaultValue">Der zurückzugebende Wert, wenn <paramref name="name" /> nicht vorhanden ist.</param>
        <param name="options">Einer der Enumerationswerte, die eine optionale Verarbeitung des abgerufenen Werts angeben.</param>
        <summary>Ruft den Wert ab, der dem angegebenen Namen und den Abrufoptionen zugeordnet ist. Wenn der Name nicht gefunden wird, wird der von Ihnen bereitgestellte Standardwert zurückgegeben.</summary>
        <returns>Der <paramref name="name" /> zugeordnete Wert, der entsprechend den <paramref name="options" /> verarbeitet wurde, oder <paramref name="defaultValue" />, wenn <paramref name="name" /> nicht gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Überladung können spezielle Verarbeitung des abgerufenen Werts angeben. Sie können z. B. angeben <xref:Microsoft.Win32.RegistryValueOptions.DoNotExpandEnvironmentNames?displayProperty=nameWithType> beim Abrufen der eines Registrierungswert vom Typ <xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType> zum Abrufen der Zeichenfolge ohne Erweiterung eingebetteten Umgebungsvariablen.  
  
 Verwenden der `defaultValue` Parameter zum Angeben des Werts zurückgegeben, wenn `name` ist nicht vorhanden.  
  
> [!NOTE]
>  Ein Registrierungsschlüssel kann ein Wert sein, die nicht mit einem beliebigen Namen zugeordnet ist. Wenn es sich bei diesen unbenannten Wert in den Registrierungs-Editor angezeigt wird, wird die Zeichenfolge "(Standard)" anstelle eines Namens angezeigt. Um diesen unbenannten Wert abzurufen, geben Sie entweder `null` oder eine leere Zeichenfolge ("") für `name`.  
>   
>  <xref:Microsoft.Win32.RegistryKey.GetValue%2A> Beim Lesen von Werten des Typs REG_NONE oder REG_LINK unterstützt nicht.  In beiden Fällen den Standardwert (`null`) anstelle des tatsächlichen Werts zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Testschlüssel erstellt, fügt einen Wert mit einer eingebetteten Umgebungsvariablen hinzu und ruft den Wert in Formularen erweitert und nicht erweiterten ab.  
  
 [!code-cpp[RegistryValueOptions#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistryValueOptions/CPP/RegistryValueOptions.cpp#1)]
 [!code-csharp[RegistryValueOptions#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryValueOptions/CS/source.cs#1)]
 [!code-vb[RegistryValueOptions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryValueOptions/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt nicht die erforderlichen Berechtigungen zum Lesen aus dem Registrierungsschlüssel.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> enthält, die die angegebene Wert ist geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <exception cref="T:System.IO.IOException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> enthält, die die angegebene Wert zum Löschen gekennzeichnet wurde.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> ist kein gültiger <see cref="T:Microsoft.Win32.RegistryValueOptions" /> Wert; z. B. ein ungültiger Wert umgewandelt wird <see cref="T:Microsoft.Win32.RegistryValueOptions" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer besitzt nicht die notwendigen Registrierungsrechte.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">aus der Registrierung zu lesen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Um einen Registrierungsschlüssel vom Typ REG_EXPAND_SZ zu lesen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:Microsoft.Win32.RegistryValueOptions" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="Overload:Microsoft.Win32.RegistryKey.SetValue" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="GetValueKind">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryValueKind GetValueKind (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.Win32.RegistryValueKind GetValueKind(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValueKind(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValueKind (name As String) As RegistryValueKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryValueKind GetValueKind(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetValueKind : string -&gt; Microsoft.Win32.RegistryValueKind" Usage="registryKey.GetValueKind name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryValueKind</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des Werts, dessen Registrierungsdatentyp abgerufen werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Ruft den Registrierungsdatentyp des Werts ab, der dem angegebenen Namen zugeordnet ist.</summary>
        <returns>Der Registrierungsdatentyp des <paramref name="name" /> zugeordneten Werts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ein Registrierungsschlüssel kann ein Wert sein, die nicht mit einem beliebigen Namen zugeordnet ist. Wenn es sich bei diesen unbenannten Wert in den Registrierungs-Editor angezeigt wird, wird die Zeichenfolge "(Standard)" anstelle eines Namens angezeigt. Geben Sie zum Abrufen des Datentyp für diesen unbenannten Wert entweder `null` oder eine leere Zeichenfolge ("") für `name`.  
  
 Eine Beschreibung der unterstützten Registrierung-Datentypen, finden Sie unter den <xref:Microsoft.Win32.RegistryValueKind> Enumeration.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Testschlüssel und fügt Werte unterschiedliche Datentypen auf den Schlüssel. Im Beispiel liest Name/Wert-Paare, und zeigt sie an der Konsole mit der <xref:Microsoft.Win32.RegistryKey.GetValueKind%2A> Methode, um die entsprechenden Datentypen für die Registrierung abzurufen.  
  
 [!code-cpp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt nicht die erforderlichen Berechtigungen zum Lesen aus dem Registrierungsschlüssel.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> enthält, die die angegebene Wert ist geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <exception cref="T:System.IO.IOException">Der Unterschlüssel, der den angegebenen Wert enthält, ist nicht vorhanden.  
  
- oder -  
Der Name-Wert-Paar, das anhand des <paramref name="name" /> ist nicht vorhanden.  
  
Diese Ausnahme wird unter Windows 95, Windows 98 oder Windows Millennium Edition nicht ausgelöst.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer besitzt nicht die notwendigen Registrierungsrechte.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">aus der Registrierung zu lesen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.SetValue(System.String,System.Object)" />
        <altmember cref="T:Microsoft.Win32.RegistryValueKind" />
      </Docs>
    </Member>
    <Member MemberName="GetValueNames">
      <MemberSignature Language="C#" Value="public string[] GetValueNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetValueNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValueNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValueNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetValueNames();" />
      <MemberSignature Language="F#" Value="member this.GetValueNames : unit -&gt; string[]" Usage="registryKey.GetValueNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein Array von Zeichenfolgen ab, das die Namen aller diesem Schlüssel zugeordneten Werte enthält.</summary>
        <returns>Ein Array von Zeichenfolgen, das die Namen der Werte für den aktuellen Schlüssel enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn keine Wertenamen für den Schlüssel gefunden werden, wird ein leeres Array zurückgegeben.  
  
 Ein Registrierungsschlüssel haben einen Standardwert –, also ein Name/Wert-Paar, das in der der Name ist eine leere Zeichenfolge (""). Wenn Sie ein Standardwert für einen Registrierungsschlüssel festgelegt wurde, wird das Array zurückgegeben, durch die <xref:Microsoft.Win32.RegistryKey.GetValueNames%2A> Methode enthält die leere Zeichenfolge.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:Microsoft.Win32.RegistryKey> Klasse.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt nicht die erforderlichen Berechtigungen zum Lesen aus dem Registrierungsschlüssel.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> bearbeitet wird, ist geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer besitzt nicht die notwendigen Registrierungsrechte.</exception>
        <exception cref="T:System.IO.IOException">Ein Systemfehler ist aufgetreten; Beispielsweise wurde der aktuelle Schlüssel gelöscht.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">die Möglichkeit, die aus der Registrierung gelesen werden soll. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeRegistryHandle Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeRegistryHandle Handle" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As SafeRegistryHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ Handle { Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : Microsoft.Win32.SafeHandles.SafeRegistryHandle" Usage="Microsoft.Win32.RegistryKey.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeRegistryHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:Microsoft.Win32.SafeHandles.SafeRegistryHandle" />-Objekt ab, das den Registrierungsschlüssel darstellt, der vom aktuellen <see cref="T:Microsoft.Win32.RegistryKey" />-Objekt gekapselt wird.</summary>
        <value>Das Handle für den Registrierungsschlüssel.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Der Registrierungsschlüssel ist geschlossen. Geschlossene Schlüssel können nicht zugegriffen werden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer besitzt nicht die notwendigen Registrierungsrechte.</exception>
        <exception cref="T:System.IO.IOException">Ein Systemfehler ist aufgetreten, z. B. Löschen des aktuellen Schlüssels.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt nicht die erforderlichen Berechtigungen zum Lesen des Schlüssels.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Bei den Zugriff auf den angegebenen Registrierungsschlüssel, wenn handelt es sich um eine remote-Schlüssel. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="Microsoft.Win32.RegistryKey.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Schlüssels ab.</summary>
        <value>Der absolute (vollständige) Name des Schlüssels.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Name des Schlüssels enthält den absoluten Pfad des Schlüssels in der Registrierung beginnt stets mit z. B. einem Basisschlüssel HKEY_LOCAL_MACHINE.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:Microsoft.Win32.RegistryKey> Klasse.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> ist geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <altmember cref="M:Microsoft.Win32.RegistryKey.ToString" />
      </Docs>
    </Member>
    <Member MemberName="OpenBaseKey">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey OpenBaseKey (Microsoft.Win32.RegistryHive hKey, Microsoft.Win32.RegistryView view);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey OpenBaseKey(valuetype Microsoft.Win32.RegistryHive hKey, valuetype Microsoft.Win32.RegistryView view) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenBaseKey(Microsoft.Win32.RegistryHive,Microsoft.Win32.RegistryView)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenBaseKey (hKey As RegistryHive, view As RegistryView) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ OpenBaseKey(Microsoft::Win32::RegistryHive hKey, Microsoft::Win32::RegistryView view);" />
      <MemberSignature Language="F#" Value="static member OpenBaseKey : Microsoft.Win32.RegistryHive * Microsoft.Win32.RegistryView -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.OpenBaseKey (hKey, view)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hKey" Type="Microsoft.Win32.RegistryHive" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="view" Type="Microsoft.Win32.RegistryView" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="hKey">Der zu öffnende HKEY.</param>
        <param name="view">Die zu verwendende Registrierungsansicht.</param>
        <summary>Öffnet einen neuen <see cref="T:Microsoft.Win32.RegistryKey" />, der den angeforderten Schlüssel auf dem lokalen Computer mit der angegebenen Ansicht darstellt.</summary>
        <returns>Der angeforderte Registrierungsschlüssel.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="hKey" /> oder <paramref name="view" /> ist ungültig.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer besitzt nicht die notwendigen Registrierungsrechte.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt nicht die erforderlichen Berechtigungen zum Ausführen dieser Aktion.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenRemoteBaseKey">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet einen neuen T:Microsoft.Win32.RegistryKey, der den angeforderten Schlüssel auf einem Remotecomputer darstellt, mit der Option für die angegebene Registrierungsansicht.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenRemoteBaseKey">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey OpenRemoteBaseKey (Microsoft.Win32.RegistryHive hKey, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey OpenRemoteBaseKey(valuetype Microsoft.Win32.RegistryHive hKey, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenRemoteBaseKey (hKey As RegistryHive, machineName As String) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ OpenRemoteBaseKey(Microsoft::Win32::RegistryHive hKey, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member OpenRemoteBaseKey : Microsoft.Win32.RegistryHive * string -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.OpenRemoteBaseKey (hKey, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hKey" Type="Microsoft.Win32.RegistryHive" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="machineName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="hKey">Der zu öffnende HKEY aus der <see cref="T:Microsoft.Win32.RegistryHive" />-Enumeration.</param>
        <param name="machineName">Der Remotecomputer.</param>
        <summary>Öffnet einen neuen <see cref="T:Microsoft.Win32.RegistryKey" />, der den angeforderten Schlüssel für einen Remotecomputer darstellt.</summary>
        <returns>Der angeforderte Registrierungsschlüssel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Registrierung des lokalen Computers wird geöffnet, wenn `machineName` ist <xref:System.String.Empty?displayProperty=nameWithType>. Der angeforderte Schlüssel muss ein Stammschlüssel auf dem Remotecomputer und wird durch die entsprechenden identifiziert <xref:Microsoft.Win32.RegistryHive> Wert.  
  
 Damit für einen Schlüssel Remote geöffnet werden kann müssen sowohl die Server-und Clientcomputern den Remoteregistrierungsdienst ausgeführt werden und ist die Remoteverwaltung aktiviert.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, einen Registrierungsschlüssel auf einem Remotecomputer zu öffnen und die Werte des Schlüssels aufgelistet. Der Remotecomputer muss den Remoteregistrierungsdienst ausgeführt werden. Geben Sie den Namen des Remotecomputers als Befehlszeilenargument, das Programm aufrufen.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey.OpenRemoteBaseKey#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.OpenRemoteBaseKey/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey.OpenRemoteBaseKey#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.OpenRemoteBaseKey/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey.OpenRemoteBaseKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.OpenRemoteBaseKey/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="hKey" /> ist ungültig.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="machineName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="machineName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt nicht die erforderlichen Berechtigungen zum Ausführen dieses Vorgangs.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer besitzt nicht die notwendigen Registrierungsrechte.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Bei den Zugriff auf den angegebenen Registrierungsschlüssel, wenn handelt es sich um eine remote-Schlüssel. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:Microsoft.Win32.RegistryHive" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="OpenRemoteBaseKey">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey OpenRemoteBaseKey (Microsoft.Win32.RegistryHive hKey, string machineName, Microsoft.Win32.RegistryView view);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey OpenRemoteBaseKey(valuetype Microsoft.Win32.RegistryHive hKey, string machineName, valuetype Microsoft.Win32.RegistryView view) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String,Microsoft.Win32.RegistryView)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenRemoteBaseKey (hKey As RegistryHive, machineName As String, view As RegistryView) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ OpenRemoteBaseKey(Microsoft::Win32::RegistryHive hKey, System::String ^ machineName, Microsoft::Win32::RegistryView view);" />
      <MemberSignature Language="F#" Value="static member OpenRemoteBaseKey : Microsoft.Win32.RegistryHive * string * Microsoft.Win32.RegistryView -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.OpenRemoteBaseKey (hKey, machineName, view)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hKey" Type="Microsoft.Win32.RegistryHive" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="machineName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="view" Type="Microsoft.Win32.RegistryView" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="hKey">Der zu öffnende HKEY aus der <see cref="T:Microsoft.Win32.RegistryHive" />-Enumeration.</param>
        <param name="machineName">Der Remotecomputer.</param>
        <param name="view">Die zu verwendende Registrierungsansicht.</param>
        <summary>Öffnet einen neuen Registrierungsschlüssel, der den angeforderten Schlüssel auf einem Remotecomputer mit der angegebenen Ansicht darstellt.</summary>
        <returns>Der angeforderte Registrierungsschlüssel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Registrierung des lokalen Computers wird geöffnet, wenn `machineName` ist <xref:System.String.Empty?displayProperty=nameWithType>. Der angeforderte Schlüssel muss ein Stammschlüssel auf dem Remotecomputer und wird durch die entsprechenden identifiziert <xref:Microsoft.Win32.RegistryHive> Wert.  
  
 Damit für einen Schlüssel Remote geöffnet werden kann müssen sowohl die Server-und Clientcomputern den Remoteregistrierungsdienst ausgeführt werden und ist die Remoteverwaltung aktiviert.  
  
 Auf der 64-Bit-Versionen von Windows werden die Teile der Registrierung für 32-Bit und 64-Bit-Anwendungen getrennt gespeichert. Es gibt eine 32-Bit-Ansicht für 32-Bit-Anwendungen und eine 64-Bit-Ansicht für 64-Bit-Anwendungen. Wenn `view` ist <xref:Microsoft.Win32.RegistryView.Registry64> jedoch der Remotecomputer ein 32-Bit-Betriebssystem ausgeführt wird, wird der zurückgegebene Schlüssel verwendet die <xref:Microsoft.Win32.RegistryView.Registry32> anzeigen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="hKey" /> oder <paramref name="view" /> ist ungültig.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="machineName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="machineName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer besitzt nicht die notwendigen Registrierungsrechte.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt nicht die erforderlichen Berechtigungen zum Ausführen dieses Vorgangs.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenSubKey">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den angegebenen Unterschlüssel ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name oder der Pfad des Unterschlüssels, der schreibgeschützt geöffnet werden soll.</param>
        <summary>Ruft einen Unterschlüssel als schreibgeschützt ab.</summary>
        <returns>Der angeforderte Unterschlüssel oder <see langword="null" />, wenn bei dem Vorgang ein Fehler aufgetreten ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bevor sie mit anderen Methoden und Eigenschaften bearbeitet werden kann, müssen Sie einen Schlüssel öffnen. Um einen Schlüssel zu ändern, müssen Sie es mit einer Überladung der öffnen die <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> -Methode, die Ihnen ermöglicht, die Schreibzugriff, z. B. Angeben der <xref:Microsoft.Win32.RegistryKey.OpenSubKey%28System.String%2CMicrosoft.Win32.RegistryKeyPermissionCheck%29> überladen oder <xref:Microsoft.Win32.RegistryKey.OpenSubKey%28System.String%2CSystem.Boolean%29> überladen.  
  
 Wenn der angegebene Unterschlüssel kann, klicken Sie dann gefunden werden `null` zurückgegeben wird.  
  
 Zum Verwenden der <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> -Methode, benötigen Sie eine Instanz von <xref:Microsoft.Win32.RegistryKey>. Um eine Instanz des <xref:Microsoft.Win32.RegistryKey>, verwenden Sie einen der statischen Elemente der der <xref:Microsoft.Win32.Registry> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Testschlüssel erstellt und verwendet die <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> Methode zum Öffnen aus beiden Überladungen der Methode veranschaulicht.  
  
 [!code-cpp[RegistryKey.OpenSubKey#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CPP/opensubkey.cpp#1)]
 [!code-csharp[RegistryKey.OpenSubKey#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CS/opensubkey.cs#1)]
 [!code-vb[RegistryKey.OpenSubKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryKey.OpenSubKey/VB/opensubkey.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist gleich <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> ist geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt nicht die erforderlichen Berechtigungen zum Lesen des Registrierungsschlüssels.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">die Möglichkeit, den angegebenen Registrierungsschlüssel zu lesen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Bei den Zugriff auf den angegebenen Registrierungsschlüssel, wenn handelt es sich um eine remote-Schlüssel. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, permissionCheck As RegistryKeyPermissionCheck) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey (name, permissionCheck)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Name oder Pfad des zu erstellenden oder zu öffnenden Unterschlüssels.</param>
        <param name="permissionCheck">Einer der Enumerationswerte, der angibt, ob der Schlüssel für Lesezugriff oder für Lese-/Schreibzugriff geöffnet wird.</param>
        <summary>Ruft den angegebenen Unterschlüssel für Lesezugriff oder Lese-/Schreibzugriff ab.</summary>
        <returns>Der angeforderte Unterschlüssel oder <see langword="null" />, wenn bei dem Vorgang ein Fehler aufgetreten ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt eine Ausnahme auszulösen, gibt diese Methode `null` , wenn der angeforderte Schlüssel nicht vorhanden ist.  
  
 Wenn `permissionCheck` ist <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>, wird zum Lesen und Schreiben; der Schlüssel geöffnet, wenn `permissionCheck` ist <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType> oder <xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType>, wird der Schlüssel für das Lesen, es sei denn, mit der übergeordneten Schlüssel geöffnet wurde geöffnet <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>.  
  
 Zum Verwenden der <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> -Methode, benötigen Sie eine Instanz von der <xref:Microsoft.Win32.RegistryKey> Klasse. Um eine Instanz des <xref:Microsoft.Win32.RegistryKey>, verwenden Sie eine der statischen Elemente der der <xref:Microsoft.Win32.Registry> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit 100 Schlüssel/Wert-Paaren erstellt und wird geschlossen. Im Beispiel wird der Unterschlüssel mit <xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default>, zeichnet die Zeit, die sie gelangen zum Lesen aller Werte und schließt den Unterschlüssel. Im Beispiel wird der Unterschlüssel mit <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree> und zeichnet die Zeit, die zum Lesen aller Werte. Schließlich wird im Beispiel berechnet und zeigt die prozentuale leistungsverbesserung.  
  
 [!code-csharp[RegistryKey.OpenSubKey_PermCheck#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryKey.OpenSubKey_PermCheck/cs/source.cs#1)]
 [!code-vb[RegistryKey.OpenSubKey_PermCheck#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryKey.OpenSubKey_PermCheck/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist gleich <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="permissionCheck" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> ist geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt nicht die erforderlichen Berechtigungen zum Lesen des Registrierungsschlüssels.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">die Möglichkeit, den angegebenen Registrierungsschlüssel zu lesen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Bei den Zugriff auf den angegebenen Registrierungsschlüssel, wenn handelt es sich um eine remote-Schlüssel. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, writable As Boolean) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, bool writable);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string * bool -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey (name, writable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Name oder Pfad des zu öffnenden Unterschlüssels.</param>
        <param name="writable">Muss für Schreibzugriff auf den Schlüssel auf <see langword="true" /> festgelegt werden.</param>
        <summary>Ruft einen angegebenen Unterschlüssel ab und gibt an, ob Schreibzugriff auf den Schlüssel angewendet werden soll.</summary>
        <returns>Der angeforderte Unterschlüssel oder <see langword="null" />, wenn bei dem Vorgang ein Fehler aufgetreten ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der angeforderte Schlüssel nicht vorhanden ist, gibt diese Methode `null` anstatt eine Ausnahme auszulösen.  
  
 Wenn `writable` ist `true`, der Schlüssel wird zum Lesen und Schreiben geöffnet werden, andernfalls der Schlüssel geöffnet als schreibgeschützt.  
  
 Zum Verwenden der <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> -Methode, benötigen Sie eine Instanz von der <xref:Microsoft.Win32.RegistryKey> Methode. Um eine Instanz des <xref:Microsoft.Win32.RegistryKey>, verwenden Sie eine der statischen Elemente der der <xref:Microsoft.Win32.Registry> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Testschlüssel erstellt und verwendet die <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> Methode zum Öffnen aus beiden Überladungen der Methode veranschaulicht.  
  
 [!code-cpp[RegistryKey.OpenSubKey#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CPP/opensubkey.cpp#1)]
 [!code-csharp[RegistryKey.OpenSubKey#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CS/opensubkey.cs#1)]
 [!code-vb[RegistryKey.OpenSubKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryKey.OpenSubKey/VB/opensubkey.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> ist geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt nicht die erforderlichen Berechtigungen zum Zugriff auf den Registrierungsschlüssel im angegebenen Modus.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">die Möglichkeit, den angegebenen Registrierungsschlüssel zu lesen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Bei den Zugriff auf den angegebenen Registrierungsschlüssel, wenn handelt es sich um eine remote-Schlüssel. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, System.Security.AccessControl.RegistryRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, valuetype System.Security.AccessControl.RegistryRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Security.AccessControl.RegistryRights)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, rights As RegistryRights) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, System::Security::AccessControl::RegistryRights rights);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string * System.Security.AccessControl.RegistryRights -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.RegistryRights" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Name oder Pfad des zu erstellenden oder zu öffnenden Unterschlüssels.</param>
        <param name="rights">Die Berechtigungen für den Registrierungsschlüssel.</param>
        <summary>Ruft einen Unterschlüssel mit dem angegebenen Namen und Zugriffsrechten ab. Verfügbar ab .NET Framework 4.6.</summary>
        <returns>Der angeforderte Unterschlüssel oder <see langword="null" />, wenn bei dem Vorgang ein Fehler aufgetreten ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bevor sie mit anderen Methoden und Eigenschaften bearbeitet werden kann, müssen Sie einen Schlüssel öffnen. Um einen Schlüssel zu ändern, müssen Sie es mit einer Überladung der öffnen die <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> -Methode, die Sie Schreibzugriff angeben kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> ist geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt nicht die erforderlichen Berechtigungen zum Zugriff auf den Registrierungsschlüssel im angegebenen Modus.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, System.Security.AccessControl.RegistryRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype System.Security.AccessControl.RegistryRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,System.Security.AccessControl.RegistryRights)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, permissionCheck As RegistryKeyPermissionCheck, rights As RegistryRights) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, System::Security::AccessControl::RegistryRights rights);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck * System.Security.AccessControl.RegistryRights -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey (name, permissionCheck, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.RegistryRights" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Name oder Pfad des zu erstellenden oder zu öffnenden Unterschlüssels.</param>
        <param name="permissionCheck">Einer der Enumerationswerte, der angibt, ob der Schlüssel für Lesezugriff oder für Lese-/Schreibzugriff geöffnet wird.</param>
        <param name="rights">Eine bitweise Kombination von Enumerationswerten, die den gewünschten Sicherheitszugriff angeben.</param>
        <summary>Ruft den angegebenen Unterschlüssel für Lesezugriff oder Lese-/Schreibzugriff ab, und fordert die angegebenen Zugriffsrechte an.</summary>
        <returns>Der angeforderte Unterschlüssel oder <see langword="null" />, wenn bei dem Vorgang ein Fehler aufgetreten ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt eine Ausnahme auszulösen, gibt diese Methode `null` , wenn der angeforderte Schlüssel nicht vorhanden ist.  
  
 Wenn `permissionCheck` ist <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>, wird zum Lesen und Schreiben; der Schlüssel geöffnet, wenn `permissionCheck` ist <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType> oder <xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType>, wird der Schlüssel für das Lesen, es sei denn, mit der übergeordneten Schlüssel geöffnet wurde geöffnet <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>.  
  
 Der Zugriff für angegebene `permissionCheck` hat Vorrang vor den Zugriff für angegebene `rights`. Wenn Sie angeben, z. B. <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType> für `permissionCheck` und <xref:System.Security.AccessControl.RegistryRights.WriteKey?displayProperty=nameWithType> für `rights`, beim Schreiben auf den Unterschlüssel löst eine Ausnahme aus.  
  
 Zum Verwenden der <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> -Methode, benötigen Sie eine Instanz von der <xref:Microsoft.Win32.RegistryKey> Klasse. Um eine Instanz des <xref:Microsoft.Win32.RegistryKey>, verwenden Sie eine der statischen Elemente der der <xref:Microsoft.Win32.Registry> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist gleich <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="permissionCheck" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> ist geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <exception cref="T:System.Security.SecurityException"><paramref name="rights" /> enthält ungültige Werte für Registrierungsrechte.  
  
- oder -  
Der Benutzer besitzt nicht die angeforderten Berechtigungen.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">die Möglichkeit, den angegebenen Registrierungsschlüssel zu lesen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Bei den Zugriff auf den angegebenen Registrierungsschlüssel, wenn handelt es sich um eine remote-Schlüssel. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.RegistrySecurity registrySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.RegistrySecurity registrySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.SetAccessControl(System.Security.AccessControl.RegistrySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::RegistrySecurity ^ registrySecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.RegistrySecurity -&gt; unit" Usage="registryKey.SetAccessControl registrySecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="registrySecurity" Type="System.Security.AccessControl.RegistrySecurity" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="registrySecurity">Die Zugriffssteuerungssicherheit, die für den aktuellen Unterschlüssel angewendet werden soll.</param>
        <summary>Übernimmt Windows-Zugriffssteuerungssicherheit für einen vorhandenen Registrierungsschlüssel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden, um Berechtigungen für einen Registrierungsschlüssel ändern der <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A> Methode zum Abrufen einer <xref:System.Security.AccessControl.RegistrySecurity> Objekt, das die vorhandene Windows-zugriffssteuerungssicherheit darstellt, zu ändern, die <xref:System.Security.AccessControl.RegistrySecurity> Objekt aus, und verwenden Sie dann die <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A> Methode, um das Sicherheitsupdate für Der Schlüssel.  
  
> [!CAUTION]
>  Die <xref:System.Security.AccessControl.RegistrySecurity> für angegebene Objekt `registrySecurity` ersetzt die vorhandene Sicherheit für den Registrierungsschlüssel. Um Berechtigungen für einen neuen Benutzer hinzuzufügen, verwenden Sie die <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A> Methode zum Abrufen des vorhandenen Zugriffs Steuern der Sicherheit, und anschließend zu ändern.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird einen Testschlüssel erstellt. Der aktuelle Benutzer kann <xref:System.Security.AccessControl.RegistryRights.ReadKey> und <xref:System.Security.AccessControl.RegistryRights.Delete> Rechte jedoch verweigert <xref:System.Security.AccessControl.RegistryRights.ChangePermissions> und <xref:System.Security.AccessControl.RegistryRights.WriteKey> Rechte. Nachfolgende versucht, die erfolgreich oder Fehler, die Abhängigkeit von diesen Berechtigungen.  
  
 Bevor der Schlüssel gelöscht wird, wird der Code angehalten. Wechseln Sie zu den Registrierungs-Editor, und stellen Sie sicher, dass die gleichen Zugriffsrechte angewendet werden soll, wenn die Schlüssel zugegriffen wird, verwenden den Registrierungs-Editor. (Dies funktioniert am besten bei Verwendung von **RunAs** über die Befehlszeile, um den Registrierungs-Editor und der Beispielcode als lokaler Benutzer ohne Administratorrechte ausführen. Die Registrierungs-Editor kann ein Administrator Berechtigungen ändern immer, auch wenn der besagte Administrator diese Berechtigungen verweigert wurde. Wenn Sie einen lokalen Benutzer, die den Befehl "," testuser "definiert haben `runas /user:TestUser cmd` öffnet ein Befehlsfenster auf dem Sie den Registrierungs-Editor, und klicken Sie dann den Beispielcode ausführen können.)  
  
 [!code-cpp[RegistrySecurity101#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistrySecurity101/cpp/source.cpp#1)]
 [!code-csharp[RegistrySecurity101#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistrySecurity101/CS/source.cs#1)]
 [!code-vb[RegistrySecurity101#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistrySecurity101/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Die aktuelle <see cref="T:Microsoft.Win32.RegistryKey" /> Objekt stellt einen Schlüssel mit zugriffssteuerungssicherheit dar, und der Aufrufer verfügt nicht über <see cref="F:System.Security.AccessControl.RegistryRights.ChangePermissions" /> Rechte.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="registrySecurity" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> bearbeitet wird, ist geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt den Wert eines Name-Wert-Paars im Registrierungsschlüssel fest. Je nach Überladung wird der Registrierungsdatentyp entweder abhängig von der Art der zu speichernden Daten oder abhängig von <see cref="T:Microsoft.Win32.RegistryValueKind" /> bestimmt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (string name, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(string name, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.SetValue(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (name As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::String ^ name, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : string * obj -&gt; unit" Usage="registryKey.SetValue (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu speichernden Werts.</param>
        <param name="value">Die zu speichernden Daten.</param>
        <summary>Legt das angegebene Name-Wert-Paar fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da viele Werte in jedem Schlüssel in der Registrierung gespeichert werden können, müssen Sie verwenden die `name` Parameter zum Angeben eines bestimmten Werts festlegen möchten.  
  
> [!NOTE]
>  Ein Registrierungsschlüssel kann ein Wert sein, die nicht mit einem beliebigen Namen zugeordnet ist. Wenn es sich bei diesen unbenannten Wert in den Registrierungs-Editor angezeigt wird, wird die Zeichenfolge "(Standard)" anstelle eines Namens angezeigt. Um dies unbenannten Wert festzulegen, geben Sie entweder `null` oder eine leere Zeichenfolge ("") für `name`.  
  
 Um die Werte in einen Schlüssel festzulegen, müssen Sie den Schlüssel mit Schreibzugriff öffnen. Wenn Sie einen Schlüssel mit Schreibzugriff geöffnet haben, können Sie Name/Wert-Paare in diesem Schlüssel ändern.  
  
 Wenn das angegebene `name` existiert nicht in den Schlüssel, wird er erstellt und der zugehörige Wert wird festgelegt, um `value`.  
  
 Diese Überladung der <xref:Microsoft.Win32.RegistryKey.SetValue%2A> 64-Bit-Ganzzahlen als Zeichenfolgen speichert (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>). Zum Speichern von 64-Bit-Zahlen als <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType> verwenden Sie die Werte, die <xref:Microsoft.Win32.RegistryKey.SetValue%28System.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> Überladung, der angibt, <xref:Microsoft.Win32.RegistryValueKind>.  
  
 Diese Überladung der <xref:Microsoft.Win32.RegistryKey.SetValue%2A> speichert alle Zeichenfolgenwerte als <xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>, auch wenn sie erweiterbare Verweise auf Umgebungsvariablen enthalten. Zum Speichern von Zeichenfolgenwerten als erweiterbarer Zeichenfolgen (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), verwenden Sie die <xref:Microsoft.Win32.RegistryKey.SetValue%28System.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> Überladung, der angibt, <xref:Microsoft.Win32.RegistryValueKind>.  
  
 Numerische Typen als 32-Bit-Ganzzahlen werden durch diese methodenüberladung als Zeichenfolgen gespeichert. Enumerationselementen werden als Zeichenfolgen, die mit den Elementnamen gespeichert.  
  
> [!CAUTION]
>  Machen Sie nicht <xref:Microsoft.Win32.RegistryKey> Objekte so, dass ein schädliches Programm kann Tausende von bedeutungslosen Unterschlüsseln erstellen oder Schlüssel/Wert-Paare. Lassen Sie Aufrufer beliebige Schlüssel oder Werte eingeben zu, z. B. nicht.  
  
> [!NOTE]
>  Unter Windows 98 und Windows Millennium Edition ist die Registrierung nicht Unicode, und nicht alle Unicode-Zeichen sind für alle Codepages gültig. Ein Unicode-Zeichen, die für die aktuelle Codepage ungültig ist, wird durch die beste Übereinstimmung ersetzt. Es werden keine Ausnahmen ausgelöst.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die <xref:Microsoft.Win32.RegistryKey.SetValue%2A> Methode bestimmt den Datentyp aus, wenn sie Werte festlegt. Das Beispiel erstellt einen Testschlüssel und fügt Werte unterschiedliche Datentypen auf den Schlüssel. Im Beispiel liest Name/Wert-Paare, und zeigt sie an der Konsole mit der <xref:Microsoft.Win32.RegistryKey.GetValueKind%2A> Methode, um die entsprechenden Datentypen für die Registrierung anzuzeigen.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey.SetValue1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.SetValue1/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey.SetValue1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.SetValue1/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey.SetValue1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.SetValue1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> ist ein nicht unterstützter Datentyp.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> enthält, die die angegebene Wert ist geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> ist schreibgeschützt und kann nicht geschrieben werden; z. B. der Schlüssel nicht mit Schreibzugriff geöffnet wurde.  
  
- oder -  
Die <see cref="T:Microsoft.Win32.RegistryKey" /> -Objekt stellt einen Knoten auf Stammebene dar, und das Betriebssystem ist Windows Millennium Edition oder Windows 98.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Erstellen oder Ändern von Registrierungsschlüsseln.</exception>
        <exception cref="T:System.IO.IOException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> -Objekt stellt einen Knoten auf Stammebene dar, und das Betriebssystem ist Windows 2000, Windows XP oder Windows Server 2003.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">den angegebene Registrierungsschlüssel zu ändern, falls vorhanden, oder die Registrierungsschlüssel zu erstellen, wenn es nicht bereits vorhanden ist. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Bei den Zugriff auf den angegebenen Registrierungsschlüssel, wenn handelt es sich um eine remote-Schlüssel. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueKind(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (string name, object value, Microsoft.Win32.RegistryValueKind valueKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(string name, object value, valuetype Microsoft.Win32.RegistryValueKind valueKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.SetValue(System.String,System.Object,Microsoft.Win32.RegistryValueKind)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (name As String, value As Object, valueKind As RegistryValueKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::String ^ name, System::Object ^ value, Microsoft::Win32::RegistryValueKind valueKind);" />
      <MemberSignature Language="F#" Value="member this.SetValue : string * obj * Microsoft.Win32.RegistryValueKind -&gt; unit" Usage="registryKey.SetValue (name, value, valueKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueKind" Type="Microsoft.Win32.RegistryValueKind" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu speichernden Werts.</param>
        <param name="value">Die zu speichernden Daten.</param>
        <param name="valueKind">Der beim Speichern der Daten zu verwendende Registrierungsdatentyp.</param>
        <summary>Legt mithilfe des angegebenen Registrierungsdatentyps den Wert eines Name-Wert-Paars im Registrierungsschlüssel fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da viele Werte in jedem Schlüssel in der Registrierung gespeichert werden können, müssen Sie verwenden die `name` Parameter zum Angeben eines bestimmten Werts festlegen möchten.  
  
> [!NOTE]
>  Ein Registrierungsschlüssel kann ein Wert sein, die nicht mit einem beliebigen Namen zugeordnet ist. Wenn es sich bei diesen unbenannten Wert in den Registrierungs-Editor angezeigt wird, wird die Zeichenfolge "(Standard)" anstelle eines Namens angezeigt. Um dies unbenannten Wert festzulegen, geben Sie entweder `null` oder eine leere Zeichenfolge ("") für `name`.  
  
 Um die Werte in einen Schlüssel festzulegen, müssen Sie den Schlüssel mit Schreibzugriff öffnen. Wenn Sie einen Schlüssel mit Schreibzugriff geöffnet haben, können Sie Name/Wert-Paare in diesem Schlüssel ändern.  
  
 Wenn das angegebene `name` existiert nicht in den Schlüssel, wird er erstellt, und der zugehörige Wert wird festgelegt, um `value`.  
  
> [!NOTE]
>  Angeben des Registrierungsdatentyps <xref:Microsoft.Win32.RegistryValueKind.Unknown> entspricht der Verwendung der <xref:Microsoft.Win32.RegistryKey.SetValue%2A> überladen.  
  
 Wenn der Typ des angegebenen `value` entspricht nicht dem angegebenen `valueKind`, und die Daten können nicht konvertiert, <xref:System.ArgumentException> ausgelöst. Sie können z. B. Speichern einer <xref:System.Int64?displayProperty=nameWithType> als eine <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>, jedoch nur, wenn sein Wert kleiner als der Maximalwert ist eine <xref:System.Int32?displayProperty=nameWithType>. Kann nicht gespeichert werden als einen einzelnen Zeichenfolgenwert ein <xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Wenn geschachtelte Werte übergeben werden, für die <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType> oder <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>, die Konvertierung erfolgt mit der invarianten Kultur.  
  
> [!CAUTION]
>  Machen Sie nicht <xref:Microsoft.Win32.RegistryKey> Objekte so, dass ein schädliches Programm kann Tausende von bedeutungslosen Unterschlüsseln erstellen oder Schlüssel/Wert-Paare. Lassen Sie Aufrufer beliebige Schlüssel oder Werte eingeben zu, z. B. nicht.  
  
> [!NOTE]
>  Unter Windows 98 und Windows Millennium Edition ist die Registrierung nicht Unicode, und nicht alle Unicode-Zeichen sind für alle Codepages gültig. Ein Unicode-Zeichen, die für die aktuelle Codepage ungültig ist, wird durch die beste Übereinstimmung ersetzt. Es werden keine Ausnahmen ausgelöst.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Testschlüssel erstellt und verwendet die <xref:Microsoft.Win32.RegistryKey.SetValue%2A> Methode zum Speichern mehrerer Werte, den Datentyp für jeden Wert angeben. Im Beispiel liest Name/Wert-Paare, und zeigt sie an der Konsole mit der <xref:Microsoft.Win32.RegistryKey.GetValueKind%2A> Methode, um die entsprechenden Datentypen für die Registrierung anzuzeigen.  
  
 [!code-cpp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der Typ des <paramref name="value" /> entsprach nicht den durch angegebenen Registrierungsdatentyp <paramref name="valueKind" />, daher die Daten konnten nicht konvertiert werden ordnungsgemäß.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> enthält, die die angegebene Wert ist geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> ist schreibgeschützt und kann nicht geschrieben werden; z. B. der Schlüssel nicht mit Schreibzugriff geöffnet wurde.  
  
- oder -  
Die <see cref="T:Microsoft.Win32.RegistryKey" /> -Objekt stellt einen Knoten auf Stammebene dar, und das Betriebssystem ist Windows Millennium Edition oder Windows 98.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Erstellen oder Ändern von Registrierungsschlüsseln.</exception>
        <exception cref="T:System.IO.IOException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> -Objekt stellt einen Knoten auf Stammebene dar, und das Betriebssystem ist Windows 2000, Windows XP oder Windows Server 2003.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">den angegebene Registrierungsschlüssel zu ändern, falls vorhanden, oder die Registrierungsschlüssel zu erstellen, wenn es nicht bereits vorhanden ist. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Bei den Zugriff auf den angegebenen Registrierungsschlüssel, wenn handelt es sich um eine remote-Schlüssel. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueKind(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="T:Microsoft.Win32.RegistryValueKind" />
      </Docs>
    </Member>
    <Member MemberName="SubKeyCount">
      <MemberSignature Language="C#" Value="public int SubKeyCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SubKeyCount" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SubKeyCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SubKeyCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SubKeyCount : int" Usage="Microsoft.Win32.RegistryKey.SubKeyCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Unterschlüssel des aktuellen Schlüssels ab.</summary>
        <value>Die Anzahl der Unterschlüssel des aktuellen Schlüssels.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist nicht rekursiv zählt die Namen. Es gibt nur die Anzahl der Namen, auf der Basis-Ebene, die von dem es aufgerufen wurde.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:Microsoft.Win32.RegistryKey> Klasse.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt keine Leseberechtigung für den Schlüssel.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> bearbeitet wird, ist geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer besitzt nicht die notwendigen Registrierungsrechte.</exception>
        <exception cref="T:System.IO.IOException">Ein Systemfehler ist aufgetreten, z. B. der aktuelle Schlüssel gelöscht wurde.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">die Möglichkeit, den angegebenen Registrierungsschlüssel zu lesen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt <see cref="M:Microsoft.Win32.RegistryKey.Close" /> für den aktuellen Schlüssel durch.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Diese Methode hat dieselbe Wirkung wie das Aufrufen <xref:Microsoft.Win32.RegistryKey.Close%2A>.

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="registryKey.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine Zeichenfolgenentsprechung dieses Schlüssels ab.</summary>
        <returns>Eine Zeichenfolge, die den Schlüssel darstellt. Wenn der angegebene Schlüssel ungültig ist (nicht gefunden werden kann), wird <see langword="null" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert enthält den Registrierungspfad, der dem angegebenen Schlüssel und den hexadezimalen Wert für den Schlüssel an. Der Registrierungspfad den absoluten Stamm des dem angegebenen Schlüssel enthält, beginnt immer mit einem der Basisschlüssel für die Registrierung, z. B. HKEY_LOCAL_MACHINE.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:Microsoft.Win32.RegistryKey> Klasse.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> auf die zugegriffen wird, ist geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <altmember cref="P:Microsoft.Win32.RegistryKey.Name" />
      </Docs>
    </Member>
    <Member MemberName="ValueCount">
      <MemberSignature Language="C#" Value="public int ValueCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ValueCount" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.ValueCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ValueCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueCount : int" Usage="Microsoft.Win32.RegistryKey.ValueCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Werte im Schlüssel ab.</summary>
        <value>Die Anzahl der Name-Wert-Paare im Schlüssel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Registrierungsschlüssel verfügt über einen Standardwert, der nicht mit einem beliebigen Namen zugeordnet ist. Diese unbenannten Wert kann festgelegt werden, mithilfe der <xref:Microsoft.Win32.RegistryKey.SetValue%2A> -Methode, und geben entweder `null` oder eine leere Zeichenfolge ("") für `name`. Wenn der Wert nicht festgelegt wurde, sie trägt nicht auf die Gesamtzahl von zurückgegebenen der <xref:Microsoft.Win32.RegistryKey.ValueCount%2A> Eigenschaft, nachdem es festgelegt wurde, allerdings es ist immer gezählt.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:Microsoft.Win32.RegistryKey> Klasse.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt keine Leseberechtigung für den Schlüssel.</exception>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:Microsoft.Win32.RegistryKey" /> bearbeitet wird, ist geschlossen (auf geschlossene Schlüssel können nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer besitzt nicht die notwendigen Registrierungsrechte.</exception>
        <exception cref="T:System.IO.IOException">Ein Systemfehler ist aufgetreten, z. B. der aktuelle Schlüssel gelöscht wurde.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">die Möglichkeit, den angegebenen Registrierungsschlüssel zu lesen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="View">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryView View { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.Win32.RegistryView View" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.View" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property View As RegistryView" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::RegistryView View { Microsoft::Win32::RegistryView get(); };" />
      <MemberSignature Language="F#" Value="member this.View : Microsoft.Win32.RegistryView" Usage="Microsoft.Win32.RegistryKey.View" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Ansicht ab, mit der der Registrierungsschlüssel erstellt wurde.</summary>
        <value>Die Ansicht, mit der der Registrierungsschlüssel erstellt wurde.  
  
- oder -  
 <see cref="F:Microsoft.Win32.RegistryView.Default" />, wenn keine Ansicht verwendet wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Auf der 64-Bit-Versionen von Windows werden die Teile der Registrierung für 32-Bit und 64-Bit-Anwendungen getrennt gespeichert. Es gibt eine 32-Bit-Ansicht für 32-Bit-Anwendungen und eine 64-Bit-Ansicht für 64-Bit-Anwendungen.  
  
 Gehen Sie nicht, dass die Ansicht immer die tatsächliche Ansicht entspricht der <xref:Microsoft.Win32.RegistryKey>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>