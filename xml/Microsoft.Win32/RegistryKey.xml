<Type Name="RegistryKey" FullName="Microsoft.Win32.RegistryKey">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f12d6b5694266f2353c22c7a207ab1162de17894" /><Meta Name="ms.sourcegitcommit" Value="95e24aee1283af2f120fc5da4b0bdc0712ab698f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/06/2019" /><Meta Name="ms.locfileid" Value="65156018" /></Metadata><TypeSignature Language="C#" Value="public sealed class RegistryKey : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed RegistryKey extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.RegistryKey" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class RegistryKey&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class RegistryKey sealed : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type RegistryKey = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen Knoten auf Schlüsselebene in der Windows-Registrierung dar. Diese Klasse ist eine Kapselung der Registrierung.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um eine Instanz von <xref:Microsoft.Win32.RegistryKey>zu erhalten, verwenden Sie eines der statischen Member <xref:Microsoft.Win32.Registry> der-Klasse.  
  
 Die Registrierung fungiert als zentrales Repository mit Informationen für das Betriebssystem und die Anwendungen auf einem Computer. Die Registrierung wird in einem hierarchischen Format organisiert, basierend auf einer logischen Reihenfolge der darin gespeicherten Elemente (Weitere Informationen <xref:Microsoft.Win32.Registry> finden Sie unter für die basisebenenelemente in dieser Hierarchie). Wenn Sie Informationen in der Registrierung speichern, wählen Sie den entsprechenden Speicherort basierend auf dem Typ der gespeicherten Informationen aus. Vermeiden Sie das zerstören von Informationen, die von anderen Anwendungen erstellt wurden, da dies dazu führen kann, dass diese Anwendungen unerwartetes Verhalten aufweisen und auch eine negative Auswirkung auf Ihre eigene Anwendung haben können.  
  
> [!IMPORTANT]
>  Dieser Typ implementiert die <xref:System.IDisposable>-Schnittstelle. Nach Abschluss der Verwendung sollten Sie den Typ entweder direkt oder indirekt löschen. Zum direkten Löschen des Typs rufen Sie seine <xref:System.IDisposable.Dispose%2A>-Methode in einem `try`/`catch`-Block auf. Zum indirekten Löschen verwenden Sie ein Sprachkonstrukt wie `using` (in C#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt „Verwenden eines Objekts, das IDisposable implementiert“ des Themas „Die <xref:System.IDisposable>-Schnittstelle“.  
  
 Registrierungsschlüssel sind die Basiseinheit der Organisation in der Registrierung und können mit Ordnern im Datei-Explorer verglichen werden. Ein bestimmter Schlüssel kann Unterschlüssel aufweisen, ebenso wie ein Ordner Unterordner aufweisen kann. Jeder Schlüssel kann gelöscht werden, solange der Benutzer über die entsprechenden Berechtigungen verfügt, und der Schlüssel ist kein Basis Schlüssel oder auf der Ebene direkt unter den Basis Schlüsseln. Jedem Schlüssel können auch mehrere Werte zugeordnet sein (ein Wert kann mit einer Datei verglichen werden), die zum Speichern der Informationen verwendet werden, z. b. Informationen zu einer Anwendung, die auf dem Computer installiert ist. Jeder Wert enthält ein bestimmtes Informationselement, das bei Bedarf abgerufen oder aktualisiert werden kann. Beispielsweise können Sie einen <xref:Microsoft.Win32.RegistryKey> für Ihr Unternehmen erstellen, unter dem Schlüssel HKEY_LOCAL_MACHINE\Software und dann einen Unterschlüssel für jede Anwendung, die von Ihrem Unternehmen erstellt wird. Jeder Unterschlüssel enthält die Informationen, die für diese Anwendung spezifisch sind, z. b. Farbeinstellungen, Bildschirmposition und Größe oder erkannte Dateierweiterungen.  
  
 Beachten Sie, dass die in der Registrierung gespeicherten Informationen für andere Anwendungen und Benutzer verfügbar sind und daher nicht zum Speichern von Sicherheitsdaten oder kritischen Anwendungsinformationen verwendet werden sollten.  
  
> [!CAUTION]
>  Machen Sie <xref:Microsoft.Win32.RegistryKey> Objekte nicht so verfügbar, dass ein schädliches Programm Tausende von bedeutungslosen unter Schlüsseln oder Schlüssel-Wert-Paaren erstellen könnte. Gestatten Sie z. b. nicht, dass Aufrufer beliebige Schlüssel oder Werte eingeben.  
  
 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]Ab ist die Länge eines Registrierungsschlüssels nicht mehr auf 255 Zeichen beschränkt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie Sie unter HKEY_CURRENT_USER einen Unterschlüssel erstellen, seinen Inhalt ändern und dann den Unterschlüssel löschen.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.Registry" />
    <altmember cref="T:Microsoft.Win32.RegistryHive" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="registryKey.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt den Schlüssel und schreibt diesen auf den Datenträger weg, sofern der Inhalt verändert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen dieser Methode für Systemschlüssel hat keine Auswirkung, da Systemschlüssel nie geschlossen werden.  
  
 Diese Methode führt keine Aktion aus, wenn Sie Sie für eine `RegistryKey` Instanz von aufruft, die bereits geschlossen wurde.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:Microsoft.Win32.RegistryKey> -Klasse bereitgestellt wird.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.Win32.RegistryKey.Flush" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateSubKey">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen neuen Unterschlüssel oder öffnet einen vorhandenen Unterschlüssel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey subkey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subkey">Name oder Pfad des zu erstellenden oder zu öffnenden Unterschlüssels. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Erstellt einen neuen Unterschlüssel oder öffnet einen vorhandenen Unterschlüssel für Schreibzugriff.</summary>
        <returns>Der neu erstellte Unterschlüssel oder <see langword="null" />, wenn bei dem Vorgang ein Fehler aufgetreten ist. Wenn eine Zeichenfolge der Länge 0 (null) für <paramref name="subkey" /> angegeben ist, wird das aktuelle <see cref="T:Microsoft.Win32.RegistryKey" />-Objekt zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um diese Aktion auszuführen, muss der Benutzer in der Registrierungs Hierarchie auf dieser Ebene über die entsprechende Berechtigung verfügen.  
  
> [!CAUTION]
>  Machen Sie <xref:Microsoft.Win32.RegistryKey> Objekte nicht so verfügbar, dass ein schädliches Programm Tausende von bedeutungslosen unter Schlüsseln oder Schlüssel-Wert-Paaren erstellen könnte. Gestatten Sie z. b. nicht, dass Aufrufer beliebige Schlüssel oder Werte eingeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie Sie unter HKEY_CURRENT_USER einen Unterschlüssel erstellen, seinen Inhalt ändern und dann den Unterschlüssel löschen.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="subkey" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Erstellen oder Öffnen des Registrierungsschlüssels.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:Microsoft.Win32.RegistryKey" />, für den die Methode aufgerufen wird, ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der aktuelle <see cref="T:Microsoft.Win32.RegistryKey" /> kann nicht bearbeitet werden. Möglicherweise wurde der Schlüssel schreibgeschützt geöffnet, oder der Benutzer verfügt nicht über die erforderlichen Zugriffsrechte.</exception>
        <exception cref="T:System.IO.IOException">Die Schachtelungsebene überschreitet 510.  
  
- oder - 
Ein Systemfehler ist aufgetreten. Möglicherweise wurde der Schlüssel gelöscht, oder es wurde versucht, einen Schlüssel im <see cref="F:Microsoft.Win32.Registry.LocalMachine" />-Stamm zu erstellen.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">die Möglichkeit, den angegebenen Registrierungsschlüssel zu ändern, wenn er vorhanden ist, oder, wenn er nicht bereits vorhanden ist. Zugehörige Enumerationen <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />:,<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">die Möglichkeit, auf den angegebenen Registrierungsschlüssel zuzugreifen, wenn es sich um einen Remote Schlüssel handelt. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, permissionCheck As RegistryKeyPermissionCheck) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, permissionCheck)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="subkey">Name oder Pfad des zu erstellenden oder zu öffnenden Unterschlüssels. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="permissionCheck">Einer der Enumerationswerte, der angibt, ob der Schlüssel für Lesezugriff oder für Lese-/Schreibzugriff geöffnet wird.</param>
        <summary>Erstellt einen neuen Unterschlüssel oder öffnet einen vorhandenen Unterschlüssel für Schreibzugriff unter Verwendung der angegebenen Berechtigungsprüfungsoption.</summary>
        <returns>Der neu erstellte Unterschlüssel oder <see langword="null" />, wenn bei dem Vorgang ein Fehler aufgetreten ist. Wenn eine Zeichenfolge der Länge 0 (null) für <paramref name="subkey" /> angegeben ist, wird das aktuelle <see cref="T:Microsoft.Win32.RegistryKey" />-Objekt zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um diese Aktion auszuführen, muss der Benutzer in der Registrierungs Hierarchie auf dieser Ebene über die entsprechende Berechtigung verfügen.  
  
> [!CAUTION]
>  Machen Sie <xref:Microsoft.Win32.RegistryKey> Objekte nicht so verfügbar, dass ein schädliches Programm Tausende von bedeutungslosen unter Schlüsseln oder Schlüssel-Wert-Paaren erstellen könnte. Gestatten Sie z. b. nicht, dass Aufrufer beliebige Schlüssel oder Werte eingeben.  
  
 Um die <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> -Methode verwenden zu können, müssen Sie über eine Instanz <xref:Microsoft.Win32.RegistryKey> der-Klasse verfügen. Um eine Instanz von <xref:Microsoft.Win32.RegistryKey>zu erhalten, verwenden Sie eines der statischen Member <xref:Microsoft.Win32.Registry> der-Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="subkey" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Erstellen oder Öffnen des Registrierungsschlüssels.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="permissionCheck" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:Microsoft.Win32.RegistryKey" />, für den die Methode aufgerufen wird, ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der aktuelle <see cref="T:Microsoft.Win32.RegistryKey" /> kann nicht bearbeitet werden. Möglicherweise wurde der Schlüssel schreibgeschützt geöffnet, oder der Benutzer verfügt nicht über die erforderlichen Zugriffsrechte.</exception>
        <exception cref="T:System.IO.IOException">Die Schachtelungsebene überschreitet 510.  
  
- oder - 
Ein Systemfehler ist aufgetreten. Möglicherweise wurde der Schlüssel gelöscht, oder es wurde versucht, einen Schlüssel im <see cref="F:Microsoft.Win32.Registry.LocalMachine" />-Stamm zu erstellen.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">die Möglichkeit, den angegebenen Registrierungsschlüssel zu ändern, wenn er vorhanden ist, oder, wenn er nicht bereits vorhanden ist. Zugehörige Enumerationen <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />:,<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">die Möglichkeit, auf den angegebenen Registrierungsschlüssel zuzugreifen, wenn es sich um einen Remote Schlüssel handelt. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, writable As Boolean) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, bool writable);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * bool -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, writable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="writable" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="subkey">Name oder Pfad des zu erstellenden oder zu öffnenden Unterschlüssels. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="writable"><see langword="true" />, um anzugeben, dass der neue Unterschlüssel bearbeitet werden kann, andernfalls <see langword="false" />.</param>
        <summary>Erstellt einen neuen Unterschlüssel oder öffnet einen vorhandenen Unterschlüssel mit dem angegebenen Zugriffsmodus. Verfügbar ab .NET Framework 4.6.</summary>
        <returns>Der neu erstellte Unterschlüssel oder <see langword="null" />, wenn bei dem Vorgang ein Fehler aufgetreten ist. Wenn eine Zeichenfolge der Länge 0 (null) für <paramref name="subkey" /> angegeben ist, wird das aktuelle <see cref="T:Microsoft.Win32.RegistryKey" />-Objekt zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um diese Aktion auszuführen, muss der Benutzer in der Registrierungs Hierarchie auf dieser Ebene über die entsprechende Berechtigung verfügen.  
  
> [!CAUTION]
>  Machen Sie <xref:Microsoft.Win32.RegistryKey> Objekte nicht so verfügbar, dass ein schädliches Programm Tausende von bedeutungslosen unter Schlüsseln oder Schlüssel-Wert-Paaren erstellen könnte. Gestatten Sie z. b. nicht, dass Aufrufer beliebige Schlüssel oder Werte eingeben.  
  
 Um die <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A> -Methode verwenden zu können, müssen Sie über eine Instanz <xref:Microsoft.Win32.RegistryKey> der-Klasse verfügen. Um eine Instanz von <xref:Microsoft.Win32.RegistryKey>zu erhalten, verwenden Sie eines der statischen Member <xref:Microsoft.Win32.Registry> der-Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="subkey" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Erstellen oder Öffnen des Registrierungsschlüssels.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Auf den aktuellen <see cref="T:Microsoft.Win32.RegistryKey" /> ist kein Schreibzugriff möglich. Möglicherweise wurde der Schlüssel schreibgeschützt geöffnet, oder der Benutzer verfügt nicht über die erforderlichen Zugriffsrechte.</exception>
        <exception cref="T:System.IO.IOException">Die Schachtelungsebene überschreitet 510.  
  
- oder - 
Ein Systemfehler ist aufgetreten. Möglicherweise wurde der Schlüssel gelöscht, oder es wurde versucht, einen Schlüssel im <see cref="F:Microsoft.Win32.Registry.LocalMachine" />-Stamm zu erstellen.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, System.Security.AccessControl.RegistrySecurity registrySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, class System.Security.AccessControl.RegistrySecurity registrySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,System.Security.AccessControl.RegistrySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, System::Security::AccessControl::RegistrySecurity ^ registrySecurity);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck * System.Security.AccessControl.RegistrySecurity -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, permissionCheck, registrySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="registrySecurity" Type="System.Security.AccessControl.RegistrySecurity" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="subkey">Name oder Pfad des zu erstellenden oder zu öffnenden Unterschlüssels. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="permissionCheck">Einer der Enumerationswerte, der angibt, ob der Schlüssel für Lesezugriff oder für Lese-/Schreibzugriff geöffnet wird.</param>
        <param name="registrySecurity">Die Zugriffssteuerungssicherheit für den neuen Schlüssel.</param>
        <summary>Erstellt einen neuen Unterschlüssel oder öffnet einen vorhandenen Unterschlüssel für Schreibzugriff unter Verwendung der angegebenen Berechtigungsprüfungsoption und der Registrierungssicherheit.</summary>
        <returns>Der neu erstellte Unterschlüssel oder <see langword="null" />, wenn bei dem Vorgang ein Fehler aufgetreten ist. Wenn eine Zeichenfolge der Länge 0 (null) für <paramref name="subkey" /> angegeben ist, wird das aktuelle <see cref="T:Microsoft.Win32.RegistryKey" />-Objekt zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A> -Methode erstellt einen Registrierungsschlüssel, der über die durch den `registrySecurity` -Parameter angegebene Zugriffs Steuerung verfügt. Das <xref:Microsoft.Win32.RegistryKey> Objekt, das zurückgegeben wird, stellt den Registrierungsschlüssel dar, aber dieses Objekt ist nicht durch die `registrySecurity` im-Parameter angegebene Zugriffs Steuerung eingeschränkt.  
  
 Wenn `permissionCheck`den Wert hat,wirdderSchlüsselfürdenLese-/Schreibzugriffgeöffnet.<xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType> Wenn `permissionCheck`den Wert hat,wirdderSchlüsselfürdenLesezugriffgeöffnet.<xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType>  
  
 Aus Gründen der Abwärtskompatibilität wird der Schlüssel zum Lesen und Schreiben geöffnet `permissionCheck` , <xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType> wenn ist und der über <xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType>geordnete Schlüssel ebenfalls ist. Wenn für den übergeordneten Schlüssel eine andere Einstellung festgelegt ist, wird der Lese-/Schreibstatus durch die Einstellung des übergeordneten Schlüssels gesteuert.  
  
 Um diese Aktion auszuführen, muss der Benutzer in der Registrierungs Hierarchie auf dieser Ebene über Berechtigungen verfügen.  
  
> [!CAUTION]
>  Machen Sie <xref:Microsoft.Win32.RegistryKey> Objekte nicht so verfügbar, dass ein schädliches Programm Tausende von bedeutungslosen unter Schlüsseln oder Schlüssel-Wert-Paaren erstellen könnte. Gestatten Sie z. b. nicht, dass Aufrufer beliebige Schlüssel oder Werte eingeben.  
  
 Um die <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> -Methode verwenden zu können, müssen Sie über eine Instanz <xref:Microsoft.Win32.RegistryKey> der-Klasse verfügen. Um eine Instanz von <xref:Microsoft.Win32.RegistryKey>zu erhalten, verwenden Sie eines der statischen Member <xref:Microsoft.Win32.Registry> der-Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="subkey" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Erstellen oder Öffnen des Registrierungsschlüssels.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="permissionCheck" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:Microsoft.Win32.RegistryKey" />, für den die Methode aufgerufen wird, ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Auf den aktuellen <see cref="T:Microsoft.Win32.RegistryKey" /> ist kein Schreibzugriff möglich. Möglicherweise wurde der Schlüssel schreibgeschützt geöffnet, oder der Benutzer verfügt nicht über die erforderlichen Zugriffsrechte.</exception>
        <exception cref="T:System.IO.IOException">Die Schachtelungsebene überschreitet 510.  
  
- oder - 
Ein Systemfehler ist aufgetreten. Möglicherweise wurde der Schlüssel gelöscht, oder es wurde versucht, einen Schlüssel im <see cref="F:Microsoft.Win32.Registry.LocalMachine" />-Stamm zu erstellen.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">die Möglichkeit, den angegebenen Registrierungsschlüssel zu ändern, wenn er vorhanden ist, oder, wenn er nicht bereits vorhanden ist. Zugehörige Enumerationen <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />:,<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">die Möglichkeit, auf den angegebenen Registrierungsschlüssel zuzugreifen, wenn es sich um einen Remote Schlüssel handelt. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, bool writable, Microsoft.Win32.RegistryOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, bool writable, valuetype Microsoft.Win32.RegistryOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,System.Boolean,Microsoft.Win32.RegistryOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, writable As Boolean, options As RegistryOptions) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, bool writable, Microsoft::Win32::RegistryOptions options);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * bool * Microsoft.Win32.RegistryOptions -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, writable, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="writable" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="Microsoft.Win32.RegistryOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="subkey">Name oder Pfad des zu erstellenden oder zu öffnenden Unterschlüssels. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="writable"><see langword="true" />, um anzugeben, dass der neue Unterschlüssel bearbeitet werden kann, andernfalls <see langword="false" />.</param>
        <param name="options">Die zu verwendende Registrierungsoption.</param>
        <summary>Erstellt einen neuen Unterschlüssel oder öffnet einen vorhandenen Unterschlüssel mit dem angegebenen Zugriffsmodus. Verfügbar ab .NET Framework 4.6.</summary>
        <returns>Der neu erstellte Unterschlüssel oder <see langword="null" />, wenn bei dem Vorgang ein Fehler aufgetreten ist. Wenn eine Zeichenfolge der Länge 0 (null) für <paramref name="subkey" /> angegeben ist, wird das aktuelle <see cref="T:Microsoft.Win32.RegistryKey" />-Objekt zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um diese Aktion auszuführen, muss der Benutzer in der Registrierungs Hierarchie auf dieser Ebene über die entsprechende Berechtigung verfügen.  
  
> [!CAUTION]
>  Machen Sie <xref:Microsoft.Win32.RegistryKey> Objekte nicht so verfügbar, dass ein schädliches Programm Tausende von bedeutungslosen unter Schlüsseln oder Schlüssel-Wert-Paaren erstellen könnte. Gestatten Sie z. b. nicht, dass Aufrufer beliebige Schlüssel oder Werte eingeben.  
  
 Um die <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A> -Methode verwenden zu können, müssen Sie über eine Instanz <xref:Microsoft.Win32.RegistryKey> der-Klasse verfügen. Um eine Instanz von <xref:Microsoft.Win32.RegistryKey>zu erhalten, verwenden Sie eines der statischen Member <xref:Microsoft.Win32.Registry> der-Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="subkey" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> gibt keine gültige Option an.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Erstellen oder Öffnen des Registrierungsschlüssels.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Auf den aktuellen <see cref="T:Microsoft.Win32.RegistryKey" /> ist kein Schreibzugriff möglich. Möglicherweise wurde der Schlüssel schreibgeschützt geöffnet, oder der Benutzer verfügt nicht über die erforderlichen Zugriffsrechte.</exception>
        <exception cref="T:System.IO.IOException">Die Schachtelungsebene überschreitet 510.  
  
- oder - 
Ein Systemfehler ist aufgetreten. Möglicherweise wurde der Schlüssel gelöscht, oder es wurde versucht, einen Schlüssel im <see cref="F:Microsoft.Win32.Registry.LocalMachine" />-Stamm zu erstellen.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, Microsoft.Win32.RegistryOptions options);" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype Microsoft.Win32.RegistryOptions options) cil managed" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,Microsoft.Win32.RegistryOptions)" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, Microsoft.Win32.RegistryOptions registryOptions);" FrameworkAlternate="netcore-2.0;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype Microsoft.Win32.RegistryOptions registryOptions) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, Microsoft::Win32::RegistryOptions registryOptions);" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;dotnet-plat-ext-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, permissionCheck As RegistryKeyPermissionCheck, options As RegistryOptions) As RegistryKey" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck * Microsoft.Win32.RegistryOptions -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, permissionCheck, registryOptions)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubKey (subkey As String, permissionCheck As RegistryKeyPermissionCheck, options As RegistryOptions) As RegistryKey" FrameworkAlternate="netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, Microsoft::Win32::RegistryOptions options);" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck * Microsoft.Win32.RegistryOptions -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, permissionCheck, options)" FrameworkAlternate="netframework-4.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,Microsoft.Win32.RegistryOptions)" FrameworkAlternate="netframework-4.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="registryOptions" Type="Microsoft.Win32.RegistryOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
        <Parameter Name="options" Type="Microsoft.Win32.RegistryOptions" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="subkey">Name oder Pfad des zu erstellenden oder zu öffnenden Unterschlüssels.</param>
        <param name="permissionCheck">Einer der Enumerationswerte, der angibt, ob der Schlüssel für Lesezugriff oder für Lese-/Schreibzugriff geöffnet wird.</param>
        <param name="registryOptions">Die zu verwendende Registrierungsoption, z. B. zum Erstellen eines temporären Schlüssels.</param>
        <param name="options">Die zu verwendende Registrierungsoption, z. B. zum Erstellen eines temporären Schlüssels.</param>
        <summary>Erstellt oder öffnet einen Unterschlüssel für Schreibzugriff unter Verwendung der angegebenen Berechtigungsprüfungs- und Registrierungsoptionen.</summary>
        <returns>Der neu erstellte Unterschlüssel oder <see langword="null" />, wenn bei dem Vorgang ein Fehler aufgetreten ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um das aktuelle <xref:Microsoft.Win32.RegistryKey> -Objekt zu erhalten, geben Sie eine leere Zeichenfolge ( `subkey`"") für an.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="subkey" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das aktuelle <see cref="T:Microsoft.Win32.RegistryKey" />-Objekt, auf das zugegriffen werden soll, ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das aktuelle <see cref="T:Microsoft.Win32.RegistryKey" />-Objekt kann nicht bearbeitet werden. Möglicherweise wurde der Schlüssel schreibgeschützt geöffnet, oder der Benutzer verfügt nicht über die erforderlichen Zugriffsrechte.</exception>
        <exception cref="T:System.IO.IOException">Die Schachtelungsebene überschreitet 510.  
  
- oder - 
Ein Systemfehler ist aufgetreten. Möglicherweise wurde der Schlüssel gelöscht, oder es wurde versucht, einen Schlüssel im <see cref="F:Microsoft.Win32.Registry.LocalMachine" />-Stamm zu erstellen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Erstellen oder Öffnen des Registrierungsschlüssels.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey CreateSubKey (string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, Microsoft.Win32.RegistryOptions registryOptions, System.Security.AccessControl.RegistrySecurity registrySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey CreateSubKey(string subkey, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype Microsoft.Win32.RegistryOptions registryOptions, class System.Security.AccessControl.RegistrySecurity registrySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,Microsoft.Win32.RegistryOptions,System.Security.AccessControl.RegistrySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ CreateSubKey(System::String ^ subkey, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, Microsoft::Win32::RegistryOptions registryOptions, System::Security::AccessControl::RegistrySecurity ^ registrySecurity);" />
      <MemberSignature Language="F#" Value="member this.CreateSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck * Microsoft.Win32.RegistryOptions * System.Security.AccessControl.RegistrySecurity -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.CreateSubKey (subkey, permissionCheck, registryOptions, registrySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="registryOptions" Type="Microsoft.Win32.RegistryOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="registrySecurity" Type="System.Security.AccessControl.RegistrySecurity" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="subkey">Name oder Pfad des zu erstellenden oder zu öffnenden Unterschlüssels.</param>
        <param name="permissionCheck">Einer der Enumerationswerte, der angibt, ob der Schlüssel für Lesezugriff oder für Lese-/Schreibzugriff geöffnet wird.</param>
        <param name="registryOptions">Die zu verwendende Registrierungsoption.</param>
        <param name="registrySecurity">Die Zugriffssteuerungssicherheit für den neuen Unterschlüssel.</param>
        <summary>Erstellt oder öffnet einen Unterschlüssel für Schreibzugriff unter Verwendung der angegebenen Berechtigungsprüfungsoption, Registrierungsoption und Registrierungssicherheit.</summary>
        <returns>Der neu erstellte Unterschlüssel oder <see langword="null" />, wenn bei dem Vorgang ein Fehler aufgetreten ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um das aktuelle <xref:Microsoft.Win32.RegistryKey> -Objekt zu erhalten, geben Sie eine leere Zeichenfolge ( `subkey`"") für an.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="subkey" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das aktuelle <see cref="T:Microsoft.Win32.RegistryKey" />-Objekt ist geschlossen. Auf geschlossene Schlüssel kann nicht zugegriffen werden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das aktuelle <see cref="T:Microsoft.Win32.RegistryKey" />-Objekt kann nicht bearbeitet werden. Möglicherweise wurde der Schlüssel schreibgeschützt geöffnet, oder der Benutzer verfügt nicht über die erforderlichen Zugriffsrechte.</exception>
        <exception cref="T:System.IO.IOException">Die Schachtelungsebene überschreitet 510.  
  
- oder - 
Ein Systemfehler ist aufgetreten. Möglicherweise wurde der Schlüssel gelöscht, oder es wurde versucht, einen Schlüssel im <see cref="F:Microsoft.Win32.Registry.LocalMachine" />-Stamm zu erstellen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Erstellen oder Öffnen des Registrierungsschlüssels.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteSubKey">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löscht den angegebenen Unterschlüssel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteSubKey">
      <MemberSignature Language="C#" Value="public void DeleteSubKey (string subkey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKey(string subkey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKey (subkey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKey(System::String ^ subkey);" />
      <MemberSignature Language="F#" Value="member this.DeleteSubKey : string -&gt; unit" Usage="registryKey.DeleteSubKey subkey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subkey">Der Name des zu löschenden Unterschlüssels. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Löscht den angegebenen Unterschlüssel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden <xref:Microsoft.Win32.RegistryKey.DeleteSubKeyTree%2A>Sie, um untergeordnete Unterschlüssel zu löschen.  
  
 Verwenden Sie beim Löschen von Registrierungs Schlüsseln Vorsicht.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung <xref:Microsoft.Win32.RegistryKey.DeleteSubKey%2A>von veranschaulicht.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#5](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source2.cpp#5)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#5](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source2.cs#5)]
 [!code-vb[Microsoft.Win32.RegistryKey2#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <paramref name="subkey" /> besitzt untergeordnete Unterschlüssel.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="subkey" />-Parameter gibt keinen gültigen Registrierungsschlüssel an.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="subkey" /> ist gleich <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen, um den Schlüssel zu löschen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der zu bearbeitende <see cref="T:Microsoft.Win32.RegistryKey" /> ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die notwendigen Registrierungsrechte.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">die Möglichkeit, den angegebenen Registrierungsschlüssel zu ändern. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">die Möglichkeit, auf den angegebenen Registrierungsschlüssel zuzugreifen, wenn es sich um einen Remote Schlüssel handelt. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="DeleteSubKey">
      <MemberSignature Language="C#" Value="public void DeleteSubKey (string subkey, bool throwOnMissingSubKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKey(string subkey, bool throwOnMissingSubKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKey (subkey As String, throwOnMissingSubKey As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKey(System::String ^ subkey, bool throwOnMissingSubKey);" />
      <MemberSignature Language="F#" Value="member this.DeleteSubKey : string * bool -&gt; unit" Usage="registryKey.DeleteSubKey (subkey, throwOnMissingSubKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
        <Parameter Name="throwOnMissingSubKey" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="subkey">Der Name des zu löschenden Unterschlüssels. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="throwOnMissingSubKey">Gibt an, ob eine Ausnahme ausgelöst werden soll, wenn der angegebene Unterschlüssel nicht gefunden werden kann. Wenn dieses Argument <see langword="true" /> und der angegebene Unterschlüssel nicht vorhanden ist, wird eine Ausnahme ausgelöst. Wenn dieses Argument <see langword="false" /> und der angegebene Unterschlüssel nicht vorhanden ist, findet keine Aktion statt.</param>
        <summary>Löscht den angegebenen Unterschlüssel und gibt an, ob eine Ausnahme ausgelöst wird, wenn der Unterschlüssel nicht gefunden wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden <xref:Microsoft.Win32.RegistryKey.DeleteSubKeyTree%2A>Sie, um untergeordnete Unterschlüssel zu löschen.  
  
 Verwenden Sie beim Löschen von Registrierungs Schlüsseln Vorsicht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="subkey" /> hat untergeordnete Unterschlüssel.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="subkey" /> gibt keinen gültigen Registrierungsschlüssel an, und <paramref name="throwOnMissingSubKey" /> ist <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="subkey" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen, um den Schlüssel zu löschen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der zu bearbeitende <see cref="T:Microsoft.Win32.RegistryKey" /> ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die notwendigen Registrierungsrechte.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">die Möglichkeit, den angegebenen Registrierungsschlüssel zu ändern. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">die Möglichkeit, auf den angegebenen Registrierungsschlüssel zuzugreifen, wenn es sich um einen Remote Schlüssel handelt. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteSubKeyTree">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löscht einen Unterschlüssel und untergeordnete Unterschlüssel rekursiv, mit optionaler Ausnahmebehandlung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteSubKeyTree">
      <MemberSignature Language="C#" Value="public void DeleteSubKeyTree (string subkey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKeyTree(string subkey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKeyTree (subkey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKeyTree(System::String ^ subkey);" />
      <MemberSignature Language="F#" Value="member this.DeleteSubKeyTree : string -&gt; unit" Usage="registryKey.DeleteSubKeyTree subkey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subkey">Der zu löschende Unterschlüssel. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Löscht einen Unterschlüssel und alle untergeordneten Unterschlüssel rekursiv.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen über die entsprechenden Berechtigungen verfügen, um den Unterschlüssel und seine Struktur zu löschen.  
  
> [!CAUTION]
>  Wenn Sie einen bestimmten Schlüssel löschen, werden alle Einträge unterhalb des Schlüssels in der Struktur entfernt. Es wird keine Warnung bereitgestellt. Wenn Sie einen Unterschlüssel nur löschen möchten, wenn er keine untergeordneten Unterschlüssel enthält, verwenden <xref:Microsoft.Win32.RegistryKey.DeleteSubKey%2A> Sie die-Methode.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:Microsoft.Win32.RegistryKey> -Klasse bereitgestellt wird.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="subkey" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Es wird versucht, eine Stammstruktur zu löschen.  
  
- oder - 
 <paramref name="subkey" /> gibt keinen gültigen Registrierungsunterschlüssel an.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler ist aufgetreten.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen, um den Schlüssel zu löschen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der zu bearbeitende <see cref="T:Microsoft.Win32.RegistryKey" /> ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die notwendigen Registrierungsrechte.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">die Möglichkeit, den angegebenen Registrierungsschlüssel zu ändern. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">die Möglichkeit, auf den angegebenen Registrierungsschlüssel zuzugreifen, wenn es sich um einen Remote Schlüssel handelt. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
      </Docs>
    </Member>
    <Member MemberName="DeleteSubKeyTree">
      <MemberSignature Language="C#" Value="public void DeleteSubKeyTree (string subkey, bool throwOnMissingSubKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSubKeyTree(string subkey, bool throwOnMissingSubKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSubKeyTree (subkey As String, throwOnMissingSubKey As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSubKeyTree(System::String ^ subkey, bool throwOnMissingSubKey);" />
      <MemberSignature Language="F#" Value="member this.DeleteSubKeyTree : string * bool -&gt; unit" Usage="registryKey.DeleteSubKeyTree (subkey, throwOnMissingSubKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subkey" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnMissingSubKey" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="subkey">Der Name des zu löschenden Unterschlüssels. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="throwOnMissingSubKey">Gibt an, ob eine Ausnahme ausgelöst werden soll, wenn der angegebene Unterschlüssel nicht gefunden werden kann. Wenn dieses Argument <see langword="true" /> und der angegebene Unterschlüssel nicht vorhanden ist, wird eine Ausnahme ausgelöst. Wenn dieses Argument <see langword="false" /> und der angegebene Unterschlüssel nicht vorhanden ist, findet keine Aktion statt.</param>
        <summary>Löscht den angegebenen Unterschlüssel und untergeordnete Unterschlüssel rekursiv und gibt an, ob eine Ausnahme ausgelöst wird, wenn der Unterschlüssel nicht gefunden wird.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Es wurde versucht, den Stammhive der Struktur zu löschen.  
  
- oder - 
 <paramref name="subkey" /> gibt keinen gültigen Registrierungsunterschlüssel an, und <paramref name="throwOnMissingSubKey" /> ist <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="subkey" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:Microsoft.Win32.RegistryKey" /> ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die notwendigen Registrierungsrechte.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen, um den Schlüssel zu löschen.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">die Möglichkeit, den angegebenen Registrierungsschlüssel zu ändern. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">die Möglichkeit, auf den angegebenen Registrierungsschlüssel zuzugreifen, wenn es sich um einen Remote Schlüssel handelt. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löscht den angegebenen Wert aus diesem Schlüssel und löst eine Ausnahme aus, wenn der Wert nicht gefunden wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteValue">
      <MemberSignature Language="C#" Value="public void DeleteValue (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteValue(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteValue (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteValue(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.DeleteValue : string -&gt; unit" Usage="registryKey.DeleteValue name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu löschenden Werts.</param>
        <summary>Löscht den angegebenen Wert aus diesem Schlüssel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unter Windows 95, Windows 98, Windows 98 Second Edition und Windows Millennium Edition wird der Standardwert nicht gelöscht, wenn `name` Sie eine leere Zeichenfolge für den-Parameter angeben.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:Microsoft.Win32.RegistryKey> -Klasse bereitgestellt wird.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#3](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#3)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#3](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#3)]
 [!code-vb[Microsoft.Win32.RegistryKey2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist kein gültiger Verweis auf einen Wert.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen, um den Wert zu löschen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der zu bearbeitende <see cref="T:Microsoft.Win32.RegistryKey" /> ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der zu bearbeitende <see cref="T:Microsoft.Win32.RegistryKey" /> ist schreibgeschützt.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">die Möglichkeit, den angegebenen Registrierungsschlüssel zu löschen. Zugehörige Enumerationen:<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
      </Docs>
    </Member>
    <Member MemberName="DeleteValue">
      <MemberSignature Language="C#" Value="public void DeleteValue (string name, bool throwOnMissingValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteValue(string name, bool throwOnMissingValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteValue (name As String, throwOnMissingValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteValue(System::String ^ name, bool throwOnMissingValue);" />
      <MemberSignature Language="F#" Value="member this.DeleteValue : string * bool -&gt; unit" Usage="registryKey.DeleteValue (name, throwOnMissingValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnMissingValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu löschenden Werts.</param>
        <param name="throwOnMissingValue">Gibt an, ob eine Ausnahme ausgelöst werden soll, wenn der angegebene Wert nicht gefunden werden kann. Wenn dieses Argument <see langword="true" /> ist und der angegebene Wert nicht vorhanden ist, wird eine Ausnahme ausgelöst. Wenn dieses Argument <see langword="false" /> ist und der angegebene Wert nicht vorhanden ist, findet keine Aktion statt.</param>
        <summary>Löscht den angegebenen Wert aus diesem Schlüssel und gibt an, ob eine Ausnahme ausgelöst wird, wenn der Wert nicht gefunden wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `throwOnMissingValue` ist`false`, gibt es keine Möglichkeit, zu ermitteln, ob der Löschvorgang erfolgreich war, ohne später auf den gerade gelöschten Wert zuzugreifen. Verwenden Sie daher Vorsicht, wenn Sie Werte aus der Registrierung auf diese Weise löschen.  
  
 Unter Windows 95, Windows 98, Windows 98 Second Edition und Windows Millennium Edition wird der Standardwert nicht gelöscht, wenn `name` Sie eine leere Zeichenfolge für den-Parameter angeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> ist kein gültiger Verweis auf einen Wert, und <paramref name="throwOnMissingValue" /> ist <see langword="true" />.  
  
- oder - 
 <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen, um den Wert zu löschen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der zu bearbeitende <see cref="T:Microsoft.Win32.RegistryKey" /> ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der zu bearbeitende <see cref="T:Microsoft.Win32.RegistryKey" /> ist schreibgeschützt.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">die Möglichkeit, den angegebenen Registrierungsschlüssel zu löschen. Zugehörige Enumerationen:<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="registryKey.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:Microsoft.Win32.RegistryKey" />-Klasse verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie `Dispose` auf, wenn Sie <xref:Microsoft.Win32.RegistryKey> nicht mehr benötigen. Die `Dispose`-Methode bewirkt, dass <xref:Microsoft.Win32.RegistryKey> nicht mehr verwendet werden kann. Nach dem `Dispose`Aufrufen von müssen Sie alle Verweise auf den <xref:Microsoft.Win32.RegistryKey> freigeben, damit der Garbage Collector den Speicher freigeben kann <xref:Microsoft.Win32.RegistryKey> , den der belegt hat.  
  
 Weitere Informationen finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Implementieren einer](~/docs/standard/garbage-collection/implementing-dispose.md)verwerfen-Methode.  
  
> [!NOTE]
>  Rufen Sie immer `Dispose` auf, bevor Sie den letzten Verweis auf das <xref:Microsoft.Win32.RegistryKey> freigeben. Andernfalls bleiben die verwendeten Ressourcen reserviert, bis die Garbage Collection die <xref:Microsoft.Win32.RegistryKey>-Methode des `Finalize`-Objekts aufruft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~RegistryKey ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!RegistryKey ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="registryKey.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt den Schlüssel und leert diesen auf den Datenträger, sofern der Inhalt verändert wurde.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="registryKey.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schreibt alle Attribute des angegebenen geöffneten Registrierungsschlüssels in die Registrierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es ist nicht erforderlich, aufzurufen `Flush` , um Änderungen an einem Schlüssel zu schreiben. Registrierungs Änderungen werden auf den Datenträger geleert, wenn die Registrierung Ihren verzögerten Flusher verwendet. Die verzögerte Leerung erfolgt automatisch und regelmäßig nach einem vom System angegebenen Zeitintervall. Registrierungs Änderungen werden auch beim Herunterfahren des Systems auf den Datenträger geleert.  
  
 Im <xref:Microsoft.Win32.RegistryKey.Close%2A>Gegensatz zu `Flush` gibt die-Funktion nur dann zurück, wenn alle Daten in die Registrierung geschrieben wurden.  
  
 Die `Flush` Funktion kann auch Teile oder alle anderen Schlüssel schreiben. Wenn Sie diese Funktion übermäßig aufrufen, wirkt sich dies negativ auf die Leistung einer Anwendung aus.  
  
 Eine Anwendung sollte nur dann `Flush` aufgerufen werden, wenn es absolut sicher sein muss, dass Registrierungs Änderungen auf dem Datenträger aufgezeichnet werden. Im allgemeinen `Flush` muss, wenn überhaupt, nur selten verwendet werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.Win32.RegistryKey.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FromHandle">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen Registrierungsschlüssel aus einem angegebenen Handle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromHandle">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey FromHandle (Microsoft.Win32.SafeHandles.SafeRegistryHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey FromHandle(class Microsoft.Win32.SafeHandles.SafeRegistryHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.FromHandle(Microsoft.Win32.SafeHandles.SafeRegistryHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHandle (handle As SafeRegistryHandle) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ FromHandle(Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ handle);" />
      <MemberSignature Language="F#" Value="static member FromHandle : Microsoft.Win32.SafeHandles.SafeRegistryHandle -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.FromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeRegistryHandle" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="handle">Das Handle für den Registrierungsschlüssel.</param>
        <summary>Erstellt einen Registrierungsschlüssel aus einem angegebenen Handle.</summary>
        <returns>Ein Registrierungsschlüssel.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="handle" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die notwendigen Registrierungsrechte.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über ausreichende Berechtigungen zum Ausführen dieser Aktion.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">die Möglichkeit, auf den angegebenen Registrierungsschlüssel zuzugreifen, wenn es sich um einen Remote Schlüssel handelt. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="FromHandle">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey FromHandle (Microsoft.Win32.SafeHandles.SafeRegistryHandle handle, Microsoft.Win32.RegistryView view);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey FromHandle(class Microsoft.Win32.SafeHandles.SafeRegistryHandle handle, valuetype Microsoft.Win32.RegistryView view) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.FromHandle(Microsoft.Win32.SafeHandles.SafeRegistryHandle,Microsoft.Win32.RegistryView)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHandle (handle As SafeRegistryHandle, view As RegistryView) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ FromHandle(Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ handle, Microsoft::Win32::RegistryView view);" />
      <MemberSignature Language="F#" Value="static member FromHandle : Microsoft.Win32.SafeHandles.SafeRegistryHandle * Microsoft.Win32.RegistryView -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.FromHandle (handle, view)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeRegistryHandle" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="view" Type="Microsoft.Win32.RegistryView" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="handle">Das Handle für den Registrierungsschlüssel.</param>
        <param name="view">Die zu verwendende Registrierungsansicht.</param>
        <summary>Erstellt einen Registrierungsschlüssel aus einem angegebenen Handle und einer Registrierungsansichtseinstellung.</summary>
        <returns>Ein Registrierungsschlüssel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `view` -Parameter für diese Methode wird in nachfolgenden Vorgängen verwendet, z. b. beim Öffnen von unter Schlüsseln.  
  
 Wenn `view` <xref:Microsoft.Win32.RegistryView.Registry32> ist <xref:Microsoft.Win32.RegistryView.Registry64> , aber auf dem Computer ein 32-Bit-Betriebssystem ausgeführt wird, wird die Ansicht vom zurückgegebenen Schlüssel verwendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="view" /> ist ungültig.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="handle" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die notwendigen Registrierungsrechte.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über ausreichende Berechtigungen zum Ausführen dieser Aktion.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">die Möglichkeit, auf den angegebenen Registrierungsschlüssel zuzugreifen, wenn es sich um einen Remote Schlüssel handelt. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die Zugriffssteuerungssicherheit für den aktuellen Registrierungsschlüssel zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.RegistrySecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.RegistrySecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As RegistrySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::RegistrySecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.RegistrySecurity" Usage="registryKey.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.RegistrySecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Zugriffssteuerungssicherheit für den aktuellen Registrierungsschlüssel zurück.</summary>
        <returns>Ein Objekt, das die Zugriffssteuerungsberechtigungen für den durch den aktuellen <see cref="T:Microsoft.Win32.RegistryKey" /> dargestellten Registrierungsschlüssel beschreibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methoden Überladung entspricht dem Aufrufen der <xref:Microsoft.Win32.RegistryKey.GetAccessControl%28System.Security.AccessControl.AccessControlSections%29> -Methoden Überladung mit der bitweisen Kombination der folgenden Flags <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>: <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, und <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>. Sie können diese Überladung verwenden, um nach anderen Berechtigungen zu suchen.  
  
 Der Benutzer muss über <xref:System.Security.AccessControl.RegistryRights.ReadPermissions?displayProperty=nameWithType> Rechte zum Abrufen dieser Methode verfügen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die notwendigen Berechtigungen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der zu bearbeitende <see cref="T:Microsoft.Win32.RegistryKey" /> ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Schlüssel wurde gelöscht.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.RegistrySecurity GetAccessControl (System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.RegistrySecurity GetAccessControl(valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetAccessControl(System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl (includeSections As AccessControlSections) As RegistrySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::RegistrySecurity ^ GetAccessControl(System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.RegistrySecurity" Usage="registryKey.GetAccessControl includeSections" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.RegistrySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="includeSections">Eine bitweise Kombination von Enumerationswerten, die den Typ der abzurufenden Sicherheitsinformationen angeben.</param>
        <summary>Gibt die angegebenen Abschnitte der Zugriffssteuerungssicherheit für den aktuellen Registrierungsschlüssel zurück.</summary>
        <returns>Ein Objekt, das die Zugriffssteuerungsberechtigungen für den durch den aktuellen <see cref="T:Microsoft.Win32.RegistryKey" /> dargestellten Registrierungsschlüssel beschreibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die Zugriffsberechtigungen anzufordern, die den Benutzern derzeit gewährt werden, geben Sie die bitweise Kombination der <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>folgenden <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>Flags an <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>:, und. Alternativ können Sie die <xref:Microsoft.Win32.RegistryKey.GetAccessControl> -Methoden Überladung verwenden, die genau diese Kombination von Werten angibt.  
  
 Der Benutzer muss über <xref:System.Security.AccessControl.RegistryRights.ReadPermissions?displayProperty=nameWithType> Rechte zum Abrufen dieser Methode verfügen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die notwendigen Berechtigungen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der zu bearbeitende <see cref="T:Microsoft.Win32.RegistryKey" /> ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Schlüssel wurde gelöscht.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSubKeyNames">
      <MemberSignature Language="C#" Value="public string[] GetSubKeyNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetSubKeyNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSubKeyNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetSubKeyNames();" />
      <MemberSignature Language="F#" Value="member this.GetSubKeyNames : unit -&gt; string[]" Usage="registryKey.GetSubKeyNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein Array von Zeichenfolgen mit den Namen aller Unterschlüssel ab.</summary>
        <returns>Ein Array von Zeichenfolgen, das die Namen der Unterschlüssel des aktuellen Schlüssels enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode werden keine Namen rekursiv gefunden. Sie gibt die Namen auf der Basisebene zurück, von der aus Sie aufgerufen wurde.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:Microsoft.Win32.RegistryKey> -Klasse bereitgestellt wird.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen, um aus dem Schlüssel zu lesen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der zu bearbeitende <see cref="T:Microsoft.Win32.RegistryKey" /> ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die notwendigen Registrierungsrechte.</exception>
        <exception cref="T:System.IO.IOException">Ein Systemfehler ist aufgetreten, möglicherweise wurde der aktuelle Schlüssel gelöscht.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">um die Möglichkeit zum Lesen aus der Registrierung zu erhalten. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Wert ab, der dem angegebenen Namen zugeordnet ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetValue : string -&gt; obj" Usage="registryKey.GetValue name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des abzurufenden Werts. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Ruft den Wert ab, der dem angegebenen Namen zugeordnet ist. Gibt <see langword="null" /> zurück, wenn das Name-Wert-Paar in der Registrierung nicht vorhanden ist.</summary>
        <returns>Der <paramref name="name" /> zugeordnete Wert oder <see langword="null" />, wenn <paramref name="name" /> nicht gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ein Registrierungsschlüssel kann über einen Wert verfügen, der keinem Namen zugeordnet ist. Wenn dieser unbenannte Wert im Registrierungs-Editor angezeigt wird, wird die Zeichenfolge "(Standard)" anstelle eines Namens angezeigt. Um diesen unbenannten Wert abzurufen, geben `null` Sie entweder oder die leere Zeichenfolge (" `name`") für an.  
  
 Wenn die <xref:Microsoft.Win32.RegistryKey.GetValue%2A> -Methode erweiterbare Zeichen folgen Werte (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>) abruft, werden Umgebungs Zeichenfolgen mithilfe von Daten aus der lokalen Umgebung erweitert. Um erweiterbare Zeichen folgen Werte aus der Registrierung auf einem Remote Computer abzurufen, verwenden <xref:Microsoft.Win32.RegistryKey.GetValue%28System.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueOptions%29> Sie die-Methoden Überladung, um anzugeben, dass Umgebungs Zeichenfolgen nicht erweitert werden sollen.  
  
> [!NOTE]
>  Wenn ein Wert, der erweiterbare Verweise auf Umgebungsvariablen enthält, als Zeichenfolge (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>) und nicht als erweiterbare Zeichenfolge (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>) gespeichert wurde <xref:Microsoft.Win32.RegistryKey.GetValue%2A> , wird er nicht erweitert. Sie können eine solche Zeichenfolge erweitern, nachdem Sie durch Aufrufen der <xref:System.Environment.ExpandEnvironmentVariables%2A> -Methode abgerufen wurde.  
  
> [!NOTE]
>  Die empfohlene Vorgehensweise zum Abrufen von Daten <xref:Microsoft.Win32.Registry.PerformanceData> aus dem Schlüssel besteht darin <xref:System.Diagnostics.PerformanceCounter> , die-Klasse <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType> anstelle der-Methode zu verwenden.  
>   
>  <xref:Microsoft.Win32.RegistryKey.GetValue%2A>das Lesen von Werten vom Typ REG_NONE oder REG_LINK wird von nicht unterstützt.  In beiden Fällen wird der Standardwert (`null`) anstelle des tatsächlichen Werts zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Testschlüssel erstellt, und dem Schlüssel werden Werte unterschiedlicher Datentypen hinzugefügt. Im Beispiel werden dann die Name-Wert-Paare gelesen und in der Konsole angezeigt. dabei <xref:Microsoft.Win32.RegistryKey.GetValueKind%2A> wird die-Methode verwendet, um die entsprechenden Registrierungs Datentypen abzurufen.  
  
 [!code-cpp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen, um aus dem Registrierungsschlüssel zu lesen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:Microsoft.Win32.RegistryKey" />, der den angegebenen Wert enthält, ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <exception cref="T:System.IO.IOException">Der <see cref="T:Microsoft.Win32.RegistryKey" />, der den angegebenen Wert enthält, wurde zum Löschen markiert.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die notwendigen Registrierungsrechte.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">zum Lesen aus der Registrierung. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">zum Lesen eines Registrierungsschlüssels vom Typ REG_EXPAND_SZ. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="Overload:Microsoft.Win32.RegistryKey.SetValue" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (string name, object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(string name, object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValue(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (name As String, defaultValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::String ^ name, System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="member this.GetValue : string * obj -&gt; obj" Usage="registryKey.GetValue (name, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des abzurufenden Werts. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="defaultValue">Der zurückzugebende Wert, wenn <paramref name="name" /> nicht vorhanden ist.</param>
        <summary>Ruft den Wert ab, der dem angegebenen Namen zugeordnet ist. Wenn der Name nicht gefunden wird, wird der von Ihnen bereitgestellte Standardwert zurückgegeben.</summary>
        <returns>Der <paramref name="name" /> zugeordnete Wert mit allen eingebetteten Umgebungsvariablen, die nicht erweitert wurden, oder <paramref name="defaultValue" />, wenn <paramref name="name" /> nicht gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese über <xref:Microsoft.Win32.RegistryKey.GetValue%2A> Ladung von, um den Fall zu behandeln, in dem noch kein Name vorhanden ist, z. b. wenn die Anwendung zum ersten Mal ausgeführt wird. Wenn Sie diese Überladung aufrufen, verwenden `defaultValue` Sie den-Parameter, um den zurück `name` zugebende Wert anzugeben, wenn nicht vorhanden ist.  
  
> [!NOTE]
>  Ein Registrierungsschlüssel kann über einen Wert verfügen, der keinem Namen zugeordnet ist. Wenn dieser unbenannte Wert im Registrierungs-Editor angezeigt wird, wird die Zeichenfolge "(Standard)" anstelle eines Namens angezeigt. Um diesen unbenannten Wert abzurufen, geben `null` Sie entweder oder die leere Zeichenfolge (" `name`") für an.  
  
 Wenn die <xref:Microsoft.Win32.RegistryKey.GetValue%2A> -Methode erweiterbare Zeichen folgen Werte (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>) abruft, werden Umgebungs Zeichenfolgen mithilfe von Daten aus der lokalen Umgebung erweitert. Um erweiterbare Zeichen folgen Werte aus der Registrierung auf einem Remote Computer abzurufen, geben <xref:Microsoft.Win32.RegistryKey.GetValue%2A> Sie mit der-Überladung an, dass Umgebungs Zeichenfolgen nicht erweitert werden sollen.  
  
> [!NOTE]
>  Wenn ein Wert, der erweiterbare Verweise auf Umgebungsvariablen enthält, als Zeichenfolge (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>) und nicht als erweiterbare Zeichenfolge (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>) gespeichert wurde, <xref:Microsoft.Win32.RegistryKey.GetValue%2A> wird Sie von der Methode nicht erweitert. Sie können eine solche Zeichenfolge erweitern, nachdem Sie durch Aufrufen der <xref:System.Environment.ExpandEnvironmentVariables%2A> -Methode abgerufen wurde.  
  
> [!NOTE]
>  Die empfohlene Vorgehensweise zum Abrufen von Daten <xref:Microsoft.Win32.Registry.PerformanceData> aus dem Schlüssel besteht darin <xref:System.Diagnostics.PerformanceCounter> , die-Klasse <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType> anstelle der-Methode zu verwenden.  
>   
>  <xref:Microsoft.Win32.RegistryKey.GetValue%2A>das Lesen von Werten vom Typ REG_NONE oder REG_LINK wird von nicht unterstützt.  In beiden Fällen wird der Standardwert (`null`) anstelle des tatsächlichen Werts zurückgegeben.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Testschlüssel mit einem Wert und ruft diesen Wert ab. Im Beispiel wird dann versucht, einen nicht vorhandenen Wert aus dem Schlüssel abzurufen. in diesem Fall gibt <xref:Microsoft.Win32.RegistryKey.GetValue%2A> die Methode den angegebenen Standardwert zurück.  
  
 [!code-cpp[Classic RegistryKey.GetValue Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic RegistryKey.GetValue Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RegistryKey.GetValue Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic RegistryKey.GetValue Example/CS/source.cs#1)]
 [!code-vb[Classic RegistryKey.GetValue Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic RegistryKey.GetValue Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen, um aus dem Registrierungsschlüssel zu lesen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:Microsoft.Win32.RegistryKey" />, der den angegebenen Wert enthält, ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <exception cref="T:System.IO.IOException">Der <see cref="T:Microsoft.Win32.RegistryKey" />, der den angegebenen Wert enthält, wurde zum Löschen markiert.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die notwendigen Registrierungsrechte.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">zum Lesen aus der Registrierung. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">zum Lesen eines Registrierungsschlüssels vom Typ REG_EXPAND_SZ. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="Overload:Microsoft.Win32.RegistryKey.SetValue" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (string name, object defaultValue, Microsoft.Win32.RegistryValueOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(string name, object defaultValue, valuetype Microsoft.Win32.RegistryValueOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValue(System.String,System.Object,Microsoft.Win32.RegistryValueOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (name As String, defaultValue As Object, options As RegistryValueOptions) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::String ^ name, System::Object ^ defaultValue, Microsoft::Win32::RegistryValueOptions options);" />
      <MemberSignature Language="F#" Value="member this.GetValue : string * obj * Microsoft.Win32.RegistryValueOptions -&gt; obj" Usage="registryKey.GetValue (name, defaultValue, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="defaultValue" Type="System.Object" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="Microsoft.Win32.RegistryValueOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des abzurufenden Werts. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="defaultValue">Der zurückzugebende Wert, wenn <paramref name="name" /> nicht vorhanden ist.</param>
        <param name="options">Einer der Enumerationswerte, die eine optionale Verarbeitung des abgerufenen Werts angeben.</param>
        <summary>Ruft den Wert ab, der dem angegebenen Namen und den Abrufoptionen zugeordnet ist. Wenn der Name nicht gefunden wird, wird der von Ihnen bereitgestellte Standardwert zurückgegeben.</summary>
        <returns>Der <paramref name="name" /> zugeordnete Wert, der entsprechend den <paramref name="options" /> verarbeitet wurde, oder <paramref name="defaultValue" />, wenn <paramref name="name" /> nicht gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, um eine spezielle Verarbeitung des abgerufenen Werts anzugeben. Beispielsweise können Sie beim Abrufen <xref:Microsoft.Win32.RegistryValueOptions.DoNotExpandEnvironmentNames?displayProperty=nameWithType> eines Registrierungs Werts vom Typ <xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType> angeben, um die Zeichenfolge abzurufen, ohne eingebettete Umgebungsvariablen zu erweitern.  
  
 Verwenden Sie `defaultValue` den-Parameter, um den zurück zugebende Wert anzugeben, wenn `name` nicht vorhanden ist.  
  
> [!NOTE]
>  Ein Registrierungsschlüssel kann über einen Wert verfügen, der keinem Namen zugeordnet ist. Wenn dieser unbenannte Wert im Registrierungs-Editor angezeigt wird, wird die Zeichenfolge "(Standard)" anstelle eines Namens angezeigt. Um diesen unbenannten Wert abzurufen, geben `null` Sie entweder oder die leere Zeichenfolge (" `name`") für an.  
>   
>  <xref:Microsoft.Win32.RegistryKey.GetValue%2A>das Lesen von Werten vom Typ REG_NONE oder REG_LINK wird von nicht unterstützt.  In beiden Fällen wird der Standardwert (`null`) anstelle des tatsächlichen Werts zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Testschlüssel erstellt, ein Wert mit einer eingebetteten Umgebungsvariablen hinzugefügt und der Wert in erweiterten und nicht erweiterten Formularen abgerufen.  
  
 [!code-cpp[RegistryValueOptions#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistryValueOptions/CPP/RegistryValueOptions.cpp#1)]
 [!code-csharp[RegistryValueOptions#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryValueOptions/CS/source.cs#1)]
 [!code-vb[RegistryValueOptions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryValueOptions/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen, um aus dem Registrierungsschlüssel zu lesen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:Microsoft.Win32.RegistryKey" />, der den angegebenen Wert enthält, ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <exception cref="T:System.IO.IOException">Der <see cref="T:Microsoft.Win32.RegistryKey" />, der den angegebenen Wert enthält, wurde zum Löschen markiert.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> ist kein gültiger <see cref="T:Microsoft.Win32.RegistryValueOptions" />-Wert; ein ungültiger Wert wird z. B. in <see cref="T:Microsoft.Win32.RegistryValueOptions" /> umgewandelt.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die notwendigen Registrierungsrechte.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">zum Lesen aus der Registrierung. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">zum Lesen eines Registrierungsschlüssels vom Typ REG_EXPAND_SZ. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:Microsoft.Win32.RegistryValueOptions" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="Overload:Microsoft.Win32.RegistryKey.SetValue" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="GetValueKind">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryValueKind GetValueKind (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Microsoft.Win32.RegistryValueKind GetValueKind(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValueKind(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValueKind (name As String) As RegistryValueKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryValueKind GetValueKind(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetValueKind : string -&gt; Microsoft.Win32.RegistryValueKind" Usage="registryKey.GetValueKind name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryValueKind</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des Werts, dessen Registrierungsdatentyp abgerufen werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Ruft den Registrierungsdatentyp des Werts ab, der dem angegebenen Namen zugeordnet ist.</summary>
        <returns>Der Registrierungsdatentyp des <paramref name="name" /> zugeordneten Werts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ein Registrierungsschlüssel kann über einen Wert verfügen, der keinem Namen zugeordnet ist. Wenn dieser unbenannte Wert im Registrierungs-Editor angezeigt wird, wird die Zeichenfolge "(Standard)" anstelle eines Namens angezeigt. Zum Abrufen des Registrierungs Datentyps dieses unbenannten Werts geben `null` Sie entweder oder die leere Zeichenfolge (" `name`") für an.  
  
 Eine Beschreibung der unterstützten Registrierungs Datentypen finden Sie in <xref:Microsoft.Win32.RegistryValueKind> der-Enumeration.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Testschlüssel erstellt, und dem Schlüssel werden Werte unterschiedlicher Datentypen hinzugefügt. Im Beispiel werden dann die Name-Wert-Paare gelesen und in der Konsole angezeigt. dabei <xref:Microsoft.Win32.RegistryKey.GetValueKind%2A> wird die-Methode verwendet, um die entsprechenden Registrierungs Datentypen abzurufen.  
  
 [!code-cpp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen, um aus dem Registrierungsschlüssel zu lesen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:Microsoft.Win32.RegistryKey" />, der den angegebenen Wert enthält, ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <exception cref="T:System.IO.IOException">Der Unterschlüssel, der den angegebenen Wert enthält, ist nicht vorhanden.  
  
- oder - 
Das von <paramref name="name" /> angegebene Name-Wert-Paar ist nicht vorhanden.  
  
Diese Ausnahme wird unter Windows 95, Windows 98 oder Windows Millennium Edition nicht ausgelöst.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die notwendigen Registrierungsrechte.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">zum Lesen aus der Registrierung. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.SetValue(System.String,System.Object)" />
        <altmember cref="T:Microsoft.Win32.RegistryValueKind" />
      </Docs>
    </Member>
    <Member MemberName="GetValueNames">
      <MemberSignature Language="C#" Value="public string[] GetValueNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetValueNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.GetValueNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValueNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetValueNames();" />
      <MemberSignature Language="F#" Value="member this.GetValueNames : unit -&gt; string[]" Usage="registryKey.GetValueNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein Array von Zeichenfolgen ab, das die Namen aller diesem Schlüssel zugeordneten Werte enthält.</summary>
        <returns>Ein Array von Zeichenfolgen, das die Namen der Werte für den aktuellen Schlüssel enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn keine Wert Namen für den Schlüssel gefunden werden, wird ein leeres Array zurückgegeben.  
  
 Ein Registrierungsschlüssel kann einen Standardwert aufweisen, d. h. ein Name-Wert-Paar, in dem der Name eine leere Zeichenfolge ("") ist. Wenn ein Standardwert für einen Registrierungsschlüssel festgelegt wurde, enthält das von der <xref:Microsoft.Win32.RegistryKey.GetValueNames%2A> -Methode zurückgegebene Array die leere Zeichenfolge.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:Microsoft.Win32.RegistryKey> -Klasse bereitgestellt wird.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen, um aus dem Registrierungsschlüssel zu lesen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der zu bearbeitende <see cref="T:Microsoft.Win32.RegistryKey" /> ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die notwendigen Registrierungsrechte.</exception>
        <exception cref="T:System.IO.IOException">Ein Systemfehler ist aufgetreten, möglicherweise wurde der aktuelle Schlüssel gelöscht.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">um die Möglichkeit zum Lesen aus der Registrierung zu erhalten. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeRegistryHandle Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeRegistryHandle Handle" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As SafeRegistryHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ Handle { Microsoft::Win32::SafeHandles::SafeRegistryHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : Microsoft.Win32.SafeHandles.SafeRegistryHandle" Usage="Microsoft.Win32.RegistryKey.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeRegistryHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:Microsoft.Win32.SafeHandles.SafeRegistryHandle" />-Objekt ab, das den Registrierungsschlüssel darstellt, der vom aktuellen <see cref="T:Microsoft.Win32.RegistryKey" />-Objekt gekapselt wird.</summary>
        <value>Das Handle für den Registrierungsschlüssel.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Der Registrierungsschlüssel ist geschlossen. Auf geschlossene Schlüssel kann nicht zugegriffen werden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die notwendigen Registrierungsrechte.</exception>
        <exception cref="T:System.IO.IOException">Ein Systemfehler ist aufgetreten, z. B. Löschen des aktuellen Schlüssels.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Lesen des Schlüssels.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">die Möglichkeit, auf den angegebenen Registrierungsschlüssel zuzugreifen, wenn es sich um einen Remote Schlüssel handelt. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="Microsoft.Win32.RegistryKey.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Schlüssels ab.</summary>
        <value>Der absolute (vollständige) Name des Schlüssels.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Name des Schlüssels enthält den absoluten Pfad dieses Schlüssels in der Registrierung, der immer mit einem Basis Schlüssel beginnt, z. b. HKEY_LOCAL_MACHINE.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:Microsoft.Win32.RegistryKey> -Klasse bereitgestellt wird.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:Microsoft.Win32.RegistryKey" /> ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <altmember cref="M:Microsoft.Win32.RegistryKey.ToString" />
      </Docs>
    </Member>
    <Member MemberName="OpenBaseKey">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey OpenBaseKey (Microsoft.Win32.RegistryHive hKey, Microsoft.Win32.RegistryView view);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey OpenBaseKey(valuetype Microsoft.Win32.RegistryHive hKey, valuetype Microsoft.Win32.RegistryView view) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenBaseKey(Microsoft.Win32.RegistryHive,Microsoft.Win32.RegistryView)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenBaseKey (hKey As RegistryHive, view As RegistryView) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ OpenBaseKey(Microsoft::Win32::RegistryHive hKey, Microsoft::Win32::RegistryView view);" />
      <MemberSignature Language="F#" Value="static member OpenBaseKey : Microsoft.Win32.RegistryHive * Microsoft.Win32.RegistryView -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.OpenBaseKey (hKey, view)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hKey" Type="Microsoft.Win32.RegistryHive" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="view" Type="Microsoft.Win32.RegistryView" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="hKey">Der zu öffnende HKEY.</param>
        <param name="view">Die zu verwendende Registrierungsansicht.</param>
        <summary>Öffnet einen neuen <see cref="T:Microsoft.Win32.RegistryKey" />, der den angeforderten Schlüssel auf dem lokalen Computer mit der angegebenen Ansicht darstellt.</summary>
        <returns>Der angeforderte Registrierungsschlüssel.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="hKey" /> oder <paramref name="view" /> ist ungültig.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die notwendigen Registrierungsrechte.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über ausreichende Berechtigungen zum Ausführen dieser Aktion.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenRemoteBaseKey">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet einen neuen T:Microsoft.Win32.RegistryKey, der den angeforderten Schlüssel auf einem Remotecomputer darstellt, mit der Option für die angegebene Registrierungsansicht.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenRemoteBaseKey">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey OpenRemoteBaseKey (Microsoft.Win32.RegistryHive hKey, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey OpenRemoteBaseKey(valuetype Microsoft.Win32.RegistryHive hKey, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenRemoteBaseKey (hKey As RegistryHive, machineName As String) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ OpenRemoteBaseKey(Microsoft::Win32::RegistryHive hKey, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member OpenRemoteBaseKey : Microsoft.Win32.RegistryHive * string -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.OpenRemoteBaseKey (hKey, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hKey" Type="Microsoft.Win32.RegistryHive" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="machineName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="hKey">Der zu öffnende HKEY aus der <see cref="T:Microsoft.Win32.RegistryHive" />-Enumeration.</param>
        <param name="machineName">Der Remotecomputer.</param>
        <summary>Öffnet einen neuen <see cref="T:Microsoft.Win32.RegistryKey" />, der den angeforderten Schlüssel für einen Remotecomputer darstellt.</summary>
        <returns>Der angeforderte Registrierungsschlüssel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Registrierung des lokalen Computers wird geöffnet `machineName` , <xref:System.String.Empty?displayProperty=nameWithType>wenn den Wert hat. Der angeforderte Schlüssel muss ein Stamm Schlüssel auf dem Remote Computer sein, und er wird durch den <xref:Microsoft.Win32.RegistryHive> entsprechenden Wert identifiziert.  
  
 Damit ein Schlüssel Remote geöffnet werden kann, muss sowohl auf dem Server-als auch auf dem Client Computer der Remote Registrierungsdienst ausgeführt werden, und die Remote Verwaltung muss aktiviert sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein Registrierungsschlüssel auf einem Remote Computer geöffnet und die Werte des Schlüssels aufgelistet werden. Auf dem Remote Computer muss der Remote Registrierungsdienst ausgeführt werden. Geben Sie den Namen des Remote Computers als Befehlszeilenargument an, wenn Sie das Programm aufrufen.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey.OpenRemoteBaseKey#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.OpenRemoteBaseKey/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey.OpenRemoteBaseKey#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.OpenRemoteBaseKey/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey.OpenRemoteBaseKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.OpenRemoteBaseKey/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="hKey" /> ist ungültig.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="machineName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="machineName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über ausreichende Berechtigungen zum Ausführen dieser Aktion.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die notwendigen Registrierungsrechte.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">die Möglichkeit, auf den angegebenen Registrierungsschlüssel zuzugreifen, wenn es sich um einen Remote Schlüssel handelt. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:Microsoft.Win32.RegistryHive" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="OpenRemoteBaseKey">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey OpenRemoteBaseKey (Microsoft.Win32.RegistryHive hKey, string machineName, Microsoft.Win32.RegistryView view);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Win32.RegistryKey OpenRemoteBaseKey(valuetype Microsoft.Win32.RegistryHive hKey, string machineName, valuetype Microsoft.Win32.RegistryView view) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String,Microsoft.Win32.RegistryView)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenRemoteBaseKey (hKey As RegistryHive, machineName As String, view As RegistryView) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Win32::RegistryKey ^ OpenRemoteBaseKey(Microsoft::Win32::RegistryHive hKey, System::String ^ machineName, Microsoft::Win32::RegistryView view);" />
      <MemberSignature Language="F#" Value="static member OpenRemoteBaseKey : Microsoft.Win32.RegistryHive * string * Microsoft.Win32.RegistryView -&gt; Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.RegistryKey.OpenRemoteBaseKey (hKey, machineName, view)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hKey" Type="Microsoft.Win32.RegistryHive" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="machineName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="view" Type="Microsoft.Win32.RegistryView" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="hKey">Der zu öffnende HKEY aus der <see cref="T:Microsoft.Win32.RegistryHive" />-Enumeration.</param>
        <param name="machineName">Der Remotecomputer.</param>
        <param name="view">Die zu verwendende Registrierungsansicht.</param>
        <summary>Öffnet einen neuen Registrierungsschlüssel, der den angeforderten Schlüssel auf einem Remotecomputer mit der angegebenen Ansicht darstellt.</summary>
        <returns>Der angeforderte Registrierungsschlüssel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Registrierung des lokalen Computers wird geöffnet `machineName` , <xref:System.String.Empty?displayProperty=nameWithType>wenn den Wert hat. Der angeforderte Schlüssel muss ein Stamm Schlüssel auf dem Remote Computer sein, und er wird durch den <xref:Microsoft.Win32.RegistryHive> entsprechenden Wert identifiziert.  
  
 Damit ein Schlüssel Remote geöffnet werden kann, muss sowohl auf dem Server-als auch auf dem Client Computer der Remote Registrierungsdienst ausgeführt werden, und die Remote Verwaltung muss aktiviert sein.  
  
 In den 64-Bit-Versionen von Windows werden Teile der Registrierung für 32-Bit-und 64-Bit-Anwendungen separat gespeichert. Es gibt eine 32-Bit-Ansicht für 32-Bit-Anwendungen und eine 64-Bit-Ansicht für 64-Bit-Anwendungen. Wenn `view`den Wert hat, <xref:Microsoft.Win32.RegistryView.Registry32> aberaufdemRemoteComputerein32-Bit-Betriebssystemausgeführtwird,wirddieAnsichtvomzurückgegebenenSchlüsselverwendet.<xref:Microsoft.Win32.RegistryView.Registry64>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="hKey" /> oder <paramref name="view" /> ist ungültig.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="machineName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="machineName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die notwendigen Registrierungsrechte.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über ausreichende Berechtigungen zum Ausführen dieser Aktion.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenSubKey">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den angegebenen Unterschlüssel ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name oder der Pfad des Unterschlüssels, der schreibgeschützt geöffnet werden soll.</param>
        <summary>Ruft einen Unterschlüssel als schreibgeschützt ab.</summary>
        <returns>Der angeforderte Unterschlüssel oder <see langword="null" />, wenn bei dem Vorgang ein Fehler aufgetreten ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen einen Schlüssel öffnen, bevor er mit anderen Methoden und Eigenschaften bearbeitet werden kann. Um einen Schlüssel zu ändern, müssen Sie ihn mit einer über <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> Ladung der-Methode öffnen, die Ihnen ermöglicht, Schreibzugriff anzugeben, z. b. die <xref:Microsoft.Win32.RegistryKey.OpenSubKey%28System.String%2CMicrosoft.Win32.RegistryKeyPermissionCheck%29> -Überladung oder die <xref:Microsoft.Win32.RegistryKey.OpenSubKey%28System.String%2CSystem.Boolean%29> -Überladung.  
  
 Wenn der angegebene Unterschlüssel nicht gefunden werden kann, `null` wird zurückgegeben.  
  
 Um die <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> -Methode verwenden zu können, müssen Sie über eine Instanz <xref:Microsoft.Win32.RegistryKey>von verfügen. Um eine Instanz von <xref:Microsoft.Win32.RegistryKey>zu erhalten, verwenden Sie einen der statischen Member <xref:Microsoft.Win32.Registry> der-Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Testschlüssel erstellt und die <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> -Methode verwendet, um ihn zu öffnen, sodass beide über Ladungen der-Methode dargestellt werden.  
  
 [!code-cpp[RegistryKey.OpenSubKey#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CPP/opensubkey.cpp#1)]
 [!code-csharp[RegistryKey.OpenSubKey#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CS/opensubkey.cs#1)]
 [!code-vb[RegistryKey.OpenSubKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryKey.OpenSubKey/VB/opensubkey.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist gleich <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:Microsoft.Win32.RegistryKey" /> ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen, um den Registrierungsschlüssel zu lesen.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">, um den angegebenen Registrierungsschlüssel lesen zu können. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">die Möglichkeit, auf den angegebenen Registrierungsschlüssel zuzugreifen, wenn es sich um einen Remote Schlüssel handelt. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, permissionCheck As RegistryKeyPermissionCheck) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey (name, permissionCheck)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Name oder Pfad des zu erstellenden oder zu öffnenden Unterschlüssels.</param>
        <param name="permissionCheck">Einer der Enumerationswerte, der angibt, ob der Schlüssel für Lesezugriff oder für Lese-/Schreibzugriff geöffnet wird.</param>
        <summary>Ruft den angegebenen Unterschlüssel für Lesezugriff oder Lese-/Schreibzugriff ab.</summary>
        <returns>Der angeforderte Unterschlüssel oder <see langword="null" />, wenn bei dem Vorgang ein Fehler aufgetreten ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt eine Ausnahme auszulösen, gibt diese Methode zurück `null` , wenn der angeforderte Schlüssel nicht vorhanden ist.  
  
 `permissionCheck` <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType> <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType> <xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType> `permissionCheck` Wenn den Wert hat,wirdderSchlüsselzumLesenundSchreibengeöffnet.wenndenWertoderhat,wirdderSchlüsselzumLesengeöffnet,esseidenn,derübergeordneteSchlüsselwurdemitgeöffnet.<xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>  
  
 Um die <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> -Methode verwenden zu können, müssen Sie über eine Instanz <xref:Microsoft.Win32.RegistryKey> der-Klasse verfügen. Um eine Instanz von <xref:Microsoft.Win32.RegistryKey>zu erhalten, verwenden Sie eines der statischen Member <xref:Microsoft.Win32.Registry> der-Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Unterschlüssel erstellt, der 100-Schlüssel/Wert-Paare enthält und ihn schließt. Das Beispiel öffnet den Unterschlüssel mit <xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default>, zeichnet die benötigte Zeit zum Lesen aller Werte auf und schließt den Unterschlüssel. Das Beispiel öffnet den Unterschlüssel mit <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree> und zeichnet die Zeit auf, die zum Lesen aller Werte benötigt wird. Schließlich berechnet das Beispiel die prozentuale Verbesserung und zeigt diese an.  
  
 [!code-csharp[RegistryKey.OpenSubKey_PermCheck#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryKey.OpenSubKey_PermCheck/cs/source.cs#1)]
 [!code-vb[RegistryKey.OpenSubKey_PermCheck#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryKey.OpenSubKey_PermCheck/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist gleich <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="permissionCheck" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:Microsoft.Win32.RegistryKey" /> ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen, um den Registrierungsschlüssel zu lesen.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">, um den angegebenen Registrierungsschlüssel lesen zu können. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">die Möglichkeit, auf den angegebenen Registrierungsschlüssel zuzugreifen, wenn es sich um einen Remote Schlüssel handelt. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, writable As Boolean) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, bool writable);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string * bool -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey (name, writable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Name oder Pfad des zu öffnenden Unterschlüssels.</param>
        <param name="writable">Muss für Schreibzugriff auf den Schlüssel auf <see langword="true" /> festgelegt werden.</param>
        <summary>Ruft einen angegebenen Unterschlüssel ab und gibt an, ob Schreibzugriff auf den Schlüssel angewendet werden soll.</summary>
        <returns>Der angeforderte Unterschlüssel oder <see langword="null" />, wenn bei dem Vorgang ein Fehler aufgetreten ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der angeforderte Schlüssel nicht vorhanden ist, gibt diese `null` Methode zurück, anstatt eine Ausnahme auszulösen.  
  
 Wenn `writable`den Wert hat,wirdderSchlüsselzumLesenundSchreibengeöffnet.andernfallswirdderSchlüsselschreibgeschütztgeöffnet.`true`  
  
 Um die <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> -Methode verwenden zu können, müssen Sie über eine Instanz <xref:Microsoft.Win32.RegistryKey> der-Methode verfügen. Um eine Instanz von <xref:Microsoft.Win32.RegistryKey>zu erhalten, verwenden Sie eines der statischen Member <xref:Microsoft.Win32.Registry> der-Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Testschlüssel erstellt und die <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> -Methode verwendet, um ihn zu öffnen, sodass beide über Ladungen der-Methode dargestellt werden.  
  
 [!code-cpp[RegistryKey.OpenSubKey#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CPP/opensubkey.cpp#1)]
 [!code-csharp[RegistryKey.OpenSubKey#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistryKey.OpenSubKey/CS/opensubkey.cs#1)]
 [!code-vb[RegistryKey.OpenSubKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistryKey.OpenSubKey/VB/opensubkey.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:Microsoft.Win32.RegistryKey" /> ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen, um auf den Registrierungsschlüssel im angegebenen Modus zuzugreifen.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">, um den angegebenen Registrierungsschlüssel lesen zu können. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">die Möglichkeit, auf den angegebenen Registrierungsschlüssel zuzugreifen, wenn es sich um einen Remote Schlüssel handelt. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, System.Security.AccessControl.RegistryRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, valuetype System.Security.AccessControl.RegistryRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Security.AccessControl.RegistryRights)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, rights As RegistryRights) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, System::Security::AccessControl::RegistryRights rights);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string * System.Security.AccessControl.RegistryRights -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.RegistryRights" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Name oder Pfad des zu erstellenden oder zu öffnenden Unterschlüssels.</param>
        <param name="rights">Die Berechtigungen für den Registrierungsschlüssel.</param>
        <summary>Ruft einen Unterschlüssel mit dem angegebenen Namen und Zugriffsrechten ab. Verfügbar ab .NET Framework 4.6.</summary>
        <returns>Der angeforderte Unterschlüssel oder <see langword="null" />, wenn bei dem Vorgang ein Fehler aufgetreten ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen einen Schlüssel öffnen, bevor er mit anderen Methoden und Eigenschaften bearbeitet werden kann. Um einen Schlüssel zu ändern, müssen Sie ihn mit einer über <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> Ladung der-Methode öffnen, die Ihnen ermöglicht, Schreibzugriff anzugeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:Microsoft.Win32.RegistryKey" /> ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen, um auf den Registrierungsschlüssel im angegebenen Modus zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenSubKey">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryKey OpenSubKey (string name, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, System.Security.AccessControl.RegistryRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.RegistryKey OpenSubKey(string name, valuetype Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, valuetype System.Security.AccessControl.RegistryRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String,Microsoft.Win32.RegistryKeyPermissionCheck,System.Security.AccessControl.RegistryRights)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenSubKey (name As String, permissionCheck As RegistryKeyPermissionCheck, rights As RegistryRights) As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::RegistryKey ^ OpenSubKey(System::String ^ name, Microsoft::Win32::RegistryKeyPermissionCheck permissionCheck, System::Security::AccessControl::RegistryRights rights);" />
      <MemberSignature Language="F#" Value="member this.OpenSubKey : string * Microsoft.Win32.RegistryKeyPermissionCheck * System.Security.AccessControl.RegistryRights -&gt; Microsoft.Win32.RegistryKey" Usage="registryKey.OpenSubKey (name, permissionCheck, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="permissionCheck" Type="Microsoft.Win32.RegistryKeyPermissionCheck" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.RegistryRights" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Name oder Pfad des zu erstellenden oder zu öffnenden Unterschlüssels.</param>
        <param name="permissionCheck">Einer der Enumerationswerte, der angibt, ob der Schlüssel für Lesezugriff oder für Lese-/Schreibzugriff geöffnet wird.</param>
        <param name="rights">Eine bitweise Kombination von Enumerationswerten, die den gewünschten Sicherheitszugriff angeben.</param>
        <summary>Ruft den angegebenen Unterschlüssel für Lesezugriff oder Lese-/Schreibzugriff ab, und fordert die angegebenen Zugriffsrechte an.</summary>
        <returns>Der angeforderte Unterschlüssel oder <see langword="null" />, wenn bei dem Vorgang ein Fehler aufgetreten ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt eine Ausnahme auszulösen, gibt diese Methode zurück `null` , wenn der angeforderte Schlüssel nicht vorhanden ist.  
  
 `permissionCheck` <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType> <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType> <xref:Microsoft.Win32.RegistryKeyPermissionCheck.Default?displayProperty=nameWithType> `permissionCheck` Wenn den Wert hat,wirdderSchlüsselzumLesenundSchreibengeöffnet.wenndenWertoderhat,wirdderSchlüsselzumLesengeöffnet,esseidenn,derübergeordneteSchlüsselwurdemitgeöffnet.<xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree?displayProperty=nameWithType>  
  
 Der für `permissionCheck` angegebene Zugriff hat Vorrang vor dem für `rights`angegebenen Zugriff. Wenn Sie z. b. <xref:Microsoft.Win32.RegistryKeyPermissionCheck.ReadSubTree?displayProperty=nameWithType> für `permissionCheck` und <xref:System.Security.AccessControl.RegistryRights.WriteKey?displayProperty=nameWithType> für `rights`angeben, wird durch einen Versuch, in den Unterschlüssel zu schreiben, eine Ausnahme ausgelöst.  
  
 Um die <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> -Methode verwenden zu können, müssen Sie über eine Instanz <xref:Microsoft.Win32.RegistryKey> der-Klasse verfügen. Um eine Instanz von <xref:Microsoft.Win32.RegistryKey>zu erhalten, verwenden Sie eines der statischen Member <xref:Microsoft.Win32.Registry> der-Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist gleich <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="permissionCheck" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:Microsoft.Win32.RegistryKey" /> ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <exception cref="T:System.Security.SecurityException"><paramref name="rights" /> enthält ungültige Werte für Registrierungsrechte.  
  
- oder - 
Der Benutzer verfügt nicht über die angeforderten Berechtigungen.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">, um den angegebenen Registrierungsschlüssel lesen zu können. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">die Möglichkeit, auf den angegebenen Registrierungsschlüssel zuzugreifen, wenn es sich um einen Remote Schlüssel handelt. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKey(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.DeleteSubKeyTree(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
        <altmember cref="T:Microsoft.Win32.Registry" />
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.RegistrySecurity registrySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.RegistrySecurity registrySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.SetAccessControl(System.Security.AccessControl.RegistrySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::RegistrySecurity ^ registrySecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.RegistrySecurity -&gt; unit" Usage="registryKey.SetAccessControl registrySecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="registrySecurity" Type="System.Security.AccessControl.RegistrySecurity" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="registrySecurity">Die Zugriffssteuerungssicherheit, die für den aktuellen Unterschlüssel angewendet werden soll.</param>
        <summary>Übernimmt Windows-Zugriffssteuerungssicherheit für einen vorhandenen Registrierungsschlüssel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Ändern der Berechtigungen für einen Registrierungsschlüssel verwenden Sie <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A> die-Methode, <xref:System.Security.AccessControl.RegistrySecurity> um ein-Objekt abzurufen, das die vorhandene Windows- <xref:System.Security.AccessControl.RegistrySecurity> Zugriffs Steuerungs Sicherheit darstellt, ändern <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A> Sie das Objekt, und verwenden Sie dann die-Methode zum Aktualisieren der Sicherheit für Der Schlüssel.  
  
> [!CAUTION]
>  Das <xref:System.Security.AccessControl.RegistrySecurity> für`registrySecurity` angegebene-Objekt ersetzt die vorhandene Sicherheit für den Registrierungsschlüssel. Um Berechtigungen für einen neuen Benutzer hinzuzufügen, verwenden <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A> Sie die-Methode zum Abrufen der vorhandenen Zugriffs Steuerungs Sicherheit, und ändern Sie Sie anschließend.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Testschlüssel erstellt. Der aktuelle Benutzer ist zulässig <xref:System.Security.AccessControl.RegistryRights.ReadKey> und <xref:System.Security.AccessControl.RegistryRights.Delete> verfügt über Rechte <xref:System.Security.AccessControl.RegistryRights.ChangePermissions> , <xref:System.Security.AccessControl.RegistryRights.WriteKey> aber verweigerte Rechte und Rechte. Nachfolgende Versuche, den Schlüssel zu manipulieren, sind abhängig von diesen Berechtigungen erfolgreich oder fehlerhaft.  
  
 Bevor der Schlüssel gelöscht wird, wird der Code angehalten. Sie können zum Registrierungs-Editor wechseln und überprüfen, ob die gleichen Zugriffsrechte zutreffen, wenn der Zugriff auf den Schlüssel über den Registrierungs-Editor erfolgt. (Dies funktioniert am besten, wenn Sie **runas** von der Befehlszeile aus verwenden, um den Registrierungs-Editor und den Beispielcode als lokalen Benutzer ohne Administratorrechte auszuführen. Der Registrierungs-Editor ermöglicht es einem Administrator immer, Berechtigungen zu ändern, auch wenn dem jeweiligen Administrator diese Rechte verweigert wurden. Wenn Sie einen lokalen Benutzernamens "testuser" definiert haben, `runas /user:TestUser cmd` öffnet der Befehl ein Befehlsfenster, in dem Sie den Registrierungs-Editor und dann den Beispielcode ausführen können.)  
  
 [!code-cpp[RegistrySecurity101#1](~/samples/snippets/cpp/VS_Snippets_CLR/RegistrySecurity101/cpp/source.cpp#1)]
 [!code-csharp[RegistrySecurity101#1](~/samples/snippets/csharp/VS_Snippets_CLR/RegistrySecurity101/CS/source.cs#1)]
 [!code-vb[RegistrySecurity101#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RegistrySecurity101/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Das aktuelle <see cref="T:Microsoft.Win32.RegistryKey" />-Objekt stellt einen Schlüssel mit Zugriffssteuerungssicherheit dar, und der Aufrufer verfügt nicht über <see cref="F:System.Security.AccessControl.RegistryRights.ChangePermissions" />-Rechte.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="registrySecurity" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Der zu bearbeitende <see cref="T:Microsoft.Win32.RegistryKey" /> ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt den Wert eines Name-Wert-Paars im Registrierungsschlüssel fest. Je nach Überladung wird der Registrierungsdatentyp entweder abhängig von der Art der zu speichernden Daten oder abhängig von <see cref="T:Microsoft.Win32.RegistryValueKind" /> bestimmt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (string name, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(string name, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.SetValue(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (name As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::String ^ name, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : string * obj -&gt; unit" Usage="registryKey.SetValue (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu speichernden Werts.</param>
        <param name="value">Die zu speichernden Daten.</param>
        <summary>Legt das angegebene Name-Wert-Paar fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da viele Werte in jedem Schlüssel in der Registrierung gespeichert werden können, müssen Sie den `name` -Parameter verwenden, um den bestimmten Wert anzugeben, den Sie festlegen möchten.  
  
> [!NOTE]
>  Ein Registrierungsschlüssel kann über einen Wert verfügen, der keinem Namen zugeordnet ist. Wenn dieser unbenannte Wert im Registrierungs-Editor angezeigt wird, wird die Zeichenfolge "(Standard)" anstelle eines Namens angezeigt. Um diesen unbenannten Wert festzulegen, `null` geben Sie entweder oder die leere Zeichenfolge ( `name`"") für an.  
  
 Um Werte in einem Schlüssel festzulegen, müssen Sie den Schlüssel mit Schreibzugriff öffnen. Nachdem Sie einen Schlüssel mit Schreibzugriff geöffnet haben, können Sie die Name-Wert-Paare in diesem Schlüssel ändern.  
  
 Wenn das angegebene `name` nicht im Schlüssel vorhanden ist, wird es erstellt, und der zugeordnete Wert wird auf `value`festgelegt.  
  
 Diese Überladung <xref:Microsoft.Win32.RegistryKey.SetValue%2A> von speichert ganzzahlige 64-Bit-<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>Werte als Zeichen folgen (). Um 64-Bit-Zahlen als <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType> Werte zu speichern, <xref:Microsoft.Win32.RegistryKey.SetValue%28System.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> verwenden Sie die <xref:Microsoft.Win32.RegistryValueKind>-Überladung, die angibt.  
  
 Diese Überladung <xref:Microsoft.Win32.RegistryKey.SetValue%2A> von speichert alle Zeichen folgen <xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>Werte als, auch wenn Sie erweiterbare Verweise auf Umgebungsvariablen enthalten. Um Zeichen folgen Werte als erweiterbare Zeichen folgen<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>() zu speichern <xref:Microsoft.Win32.RegistryKey.SetValue%28System.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> , verwenden Sie <xref:Microsoft.Win32.RegistryValueKind>die-Überladung, die angibt.  
  
 Numerische Typen außer 32-Bit-Ganzzahlen werden von dieser Methoden Überladung als Zeichen folgen gespeichert. Enumerationselemente werden als Zeichen folgen gespeichert, die die Elementnamen enthalten.  
  
> [!CAUTION]
>  Machen Sie <xref:Microsoft.Win32.RegistryKey> Objekte nicht so verfügbar, dass ein schädliches Programm Tausende von bedeutungslosen unter Schlüsseln oder Schlüssel-Wert-Paaren erstellen könnte. Gestatten Sie z. b. nicht, dass Aufrufer beliebige Schlüssel oder Werte eingeben.  
  
> [!NOTE]
>  Unter Windows 98 und Windows Millennium Edition ist die Registrierung nicht Unicode, und nicht alle Unicode-Zeichen sind für alle Codepages gültig. Ein Unicode-Zeichen, das für die aktuelle Codepage ungültig ist, wird durch die beste verfügbare Entsprechung ersetzt. Es werden keine Ausnahmen ausgelöst.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, <xref:Microsoft.Win32.RegistryKey.SetValue%2A> wie die-Methode beim Festlegen von Werten den Registrierungs Datentyp bestimmt. Im Beispiel wird ein Testschlüssel erstellt, und dem Schlüssel werden Werte verschiedener Datentypen hinzugefügt. Im Beispiel werden dann die Name-Wert-Paare gelesen und in der Konsole angezeigt. dabei <xref:Microsoft.Win32.RegistryKey.GetValueKind%2A> wird die-Methode verwendet, um die entsprechenden Registrierungs Datentypen anzuzeigen.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey.SetValue1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.SetValue1/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryKey.SetValue1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.SetValue1/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryKey.SetValue1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey.SetValue1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> ist ein nicht unterstützter Datentyp.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:Microsoft.Win32.RegistryKey" />, der den angegebenen Wert enthält, ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der <see cref="T:Microsoft.Win32.RegistryKey" /> ist schreibgeschützt, sodass das Schreiben in den Schlüssel nicht möglich ist. Möglicherweise wurde der Schlüssel ohne Schreibzugriff geöffnet.  
  
- oder - 
Das <see cref="T:Microsoft.Win32.RegistryKey" />-Objekt stellt einen Knoten auf Stammebene dar, und das Betriebssystem ist Windows Millennium Edition oder Windows 98.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Erstellen oder Ändern von Registrierungsschlüsseln.</exception>
        <exception cref="T:System.IO.IOException">Das <see cref="T:Microsoft.Win32.RegistryKey" />-Objekt stellt einen Knoten auf der Stammebene dar, und das Betriebssystem ist Windows 2000, Windows XP oder Windows Server 2003.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">, um den angegebenen Registrierungsschlüssel zu ändern, wenn er vorhanden ist, oder, wenn er nicht bereits vorhanden ist. Zugehörige Enumerationen <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />:,<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">die Möglichkeit, auf den angegebenen Registrierungsschlüssel zuzugreifen, wenn es sich um einen Remote Schlüssel handelt. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueKind(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (string name, object value, Microsoft.Win32.RegistryValueKind valueKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(string name, object value, valuetype Microsoft.Win32.RegistryValueKind valueKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.SetValue(System.String,System.Object,Microsoft.Win32.RegistryValueKind)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (name As String, value As Object, valueKind As RegistryValueKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::String ^ name, System::Object ^ value, Microsoft::Win32::RegistryValueKind valueKind);" />
      <MemberSignature Language="F#" Value="member this.SetValue : string * obj * Microsoft.Win32.RegistryValueKind -&gt; unit" Usage="registryKey.SetValue (name, value, valueKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueKind" Type="Microsoft.Win32.RegistryValueKind" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des zu speichernden Werts.</param>
        <param name="value">Die zu speichernden Daten.</param>
        <param name="valueKind">Der beim Speichern der Daten zu verwendende Registrierungsdatentyp.</param>
        <summary>Legt mithilfe des angegebenen Registrierungsdatentyps den Wert eines Name-Wert-Paars im Registrierungsschlüssel fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da viele Werte in jedem Schlüssel in der Registrierung gespeichert werden können, müssen Sie den `name` -Parameter verwenden, um den bestimmten Wert anzugeben, den Sie festlegen möchten.  
  
> [!NOTE]
>  Ein Registrierungsschlüssel kann über einen Wert verfügen, der keinem Namen zugeordnet ist. Wenn dieser unbenannte Wert im Registrierungs-Editor angezeigt wird, wird die Zeichenfolge "(Standard)" anstelle eines Namens angezeigt. Um diesen unbenannten Wert festzulegen, `null` geben Sie entweder oder die leere Zeichenfolge ( `name`"") für an.  
  
 Um Werte in einem Schlüssel festzulegen, müssen Sie den Schlüssel mit Schreibzugriff öffnen. Nachdem Sie einen Schlüssel mit Schreibzugriff geöffnet haben, können Sie die Name-Wert-Paare in diesem Schlüssel ändern.  
  
 Wenn das angegebene `name` nicht im Schlüssel vorhanden ist, wird es erstellt, und der zugeordnete Wert wird auf `value`festgelegt.  
  
> [!NOTE]
>  Die Angabe des Registrierungs Datentyps <xref:Microsoft.Win32.RegistryValueKind.Unknown> entspricht der Verwendung der <xref:Microsoft.Win32.RegistryKey.SetValue%2A> -Überladung.  
  
 Wenn der angegebene Typ nicht mit `value` dem angegebenen `valueKind`-Wert identisch ist und die Daten nicht konvertiert werden können <xref:System.ArgumentException> , wird ausgelöst. Beispielsweise können Sie einen <xref:System.Int64?displayProperty=nameWithType> <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>als, aber nur dann speichern, wenn der Wert kleiner als <xref:System.Int32?displayProperty=nameWithType>der maximale Wert eines ist. Sie können einen einzelnen Zeichen folgen Wert nicht als <xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>speichern.  
  
> [!NOTE]
>  Wenn für oder <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>geachtelte Werte <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType> übermittelt werden, erfolgt die Konvertierung mithilfe der invarianten Kultur.  
  
> [!CAUTION]
>  Machen Sie <xref:Microsoft.Win32.RegistryKey> Objekte nicht so verfügbar, dass ein schädliches Programm Tausende von bedeutungslosen unter Schlüsseln oder Schlüssel-Wert-Paaren erstellen könnte. Gestatten Sie z. b. nicht, dass Aufrufer beliebige Schlüssel oder Werte eingeben.  
  
> [!NOTE]
>  Unter Windows 98 und Windows Millennium Edition ist die Registrierung nicht Unicode, und nicht alle Unicode-Zeichen sind für alle Codepages gültig. Ein Unicode-Zeichen, das für die aktuelle Codepage ungültig ist, wird durch die beste verfügbare Entsprechung ersetzt. Es werden keine Ausnahmen ausgelöst.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Testschlüssel erstellt und die <xref:Microsoft.Win32.RegistryKey.SetValue%2A> -Methode verwendet, um mehrere Werte zu speichern, wobei der Registrierungs Datentyp für jeden Wert angegeben wird. Im Beispiel werden dann die Name-Wert-Paare gelesen und in der Konsole angezeigt. dabei <xref:Microsoft.Win32.RegistryKey.GetValueKind%2A> wird die-Methode verwendet, um die entsprechenden Registrierungs Datentypen anzuzeigen.  
  
 [!code-cpp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.RegistryValueKind#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryValueKind/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der Typ von <paramref name="value" /> stimmt nicht mit dem durch <paramref name="valueKind" /> angegebenen Registrierungsdatentyp überein. Die Daten konnten daher nicht ordnungsgemäß konvertiert werden.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:Microsoft.Win32.RegistryKey" />, der den angegebenen Wert enthält, ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der <see cref="T:Microsoft.Win32.RegistryKey" /> ist schreibgeschützt, sodass das Schreiben in den Schlüssel nicht möglich ist. Möglicherweise wurde der Schlüssel ohne Schreibzugriff geöffnet.  
  
- oder - 
Das <see cref="T:Microsoft.Win32.RegistryKey" />-Objekt stellt einen Knoten auf Stammebene dar, und das Betriebssystem ist Windows Millennium Edition oder Windows 98.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Erstellen oder Ändern von Registrierungsschlüsseln.</exception>
        <exception cref="T:System.IO.IOException">Das <see cref="T:Microsoft.Win32.RegistryKey" />-Objekt stellt einen Knoten auf der Stammebene dar, und das Betriebssystem ist Windows 2000, Windows XP oder Windows Server 2003.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">, um den angegebenen Registrierungsschlüssel zu ändern, wenn er vorhanden ist, oder, wenn er nicht bereits vorhanden ist. Zugehörige Enumerationen <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />:,<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">die Möglichkeit, auf den angegebenen Registrierungsschlüssel zuzugreifen, wenn es sich um einen Remote Schlüssel handelt. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValueKind(System.String)" />
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetValue(System.String)" />
        <altmember cref="P:Microsoft.Win32.RegistryKey.ValueCount" />
        <altmember cref="T:Microsoft.Win32.RegistryValueKind" />
      </Docs>
    </Member>
    <Member MemberName="SubKeyCount">
      <MemberSignature Language="C#" Value="public int SubKeyCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SubKeyCount" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.SubKeyCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SubKeyCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SubKeyCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SubKeyCount : int" Usage="Microsoft.Win32.RegistryKey.SubKeyCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Unterschlüssel des aktuellen Schlüssels ab.</summary>
        <value>Die Anzahl der Unterschlüssel des aktuellen Schlüssels.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Eigenschaft werden keine Namen rekursiv gezählt. Er gibt nur die Anzahl der Namen auf der Basisebene zurück, von der er aufgerufen wurde.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:Microsoft.Win32.RegistryKey> -Klasse bereitgestellt wird.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt keine Leseberechtigung für den Schlüssel.</exception>
        <exception cref="T:System.ObjectDisposedException">Der zu bearbeitende <see cref="T:Microsoft.Win32.RegistryKey" /> ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die notwendigen Registrierungsrechte.</exception>
        <exception cref="T:System.IO.IOException">Ein Systemfehler ist aufgetreten, möglicherweise wurde der aktuelle Schlüssel gelöscht.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">, um den angegebenen Registrierungsschlüssel lesen zu können. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <altmember cref="M:Microsoft.Win32.RegistryKey.GetSubKeyNames" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt <see cref="M:Microsoft.Win32.RegistryKey.Close" /> für den aktuellen Schlüssel durch.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Diese Methode hat denselben Effekt wie das Aufrufen <xref:Microsoft.Win32.RegistryKey.Close%2A>von.

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.RegistryKey.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="registryKey.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine Zeichenfolgenentsprechung dieses Schlüssels ab.</summary>
        <returns>Eine Zeichenfolge, die den Schlüssel darstellt. Wenn der angegebene Schlüssel ungültig ist (nicht gefunden werden kann), wird <see langword="null" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert enthält den Registrierungs Pfad des angegebenen Schlüssels und den Hexadezimalwert für den Schlüssel. Der Registrierungs Pfad enthält den absoluten Stamm des angegebenen Schlüssels und startet immer an einem der Basis Schlüssel für die Registrierung, z. b. HKEY_LOCAL_MACHINE.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:Microsoft.Win32.RegistryKey> -Klasse bereitgestellt wird.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#4)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#4)]
 [!code-vb[Microsoft.Win32.RegistryKey2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:Microsoft.Win32.RegistryKey" />, auf den zugegriffen werden soll, ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <altmember cref="P:Microsoft.Win32.RegistryKey.Name" />
      </Docs>
    </Member>
    <Member MemberName="ValueCount">
      <MemberSignature Language="C#" Value="public int ValueCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ValueCount" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.ValueCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ValueCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueCount : int" Usage="Microsoft.Win32.RegistryKey.ValueCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Werte im Schlüssel ab.</summary>
        <value>Die Anzahl der Name-Wert-Paare im Schlüssel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Registrierungsschlüssel weist einen Standardwert auf, der keinem Namen zugeordnet ist. Dieser unbenannte Wert kann mithilfe der <xref:Microsoft.Win32.RegistryKey.SetValue%2A> -Methode festgelegt werden und entweder `null` oder die leere Zeichenfolge ("" `name`) für angeben. Wenn der Standardwert nie festgelegt wurde, trägt er nicht zur Gesamtanzahl bei, die von der <xref:Microsoft.Win32.RegistryKey.ValueCount%2A> -Eigenschaft zurückgegeben wird. Nachdem er festgelegt wurde, wird er immer gezählt.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:Microsoft.Win32.RegistryKey> -Klasse bereitgestellt wird.  
  
 [!code-cpp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CPP/source.cpp#2)]
 [!code-csharp[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/CS/source.cs#2)]
 [!code-vb[Microsoft.Win32.RegistryKey2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.RegistryKey2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Benutzer besitzt keine Leseberechtigung für den Schlüssel.</exception>
        <exception cref="T:System.ObjectDisposedException">Der zu bearbeitende <see cref="T:Microsoft.Win32.RegistryKey" /> ist geschlossen (auf geschlossene Schlüssel kann nicht zugegriffen werden).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die notwendigen Registrierungsrechte.</exception>
        <exception cref="T:System.IO.IOException">Ein Systemfehler ist aufgetreten, möglicherweise wurde der aktuelle Schlüssel gelöscht.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">, um den angegebenen Registrierungsschlüssel lesen zu können. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="View">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.RegistryView View { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.Win32.RegistryView View" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Win32.RegistryKey.View" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property View As RegistryView" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::RegistryView View { Microsoft::Win32::RegistryView get(); };" />
      <MemberSignature Language="F#" Value="member this.View : Microsoft.Win32.RegistryView" Usage="Microsoft.Win32.RegistryKey.View" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Ansicht ab, mit der der Registrierungsschlüssel erstellt wurde.</summary>
        <value>Die Ansicht, mit der der Registrierungsschlüssel erstellt wurde.  
  
- oder - 
 <see cref="F:Microsoft.Win32.RegistryView.Default" />, wenn keine Ansicht verwendet wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In den 64-Bit-Versionen von Windows werden Teile der Registrierung für 32-Bit-und 64-Bit-Anwendungen separat gespeichert. Es gibt eine 32-Bit-Ansicht für 32-Bit-Anwendungen und eine 64-Bit-Ansicht für 64-Bit-Anwendungen.  
  
 Gehen Sie nicht davon aus, dass die Sicht immer der tatsächlichen Ansicht von <xref:Microsoft.Win32.RegistryKey>entspricht.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>