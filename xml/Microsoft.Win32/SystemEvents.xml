<Type Name="SystemEvents" FullName="Microsoft.Win32.SystemEvents">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cb0e0a30ff4825d98f0e7d5c42f34b95733685f4" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52243120" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SystemEvents" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SystemEvents extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.SystemEvents" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SystemEvents" />
  <TypeSignature Language="C++ CLI" Value="public ref class SystemEvents sealed" />
  <TypeSignature Language="F#" Value="type SystemEvents = class" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Ermöglicht den Zugriff auf Systemereignisbenachrichtigungen. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:Microsoft.Win32.SystemEvents> Klasse bietet die Möglichkeit, die auf bestimmte Typen von Systemereignisse zu reagieren.  
  
 Wenn ein Systemereignis ausgelöst wird, werden allen Delegaten, der dem Ereignis zugeordnet aufgerufen unter Verwendung des Threads, die überwacht Systemereignisse. Aus diesem Grund sollten Sie alle Aufrufe aus Ihrem Event Handler-threadsicher. Wenn Sie möchten eine Systemereignis aufrufen, die nicht als Member dieser Klasse verfügbar gemacht wird, können Sie mithilfe der <xref:Microsoft.Win32.SystemEvents.InvokeOnEventsThread%2A> Methode.  
  
> [!CAUTION]
>  Führen Sie keine zeitaufwändige Verarbeitung für den Thread, der einen System-Ereignishandler auslöst, da es möglicherweise, dass andere Anwendungen funktionieren verhindern.  
  
> [!NOTE]
>  Einige Systemereignisse möglicherweise nicht ausgelöst werden, auf [!INCLUDE[windowsver](~/includes/windowsver-md.md)]. Stellen Sie sicher, dass Ihre Anwendung erwartungsgemäß auf [!INCLUDE[windowsver](~/includes/windowsver-md.md)].  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Beispiele. Das erste Beispiel zeigt, wie Sie die Systemereignisse in eine gewöhnliche Anwendung verwenden, und das zweite Beispiel zeigt, wie Systemereignisse in einem Windows-Dienst verwendet.  
  
 **Beispiel 1**  
  
 Im folgenden Codebeispiel wird registriert Interesse an einige Systemereignisse und wartet dann, bis eines dieser Ereignisse auftreten. Die dargestellte Ausgabe tritt auf, wenn der Benutzer die Bildschirmauflösung ändert.  
  
 [!code-cpp[SystemEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#1)]
 [!code-csharp[SystemEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#1)]
 [!code-vb[SystemEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#1)]  
  
 **Beispiel 2**  
  
 Im folgenden Codebeispiel wird veranschaulicht, einen sehr einfachen Windows-Dienst, der verarbeitet die <xref:Microsoft.Win32.SystemEvents.TimeChanged> und <xref:Microsoft.Win32.SystemEvents.UserPreferenceChanged> Ereignisse. Das Beispiel enthält einen Dienst namens `SimpleService`, ein Formular mit dem Namen `HiddenForm`, und einen Installer. Das Formular stellt die Nachrichtenschleife aus, die Systemereignisse erforderlich ist.  
  
> [!NOTE]
>  Dienste müssen nicht-Nachrichtenschleifen werden, es sei denn, sie mit dem Desktop interagieren dürfen. Wenn die Meldungsschleife nicht von einem ausgeblendeten Feld angegeben wird, wie in diesem Beispiel muss der Dienst unter dem lokalen Systemkonto ausgeführt werden, und manuelles Eingreifen ist erforderlich, um die Interaktion mit dem Desktop zu ermöglichen. Der Administrator muss manuell prüfen der **Datenaustausch zwischen Dienst und Desktop zulassen** auf das Kontrollkästchen der **anmelden** Registerkarte im Dialogfeld Eigenschaften von Service. In diesem Fall wird eine Nachrichtenschleife automatisch bereitgestellt. Diese Option steht nur, wenn der Dienst unter dem lokalen Systemkonto ausgeführt wird. Interaktion mit dem Desktop kann programmgesteuert aktiviert werden.  
  
 Der Dienst in diesem Beispiel startet einen Thread, der eine Instanz des ausgeführt `HiddenForm`. Die Ereignisse werden verknüpft und in das Formular verarbeitet. Die Ereignisse müssen verknüpft werden in der Load-Ereignis des Formulars, um sicherzustellen, dass Sie zuerst das Formular vollständig geladen wurde; Andernfalls werden die Ereignisse nicht ausgelöst werden.  
  
> [!NOTE]
>  Das Beispiel enthält die gesamte erforderlichen Code, einschließlich der Formular-Initialisierungscode in der Regel von Visual Studio-Designer generiert. Wenn Sie Ihren Dienst in Visual Studio entwickeln, können Sie das Auslassen von der zweiten partiellen Klasse und verwendet die **Eigenschaften** die Höhe und Breite von 0 (null), der die Rahmenart, ausgeblendeten Feld festlegen, um <xref:System.Windows.Forms.FormBorderStyle.None?displayProperty=nameWithType>, und den Fensterzustand zu <xref:System.Windows.Forms.FormWindowState.Minimized?displayProperty=nameWithType>.  
  
 Zum Ausführen des Beispiels:  
  
1.  Kompilieren Sie den Code über die Befehlszeile an. Der Name, mit denen Sie für die Quelldatei ist nicht wichtig.  
  
2.  Installieren Sie den Dienst über die Befehlszeile mit der [Installutil.exe (Installationstool)](~/docs/framework/tools/installutil-exe-installer-tool.md) Hilfsprogramm. Z. B. `InstallUtil example.exe` ist der Name der Quelldatei `example.cs` oder `example.vb`. Sie müssen ein Administrator den Dienst zu installieren sein.  
  
3.  Verwenden Sie die Dienstekonsole, zum Starten des Diensts.  
  
4.  Ändern der Systemzeit oder Ändern von benutzereinstellungen, z. B. Mauseigenschaften.  
  
5.  Zeigen Sie die Nachrichten in der **Anwendung** Kategorie der Ereignisanzeige.  
  
6.  Verwenden Sie die Dienstekonsole, zum Beenden des Diensts.  
  
7.  Deinstallieren Sie den Dienst über die Befehlszeile mithilfe der `/u` Option. Beispielsweise `InstallUtil /u example.exe`.  
  
 [!code-csharp[ManagedWindowsService#1](~/samples/snippets/csharp/VS_Snippets_CLR/ManagedWindowsService/cs/source.cs#1)]
 [!code-vb[ManagedWindowsService#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ManagedWindowsService/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.NamedPermissionSet">für vollständigen Zugriff auf Systemressourcen. Erfordern von Werten: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Zugeordnete Zustand:</permission>
    <altmember cref="T:Microsoft.Win32.PowerModeChangedEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionEndedEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionEndingEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionSwitchEventHandler" />
    <altmember cref="T:Microsoft.Win32.TimerElapsedEventHandler" />
    <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventHandler" />
    <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventHandler" />
  </Docs>
  <Members>
    <Member MemberName="CreateTimer">
      <MemberSignature Language="C#" Value="public static IntPtr CreateTimer (int interval);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateTimer(int32 interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.CreateTimer(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateTimer (interval As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CreateTimer(int interval);" />
      <MemberSignature Language="F#" Value="static member CreateTimer : int -&gt; nativeint" Usage="Microsoft.Win32.SystemEvents.CreateTimer interval" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interval" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="interval">Gibt das Intervall zwischen Zeitgeberbenachrichtigungen in Millisekunden an.</param>
        <summary>Erstellt einen neuen Fensterzeitgeber, der dem Systemereignisfenster zugeordnet ist.</summary>
        <returns>Die ID des neuen Zeitgebers.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Das Intervall ist kleiner oder gleich 0 (null).</exception>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster oder den Zeitgeber zu erstellen, ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisplaySettingsChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler DisplaySettingsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DisplaySettingsChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event DisplaySettingsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ DisplaySettingsChanged;" />
      <MemberSignature Language="F#" Value="member this.DisplaySettingsChanged : EventHandler " Usage="member this.DisplaySettingsChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Benutzer die Anzeigeeinstellungen ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Da dies ein statisches Ereignis ist, müssen Sie Ihre Ereignishandler trennen, wenn Ihre Anwendung freigegeben wird oder einen Speicherverlust führt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zur Überwachung der <xref:Microsoft.Win32.SystemEvents.DisplaySettingsChanged> Ereignis. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:Microsoft.Win32.SystemEvents> Klasse.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
        <altmember cref="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanging" />
      </Docs>
    </Member>
    <Member MemberName="DisplaySettingsChanging">
      <MemberSignature Language="C#" Value="public static event EventHandler DisplaySettingsChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DisplaySettingsChanging" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event DisplaySettingsChanging As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ DisplaySettingsChanging;" />
      <MemberSignature Language="F#" Value="member this.DisplaySettingsChanging : EventHandler " Usage="member this.DisplaySettingsChanging : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich die Anzeigeeinstellungen ändern.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Da dies ein statisches Ereignis ist, müssen Sie Ihre Ereignishandler trennen, wenn Ihre Anwendung freigegeben wird oder einen Speicherverlust führt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
        <altmember cref="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanged" />
      </Docs>
    </Member>
    <Member MemberName="EventsThreadShutdown">
      <MemberSignature Language="C#" Value="public static event EventHandler EventsThreadShutdown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EventsThreadShutdown" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.EventsThreadShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EventsThreadShutdown As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EventsThreadShutdown;" />
      <MemberSignature Language="F#" Value="member this.EventsThreadShutdown : EventHandler " Usage="member this.EventsThreadShutdown : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, bevor der auf Systemereignisse lauschende Thread beendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, da der Thread, der auf Systemereignisse lauscht ist zu. System-Ereignisdelegaten werden aufgerufen, mit dem Thread, der auf Systemereignisse lauscht.  
  
> [!CAUTION]
>  Da dies ein statisches Ereignis ist, müssen Sie Ihre Ereignishandler trennen, wenn Ihre Anwendung freigegeben wird oder einen Speicherverlust führt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="InstalledFontsChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler InstalledFontsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler InstalledFontsChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.InstalledFontsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event InstalledFontsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ InstalledFontsChanged;" />
      <MemberSignature Language="F#" Value="member this.InstalledFontsChanged : EventHandler " Usage="member this.InstalledFontsChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Benutzer Schriftarten zum System hinzufügt oder daraus entfernt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Da dies ein statisches Ereignis ist, müssen Sie Ihre Ereignishandler trennen, wenn Ihre Anwendung freigegeben wird oder einen Speicherverlust führt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="InvokeOnEventsThread">
      <MemberSignature Language="C#" Value="public static void InvokeOnEventsThread (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InvokeOnEventsThread(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.InvokeOnEventsThread(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub InvokeOnEventsThread (method As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void InvokeOnEventsThread(Delegate ^ method);" />
      <MemberSignature Language="F#" Value="static member InvokeOnEventsThread : Delegate -&gt; unit" Usage="Microsoft.Win32.SystemEvents.InvokeOnEventsThread method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">Ein Delegat, der mit dem Thread aufgerufen werden soll, der auf Systemereignisse lauscht.</param>
        <summary>Ruft den angegebenen Delegaten mit dem Thread auf, der auf Systemereignisse lauscht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode jedes Mal, die Sie benötigen, um ein Systemereignis zu behandeln, die andernfalls nicht von verfügbar gemacht wird die <xref:Microsoft.Win32.SystemEvents> Klasse.  
  
 Wenn Sie diese Methode aufrufen, wird der angegebene Delegaten vom Thread aufgerufen werden, die Ihrer Anwendung verwendet wird, um Systemereignisse zu verarbeiten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="KillTimer">
      <MemberSignature Language="C#" Value="public static void KillTimer (IntPtr timerId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KillTimer(native int timerId) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.KillTimer(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KillTimer (timerId As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KillTimer(IntPtr timerId);" />
      <MemberSignature Language="F#" Value="static member KillTimer : nativeint -&gt; unit" Usage="Microsoft.Win32.SystemEvents.KillTimer timerId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timerId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="timerId">Die ID des Zeitgebers, der beendet werden soll.</param>
        <summary>Beendet den Zeitgeber mit der angegebenen ID.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen oder den Zeitgeber zu beenden, ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="LowMemory">
      <MemberSignature Language="C#" Value="public static event EventHandler LowMemory;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LowMemory" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.LowMemory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LowMemory As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LowMemory;" />
      <MemberSignature Language="F#" Value="member this.LowMemory : EventHandler " Usage="member this.LowMemory : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2">
          <AttributeName>System.Obsolete("This event has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn im System nicht genügend RAM verfügbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis dient als Wrapper für die WM_COMPACTING-Meldung. Diese Nachricht wird an alle übergeordneten Fenster gesendet, wenn das System erkennt, dass mehr als 12,5 Prozent der Systemzeit über einen Zeitraum von 30 - 60 Sekunden aufgewendet wird Arbeitsspeicher zu komprimieren. Dies bedeutet, dass es sich bei den Systemspeicher gering ist.  
  
> [!NOTE]
>  Dieses Ereignis wird nur ausgelöst, wenn das vom Nachrichtensystem ausgeführt wird. In einem Windows-Dienst wird dieses Ereignis nicht ausgelöst, es sei denn, ein ausgeblendetes Formular verwendet wird, oder das Nachrichtensystem wurde manuell gestartet werden. Ein Codebeispiel, das Systemereignisse zu behandeln, indem Sie einem ausgeblendeten Feld in einem Windows-Dienst veranschaulicht, finden Sie unter den <xref:Microsoft.Win32.SystemEvents> Klasse.  
  
> [!CAUTION]
>  Da dies ein statisches Ereignis ist, müssen Sie Ihre Ereignishandler trennen, wenn Ihre Anwendung freigegeben wird oder einen Speicherverlust führt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
        <block subset="none" type="usage">
          <para>Diese Meldung dient nur für die Kompatibilität mit 16-Bit-Windows-basierten Anwendungen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PaletteChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler PaletteChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaletteChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.PaletteChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event PaletteChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ PaletteChanged;" />
      <MemberSignature Language="F#" Value="member this.PaletteChanged : EventHandler " Usage="member this.PaletteChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Benutzer zu einer Anwendung wechselt, die eine andere Palette verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dieses Ereignis wird nur ausgelöst, wenn das vom Nachrichtensystem ausgeführt wird. In einem Windows-Dienst wird dieses Ereignis nicht ausgelöst, es sei denn, ein ausgeblendetes Formular verwendet wird, oder das Nachrichtensystem wurde manuell gestartet werden. Ein Codebeispiel, das Systemereignisse zu behandeln, indem Sie einem ausgeblendeten Feld in einem Windows-Dienst veranschaulicht, finden Sie unter den <xref:Microsoft.Win32.SystemEvents> Klasse.  
  
> [!CAUTION]
>  Da dies ein statisches Ereignis ist, müssen Sie Ihre Ereignishandler trennen, wenn Ihre Anwendung freigegeben wird oder einen Speicherverlust führt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zur Überwachung der <xref:Microsoft.Win32.SystemEvents.PaletteChanged> Ereignis. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:Microsoft.Win32.SystemEvents> Klasse.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="PowerModeChanged">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.PowerModeChangedEventHandler PowerModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.PowerModeChangedEventHandler PowerModeChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.PowerModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event PowerModeChanged As PowerModeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::PowerModeChangedEventHandler ^ PowerModeChanged;" />
      <MemberSignature Language="F#" Value="member this.PowerModeChanged : Microsoft.Win32.PowerModeChangedEventHandler " Usage="member this.PowerModeChanged : Microsoft.Win32.PowerModeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.PowerModeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Benutzer den Betrieb des Systems unterbricht bzw. fortsetzt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dieses Ereignis wird nur ausgelöst, wenn das vom Nachrichtensystem ausgeführt wird. In einem Windows-Dienst wird dieses Ereignis nicht ausgelöst, es sei denn, ein ausgeblendetes Formular verwendet wird, oder das Nachrichtensystem wurde manuell gestartet werden. Ein Codebeispiel, das Systemereignisse zu behandeln, indem Sie einem ausgeblendeten Feld in einem Windows-Dienst veranschaulicht, finden Sie unter den <xref:Microsoft.Win32.SystemEvents> Klasse.  
  
> [!CAUTION]
>  Da dies ein statisches Ereignis ist, müssen Sie Ihre Ereignishandler trennen, wenn Ihre Anwendung freigegeben wird oder einen Speicherverlust führt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
        <altmember cref="T:Microsoft.Win32.PowerModeChangedEventArgs" />
        <altmember cref="T:Microsoft.Win32.PowerModeChangedEventHandler" />
        <altmember cref="T:Microsoft.Win32.PowerModes" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnded">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionEndedEventHandler SessionEnded;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionEndedEventHandler SessionEnded" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionEnded" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionEnded As SessionEndedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionEndedEventHandler ^ SessionEnded;" />
      <MemberSignature Language="F#" Value="member this.SessionEnded : Microsoft.Win32.SessionEndedEventHandler " Usage="member this.SessionEnded : Microsoft.Win32.SessionEndedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionEndedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Benutzer sich abmeldet oder das System herunterfährt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dieses Ereignis wird nur ausgelöst, wenn das vom Nachrichtensystem ausgeführt wird. In einem Windows-Dienst wird dieses Ereignis nicht ausgelöst, es sei denn, ein ausgeblendetes Formular verwendet wird, oder das Nachrichtensystem wurde manuell gestartet werden. Ein Codebeispiel, das Systemereignisse zu behandeln, indem Sie einem ausgeblendeten Feld in einem Windows-Dienst veranschaulicht, finden Sie unter den <xref:Microsoft.Win32.SystemEvents> Klasse.  
  
> [!CAUTION]
>  Da dies ein statisches Ereignis ist, müssen Sie Ihre Ereignishandler trennen, wenn Ihre Anwendung freigegeben wird oder einen Speicherverlust führt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
        <altmember cref="T:Microsoft.Win32.SessionEndedEventArgs" />
        <altmember cref="T:Microsoft.Win32.SessionEndedEventHandler" />
        <altmember cref="T:Microsoft.Win32.SessionEndReasons" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionEndingEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionEndingEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionEnding As SessionEndingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionEndingEventHandler ^ SessionEnding;" />
      <MemberSignature Language="F#" Value="member this.SessionEnding : Microsoft.Win32.SessionEndingEventHandler " Usage="member this.SessionEnding : Microsoft.Win32.SessionEndingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionEndingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Benutzer versucht, sich abzumelden oder das System herunterzufahren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Abbrechen dieses Ereignisses ist möglich. Festlegen der <xref:Microsoft.Win32.SessionEndingEventArgs.Cancel%2A> Eigenschaft `true` fordert, dass die Sitzung weiterhin ausgeführt. Es bietet keine Garantie dafür, die die Sitzung nicht beendet wird.  
  
 Bei Verwendung von <xref:Microsoft.Win32.SystemEvents.SessionEnding> in einem Windows-Formular, um eine System-Abmeldung oder einen Neustart zu erkennen, es ist keine deterministische entscheiden, ob die <xref:System.Windows.Forms.Form.Closing> Ereignis wird ausgelöst, bevor Sie dieses Ereignis.  
  
 Wenn Sie bestimmte Tasks vor dem ausführen möchten <xref:System.Windows.Forms.Form.Closing> ist ausgelöst wird, müssen Sie sicherstellen, dass <xref:Microsoft.Win32.SystemEvents.SessionEnding> ausgelöst wird, bevor Sie <xref:System.Windows.Forms.Form.Closing>. Zu diesem Zweck müssen Sie zum Abfangen der `WM_QUERYENDSESSION` in der Form durch Überschreiben der `WndProc` Funktion.  Dieses Beispiel zeigt, wie Sie dies tun.  
  
```vb  
Private Shared WM_QUERYENDSESSION As Integer = &H11  
 Private Shared systemShutdown As Boolean = False  
 Protected Overrides Sub WndProc(ByRef m As System.Windows.Forms.Message)  
     If m.Msg = WM_QUERYENDSESSION Then  
         MessageBox.Show("queryendsession: this is a logoff, shutdown, or reboot")  
         systemShutdown = True  
     End If  
     ' If this is WM_QUERYENDSESSION, the closing event should be raised in the base WndProc.  
     MyBase.WndProc(m)  
 End Sub 'WndProc   
 Private Sub Form1_Closing(ByVal sender As System.Object, ByVal e As System.ComponentModel.CancelEventArgs) Handles MyBase.Closing  
     If (systemShutdown) Then  
     ' Reset the variable because the user might cancel the shutdown.  
         systemShutdown = False  
         If (System.Windows.Forms.DialogResult.Yes = _  
                 MessageBox.Show("My application", "Do you want to save your work before logging off?", MessageBoxButtons.YesNo)) Then  
                 e.Cancel = True  
         Else  
                 e.Cancel = False  
         End If  
     End If  
 End Sub  
  
```  
  
```csharp  
private static int WM_QUERYENDSESSION = 0x11;  
private static bool systemShutdown = false;  
protected override void WndProc(ref System.Windows.Forms.Message m)  
{  
    if (m.Msg==WM_QUERYENDSESSION)  
    {  
        MessageBox.Show("queryendsession: this is a logoff, shutdown, or reboot");  
        systemShutdown = true;  
    }  
  
    // If this is WM_QUERYENDSESSION, the closing event should be  
    // raised in the base WndProc.  
    base.WndProc(ref m);  
  
} //WndProc   
  
private void Form1_Closing(  
    System.Object sender,   
    System.ComponentModel.CancelEventArgs e)  
{  
    if (systemShutdown)  
        // Reset the variable because the user might cancel the   
        // shutdown.  
    {  
        systemShutdown = false;  
        if (DialogResult.Yes==MessageBox.Show("My application",   
            "Do you want to save your work before logging off?",   
            MessageBoxButtons.YesNo))  
        {  
            e.Cancel = true;  
        }  
        else  
        {  
            e.Cancel = false;  
        }  
    }  
}  
```  
  
> [!IMPORTANT]
>  Konsolenanwendungen lösen Sie keine der <xref:Microsoft.Win32.SystemEvents.SessionEnding> Ereignis.  
  
> [!NOTE]
>  Dieses Ereignis wird nur ausgelöst, wenn das vom Nachrichtensystem ausgeführt wird. In einem Windows-Dienst wird dieses Ereignis nicht ausgelöst, es sei denn, ein ausgeblendetes Formular verwendet wird, oder das Nachrichtensystem wurde manuell gestartet werden. Ein Codebeispiel, das Systemereignisse zu behandeln, indem Sie einem ausgeblendeten Feld in einem Windows-Dienst veranschaulicht, finden Sie unter den <xref:Microsoft.Win32.SystemEvents> Klasse.  
  
> [!CAUTION]
>  Da dies ein statisches Ereignis ist, müssen Sie Ihre Ereignishandler trennen, wenn Ihre Anwendung freigegeben wird oder einen Speicherverlust führt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
        <altmember cref="T:Microsoft.Win32.SessionEndingEventArgs" />
        <altmember cref="T:Microsoft.Win32.SessionEndingEventHandler" />
        <altmember cref="T:Microsoft.Win32.SessionEndReasons" />
      </Docs>
    </Member>
    <Member MemberName="SessionSwitch">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionSwitchEventHandler SessionSwitch;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionSwitchEventHandler SessionSwitch" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionSwitch" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionSwitch As SessionSwitchEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionSwitchEventHandler ^ SessionSwitch;" />
      <MemberSignature Language="F#" Value="member this.SessionSwitch : Microsoft.Win32.SessionSwitchEventHandler " Usage="member this.SessionSwitch : Microsoft.Win32.SessionSwitchEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionSwitchEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich der derzeit angemeldete Benutzer geändert hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dieses Ereignis wird nur ausgelöst, wenn das vom Nachrichtensystem ausgeführt wird. In einem Windows-Dienst wird dieses Ereignis nicht ausgelöst, es sei denn, ein ausgeblendetes Formular verwendet wird, oder das Nachrichtensystem wurde manuell gestartet werden. Ein Codebeispiel, das Systemereignisse zu behandeln, indem Sie einem ausgeblendeten Feld in einem Windows-Dienst veranschaulicht, finden Sie unter den <xref:Microsoft.Win32.SystemEvents> Klasse.  
  
> [!CAUTION]
>  Da dies ein statisches Ereignis ist, müssen Sie Ihre Ereignishandler trennen, wenn Ihre Anwendung freigegeben wird oder einen Speicherverlust führt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
        <altmember cref="T:Microsoft.Win32.SessionSwitchEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="TimeChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler TimeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TimeChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.TimeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event TimeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ TimeChanged;" />
      <MemberSignature Language="F#" Value="member this.TimeChanged : EventHandler " Usage="member this.TimeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Benutzer die Systemzeit ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dieses Ereignis wird nur ausgelöst, wenn das vom Nachrichtensystem ausgeführt wird. In einem Windows-Dienst wird dieses Ereignis nicht ausgelöst, es sei denn, ein ausgeblendetes Formular verwendet wird, oder das Nachrichtensystem wurde manuell gestartet werden. Ein Codebeispiel, das Systemereignisse zu behandeln, indem Sie einem ausgeblendeten Feld in einem Windows-Dienst veranschaulicht, finden Sie unter den <xref:Microsoft.Win32.SystemEvents> Klasse.  
  
> [!CAUTION]
>  Da dies ein statisches Ereignis ist, müssen Sie Ihre Ereignishandler trennen, wenn Ihre Anwendung freigegeben wird oder einen Speicherverlust führt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
        <altmember cref="P:System.DateTime.Now" />
      </Docs>
    </Member>
    <Member MemberName="TimerElapsed">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.TimerElapsedEventHandler TimerElapsed;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.TimerElapsedEventHandler TimerElapsed" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.TimerElapsed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event TimerElapsed As TimerElapsedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::TimerElapsedEventHandler ^ TimerElapsed;" />
      <MemberSignature Language="F#" Value="member this.TimerElapsed : Microsoft.Win32.TimerElapsedEventHandler " Usage="member this.TimerElapsed : Microsoft.Win32.TimerElapsedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.TimerElapsedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Intervall eines Fensterzeitgebers abgelaufen ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dieses Ereignis wird nur ausgelöst, wenn das vom Nachrichtensystem ausgeführt wird. In einem Windows-Dienst wird dieses Ereignis nicht ausgelöst, es sei denn, ein ausgeblendetes Formular verwendet wird, oder das Nachrichtensystem wurde manuell gestartet werden. Ein Codebeispiel, das Systemereignisse zu behandeln, indem Sie einem ausgeblendeten Feld in einem Windows-Dienst veranschaulicht, finden Sie unter den <xref:Microsoft.Win32.SystemEvents> Klasse.  
  
> [!CAUTION]
>  Da dies ein statisches Ereignis ist, müssen Sie Ihre Ereignishandler trennen, wenn Ihre Anwendung freigegeben wird oder einen Speicherverlust führt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
        <altmember cref="T:Microsoft.Win32.TimerElapsedEventArgs" />
        <altmember cref="T:Microsoft.Win32.TimerElapsedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="UserPreferenceChanged">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.UserPreferenceChangedEventHandler UserPreferenceChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.UserPreferenceChangedEventHandler UserPreferenceChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.UserPreferenceChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UserPreferenceChanged As UserPreferenceChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::UserPreferenceChangedEventHandler ^ UserPreferenceChanged;" />
      <MemberSignature Language="F#" Value="member this.UserPreferenceChanged : Microsoft.Win32.UserPreferenceChangedEventHandler " Usage="member this.UserPreferenceChanged : Microsoft.Win32.UserPreferenceChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.UserPreferenceChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn eine Benutzereinstellung geändert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dieses Ereignis wird nur ausgelöst, wenn das vom Nachrichtensystem ausgeführt wird. In einem Windows-Dienst wird dieses Ereignis nicht ausgelöst, es sei denn, ein ausgeblendetes Formular verwendet wird, oder das Nachrichtensystem wurde manuell gestartet werden. Ein Codebeispiel, das Systemereignisse zu behandeln, indem Sie einem ausgeblendeten Feld in einem Windows-Dienst veranschaulicht, finden Sie unter den <xref:Microsoft.Win32.SystemEvents> Klasse.  
  
> [!CAUTION]
>  Da dies ein statisches Ereignis ist, müssen Sie Ihre Ereignishandler trennen, wenn Ihre Anwendung freigegeben wird oder einen Speicherverlust führt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventArgs" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventHandler" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceCategory" />
      </Docs>
    </Member>
    <Member MemberName="UserPreferenceChanging">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.UserPreferenceChangingEventHandler UserPreferenceChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.UserPreferenceChangingEventHandler UserPreferenceChanging" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.UserPreferenceChanging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UserPreferenceChanging As UserPreferenceChangingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::UserPreferenceChangingEventHandler ^ UserPreferenceChanging;" />
      <MemberSignature Language="F#" Value="member this.UserPreferenceChanging : Microsoft.Win32.UserPreferenceChangingEventHandler " Usage="member this.UserPreferenceChanging : Microsoft.Win32.UserPreferenceChangingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.UserPreferenceChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich eine Benutzereinstellung ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dieses Ereignis wird nur ausgelöst, wenn das vom Nachrichtensystem ausgeführt wird. In einem Windows-Dienst wird dieses Ereignis nicht ausgelöst, es sei denn, ein ausgeblendetes Formular verwendet wird, oder das Nachrichtensystem wurde manuell gestartet werden. Ein Codebeispiel, das Systemereignisse zu behandeln, indem Sie einem ausgeblendeten Feld in einem Windows-Dienst veranschaulicht, finden Sie unter den <xref:Microsoft.Win32.SystemEvents> Klasse.  
  
> [!CAUTION]
>  Da dies ein statisches Ereignis ist, müssen Sie Ihre Ereignishandler trennen, wenn Ihre Anwendung freigegeben wird oder einen Speicherverlust führt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zur Überwachung der <xref:Microsoft.Win32.SystemEvents.UserPreferenceChanging> Ereignis. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:Microsoft.Win32.SystemEvents> Klasse.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventArgs" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventHandler" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceCategory" />
      </Docs>
    </Member>
  </Members>
</Type>