<Type Name="SystemEvents" FullName="Microsoft.Win32.SystemEvents">
  <Metadata><Meta Name="ms.openlocfilehash" Value="45a3fec5fd67121e0de07cb4ad5d59859d387b65" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73376684" /></Metadata><TypeSignature Language="C#" Value="public sealed class SystemEvents" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SystemEvents extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.SystemEvents" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SystemEvents" />
  <TypeSignature Language="C++ CLI" Value="public ref class SystemEvents sealed" />
  <TypeSignature Language="F#" Value="type SystemEvents = class" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Ermöglicht den Zugriff auf Systemereignisbenachrichtigungen. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:Microsoft.Win32.SystemEvents>-Klasse bietet die Möglichkeit, auf bestimmte Typen von System Ereignissen zu reagieren.  
  
 Wenn ein System Ereignis ausgelöst wird, werden alle an das Ereignis angefügten Delegaten mit dem Thread aufgerufen, der auf Systemereignisse überwacht. Daher sollten Sie alle Aufrufe von ihren Ereignis Handlern Thread sicher durchführen. Wenn Sie ein System Ereignis abrufen müssen, das nicht als Member dieser Klasse verfügbar gemacht wird, können Sie die <xref:Microsoft.Win32.SystemEvents.InvokeOnEventsThread%2A>-Methode verwenden.  
  
> [!CAUTION]
>  Führen Sie keine zeitaufwändige Verarbeitung auf dem Thread aus, der einen System Ereignishandler auslöst, da dadurch möglicherweise andere Anwendungen nicht funktionieren.  
  
> [!NOTE]
>  Einige Systemereignisse können nicht auf [!INCLUDE[windowsver](~/includes/windowsver-md.md)]ausgelöst werden. Stellen Sie sicher, dass Ihre Anwendung auf [!INCLUDE[windowsver](~/includes/windowsver-md.md)]erwartungsgemäß funktioniert.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Beispiele. Im ersten Beispiel wird gezeigt, wie Systemereignisse in einer normalen Anwendung verwendet werden, und das zweite Beispiel zeigt, wie Systemereignisse in einem Windows-Dienst verwendet werden.  
  
 **Beispiel 1**  
  
 Im folgenden Codebeispiel wird das Interesse an einigen System Ereignissen registriert und dann darauf gewartet, dass alle Ereignisse eintreten. Die angezeigte Ausgabe tritt auf, wenn der Benutzer die Bildschirmauflösung ändert.  
  
 [!code-cpp[SystemEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#1)]
 [!code-csharp[SystemEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#1)]
 [!code-vb[SystemEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#1)]  
  
 **Beispiel 2**  
  
 Im folgenden Codebeispiel wird ein sehr einfacher Windows-Dienst veranschaulicht, der die Ereignisse <xref:Microsoft.Win32.SystemEvents.TimeChanged> und <xref:Microsoft.Win32.SystemEvents.UserPreferenceChanged> behandelt. Das Beispiel enthält einen Dienst mit dem Namen `SimpleService`, ein Formular mit dem Namen `HiddenForm`und ein Installationsprogramm. Das Formular stellt die Nachrichten Schleife bereit, die von System Ereignissen benötigt wird.  
  
> [!NOTE]
>  Dienste verfügen über keine Nachrichten Schleifen, es sei denn, Sie dürfen mit dem Desktop interagieren. Wenn die Nachrichten Schleife nicht in einem verborgenen Formular, wie in diesem Beispiel, bereitgestellt wird, muss der Dienst unter dem lokalen Systemkonto ausgeführt werden, und es ist ein manueller Eingriff erforderlich, um die Interaktion mit dem Desktop zu ermöglichen. Das heißt, dass der Administrator das Kontrollkästchen **Dienst für die Interaktion mit dem Desktop zulassen** auf der Registerkarte **Anmelden** im Dialogfeld Dienst Eigenschaften manuell aktivieren muss. In diesem Fall wird automatisch eine Nachrichten Schleife bereitgestellt. Diese Option ist nur verfügbar, wenn der Dienst unter dem lokalen Systemkonto ausgeführt wird. Die Interaktion mit dem Desktop kann nicht Programm gesteuert aktiviert werden.  
  
 Der Dienst in diesem Beispiel startet einen Thread, der eine Instanz von `HiddenForm`ausführt. Die Ereignisse werden im Formular eingebunden und behandelt. Die Ereignisse müssen im Lade Ereignis des Formulars verknüpft werden, um sicherzustellen, dass das Formular zuerst vollständig geladen wird. Andernfalls werden die Ereignisse nicht ausgelöst.  
  
> [!NOTE]
>  Im Beispiel wird der gesamte erforderliche Code bereitstellt, einschließlich des von Visual Studio-Designern generierten Formular Initialisierungs Codes. Wenn Sie den Dienst in Visual Studio entwickeln, können Sie die zweite partielle Klasse weglassen und das **Eigenschaften** Fenster verwenden, um die Höhe und Breite des verborgenen Formulars auf NULL festzulegen, die Rahmenart auf <xref:System.Windows.Forms.FormBorderStyle.None?displayProperty=nameWithType>und den Fenster Zustand <xref:System.Windows.Forms.FormWindowState.Minimized?displayProperty=nameWithType>.  
  
 So führen Sie das Beispiel aus:  
  
1.  Kompilieren Sie den Code über die Befehlszeile. Der Name, den Sie für die Quelldatei verwenden, ist nicht wichtig.  
  
2.  Installieren Sie den Dienst über die Befehlszeile mit dem Hilfsprogramm [installutil. exe (Installationstool)](~/docs/framework/tools/installutil-exe-installer-tool.md) . Beispielsweise `InstallUtil example.exe`, wenn der Name der Quelldatei `example.cs` oder `example.vb`ist. Sie müssen ein Administrator sein, um den Dienst installieren zu können.  
  
3.  Verwenden Sie die Konsole Dienste, um den Dienst zu starten.  
  
4.  Ändern Sie die Systemzeit, oder ändern Sie die Benutzereinstellungen, wie z. b. die Maus Eigenschaften.  
  
5.  Zeigen Sie die Nachrichten in der **Anwendungs** Kategorie Ereignisanzeige an.  
  
6.  Verwenden Sie die Konsole Dienste, um den Dienst zu unterbinden.  
  
7.  Deinstallieren Sie den Dienst über die Befehlszeile mithilfe der Option `/u`. Beispielsweise `InstallUtil /u example.exe`.  
  
 [!code-csharp[ManagedWindowsService#1](~/samples/snippets/csharp/VS_Snippets_CLR/ManagedWindowsService/cs/source.cs#1)]
 [!code-vb[ManagedWindowsService#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ManagedWindowsService/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.NamedPermissionSet">für vollständigen Zugriff auf Systemressourcen. Anforderungs Werte: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Zugeordneter Status:</permission>
    <altmember cref="T:Microsoft.Win32.PowerModeChangedEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionEndedEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionEndingEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionSwitchEventHandler" />
    <altmember cref="T:Microsoft.Win32.TimerElapsedEventHandler" />
    <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventHandler" />
    <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventHandler" />
  </Docs>
  <Members>
    <Member MemberName="CreateTimer">
      <MemberSignature Language="C#" Value="public static IntPtr CreateTimer (int interval);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateTimer(int32 interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.CreateTimer(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateTimer (interval As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CreateTimer(int interval);" />
      <MemberSignature Language="F#" Value="static member CreateTimer : int -&gt; nativeint" Usage="Microsoft.Win32.SystemEvents.CreateTimer interval" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interval" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="interval">Gibt das Intervall zwischen Zeitgeberbenachrichtigungen in Millisekunden an.</param>
        <summary>Erstellt einen neuen Fensterzeitgeber, der dem Systemereignisfenster zugeordnet ist.</summary>
        <returns>Die ID des neuen Zeitgebers.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Das Intervall ist kleiner oder gleich 0 (null).</exception>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster oder den Zeitgeber zu erstellen, ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisplaySettingsChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler DisplaySettingsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DisplaySettingsChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event DisplaySettingsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ DisplaySettingsChanged;" />
      <MemberSignature Language="F#" Value="member this.DisplaySettingsChanged : EventHandler " Usage="member this.DisplaySettingsChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Benutzer die Anzeigeeinstellungen ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Da es sich hierbei um ein statisches Ereignis handelt, müssen Sie die Ereignishandler trennen, wenn die Anwendung verworfen wird, oder die Arbeitsspeicher Verluste entstehen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Überwachen des <xref:Microsoft.Win32.SystemEvents.DisplaySettingsChanged> Ereignisses veranschaulicht. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:Microsoft.Win32.SystemEvents>-Klasse bereitgestellt wird.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
        <altmember cref="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanging" />
      </Docs>
    </Member>
    <Member MemberName="DisplaySettingsChanging">
      <MemberSignature Language="C#" Value="public static event EventHandler DisplaySettingsChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DisplaySettingsChanging" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event DisplaySettingsChanging As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ DisplaySettingsChanging;" />
      <MemberSignature Language="F#" Value="member this.DisplaySettingsChanging : EventHandler " Usage="member this.DisplaySettingsChanging : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich die Anzeigeeinstellungen ändern.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Da es sich hierbei um ein statisches Ereignis handelt, müssen Sie die Ereignishandler trennen, wenn die Anwendung verworfen wird, oder die Arbeitsspeicher Verluste entstehen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
        <altmember cref="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanged" />
      </Docs>
    </Member>
    <Member MemberName="EventsThreadShutdown">
      <MemberSignature Language="C#" Value="public static event EventHandler EventsThreadShutdown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EventsThreadShutdown" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.EventsThreadShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EventsThreadShutdown As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EventsThreadShutdown;" />
      <MemberSignature Language="F#" Value="member this.EventsThreadShutdown : EventHandler " Usage="member this.EventsThreadShutdown : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, bevor der auf Systemereignisse lauschende Thread beendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn der Thread, der auf Systemereignisse lauscht, im Begriff ist, beendet zu werden. System Ereignis Delegaten werden mithilfe des Threads aufgerufen, der auf Systemereignisse lauscht.  
  
> [!CAUTION]
>  Da es sich hierbei um ein statisches Ereignis handelt, müssen Sie die Ereignishandler trennen, wenn die Anwendung verworfen wird, oder die Arbeitsspeicher Verluste entstehen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="InstalledFontsChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler InstalledFontsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler InstalledFontsChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.InstalledFontsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event InstalledFontsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ InstalledFontsChanged;" />
      <MemberSignature Language="F#" Value="member this.InstalledFontsChanged : EventHandler " Usage="member this.InstalledFontsChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Benutzer Schriftarten zum System hinzufügt oder daraus entfernt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Da es sich hierbei um ein statisches Ereignis handelt, müssen Sie die Ereignishandler trennen, wenn die Anwendung verworfen wird, oder die Arbeitsspeicher Verluste entstehen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="InvokeOnEventsThread">
      <MemberSignature Language="C#" Value="public static void InvokeOnEventsThread (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InvokeOnEventsThread(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.InvokeOnEventsThread(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub InvokeOnEventsThread (method As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void InvokeOnEventsThread(Delegate ^ method);" />
      <MemberSignature Language="F#" Value="static member InvokeOnEventsThread : Delegate -&gt; unit" Usage="Microsoft.Win32.SystemEvents.InvokeOnEventsThread method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">Ein Delegat, der mit dem Thread aufgerufen werden soll, der auf Systemereignisse lauscht.</param>
        <summary>Ruft den angegebenen Delegaten mit dem Thread auf, der auf Systemereignisse lauscht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Methode jederzeit verwenden, wenn Sie ein System Ereignis behandeln müssen, das nicht anderweitig von der <xref:Microsoft.Win32.SystemEvents>-Klasse verfügbar gemacht wird.  
  
 Wenn Sie diese Methode aufrufen, wird der angegebene Delegat von dem Thread aufgerufen, der von der Anwendung zum Verarbeiten von System Ereignissen verwendet wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="KillTimer">
      <MemberSignature Language="C#" Value="public static void KillTimer (IntPtr timerId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KillTimer(native int timerId) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.KillTimer(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KillTimer (timerId As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KillTimer(IntPtr timerId);" />
      <MemberSignature Language="F#" Value="static member KillTimer : nativeint -&gt; unit" Usage="Microsoft.Win32.SystemEvents.KillTimer timerId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timerId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="timerId">Die ID des Zeitgebers, der beendet werden soll.</param>
        <summary>Beendet den Zeitgeber mit der angegebenen ID.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen oder den Zeitgeber zu beenden, ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="LowMemory">
      <MemberSignature Language="C#" Value="public static event EventHandler LowMemory;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LowMemory" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.LowMemory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LowMemory As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LowMemory;" />
      <MemberSignature Language="F#" Value="member this.LowMemory : EventHandler " Usage="member this.LowMemory : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.Obsolete("This event has been deprecated. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-plat-ext-3.0;netcore-3.0">
          <AttributeName>System.Obsolete("This event has been deprecated. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn im System nicht genügend RAM verfügbar ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis umschließt die WM_COMPACTING-Nachricht. Diese Nachricht wird an alle Fenster der obersten Ebene gesendet, wenn das System mehr als 12,5 Prozent der Systemzeit über ein Intervall von 30 bis 60 Sekunden erkennt, das für den Komprimierungs Speicher aufgewendet wird. Dies weist darauf hin, dass der Systemspeicher gering ist.  
  
> [!NOTE]
>  Dieses Ereignis wird nur ausgelöst, wenn das nachrichtenpump ausgeführt wird. In einem Windows-Dienst wird dieses Ereignis nicht ausgelöst, es sei denn, es wird ein ausgeblendetes Formular verwendet, oder das nachrichtenpump wurde manuell gestartet. Ein Codebeispiel, das zeigt, wie Systemereignisse mithilfe eines verborgenen Formulars in einem Windows-Dienst behandelt werden, finden Sie in der <xref:Microsoft.Win32.SystemEvents>-Klasse.  
  
> [!CAUTION]
>  Da es sich hierbei um ein statisches Ereignis handelt, müssen Sie die Ereignishandler trennen, wenn die Anwendung verworfen wird, oder die Arbeitsspeicher Verluste entstehen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
        <block subset="none" type="usage"><para>Diese Meldung wird nur für die Kompatibilität mit 16-Bit-Windows-basierten Anwendungen bereitgestellt.</para></block>
      </Docs>
    </Member>
    <Member MemberName="PaletteChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler PaletteChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaletteChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.PaletteChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event PaletteChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ PaletteChanged;" />
      <MemberSignature Language="F#" Value="member this.PaletteChanged : EventHandler " Usage="member this.PaletteChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Benutzer zu einer Anwendung wechselt, die eine andere Palette verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dieses Ereignis wird nur ausgelöst, wenn das nachrichtenpump ausgeführt wird. In einem Windows-Dienst wird dieses Ereignis nicht ausgelöst, es sei denn, es wird ein ausgeblendetes Formular verwendet, oder das nachrichtenpump wurde manuell gestartet. Ein Codebeispiel, das zeigt, wie Systemereignisse mithilfe eines verborgenen Formulars in einem Windows-Dienst behandelt werden, finden Sie in der <xref:Microsoft.Win32.SystemEvents>-Klasse.  
  
> [!CAUTION]
>  Da es sich hierbei um ein statisches Ereignis handelt, müssen Sie die Ereignishandler trennen, wenn die Anwendung verworfen wird, oder die Arbeitsspeicher Verluste entstehen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Überwachen des <xref:Microsoft.Win32.SystemEvents.PaletteChanged> Ereignisses veranschaulicht. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:Microsoft.Win32.SystemEvents>-Klasse bereitgestellt wird.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="PowerModeChanged">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.PowerModeChangedEventHandler PowerModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.PowerModeChangedEventHandler PowerModeChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.PowerModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event PowerModeChanged As PowerModeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::PowerModeChangedEventHandler ^ PowerModeChanged;" />
      <MemberSignature Language="F#" Value="member this.PowerModeChanged : Microsoft.Win32.PowerModeChangedEventHandler " Usage="member this.PowerModeChanged : Microsoft.Win32.PowerModeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.PowerModeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Benutzer den Betrieb des Systems unterbricht bzw. fortsetzt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dieses Ereignis wird nur ausgelöst, wenn das nachrichtenpump ausgeführt wird. In einem Windows-Dienst wird dieses Ereignis nicht ausgelöst, es sei denn, es wird ein ausgeblendetes Formular verwendet, oder das nachrichtenpump wurde manuell gestartet. Ein Codebeispiel, das zeigt, wie Systemereignisse mithilfe eines verborgenen Formulars in einem Windows-Dienst behandelt werden, finden Sie in der <xref:Microsoft.Win32.SystemEvents>-Klasse.  
  
> [!CAUTION]
>  Da es sich hierbei um ein statisches Ereignis handelt, müssen Sie die Ereignishandler trennen, wenn die Anwendung verworfen wird, oder die Arbeitsspeicher Verluste entstehen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
        <altmember cref="T:Microsoft.Win32.PowerModeChangedEventArgs" />
        <altmember cref="T:Microsoft.Win32.PowerModeChangedEventHandler" />
        <altmember cref="T:Microsoft.Win32.PowerModes" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnded">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionEndedEventHandler SessionEnded;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionEndedEventHandler SessionEnded" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionEnded" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionEnded As SessionEndedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionEndedEventHandler ^ SessionEnded;" />
      <MemberSignature Language="F#" Value="member this.SessionEnded : Microsoft.Win32.SessionEndedEventHandler " Usage="member this.SessionEnded : Microsoft.Win32.SessionEndedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionEndedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Benutzer sich abmeldet oder das System herunterfährt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dieses Ereignis wird nur ausgelöst, wenn das nachrichtenpump ausgeführt wird. In einem Windows-Dienst wird dieses Ereignis nicht ausgelöst, es sei denn, es wird ein ausgeblendetes Formular verwendet, oder das nachrichtenpump wurde manuell gestartet. Ein Codebeispiel, das zeigt, wie Systemereignisse mithilfe eines verborgenen Formulars in einem Windows-Dienst behandelt werden, finden Sie in der <xref:Microsoft.Win32.SystemEvents>-Klasse.  
  
> [!CAUTION]
>  Da es sich hierbei um ein statisches Ereignis handelt, müssen Sie die Ereignishandler trennen, wenn die Anwendung verworfen wird, oder die Arbeitsspeicher Verluste entstehen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
        <altmember cref="T:Microsoft.Win32.SessionEndedEventArgs" />
        <altmember cref="T:Microsoft.Win32.SessionEndedEventHandler" />
        <altmember cref="T:Microsoft.Win32.SessionEndReasons" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionEndingEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionEndingEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionEnding As SessionEndingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionEndingEventHandler ^ SessionEnding;" />
      <MemberSignature Language="F#" Value="member this.SessionEnding : Microsoft.Win32.SessionEndingEventHandler " Usage="member this.SessionEnding : Microsoft.Win32.SessionEndingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionEndingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Benutzer versucht, sich abzumelden oder das System herunterzufahren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Abbrechen dieses Ereignisses ist möglich. Wenn Sie die <xref:Microsoft.Win32.SessionEndingEventArgs.Cancel%2A>-Eigenschaft auf `true` festlegen, wird die Fortführung der Sitzung angefordert. Es bietet keine Garantie dafür, dass die Sitzung nicht beendet wird.  
  
 Wenn Sie <xref:Microsoft.Win32.SystemEvents.SessionEnding> in einem Windows Form verwenden, um eine System Abmeldung oder einen Neustart zu erkennen, gibt es keine deterministische Möglichkeit zu entscheiden, ob das <xref:System.Windows.Forms.Form.Closing> Ereignis vor diesem Ereignis ausgelöst wird.  
  
 Wenn Sie vor dem Auslösen <xref:System.Windows.Forms.Form.Closing> einige besondere Aufgaben ausführen möchten, müssen Sie sicherstellen, dass <xref:Microsoft.Win32.SystemEvents.SessionEnding> vor <xref:System.Windows.Forms.Form.Closing>ausgelöst wird. Zu diesem Zweck müssen Sie die `WM_QUERYENDSESSION` im Formular durch Überschreiben der `WndProc`-Funktion abfangen.  Diese Vorgehensweise wird in diesem Beispiel veranschaulicht.  
  
```vb  
Private Shared WM_QUERYENDSESSION As Integer = &H11  
 Private Shared systemShutdown As Boolean = False  
 Protected Overrides Sub WndProc(ByRef m As System.Windows.Forms.Message)  
     If m.Msg = WM_QUERYENDSESSION Then  
         MessageBox.Show("queryendsession: this is a logoff, shutdown, or reboot")  
         systemShutdown = True  
     End If  
     ' If this is WM_QUERYENDSESSION, the closing event should be raised in the base WndProc.  
     MyBase.WndProc(m)  
 End Sub 'WndProc   
 Private Sub Form1_Closing(ByVal sender As System.Object, ByVal e As System.ComponentModel.CancelEventArgs) Handles MyBase.Closing  
     If (systemShutdown) Then  
     ' Reset the variable because the user might cancel the shutdown.  
         systemShutdown = False  
         If (System.Windows.Forms.DialogResult.Yes = _  
                 MessageBox.Show("My application", "Do you want to save your work before logging off?", MessageBoxButtons.YesNo)) Then  
                 e.Cancel = True  
         Else  
                 e.Cancel = False  
         End If  
     End If  
 End Sub  
  
```  
  
```csharp  
private static int WM_QUERYENDSESSION = 0x11;  
private static bool systemShutdown = false;  
protected override void WndProc(ref System.Windows.Forms.Message m)  
{  
    if (m.Msg==WM_QUERYENDSESSION)  
    {  
        MessageBox.Show("queryendsession: this is a logoff, shutdown, or reboot");  
        systemShutdown = true;  
    }  
  
    // If this is WM_QUERYENDSESSION, the closing event should be  
    // raised in the base WndProc.  
    base.WndProc(ref m);  
  
} //WndProc   
  
private void Form1_Closing(  
    System.Object sender,   
    System.ComponentModel.CancelEventArgs e)  
{  
    if (systemShutdown)  
        // Reset the variable because the user might cancel the   
        // shutdown.  
    {  
        systemShutdown = false;  
        if (DialogResult.Yes==MessageBox.Show("My application",   
            "Do you want to save your work before logging off?",   
            MessageBoxButtons.YesNo))  
        {  
            e.Cancel = true;  
        }  
        else  
        {  
            e.Cancel = false;  
        }  
    }  
}  
```  
  
> [!IMPORTANT]
>  Konsolen Anwendungen erhöhen das <xref:Microsoft.Win32.SystemEvents.SessionEnding>-Ereignis nicht.  
  
> [!NOTE]
>  Dieses Ereignis wird nur ausgelöst, wenn das nachrichtenpump ausgeführt wird. In einem Windows-Dienst wird dieses Ereignis nicht ausgelöst, es sei denn, es wird ein ausgeblendetes Formular verwendet, oder das nachrichtenpump wurde manuell gestartet. Ein Codebeispiel, das zeigt, wie Systemereignisse mithilfe eines verborgenen Formulars in einem Windows-Dienst behandelt werden, finden Sie in der <xref:Microsoft.Win32.SystemEvents>-Klasse.  
  
> [!CAUTION]
>  Da es sich hierbei um ein statisches Ereignis handelt, müssen Sie die Ereignishandler trennen, wenn die Anwendung verworfen wird, oder die Arbeitsspeicher Verluste entstehen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
        <altmember cref="T:Microsoft.Win32.SessionEndingEventArgs" />
        <altmember cref="T:Microsoft.Win32.SessionEndingEventHandler" />
        <altmember cref="T:Microsoft.Win32.SessionEndReasons" />
      </Docs>
    </Member>
    <Member MemberName="SessionSwitch">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionSwitchEventHandler SessionSwitch;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionSwitchEventHandler SessionSwitch" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionSwitch" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionSwitch As SessionSwitchEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionSwitchEventHandler ^ SessionSwitch;" />
      <MemberSignature Language="F#" Value="member this.SessionSwitch : Microsoft.Win32.SessionSwitchEventHandler " Usage="member this.SessionSwitch : Microsoft.Win32.SessionSwitchEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionSwitchEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich der derzeit angemeldete Benutzer geändert hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dieses Ereignis wird nur ausgelöst, wenn das nachrichtenpump ausgeführt wird. In einem Windows-Dienst wird dieses Ereignis nicht ausgelöst, es sei denn, es wird ein ausgeblendetes Formular verwendet, oder das nachrichtenpump wurde manuell gestartet. Ein Codebeispiel, das zeigt, wie Systemereignisse mithilfe eines verborgenen Formulars in einem Windows-Dienst behandelt werden, finden Sie in der <xref:Microsoft.Win32.SystemEvents>-Klasse.  
  
> [!CAUTION]
>  Da es sich hierbei um ein statisches Ereignis handelt, müssen Sie die Ereignishandler trennen, wenn die Anwendung verworfen wird, oder die Arbeitsspeicher Verluste entstehen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
        <altmember cref="T:Microsoft.Win32.SessionSwitchEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="TimeChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler TimeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TimeChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.TimeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event TimeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ TimeChanged;" />
      <MemberSignature Language="F#" Value="member this.TimeChanged : EventHandler " Usage="member this.TimeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Benutzer die Systemzeit ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dieses Ereignis wird nur ausgelöst, wenn das nachrichtenpump ausgeführt wird. In einem Windows-Dienst wird dieses Ereignis nicht ausgelöst, es sei denn, es wird ein ausgeblendetes Formular verwendet, oder das nachrichtenpump wurde manuell gestartet. Ein Codebeispiel, das zeigt, wie Systemereignisse mithilfe eines verborgenen Formulars in einem Windows-Dienst behandelt werden, finden Sie in der <xref:Microsoft.Win32.SystemEvents>-Klasse.  
  
> [!CAUTION]
>  Da es sich hierbei um ein statisches Ereignis handelt, müssen Sie die Ereignishandler trennen, wenn die Anwendung verworfen wird, oder die Arbeitsspeicher Verluste entstehen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
        <altmember cref="P:System.DateTime.Now" />
      </Docs>
    </Member>
    <Member MemberName="TimerElapsed">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.TimerElapsedEventHandler TimerElapsed;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.TimerElapsedEventHandler TimerElapsed" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.TimerElapsed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event TimerElapsed As TimerElapsedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::TimerElapsedEventHandler ^ TimerElapsed;" />
      <MemberSignature Language="F#" Value="member this.TimerElapsed : Microsoft.Win32.TimerElapsedEventHandler " Usage="member this.TimerElapsed : Microsoft.Win32.TimerElapsedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.TimerElapsedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Intervall eines Fensterzeitgebers abgelaufen ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dieses Ereignis wird nur ausgelöst, wenn das nachrichtenpump ausgeführt wird. In einem Windows-Dienst wird dieses Ereignis nicht ausgelöst, es sei denn, es wird ein ausgeblendetes Formular verwendet, oder das nachrichtenpump wurde manuell gestartet. Ein Codebeispiel, das zeigt, wie Systemereignisse mithilfe eines verborgenen Formulars in einem Windows-Dienst behandelt werden, finden Sie in der <xref:Microsoft.Win32.SystemEvents>-Klasse.  
  
> [!CAUTION]
>  Da es sich hierbei um ein statisches Ereignis handelt, müssen Sie die Ereignishandler trennen, wenn die Anwendung verworfen wird, oder die Arbeitsspeicher Verluste entstehen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
        <altmember cref="T:Microsoft.Win32.TimerElapsedEventArgs" />
        <altmember cref="T:Microsoft.Win32.TimerElapsedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="UserPreferenceChanged">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.UserPreferenceChangedEventHandler UserPreferenceChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.UserPreferenceChangedEventHandler UserPreferenceChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.UserPreferenceChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UserPreferenceChanged As UserPreferenceChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::UserPreferenceChangedEventHandler ^ UserPreferenceChanged;" />
      <MemberSignature Language="F#" Value="member this.UserPreferenceChanged : Microsoft.Win32.UserPreferenceChangedEventHandler " Usage="member this.UserPreferenceChanged : Microsoft.Win32.UserPreferenceChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.UserPreferenceChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn eine Benutzereinstellung geändert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dieses Ereignis wird nur ausgelöst, wenn das nachrichtenpump ausgeführt wird. In einem Windows-Dienst wird dieses Ereignis nicht ausgelöst, es sei denn, es wird ein ausgeblendetes Formular verwendet, oder das nachrichtenpump wurde manuell gestartet. Ein Codebeispiel, das zeigt, wie Systemereignisse mithilfe eines verborgenen Formulars in einem Windows-Dienst behandelt werden, finden Sie in der <xref:Microsoft.Win32.SystemEvents>-Klasse.  
  
> [!CAUTION]
>  Da es sich hierbei um ein statisches Ereignis handelt, müssen Sie die Ereignishandler trennen, wenn die Anwendung verworfen wird, oder die Arbeitsspeicher Verluste entstehen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventArgs" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventHandler" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceCategory" />
      </Docs>
    </Member>
    <Member MemberName="UserPreferenceChanging">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.UserPreferenceChangingEventHandler UserPreferenceChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.UserPreferenceChangingEventHandler UserPreferenceChanging" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.UserPreferenceChanging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UserPreferenceChanging As UserPreferenceChangingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::UserPreferenceChangingEventHandler ^ UserPreferenceChanging;" />
      <MemberSignature Language="F#" Value="member this.UserPreferenceChanging : Microsoft.Win32.UserPreferenceChangingEventHandler " Usage="member this.UserPreferenceChanging : Microsoft.Win32.UserPreferenceChangingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.UserPreferenceChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich eine Benutzereinstellung ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Dieses Ereignis wird nur ausgelöst, wenn das nachrichtenpump ausgeführt wird. In einem Windows-Dienst wird dieses Ereignis nicht ausgelöst, es sei denn, es wird ein ausgeblendetes Formular verwendet, oder das nachrichtenpump wurde manuell gestartet. Ein Codebeispiel, das zeigt, wie Systemereignisse mithilfe eines verborgenen Formulars in einem Windows-Dienst behandelt werden, finden Sie in der <xref:Microsoft.Win32.SystemEvents>-Klasse.  
  
> [!CAUTION]
>  Da es sich hierbei um ein statisches Ereignis handelt, müssen Sie die Ereignishandler trennen, wenn die Anwendung verworfen wird, oder die Arbeitsspeicher Verluste entstehen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Überwachen des <xref:Microsoft.Win32.SystemEvents.UserPreferenceChanging> Ereignisses veranschaulicht. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:Microsoft.Win32.SystemEvents>-Klasse bereitgestellt wird.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Systemereignisbenachrichtigungen werden unter dem aktuellen Kontext nicht unterstützt. Beispielsweise unterstützen Serverprozesse möglicherweise keine globalen Systemereignisbenachrichtigungen.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">Beim Versuch, einen Thread für das Systemereignisfenster zu erstellen, ist ein Fehler aufgetreten.</exception>
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventArgs" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventHandler" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceCategory" />
      </Docs>
    </Member>
  </Members>
</Type>
