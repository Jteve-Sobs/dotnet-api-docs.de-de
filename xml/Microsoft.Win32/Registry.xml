<Type Name="Registry" FullName="Microsoft.Win32.Registry">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0916cb8d2d62ec042e4b67e3db168ea990979805" /><Meta Name="ms.sourcegitcommit" Value="367e1eae0725e6da7136cd073aaa856ded5d5c29" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/13/2019" /><Meta Name="ms.locfileid" Value="75015156" /></Metadata><TypeSignature Language="C#" Value="public static class Registry" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Registry extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.Registry" />
  <TypeSignature Language="VB.NET" Value="Public Class Registry" />
  <TypeSignature Language="C++ CLI" Value="public ref class Registry abstract sealed" />
  <TypeSignature Language="F#" Value="type Registry = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt <see cref="T:Microsoft.Win32.RegistryKey" />-Objekte, die die Stammschlüssel in der Windows-Registrierung darstellen, sowie <see langword="static" />-Methoden für den Zugriff auf Schlüssel-/-Wert-Paare bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Klasse stellt den Satz von Standard Stamm Schlüsseln in der Registrierung auf Computern bereit, auf denen Windows ausgeführt wird. Die Registrierung ist eine Speicher Einrichtung für Informationen zu Anwendungen, Benutzern und Standard Systemeinstellungen. Beispielsweise können Anwendungen die Registrierung zum Speichern von Informationen verwenden, die nach dem Schließen der Anwendung beibehalten werden müssen, und auf die gleichen Informationen zugreifen, wenn die Anwendung erneut geladen wird. Beispielsweise können Sie Farbeinstellungen, Bildschirm Positionen oder die Größe des Fensters speichern. Sie können diese Daten für jeden Benutzer steuern, indem Sie die Informationen an einem anderen Speicherort in der Registrierung speichern.  
  
 Die Basis-oder Stamm <xref:Microsoft.Win32.RegistryKey> Instanzen, die von der `Registry`-Klasse verfügbar gemacht werden, beschreiben den grundlegenden Speichermechanismus für Unterschlüssel und Werte in der Registrierung. Alle Schlüssel sind schreibgeschützt, da die Registrierung von Ihrem vorhanden sein abhängig ist. Die von `Registry` verfügbar gemachten Schlüssel lauten wie folgt:  
  
 <xref:Microsoft.Win32.Registry.CurrentUser>  
 Speichert Informationen zu Benutzereinstellungen.  
  
 <xref:Microsoft.Win32.Registry.LocalMachine>  
 Speichert Konfigurationsinformationen für den lokalen Computer.  
  
 <xref:Microsoft.Win32.Registry.ClassesRoot>  
 Speichert Informationen zu Typen (und Klassen) und deren Eigenschaften.  
  
 <xref:Microsoft.Win32.Registry.Users>  
 Speichert Informationen zur Standardbenutzer Konfiguration.  
  
 <xref:Microsoft.Win32.Registry.PerformanceData>  
 Speichert Leistungsinformationen für Softwarekomponenten.  
  
 <xref:Microsoft.Win32.Registry.CurrentConfig>  
 Speichert Nichtbenutzer spezifische Hardwareinformationen.  
  
 <xref:Microsoft.Win32.Registry.DynData>  
 Speichert dynamische Daten.  
  
 Nachdem Sie den Stamm Schlüssel identifiziert haben, unter dem Sie Informationen aus der Registrierung speichern/abrufen möchten, können Sie die <xref:Microsoft.Win32.RegistryKey>-Klasse verwenden, um Unterschlüssel hinzuzufügen oder zu entfernen und die Werte für einen bestimmten Schlüssel zu bearbeiten.  
  
 Hardware Geräte können mithilfe der Plug & Play-Schnittstelle automatisch Informationen in der Registrierung platzieren. Software für die Installation von Gerätetreibern kann Informationen in der Registrierung durch Schreiben in Standard-APIs platzieren.  
  
## <a name="static-methods-for-getting-and-setting-values"></a>Statische Methoden zum erhalten und Festlegen von Werten  
 In der .NET Framework Version 2,0 enthält die <xref:Microsoft.Win32.Registry>-Klasse auch `static`<xref:Microsoft.Win32.Registry.GetValue%2A> und <xref:Microsoft.Win32.Registry.SetValue%2A> Methoden zum Festlegen und Abrufen von Werten aus Registrierungs Schlüsseln. Diese Methoden öffnen und schließen Registrierungsschlüssel jedes Mal, wenn Sie verwendet werden, sodass Sie nicht ebenso wie analoge Methoden in der <xref:Microsoft.Win32.RegistryKey>-Klasse sind, wenn Sie auf eine große Anzahl von Werten zugreifen.  
  
 Die <xref:Microsoft.Win32.RegistryKey>-Klasse stellt auch Methoden bereit, die es Ihnen ermöglichen, die Windows-Zugriffs Steuerungs Sicherheit für Registrierungsschlüssel festzulegen, den Datentyp eines Werts vor dem Abrufen zu testen und Schlüssel zu löschen.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Das erste Beispiel veranschaulicht Stamm Schlüssel, und im zweiten Beispiel werden die Methoden `static`<xref:Microsoft.Win32.Registry.GetValue%2A> und <xref:Microsoft.Win32.Registry.SetValue%2A> veranschaulicht.  
  
 Beispiel 1  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Unterschlüssel des HKEY_USERS Schlüssels abgerufen und die Namen auf dem Bildschirm gedruckt werden. Verwenden Sie die <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>-Methode, um eine Instanz des jeweiligen unter Schlüssels zu erstellen. Sie können dann andere Vorgänge in `RegistryKey` verwenden, um diesen Schlüssel zu bearbeiten.  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 Beispiel 2  
  
 Im folgenden Codebeispiel werden die Werte mehrerer Datentypen in einem Beispiel Schlüssel gespeichert, und der Schlüssel wird wie folgt erstellt. Anschließend werden die Werte abgerufen und angezeigt. Das Beispiel veranschaulicht das Speichern und Abrufen des Standard Paars (Name/Wert-Paar) und die Verwendung von `defaultValue`, wenn kein Name/Wert-Paar vorhanden ist.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.RegistryHive" />
    <altmember cref="T:Microsoft.Win32.RegistryKey" />
  </Docs>
  <Members>
    <Member MemberName="ClassesRoot">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey ClassesRoot;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey ClassesRoot" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.ClassesRoot" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClassesRoot As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ ClassesRoot;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClassesRoot : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.ClassesRoot" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Definiert die Typen (oder Klassen) von Dokumenten und die diesen Typen zugeordneten Eigenschaften. Dieses Feld liest den Basisschlüssel HKEY_CLASSES_ROOT der Windows-Registrierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sowohl herkömmliche Anwendungen als auch OLE-Anwendungen verwenden Daten, die unter diesem Schlüssel gespeichert sind. Dieser Schlüssel bietet auch Abwärtskompatibilität mit der Windows 3,1-Registrierungsdatenbank, indem Informationen für die Unterstützung von DDE und OLE gespeichert werden. Datei-Viewer und Erweiterungen der Benutzeroberfläche speichern Ihre OLE-Klassen Bezeichner in diesem Schlüssel, und Verarbeitungs Server sind in diesem Schlüssel registriert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die Unterschlüssel dieses Schlüssels abgerufen werden und wie die Namen auf dem Bildschirm ausgegeben werden. Verwenden Sie die <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>-Methode, um eine Instanz des jeweiligen unter Schlüssels zu erstellen. Sie können dann andere Vorgänge in <xref:Microsoft.Win32.RegistryKey> verwenden, um diesen Schlüssel zu bearbeiten.  
  
 [!code-cpp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.ClassesRoot Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentConfig">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentConfig;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentConfig" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentConfig" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentConfig As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentConfig;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentConfig : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentConfig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Enthält benutzerunabhängige Konfigurationsinformationen über die Hardware. Dieses Feld liest den Basisschlüssel HKEY_CURRENT_CONFIG der Windows-Registrierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member wird einem Unterschlüssel in <xref:Microsoft.Win32.Registry.LocalMachine>zugeordnet.  
  
 Ein Beispiel für die Verwendung dieses Members ist eine Anwendung, die einen anderen Servernamen für Ihre Daten speichert, je nachdem, ob das System mit einem Netzwerk verbunden ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die Unterschlüssel dieses Schlüssels abgerufen werden und wie die Namen auf dem Bildschirm ausgegeben werden. Verwenden Sie die <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>-Methode, um eine Instanz des jeweiligen unter Schlüssels zu erstellen. Sie können dann andere Vorgänge in <xref:Microsoft.Win32.RegistryKey> verwenden, um diesen Schlüssel zu bearbeiten.  
  
 [!code-cpp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentConfig Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUser">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentUser;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentUser" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentUser" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentUser As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentUser;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentUser : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentUser" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Enthält Informationen über die Einstellungen des aktuellen Benutzers. Dieses Feld liest den Basisschlüssel HKEY_CURRENT_USER der Windows-Registrierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zu den in diesem Schlüssel gespeicherten Informationen gehören die Einstellungen der Umgebungsvariablen und Daten zu Programm Gruppen, Farben, Druckern, Netzwerkverbindungen und Anwendungseinstellungen. Dieser Schlüssel erleichtert das Festlegen der Einstellungen des aktuellen Benutzers. In diesem Schlüssel speichern Softwareanbieter die aktuellen benutzerspezifischen Einstellungen für die Verwendung in Ihren Anwendungen. Microsoft erstellt beispielsweise den Schlüssel HKEY_CURRENT_USER \Software\Microsoft, damit seine Anwendungen verwenden können, wobei jede Anwendung unter dem Microsoft-Schlüssel einen eigenen Unterschlüssel erstellt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die Unterschlüssel dieses Schlüssels abgerufen werden und wie die Namen auf dem Bildschirm ausgegeben werden. Verwenden Sie die <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>-Methode, um eine Instanz des jeweiligen unter Schlüssels zu erstellen. Sie können dann andere Vorgänge in <xref:Microsoft.Win32.RegistryKey> verwenden, um diesen Schlüssel zu bearbeiten.  
  
 [!code-cpp[Classic Registry.CurrentUser Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentUser Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentUser Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey DynData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey DynData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.DynData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DynData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ DynData;" />
      <MemberSignature Language="F#" Value=" staticval mutable DynData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.DynData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PerformanceData instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The DynData registry key only works on Win9x, which is no longer supported by the CLR.  On NT-based operating systems, use the PerformanceData registry key instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert dynamische Registrierungsdaten. Dieses Feld liest den Basisschlüssel HKEY_DYN_DATA der Windows-Registrierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Windows 98/Windows Me-Registrierung unterstützt sowohl statische Daten (die auf dem Datenträger in der Registrierung gespeichert sind) als auch dynamische Daten (die sich häufig ändern, z. b. Leistungsstatistiken). Dieser dynamische Datenbereich ermöglicht es virtuellen Gerätetreibern (VxDs), Echtzeitdaten für Win32-Anwendungen bereitzustellen, die sowohl Remote als auch lokal ausgeführt werden können. Außerdem kann der System Monitor Leistungsstatistiken für Windows 98-und Windows Me-Remote Systeme bereitstellen.  
  
 VxDs sind nicht auf Leistungsdaten beschränkt. Sie können alle Daten, die Sie aus Ring 0 an Ring 3 übergeben möchten, effizient bereitstellen, ohne die CPU zu monopolisiert. Die Registrierung unterstützt dynamische Daten durch Speichern eines Zeigers auf eine Funktion, die einen Wert (oder viele Werte) zurückgibt. Wenn ein Registrierungs Aufruf Werte abfragt, die einem dynamischen Schlüssel zugeordnet sind, wird diese Funktion aufgerufen, um den gewünschten Wert oder die gewünschten Werte zurückzugeben.  
  
> [!NOTE]
>  Dynamische Schlüssel wurden in Microsoft Windows 95 eingeführt, um dynamische Registrierungsdaten zu verarbeiten. Sie werden nur in Windows 98/Windows Me unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die Unterschlüssel dieses Schlüssels abgerufen werden und wie die Namen auf dem Bildschirm ausgegeben werden. Verwenden Sie die <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>-Methode, um eine Instanz des jeweiligen unter Schlüssels zu erstellen. Sie können dann andere Vorgänge in <xref:Microsoft.Win32.RegistryKey> verwenden, um diesen Schlüssel zu bearbeiten. Beachten Sie, dass in diesem Beispiel keine Ergebnisse zurückgegeben werden können, da möglicherweise keine dynamischen Daten verfügbar sind oder wenn Sie nicht Windows 98/Me ausführen. Die Verwendung dieses Schlüssels kann einen Fehler auf anderen Systemen verursachen.  
  
 [!code-cpp[Classic Registry.DynData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.DynData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.DynData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.DynData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das Betriebssystem unterstützt keine dynamischen Daten, d. h., es ist nicht Windows 98, Windows 98 Second Edition oder Windows Millennium Edition (Windows Me).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public static object GetValue (string keyName, string valueName, object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetValue(string keyName, string valueName, object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetValue (keyName As String, valueName As String, defaultValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member GetValue : string * string * obj -&gt; obj" Usage="Microsoft.Win32.Registry.GetValue (keyName, valueName, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="defaultValue" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName">Der vollständige Registrierungspfad des Schlüssels, beginnend mit einem gültigen Registrierungsstamm (z. B. "HKEY_CURRENT_USER").</param>
        <param name="valueName">Der Name des Name-/Wert-Paars.</param>
        <param name="defaultValue">Der zurückzugebende Wert, wenn <paramref name="valueName" /> nicht vorhanden ist.</param>
        <summary>Ruft den Wert ab, der dem angegebenen Namen im angegebenen Registrierungsschlüssel zugeordnet ist. Wenn der Name im angegebenen Schlüssel nicht gefunden wird, wird ein von Ihnen bereitgestellter Standardwert zurückgegeben, oder <see langword="null" />, wenn der angegebene Schlüssel nicht vorhanden ist.</summary>
        <returns><see langword="null" />, wenn der durch <paramref name="keyName" /> angegebene Unterschlüssel nicht vorhanden ist, andernfalls der Wert, der <paramref name="valueName" /> zugeordnet ist, oder <paramref name="defaultValue" />, wenn <paramref name="valueName" /> nicht gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der Zeichenfolge `valueName` wird keine Groß-/Kleinschreibung beachtet.  
  
> [!NOTE]
>  Ein Registrierungsschlüssel kann einen Wert enthalten, der keinem Namen zugeordnet ist. Wenn dieser unbenannte Wert im Registrierungs-Editor angezeigt wird, wird die Zeichenfolge "(Standard)" anstelle eines Namens angezeigt. Um diesen unbenannten Wert abzurufen, geben Sie entweder `null` oder eine leere Zeichenfolge ("") für `valueName`an.  
  
 Gültige Stamm Namen sind HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG und HKEY_DYN_DATA. In Visual Basic z. b. die Zeichenfolge "HKEY_CURRENT_USER \mytestkey" auf Schlüssel-Wert-Paare für den Unterschlüssel "MyTestKey" im HKEY_CURRENT_USER Stamm.  
  
 Wenn die <xref:Microsoft.Win32.RegistryKey.GetValue%2A>-Methode erweiterbare Zeichen folgen Werte (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>) abruft, werden Umgebungs Zeichenfolgen mithilfe von Daten aus der lokalen Umgebung erweitert. Wenn ein Wert, der erweiterbare Verweise auf Umgebungsvariablen enthält, nicht als erweiterbare Zeichenfolge (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), sondern als Zeichenfolge (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>) gespeichert wurde, wird er von <xref:Microsoft.Win32.RegistryKey.GetValue%2A> nicht erweitert. Sie können eine solche Zeichenfolge erweitern, nachdem Sie abgerufen wurde, indem Sie die <xref:System.Environment.ExpandEnvironmentVariables%2A?displayProperty=nameWithType>-Methode aufrufen.  
  
> [!NOTE]
>  Die empfohlene Vorgehensweise zum Abrufen von Daten aus HKEY_PERFORMANCE_DATA besteht darin, die <xref:System.Diagnostics.PerformanceCounter>-Klasse anstelle der <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType>-Methode zu verwenden.  
  
 Die Methoden <xref:Microsoft.Win32.Registry.GetValue%2A> und <xref:Microsoft.Win32.Registry.SetValue%2A> öffnen und schließen Registrierungsschlüssel jedes Mal, wenn Sie verwendet werden, sodass Sie nicht ebenso wie die Methoden der <xref:Microsoft.Win32.RegistryKey>-Klasse sind, wenn Sie auf eine große Anzahl von Werten zugreifen.  
  
 <xref:Microsoft.Win32.RegistryKey> stellt auch Methoden bereit, mit denen Sie einem Registrierungsschlüssel eine Zugriffs Steuerungs Liste (ACL) hinzufügen, den Datentyp eines Werts vor dem Abruf testen und Schlüssel löschen können.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die Werte mehrerer Datentypen in einem Beispiel Schlüssel gespeichert, und der Schlüssel wird wie folgt erstellt. Anschließend werden die Werte abgerufen und angezeigt. Das Beispiel veranschaulicht das Speichern und Abrufen des Standard Paars (Name/Wert-Paar) und die Verwendung von `defaultValue`, wenn kein Name/Wert-Paar vorhanden ist.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen, um aus dem Registrierungsschlüssel zu lesen.</exception>
        <exception cref="T:System.IO.IOException">Der <see cref="T:Microsoft.Win32.RegistryKey" />, der den angegebenen Wert enthält, wurde zum Löschen markiert.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keyName" /> beginnt nicht mit einem gültigen Registrierungsstamm.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">zum Lesen aus der Registrierung. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">zum Lesen eines Registrierungsschlüssels vom Typ REG_EXPAND_SZ. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LocalMachine">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey LocalMachine;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey LocalMachine" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.LocalMachine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LocalMachine As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ LocalMachine;" />
      <MemberSignature Language="F#" Value=" staticval mutable LocalMachine : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.LocalMachine" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert die Konfigurationsinformationen für den lokalen Computer. Dieses Feld liest den Basisschlüssel HKEY_LOCAL_MACHINE der Windows-Registrierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LocalMachine` enthält fünf Schlüssel:  
  
 Hardware  
 Beschreibt die physische Hardware des Computers, die Art und Weise, wie Gerätetreiber diese Hardware verwenden, sowie Zuordnungen und zugehörige Daten, die Kernelmodustreiber mit Benutzermoduscode verknüpfen. Alle Daten in diesem Schlüssel werden jedes Mal neu erstellt, wenn das System gestartet wird. Der Beschreibungs Unterschlüssel beschreibt die tatsächliche Computer Hardware. Der DeviceMap-Unterschlüssel enthält verschiedene Daten in Formaten für bestimmte Klassen von Treibern. Der ResourceMap-Unterschlüssel beschreibt, welche Gerätetreiber welche Hardware Ressourcen beanspruchen. Das Windows NT-Diagnoseprogramm (WINMSDP. exe) kann seinen Inhalt in einem leicht lesbaren Formular melden.  
  
 SAM  
 Die Verzeichnisdienst Datenbank mit Sicherheitsinformationen für Benutzer-und Gruppenkonten und für die Domänen in Windows 2000 Server (Sam ist der Sicherheits Konto-Manager, der als Verzeichnisdienst-Datenbank bezeichnet wird).  
  
 Sicherheit  
 Enthält die lokale Sicherheitsrichtlinie, z. b. bestimmte Benutzerrechte. Dieser Schlüssel wird nur vom Windows 2000-Sicherheits Subsystem verwendet.  
  
 Software  
 Die Software Datenbank pro Computer. Dieser Schlüssel enthält Daten zu Software, die auf dem lokalen Computer installiert ist, sowie verschiedene Elemente verschiedener Konfigurationsdaten.  
  
 System  
 Steuert den Systemstart, das Laden von Gerätetreibern, Windows 2000-Dienste und das Betriebssystem Verhalten.  
  
 Gemäß der Konvention haben die Daten in <xref:Microsoft.Win32.Registry.CurrentUser> Vorrang, wenn ähnliche Daten unter <xref:Microsoft.Win32.Registry.CurrentUser> und <xref:Microsoft.Win32.Registry.LocalMachine>vorhanden sind. Werte in diesem Schlüssel können jedoch auch die Daten in Registry. LocalMachine erweitern (anstatt Sie zu ersetzen). Außerdem sind einige Elemente (z. b. Gerätetreiber Lade Einträge) bedeutungslos, wenn Sie außerhalb von "Registry. LocalMachine" auftreten.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die Unterschlüssel dieses Schlüssels abgerufen werden und wie die Namen auf dem Bildschirm ausgegeben werden. Verwenden Sie die <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>-Methode, um eine Instanz des jeweiligen unter Schlüssels zu erstellen. Sie können dann andere Vorgänge in <xref:Microsoft.Win32.RegistryKey> verwenden, um diesen Schlüssel zu bearbeiten.  
  
 [!code-cpp[Classic Registry.LocalMachine Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.LocalMachine Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.LocalMachine Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformanceData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey PerformanceData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey PerformanceData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.PerformanceData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PerformanceData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ PerformanceData;" />
      <MemberSignature Language="F#" Value=" staticval mutable PerformanceData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.PerformanceData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Enthält Informationen zur Leistung für Softwarekomponenten. Dieses Feld liest den Basisschlüssel HKEY_PERFORMANCE_DATA der Windows-Registrierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jede Softwarekomponente erstellt Schlüssel für die Objekte und Leistungsindikatoren, wenn Sie installiert wird, und schreibt Indikator Daten während der Ausführung. Sie können auf diese Daten zugreifen, wenn Sie auf alle anderen Registrierungsdaten zugreifen, indem Sie die <xref:Microsoft.Win32.RegistryKey> Funktionen verwenden.  
  
 Obwohl Sie die Registrierung verwenden, um Leistungsdaten zu erfassen, werden die Daten nicht in der Registrierungsdatenbank gespeichert. Der Zugriff auf die Registrierung mit diesem Schlüssel bewirkt, dass das System die Daten der entsprechenden Systemobjekt-Manager sammelt.  
  
 Verwenden Sie zum Abrufen von Leistungsdaten aus dem lokalen System die <xref:Microsoft.Win32.RegistryKey.GetValue%2A>-Methode mit dem-Schlüssel Registry. PerformanceData. Der erste-Befehl öffnet den Schlüssel (Sie müssen den Schlüssel nicht explizit zuerst öffnen). Stellen Sie jedoch sicher, dass Sie die <xref:Microsoft.Win32.RegistryKey.Close%2A>-Methode verwenden, um das Handle für den Schlüssel zu schließen, wenn Sie mit dem Abrufen von Leistungsdaten fertig sind. Der Benutzer kann eine Softwarekomponente nicht installieren oder entfernen, während die Leistungsdaten verwendet werden.  
  
 Zum Abrufen von Leistungsdaten von einem Remote System müssen Sie die <xref:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey%2A>-Methode mit dem Computernamen des Remote Systems und dem Registry. PerformanceData-Schlüssel verwenden. Dieser Befehl ruft einen Schlüssel ab, der die Leistungsdaten für das Remote System darstellt. Rufen Sie zum Abrufen der Daten <xref:Microsoft.Win32.RegistryKey.GetValue%2A> mit diesem Schlüssel anstelle des Registry. PerformanceData-Schlüssels auf.  
  
> [!NOTE]
>  Unter Windows Server 2003 muss ein Benutzer mindestens zur Gruppe "System Monitor Benutzer" gehören, um auf Unterschlüssel dieses Basis Schlüssels zugreifen zu können.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die Unterschlüssel dieses Schlüssels abgerufen werden und wie die Namen auf dem Bildschirm ausgegeben werden. Verwenden Sie die <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>-Methode, um eine Instanz des jeweiligen unter Schlüssels zu erstellen. Sie können dann andere Vorgänge in <xref:Microsoft.Win32.RegistryKey> verwenden, um diesen Schlüssel zu bearbeiten. Beachten Sie, dass in diesem Beispiel häufig keine Ergebnisse zurückgegeben werden können, da möglicherweise keine Leistungsdaten vorhanden sind.  
  
 [!code-cpp[Classic Registry.PerformanceData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.PerformanceData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.PerformanceData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt den Wert eines Name-/Wert-Paars in einem Registrierungsschlüssel fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel werden die Werte mehrerer Datentypen in einem Beispiel Schlüssel gespeichert, und der Schlüssel wird wie folgt erstellt. Anschließend werden die Werte abgerufen und angezeigt. Das Beispiel veranschaulicht das Speichern und Abrufen des Standard Paars (Name/Wert-Paar) und die Verwendung von `defaultValue`, wenn kein Name/Wert-Paar vorhanden ist.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName">Der vollständige Registrierungspfad des Schlüssels, beginnend mit einem gültigen Registrierungsstamm (z. B. "HKEY_CURRENT_USER").</param>
        <param name="valueName">Der Name des Name-/Wert-Paars.</param>
        <param name="value">Der zu speichernde Wert.</param>
        <summary>Legt das angegebene Name-/Wert-Paar für den angegebenen Registrierungsschlüssel fest. Wenn der angegebene Schlüssel nicht vorhanden ist, wird er erstellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beginnend mit dem [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]ist der `valueName` Parameter nicht mehr auf maximal 255 Zeichen beschränkt. der `keyName`-Parameter weist jedoch weiterhin die 255-Zeichen-Einschränkung auf.  
  
 Da viele Werte in jedem Schlüssel in der Registrierung gespeichert werden können, müssen Sie den `valueName`-Parameter verwenden, um den bestimmten Wert anzugeben, den Sie festlegen möchten.  
  
> [!NOTE]
>  Ein Registrierungsschlüssel kann einen Wert enthalten, der keinem Namen zugeordnet ist. Wenn dieser unbenannte Wert im Registrierungs-Editor angezeigt wird, wird die Zeichenfolge "(Standard)" anstelle eines Namens angezeigt. Um diesen unbenannten Wert festzulegen, geben Sie entweder `null` oder eine leere Zeichenfolge ("") für `valueName`an.  
  
 Wenn `valueName` im Schlüssel nicht vorhanden ist, wird Sie erstellt, und der zugeordnete Wert wird auf `value`festgelegt.  
  
 Wenn `keyName` einen Unterschlüssel angibt, der nicht vorhanden ist, wird der Unterschlüssel im angegebenen Stamm erstellt. Beispielsweise erstellt in Visual Basic die Zeichenfolge "HKEY_CURRENT_USER \mytestkey" den Unterschlüssel "MyTestKey" im Stammverzeichnis HKEY_CURRENT_USER. Die Zeichenfolge "HKEY_CURRENT_USER \mytestkey\key2\key3" erstellt die untergeordneten Schlüssel "MyTestKey", "MyTestKey\Key2" und "MyTestKey\Key2\Key3".  
  
 Gültige Stamm Namen sind HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG und HKEY_DYN_DATA.  
  
> [!NOTE]
>  Die <xref:Microsoft.Win32.Registry.SetValue%2A>-Methode öffnet einen Registrierungsschlüssel, legt den Wert fest und schließt den Schlüssel jedes Mal, wenn er aufgerufen wird. Wenn Sie eine große Anzahl von Werten ändern müssen, bietet die <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType>-Methode möglicherweise eine bessere Leistung. Die <xref:Microsoft.Win32.RegistryKey>-Klasse stellt auch Methoden bereit, mit denen Sie einem Registrierungsschlüssel eine Zugriffs Steuerungs Liste (ACL) hinzufügen, den Datentyp eines Werts vor dem Abruf testen und Schlüssel löschen können.  
  
 Diese Überladung von <xref:Microsoft.Win32.Registry.SetValue%2A> speichert ganzzahlige 64-Bit-Werte als Zeichen folgen (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>). Um 64-Bit-Zahlen als <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType> Werte zu speichern, verwenden Sie die <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29>-Methoden Überladung.  
  
 Diese Überladung von <xref:Microsoft.Win32.Registry.SetValue%2A> speichert alle Zeichen folgen Werte als <xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType> Objekte, auch wenn Sie erweiterbare Verweise auf Umgebungsvariablen enthalten. Um Zeichen folgen Werte als erweiterbare Zeichen folgen (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>) zu speichern, verwenden Sie die <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29>-Methoden Überladung.  
  
 Diese Überladung entspricht dem Aufrufen der <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29>-Methoden Überladung mit <xref:Microsoft.Win32.RegistryValueKind.Unknown?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Unter Windows 98 und Windows Millennium Edition (Windows Me) ist die Registrierung nicht Unicode, und nicht alle Unicode-Zeichen sind für alle Codepages gültig. Ein Unicode-Zeichen, das für die aktuelle Codepage ungültig ist, wird durch die beste verfügbare Entsprechung ersetzt. Es werden keine Ausnahmen ausgelöst.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die Werte mehrerer Datentypen in einem Beispiel Schlüssel gespeichert, und der Schlüssel wird wie folgt erstellt. Anschließend werden die Werte abgerufen und angezeigt. Das Beispiel veranschaulicht das Speichern und Abrufen des Standard Paars (Name/Wert-Paar) und die Verwendung von `defaultValue`, wenn kein Name/Wert-Paar vorhanden ist.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keyName" /> beginnt nicht mit einem gültigen Registrierungsstamm.  
  
- oder - 
 <paramref name="keyName" /> überschreitet die maximal zulässige Länge (255 Zeichen).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Die <see cref="T:Microsoft.Win32.RegistryKey" />-Klasse ist schreibgeschützt. Es ist kein Schreibzugriff möglich, d. h., es handelt sich z. B. um einen Knoten auf Stammebene.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Erstellen oder Ändern von Registrierungsschlüsseln.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">, um den angegebenen Registrierungsschlüssel zu ändern, wenn er vorhanden ist, oder, wenn er nicht bereits vorhanden ist. Zugehörige Enumerationen: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /><see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value, Microsoft.Win32.RegistryValueKind valueKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value, valuetype Microsoft.Win32.RegistryValueKind valueKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object, valueKind As RegistryValueKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value, Microsoft::Win32::RegistryValueKind valueKind);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj * Microsoft.Win32.RegistryValueKind -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value, valueKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueKind" Type="Microsoft.Win32.RegistryValueKind" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName">Der vollständige Registrierungspfad des Schlüssels, beginnend mit einem gültigen Registrierungsstamm (z. B. "HKEY_CURRENT_USER").</param>
        <param name="valueName">Der Name des Name-/Wert-Paars.</param>
        <param name="value">Der zu speichernde Wert.</param>
        <param name="valueKind">Der beim Speichern der Daten zu verwendende Registrierungsdatentyp.</param>
        <summary>Legt unter Verwendung des angegebenen Registrierungsdatentyps das Name-/Wert-Paar für den angegebenen Registrierungsschlüssel fest. Wenn der angegebene Schlüssel nicht vorhanden ist, wird er erstellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beginnend mit dem [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]ist der `valueName` Parameter nicht mehr auf maximal 255 Zeichen beschränkt. Allerdings hat der `keyName`-Parameter weiterhin die Einschränkung von 255 Zeichen.  
  
 Da viele Werte in jedem Schlüssel in der Registrierung gespeichert werden können, müssen Sie den `valueName`-Parameter verwenden, um den bestimmten Wert anzugeben, den Sie festlegen möchten.  
  
> [!NOTE]
>  Ein Registrierungsschlüssel kann einen Wert enthalten, der keinem Namen zugeordnet ist. Wenn dieser unbenannte Wert im Registrierungs-Editor angezeigt wird, wird die Zeichenfolge "(Standard)" anstelle eines Namens angezeigt. Um diesen unbenannten Wert festzulegen, geben Sie entweder `null` oder eine leere Zeichenfolge ("") für `valueName`an.  
  
 Wenn `valueName` im Schlüssel nicht vorhanden ist, wird Sie erstellt, und der zugeordnete Wert wird auf `value`festgelegt.  
  
 Wenn `keyName` einen Unterschlüssel angibt, der nicht vorhanden ist, wird der Unterschlüssel im angegebenen Stamm erstellt. Beispielsweise erstellt in Visual Basic die Zeichenfolge "HKEY_CURRENT_USER \mytestkey" den Unterschlüssel "MyTestKey" im Stammverzeichnis HKEY_CURRENT_USER. Die Zeichenfolge "HKEY_CURRENT_USER \mytestkey\key2\key3" erstellt die untergeordneten Schlüssel "MyTestKey", "MyTestKey\Key2" und "MyTestKey\Key2\Key3".  
  
 Gültige Stamm Namen sind HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG und HKEY_DYN_DATA.  
  
> [!NOTE]
>  Die <xref:Microsoft.Win32.Registry.SetValue%2A>-Methode öffnet einen Registrierungsschlüssel, legt den Wert fest und schließt den Schlüssel jedes Mal, wenn er aufgerufen wird. Wenn Sie eine große Anzahl von Werten ändern müssen, bietet die <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType>-Methode möglicherweise eine bessere Leistung. Die <xref:Microsoft.Win32.RegistryKey>-Klasse stellt auch Methoden bereit, mit denen Sie einem Registrierungsschlüssel eine Zugriffs Steuerungs Liste (ACL) hinzufügen, den Datentyp eines Werts vor dem Abruf testen und Schlüssel löschen können.  
  
 Wenn der Typ des angegebenen `value` nicht mit dem angegebenen `valueKind`identisch ist und die Daten nicht konvertiert werden können, wird <xref:System.ArgumentException> ausgelöst. Beispielsweise können Sie eine <xref:System.Int64?displayProperty=nameWithType> als <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>speichern, aber nur, wenn der Wert kleiner als der Höchstwert eines <xref:System.Int32?displayProperty=nameWithType>ist. Es ist nicht möglich, einen einzelnen Zeichen folgen Wert als <xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>zu speichern.  
  
> [!NOTE]
>  Wenn für <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType> oder <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>geachtelte Werte übermittelt werden, erfolgt die Konvertierung mithilfe der invarianten Kultur.  
  
> [!NOTE]
>  Unter Windows 98 und Windows Millennium Edition (Windows Me) ist die Registrierung nicht Unicode, und nicht alle Unicode-Zeichen sind für alle Codepages gültig. Ein Unicode-Zeichen, das für die aktuelle Codepage ungültig ist, wird durch die beste verfügbare Entsprechung ersetzt. Es werden keine Ausnahmen ausgelöst.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die Werte mehrerer Datentypen in einem Beispiel Schlüssel gespeichert, und der Schlüssel wird wie folgt erstellt. Anschließend werden die Werte abgerufen und angezeigt. Das Beispiel veranschaulicht das Speichern und Abrufen des Standard Paars (Name/Wert-Paar) und die Verwendung von `defaultValue`, wenn kein Name/Wert-Paar vorhanden ist.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keyName" /> beginnt nicht mit einem gültigen Registrierungsstamm.  
  
- oder - 
 <paramref name="keyName" /> überschreitet die maximal zulässige Länge (255 Zeichen).  
  
- oder - 
Der Typ von <paramref name="value" /> stimmt nicht mit dem durch <paramref name="valueKind" /> angegebenen Registrierungsdatentyp überein. Die Daten konnten daher nicht ordnungsgemäß konvertiert werden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der <see cref="T:Microsoft.Win32.RegistryKey" /> ist schreibgeschützt. Es ist kein Schreibzugriff möglich, d. h. es handelt sich z. B. um einen Knoten auf Stammebene oder um einen Schlüssel, der nicht mit Schreibzugriff geöffnet wurde.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Erstellen oder Ändern von Registrierungsschlüsseln.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">, um den angegebenen Registrierungsschlüssel zu ändern, wenn er vorhanden ist, oder, wenn er nicht bereits vorhanden ist. Zugehörige Enumerationen: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" /><see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Users">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey Users;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey Users" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.Users" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Users As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ Users;" />
      <MemberSignature Language="F#" Value=" staticval mutable Users : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.Users" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Enthält Informationen über die Standardkonfiguration des Benutzer. Dieses Feld liest den Basisschlüssel HKEY_USERS der Windows-Registrierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Schlüssel enthält eine Verzweigung für jeden Benutzer des Computers. Die Standardkonfiguration wird für neue Benutzer auf dem lokalen Computer und für den standardmäßigen aktuellen Benutzer bereitgestellt, wenn der Benutzer die Einstellungen nicht geändert hat. Da Windows 98/Me auch Registry. users unterstützt, können Anwendungen auf die benutzerspezifischen Informationen auf die gleiche Weise wie unter Windows 2000 zugreifen. Die Informationen der einzelnen Benutzer werden in einer separaten Datei gespeichert, die lokal oder auf einem Netzwerkserver gespeichert werden kann. Windows 98/Me kann diese Datei in das aktuelle System des Benutzers kopieren, damit die Einstellungen des Benutzers von einem Computer auf einen anderen verschoben werden können.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die Unterschlüssel dieses Schlüssels abgerufen werden und wie die Namen auf dem Bildschirm ausgegeben werden. Verwenden Sie die <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>-Methode, um eine Instanz des jeweiligen unter Schlüssels zu erstellen. Sie können dann andere Vorgänge in <xref:Microsoft.Win32.RegistryKey> verwenden, um diesen Schlüssel zu bearbeiten.  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
