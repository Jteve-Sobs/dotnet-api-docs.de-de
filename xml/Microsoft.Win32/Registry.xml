<Type Name="Registry" FullName="Microsoft.Win32.Registry">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b5ddffb41db3e1edcd0591a5abd1027692cd10e8" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48757684" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Registry" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Registry extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.Registry" />
  <TypeSignature Language="VB.NET" Value="Public Class Registry" />
  <TypeSignature Language="C++ CLI" Value="public ref class Registry abstract sealed" />
  <TypeSignature Language="F#" Value="type Registry = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt <see cref="T:Microsoft.Win32.RegistryKey" />-Objekte, die die Stammschlüssel in der Windows-Registrierung darstellen, sowie <see langword="static" />-Methoden für den Zugriff auf Schlüssel-/-Wert-Paare bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Klasse stellt den Satz von standard-Stammzertifizierungsstellen-Schlüsseln finden Sie in der Registrierung auf Computern mit Windows. Die Registrierung ist einer Speicherfunktion Informationen zu Anwendungen, Benutzer und System-Standardeinstellungen. Beispielsweise können Anwendungen verwenden Sie die Registrierung zum Speichern von Informationen, die nach dem Schließen der Anwendungs beibehalten werden muss, und die gleiche Informationen zugreifen, wenn die Anwendung erneut geladen wird. Beispielsweise können Sie die farbeinstellungen, Bildschirmpositionen oder die Größe des Fensters speichern. Sie können diese Daten für jeden Benutzer steuern, indem die Daten an einem anderen Speicherort in der Registrierung gespeichert.  
  
 Die Basis- oder Stammnamespace <xref:Microsoft.Win32.RegistryKey> -Instanzen, die von verfügbar gemacht werden die `Registry` Klasse voneinander abzugrenzen, und die grundlegenden Speichermechanismus für Unterschlüssel und Werte in der Registrierung. Alle Schlüssel sind schreibgeschützt, da die Registrierung von deren Existenz abhängig ist. Die Schlüssel von verfügbar gemachten `Registry` sind:  
  
 <xref:Microsoft.Win32.Registry.CurrentUser>  
 Speichert Informationen zu benutzereinstellungen.  
  
 <xref:Microsoft.Win32.Registry.LocalMachine>  
 Speichert die Konfigurationsinformationen für den lokalen Computer.  
  
 <xref:Microsoft.Win32.Registry.ClassesRoot>  
 Speichert Informationen zu Typen (und Klassen) und deren Eigenschaften.  
  
 <xref:Microsoft.Win32.Registry.Users>  
 Speichert Informationen über die Standardkonfiguration für den Benutzer.  
  
 <xref:Microsoft.Win32.Registry.PerformanceData>  
 Speichert Leistungsinformationen für Softwarekomponenten.  
  
 <xref:Microsoft.Win32.Registry.CurrentConfig>  
 Speichert Hardwareinformationen für nicht-Benutzer-spezifische.  
  
 <xref:Microsoft.Win32.Registry.DynData>  
 Speichert dynamische Daten.  
  
 Nachdem Sie den Stammschlüssel identifiziert haben, unter denen Informationen aus der Registrierung gespeichert oder abgerufen werden sollen, können Sie mithilfe der <xref:Microsoft.Win32.RegistryKey> Klasse zum Hinzufügen oder entfernen die Unterschlüssel, und bearbeiten Sie die Werte für einen bestimmten Schlüssel.  
  
 Hardwaregeräte können Informationen in der Registrierung automatisch mit der Plug & Play-Schnittstelle platzieren. Software für die Installation von Gerätetreibern kann Informationen in der Registrierung durch Schreiben in standard-APIs platzieren.  
  
## <a name="static-methods-for-getting-and-setting-values"></a>Statische Methoden zum Abrufen und Festlegen von Werten  
 In .NET Framework, Version 2.0 der <xref:Microsoft.Win32.Registry> Klasse enthält auch `static` <xref:Microsoft.Win32.Registry.GetValue%2A> und <xref:Microsoft.Win32.Registry.SetValue%2A> Methoden zum Festlegen und Abrufen von Werten von Registrierungsschlüsseln. Diese Methoden zu öffnen und schließen Registrierungsschlüssel, jedes Mal, sie verwendet werden, sodass sie nicht ausführen, sowie analoge Methoden, die in der <xref:Microsoft.Win32.RegistryKey> Klasse, die beim Zugriff auf eine große Anzahl von Werten.  
  
 Die <xref:Microsoft.Win32.RegistryKey> Klasse stellt auch Methoden, mit denen Sie Windows-zugriffssteuerungssicherheit für den Registrierungsschlüssel, um den Datentyp eines Werts zu testen, bevor Sie sie abrufen und Löschen von Schlüsseln festlegen können.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Das erste Beispiel veranschaulicht die Stammverzeichnis Schlüsseln und das zweite Beispiel veranschaulicht die `static` <xref:Microsoft.Win32.Registry.GetValue%2A> und <xref:Microsoft.Win32.Registry.SetValue%2A> Methoden.  
  
 Beispiel 1  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Unterschlüssel des dem HKEY_USERS-Schlüssel abrufen und ihre Namen auf dem Bildschirm drucken wird. Verwenden der <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> Methode zum Erstellen einer Instanz des betreffenden Unterschlüssels von Interesse sind. Anschließend können Sie andere Vorgänge im `RegistryKey` diesen Schlüssel zu bearbeiten.  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 Beispiel 2  
  
 Im folgenden Codebeispiel werden Werte verschiedener Datentypen in einem Beispielschlüssel, den Schlüssel erstellt, macht dies auch, und klicken Sie dann Ruft ab und zeigt die Werte gespeichert. Im Beispiel wird veranschaulicht, speichern und Abrufen von Standard (namenlos) Name/Wert-Paar, und die Verwendung von `defaultValue` Wenn Name/Wert-Paar ist nicht vorhanden.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.RegistryHive" />
    <altmember cref="T:Microsoft.Win32.RegistryKey" />
  </Docs>
  <Members>
    <Member MemberName="ClassesRoot">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey ClassesRoot;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey ClassesRoot" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.ClassesRoot" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClassesRoot As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ ClassesRoot;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClassesRoot : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.ClassesRoot" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Definiert die Typen (oder Klassen) von Dokumenten und die diesen Typen zugeordneten Eigenschaften. Dieses Feld liest den Basisschlüssel HKEY_CLASSES_ROOT der Windows-Registrierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Herkömmliche Anwendungen und OLE-Anwendungen verwenden die Daten, die unter diesem Schlüssel gespeichert ist. Dieser Schlüssel bietet Abwärtskompatibilität mit der Registrierungsdatenbank Windows 3.1 auch durch das Speichern von Informationen für die DDE- und OLE-Unterstützung. Datei-Viewer und Erweiterungen von Benutzer-Schnittstelle, speichern die OLE-Klassen-IDs in diesem Schlüssel, und Verarbeitungsserver werden in diesem Schlüssel registriert.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie die Unterschlüssel des Schlüssels abrufen, und gibt deren Namen auf dem Bildschirm. Verwenden der <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> Methode zum Erstellen einer Instanz des betreffenden Unterschlüssels von Interesse sind. Anschließend können Sie andere Vorgänge im <xref:Microsoft.Win32.RegistryKey> diesen Schlüssel zu bearbeiten.  
  
 [!code-cpp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.ClassesRoot Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentConfig">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentConfig;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentConfig" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentConfig" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentConfig As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentConfig;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentConfig : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentConfig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Enthält benutzerunabhängige Konfigurationsinformationen über die Hardware. Dieses Feld liest den Basisschlüssel HKEY_CURRENT_CONFIG der Windows-Registrierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member wird in einen Unterschlüssel zugeordnet <xref:Microsoft.Win32.Registry.LocalMachine>.  
  
 Ein Beispiel für dieses Element ist eine Anwendung, die speichert einen anderen Servernamen für die Daten, je nachdem, ob das System mit einem Netzwerk angeschlossen ist.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie die Unterschlüssel des Schlüssels abrufen, und gibt deren Namen auf dem Bildschirm. Verwenden der <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> Methode zum Erstellen einer Instanz des betreffenden Unterschlüssels von Interesse sind. Anschließend können Sie andere Vorgänge im <xref:Microsoft.Win32.RegistryKey> diesen Schlüssel zu bearbeiten.  
  
 [!code-cpp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentConfig Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUser">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentUser;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentUser" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentUser" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentUser As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentUser;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentUser : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentUser" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Enthält Informationen über die Einstellungen des aktuellen Benutzers. Dieses Feld liest den Basisschlüssel HKEY_CURRENT_USER der Windows-Registrierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In diesem Schlüssel gespeicherten Informationen enthält die Einstellungen, Umgebungsvariablen und die Daten über die Programmgruppen, Farben, Drucker, Verbindungen mit Netzwerken und Anwendungsvoreinstellungen. Dieser Schlüssel erleichtert es den aktuellen Einstellungen des Benutzers herstellen. In diesem Schlüssel speichern Softwarehersteller die aktuellen benutzerspezifische Einstellungen in ihren Anwendungen verwendet werden. Microsoft erstellt z. B. den Schlüssel "HKEY_CURRENT_USER\Software\Microsoft" an, für ihre Anwendungen mit jeder Anwendung, erstellen einen eigenen Unterschlüssel unter dem Microsoft-Schlüssel verwenden.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie die Unterschlüssel des Schlüssels abrufen, und gibt deren Namen auf dem Bildschirm. Verwenden der <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> Methode zum Erstellen einer Instanz des betreffenden Unterschlüssels von Interesse sind. Anschließend können Sie andere Vorgänge im <xref:Microsoft.Win32.RegistryKey> diesen Schlüssel zu bearbeiten.  
  
 [!code-cpp[Classic Registry.CurrentUser Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentUser Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentUser Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey DynData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey DynData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.DynData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DynData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ DynData;" />
      <MemberSignature Language="F#" Value=" staticval mutable DynData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.DynData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PerformanceData instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The DynData registry key only works on Win9x, which is no longer supported by the CLR.  On NT-based operating systems, use the PerformanceData registry key instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert dynamische Registrierungsdaten. Dieses Feld liest den Basisschlüssel HKEY_DYN_DATA der Windows-Registrierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Registrierung von Windows 98/Windows Me unterstützt sowohl die statische Daten (die auf dem Datenträger in der Registrierung gespeichert ist) als auch die dynamischen Daten (die häufig, wie z. B. Leistungsstatistiken geändert wird). Dieser Bereich für dynamische Daten ist der Mechanismus, mit dem virtuellen Gerätetreibern (VxDs) in Echtzeit Daten bereitstellen, kann für Win32-Anwendungen, die als auch lokal ausgeführt werden können. Darüber hinaus können den Systemmonitor, um die Leistungsstatistiken auf remote Windows 98/Windows Me-Systemen bereitstellen.  
  
 VxDs sind nicht auf Leistungsdaten beschränkt. Sie können beliebige Daten bereitstellen, die sie in Ring 0 an Ring 3 effizient übergeben, ohne die CPU stark auszulasten möchten. Die Registrierung unterstützt dynamische Daten, durch das Speichern von einem Zeiger auf eine Funktion, die einen Wert (oder viele Werte) zurückgibt. Beim Abfragen einer Registrierungswerte-Aufruf zugeordnet ist eines dynamische Schlüssels, dass die Funktion aufgerufen wird, um den gewünschten Wert oder Werte zurückgeben.  
  
> [!NOTE]
>  Dynamische Schlüssel wurden in Microsoft Windows 95, behandeln dynamische Registrierungsdaten eingeführt. Sie werden nur in Windows 98/Windows Me unterstützt.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie die Unterschlüssel des Schlüssels abrufen, und gibt deren Namen auf dem Bildschirm. Verwenden der <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> Methode zum Erstellen einer Instanz des betreffenden Unterschlüssels von Interesse sind. Anschließend können Sie andere Vorgänge im <xref:Microsoft.Win32.RegistryKey> diesen Schlüssel zu bearbeiten. Beachten Sie, dass in diesem Beispiel kann keine Ergebnisse zurück, da gibt es möglicherweise keine dynamische Daten verfügbar, oder Sie möglicherweise nicht Windows 98 führen / Me. Mit diesem Schlüssel möglicherweise einen Fehler auf anderen Systemen.  
  
 [!code-cpp[Classic Registry.DynData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.DynData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.DynData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.DynData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das Betriebssystem unterstützt keine dynamischen Daten, d. h., es ist nicht Windows 98, Windows 98 Second Edition oder Windows Millennium Edition (Windows Me).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public static object GetValue (string keyName, string valueName, object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetValue(string keyName, string valueName, object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetValue (keyName As String, valueName As String, defaultValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member GetValue : string * string * obj -&gt; obj" Usage="Microsoft.Win32.Registry.GetValue (keyName, valueName, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="keyName">Der vollständige Registrierungspfad des Schlüssels, beginnend mit einem gültigen Registrierungsstamm (z. B. "HKEY_CURRENT_USER").</param>
        <param name="valueName">Der Name des Name-/Wert-Paars.</param>
        <param name="defaultValue">Der zurückzugebende Wert, wenn <c>valueName</c> nicht vorhanden ist.</param>
        <summary>Ruft den Wert ab, der dem angegebenen Namen im angegebenen Registrierungsschlüssel zugeordnet ist. Wenn der Name im angegebenen Schlüssel nicht gefunden wird, wird ein von Ihnen bereitgestellter Standardwert zurückgegeben, oder <see langword="null" />, wenn der angegebene Schlüssel nicht vorhanden ist.</summary>
        <returns>
          <see langword="null" />, wenn der durch <paramref name="keyName" /> angegebene Unterschlüssel nicht vorhanden ist, andernfalls der Wert, der <paramref name="valueName" /> zugeordnet ist, oder <paramref name="defaultValue" />, wenn <paramref name="valueName" /> nicht gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Zeichenfolge `valueName` wird nicht beachtet.  
  
> [!NOTE]
>  Ein Registrierungsschlüssel kann es sich um einen Wert enthalten, die nicht mit einem beliebigen Namen zugeordnet ist. Wenn es sich bei diesen unbenannten Wert in den Registrierungs-Editor angezeigt wird, wird die Zeichenfolge "(Standard)" anstelle eines Namens angezeigt. Um diesen unbenannten Wert abzurufen, geben Sie entweder `null` oder eine leere Zeichenfolge ("") für `valuName`.  
  
 Gültiges Stammzertifizierungsstellen-Namen sind HKEY_CURRENT_USER "," HKEY_LOCAL_MACHINE "," HKEY_CLASSES_ROOT "," HKEY_USERS "," HKEY_PERFORMANCE_DATA "," HKEY_CURRENT_CONFIG, und "HKEY_DYN_DATA. In Visual Basic greift z. B. die Zeichenfolge "HKEY_CURRENT_USER\MyTestKey" Schlüssel/Wert-Paare für den Unterschlüssel "MyTestKey" in den Stamm von HKEY_CURRENT_USER.  
  
 Wenn die <xref:Microsoft.Win32.RegistryKey.GetValue%2A> Methode ruft die Werte der erweiterbaren Zeichenfolge ab (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), erweitert er Umgebungszeichenfolgen mit Daten aus der lokalen Umgebung. Wenn Sie ein Wert mit der erweiterbaren verweisen auf Umgebungsvariablen als Zeichenfolge gespeichert wurde (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>), und nicht als erweiterbare Zeichenfolge (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), <xref:Microsoft.Win32.RegistryKey.GetValue%2A> nicht erweitert. Können Sie eine solche Zeichenfolge erweitern, nachdem sie durch den Aufruf abgerufen wurde die <xref:System.Environment.ExpandEnvironmentVariables%2A?displayProperty=nameWithType> Methode.  
  
> [!NOTE]
>  Die empfohlene Methode zum Abrufen von Daten aus HKEY_PERFORMANCE_DATA ist die Verwendung der <xref:System.Diagnostics.PerformanceCounter> Klasse anstelle der <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType> Methode.  
  
 Die <xref:Microsoft.Win32.Registry.GetValue%2A> und <xref:Microsoft.Win32.Registry.SetValue%2A> Methoden öffnen und schließen Registrierungsschlüssel, jedes Mal, sie verwendet werden, damit sie keine durchführen, sowie die Methoden der <xref:Microsoft.Win32.RegistryKey> Klasse, wenn Sie Zugriff auf eine große Anzahl von Werten.  
  
 <xref:Microsoft.Win32.RegistryKey> Außerdem bietet Methoden, mit die Sie einen Registrierungsschlüssel, um den Datentyp eines Werts zu testen, bevor Sie sie abrufen und Löschen von Schlüsseln eine Zugriffssteuerungsliste (ACL) hinzufügen können.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Werte verschiedener Datentypen in einem Beispielschlüssel, den Schlüssel erstellt, macht dies auch, und klicken Sie dann Ruft ab und zeigt die Werte gespeichert. Im Beispiel wird veranschaulicht, speichern und Abrufen von Standard (namenlos) Name/Wert-Paar, und die Verwendung von `defaultValue` Wenn Name/Wert-Paar ist nicht vorhanden.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen, um aus dem Registrierungsschlüssel zu lesen.</exception>
        <exception cref="T:System.IO.IOException">Der <see cref="T:Microsoft.Win32.RegistryKey" />, der den angegebenen Wert enthält, wurde zum Löschen markiert.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyName" /> beginnt nicht mit einem gültigen Registrierungsstamm.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">aus der Registrierung zu lesen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Um einen Registrierungsschlüssel vom Typ REG_EXPAND_SZ zu lesen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LocalMachine">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey LocalMachine;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey LocalMachine" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.LocalMachine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LocalMachine As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ LocalMachine;" />
      <MemberSignature Language="F#" Value=" staticval mutable LocalMachine : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.LocalMachine" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Speichert die Konfigurationsinformationen für den lokalen Computer. Dieses Feld liest den Basisschlüssel HKEY_LOCAL_MACHINE der Windows-Registrierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LocalMachine` enthält fünf Schlüssel:  
  
 Hardware  
 Beschreibt die physische Hardware des Computers, die Möglichkeit, die Gerätetreiber verwenden, Hardware, und die Zuordnungen und die zugehörigen Daten, die im Kernelmodus-Treiber mit Benutzermodus-Code zu verknüpfen. Alle Daten in diesem Schlüssel wird neu erstellt jedes Mal, wenn das System gestartet wird. Des Unterschlüssels "Beschreibung" wird beschrieben, die tatsächliche Computer-Hardware. Der Unterschlüssel DeviceMap enthält verschiedene Daten in Formaten, die spezifisch für bestimmte Klassen von Treibern. Der Unterschlüssel beschreibt ResourceMap, welche Gerätetreiber welche Hardwareressourcen beanspruchen. Das Windows NT-Diagnose-Programm (Winmsdp.exe) kann an seinen Inhalt in einem leicht lesbaren Formular melden.  
  
 SAM  
 Die Datenbank der Verzeichnisdienste der Sicherheitsinformationen, die für Benutzer- und Gruppenkonten und für die Domänen in Windows 2000 Server (SAM ist Security Account Manager, als die Directory Services-Datenbank bezeichnet).  
  
 Sicherheit  
 Enthält die lokale Sicherheitsrichtlinie, z. B. bestimmte Benutzerrechte. Dieser Schlüssel wird nur durch das Windows 2000-Subsystem verwendet.  
  
 Software  
 Die pro Computer Software-Datenbank. Dieser Schlüssel enthält Daten über Software, die auf dem lokalen Computer zusammen mit verschiedenen Elementen Konfigurationsdaten installiert.  
  
 System  
 Systemstart für Steuerelemente, das Laden der Gerätetreiber, Windows 2000-Diensten und das Verhalten des Betriebssystems.  
  
 Gemäß der Konvention, wie Daten unter vorhanden sind <xref:Microsoft.Win32.Registry.CurrentUser> und wählen Sie unter <xref:Microsoft.Win32.Registry.LocalMachine>, die Daten in <xref:Microsoft.Win32.Registry.CurrentUser> hat Vorrang vor. Allerdings können Werte in diesem Schlüssel auch erweitern (und Daten in Registry.LocalMachine nicht ersetzen). Darüber hinaus sind einige Elemente (z. B. Gerätetreiber Einträge laden) bedeutungslos, wenn sie außerhalb von Registry.LocalMachine auftreten.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie die Unterschlüssel des Schlüssels abrufen, und gibt deren Namen auf dem Bildschirm. Verwenden der <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> Methode zum Erstellen einer Instanz des betreffenden Unterschlüssels von Interesse sind. Anschließend können Sie andere Vorgänge im <xref:Microsoft.Win32.RegistryKey> diesen Schlüssel zu bearbeiten.  
  
 [!code-cpp[Classic Registry.LocalMachine Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.LocalMachine Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.LocalMachine Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformanceData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey PerformanceData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey PerformanceData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.PerformanceData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PerformanceData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ PerformanceData;" />
      <MemberSignature Language="F#" Value=" staticval mutable PerformanceData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.PerformanceData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Enthält Informationen zur Leistung für Softwarekomponenten. Dieses Feld liest den Basisschlüssel HKEY_PERFORMANCE_DATA der Windows-Registrierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jede Softwarekomponente erstellt für die Objekte, Leistungsindikatoren, wenn er installiert ist, und schreibt Daten, während es ausgeführt wird. Sie können diese Daten zugreifen, wie Sie alle anderen Registrierungsdaten mithilfe der <xref:Microsoft.Win32.RegistryKey> Funktionen.  
  
 Obwohl Sie die Registrierung verwenden, um Leistungsdaten zu sammeln, ist die Daten nicht in der Registrierungsdatenbank gespeichert. Stattdessen wird der Zugriff auf die Registrierung mit diesem Schlüssel das System zum Erfassen der Daten aus der entsprechenden Objekt-Manager.  
  
 Verwenden Sie zum Abrufen von Daten aus dem lokalen System die <xref:Microsoft.Win32.RegistryKey.GetValue%2A> Methode, mit dem Schlüssel Registry.PerformanceData. Beim erste Aufruf wird den Schlüssel (Sie müssen nicht explizit den Schlüssel zunächst öffnen) geöffnet. Achten Sie aber mit der <xref:Microsoft.Win32.RegistryKey.Close%2A> Methode, um das Handle für den Schlüssel zu schließen, wenn Sie nach dem Abrufen der Leistungsdaten sind. Der Benutzer kann nicht zu installieren oder entfernen eine Softwarekomponente, während Leistungsdaten verwendet werden.  
  
 Um Leistungsdaten von einem Remotesystem zu erhalten, müssen Sie verwenden die <xref:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey%2A> Methode, mit dem Computernamen das Remotesystem und dem Registry.PerformanceData-Schlüssel. Dieser Aufruf ruft einen Schlüssel, der die Leistungsdaten für das Remotesystem darstellt. Um die Daten abzurufen, rufen <xref:Microsoft.Win32.RegistryKey.GetValue%2A> statt diesen Schlüssel, den Registry.PerformanceData-Schlüssel.  
  
> [!NOTE]
>  Unter Windows Server 2003 muss ein Benutzer mindestens zu der Gruppe "Systemmonitorbenutzer" hinzu gehören, um auf Basis Unterschlüssel zugreifen.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie die Unterschlüssel des Schlüssels abrufen, und gibt deren Namen auf dem Bildschirm. Verwenden der <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> Methode zum Erstellen einer Instanz des betreffenden Unterschlüssels von Interesse sind. Anschließend können Sie andere Vorgänge im <xref:Microsoft.Win32.RegistryKey> diesen Schlüssel zu bearbeiten. Beachten Sie, dass in diesem Beispiel wird häufig keine Ergebnisse zurückgegeben werden, da gibt es möglicherweise keine Leistungsdaten.  
  
 [!code-cpp[Classic Registry.PerformanceData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.PerformanceData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.PerformanceData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt den Wert eines Name-/Wert-Paars in einem Registrierungsschlüssel fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel werden Werte verschiedener Datentypen in einem Beispielschlüssel, den Schlüssel erstellt, macht dies auch, und klicken Sie dann Ruft ab und zeigt die Werte gespeichert. Im Beispiel wird veranschaulicht, speichern und Abrufen von Standard (namenlos) Name/Wert-Paar, und die Verwendung von `defaultValue` Wenn Name/Wert-Paar ist nicht vorhanden.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="keyName">Der vollständige Registrierungspfad des Schlüssels, beginnend mit einem gültigen Registrierungsstamm (z. B. "HKEY_CURRENT_USER").</param>
        <param name="valueName">Der Name des Name-/Wert-Paars.</param>
        <param name="value">Der zu speichernde Wert.</param>
        <summary>Legt das angegebene Name-/Wert-Paar für den angegebenen Registrierungsschlüssel fest. Wenn der angegebene Schlüssel nicht vorhanden ist, wird er erstellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], wird die `valueName` Parameter ist nicht mehr auf ein Maximum von 255 Zeichen beschränkt jedoch den `keyName` Parameter fortgesetzt wird, auf 255 Zeichen beschränkt.  
  
 Da viele Werte in jedem Schlüssel in der Registrierung gespeichert werden können, müssen Sie verwenden die `valueName` Parameter zum Angeben eines bestimmten Werts festlegen möchten.  
  
> [!NOTE]
>  Ein Registrierungsschlüssel kann es sich um einen Wert enthalten, die nicht mit einem beliebigen Namen zugeordnet ist. Wenn es sich bei diesen unbenannten Wert in den Registrierungs-Editor angezeigt wird, wird die Zeichenfolge "(Standard)" anstelle eines Namens angezeigt. Um dies unbenannten Wert festzulegen, geben Sie entweder `null` oder eine leere Zeichenfolge ("") für `valueName`.  
  
 Wenn `valueName` existiert nicht in den Schlüssel, wird er erstellt und der zugehörige Wert wird festgelegt, um `value`.  
  
 Wenn `keyName` gibt einen Unterschlüssel, die nicht vorhanden ist, wird der Unterschlüssel im angegebenen Stammverzeichnis erstellt. Beispielsweise erstellt die Zeichenfolge "HKEY_CURRENT_USER\MyTestKey" in Visual Basic den Unterschlüssel "MyTestKey" in den Stamm von HKEY_CURRENT_USER. Die Zeichenfolge "HKEY_CURRENT_USER\MyTestKey\Key2\Key3" wird die geschachtelte Unterschlüssel "MyTestKey", "MyTestKey\Key2" und "MyTestKey\Key2\Key3" erstellt.  
  
 Gültiges Stammzertifizierungsstellen-Namen enthalten HKEY_CURRENT_USER "," HKEY_LOCAL_MACHINE "," HKEY_CLASSES_ROOT "," HKEY_USERS "," HKEY_PERFORMANCE_DATA "," HKEY_CURRENT_CONFIG, und "HKEY_DYN_DATA.  
  
> [!NOTE]
>  Die <xref:Microsoft.Win32.Registry.SetValue%2A> Methode öffnet einen Registrierungsschlüssel, legt den Wert fest und schließt den Schlüssel jedes Mal, die sie aufgerufen wird. Wenn Sie eine große Anzahl von Werten ändern müssen die <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> Methode bietet möglicherweise eine bessere Leistung. Die <xref:Microsoft.Win32.RegistryKey> Klasse stellt auch Methoden, mit denen Sie einen Registrierungsschlüssel, um den Datentyp eines Werts zu testen, bevor Sie sie abrufen und Löschen von Schlüsseln eine Zugriffssteuerungsliste (ACL) hinzufügen können.  
  
 Diese Überladung der <xref:Microsoft.Win32.Registry.SetValue%2A> 64-Bit-Ganzzahlen als Zeichenfolgen speichert (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>). Zum Speichern von 64-Bit-Zahlen als <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType> verwenden Sie die Werte, die <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> -methodenüberladung.  
  
 Diese Überladung der <xref:Microsoft.Win32.Registry.SetValue%2A> speichert alle Zeichenfolgenwerte als <xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType> Objekte, selbst wenn sie erweiterbare Verweise auf Umgebungsvariablen enthalten. Zum Speichern von Zeichenfolgenwerten als erweiterbarer Zeichenfolgen (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), verwenden Sie die <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> -methodenüberladung.  
  
 Diese Überladung entspricht dem Aufrufen der <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> methodenüberladung mit <xref:Microsoft.Win32.RegistryValueKind.Unknown?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Klicken Sie auf Windows 98 und Windows Millennium Edition (Windows Me) die Registrierung ist nicht Unicode und nicht alle Unicode-Zeichen sind für alle Codepages gültig. Ein Unicode-Zeichen, die für die aktuelle Codepage ungültig ist, wird durch die beste Übereinstimmung ersetzt. Es werden keine Ausnahmen ausgelöst.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Werte verschiedener Datentypen in einem Beispielschlüssel, den Schlüssel erstellt, macht dies auch, und klicken Sie dann Ruft ab und zeigt die Werte gespeichert. Im Beispiel wird veranschaulicht, speichern und Abrufen von Standard (namenlos) Name/Wert-Paar, und die Verwendung von `defaultValue` Wenn Name/Wert-Paar ist nicht vorhanden.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyName" /> beginnt nicht mit einem gültigen Registrierungsstamm.  
  
- oder -  
 <paramref name="keyName" /> überschreitet die maximal zulässige Länge (255 Zeichen).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Die <see cref="T:Microsoft.Win32.RegistryKey" />-Klasse ist schreibgeschützt. Es ist kein Schreibzugriff möglich, d. h., es handelt sich z. B. um einen Knoten auf Stammebene.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Erstellen oder Ändern von Registrierungsschlüsseln.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">den angegebene Registrierungsschlüssel zu ändern, falls vorhanden, oder die Registrierungsschlüssel zu erstellen, wenn es nicht bereits vorhanden ist. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value, Microsoft.Win32.RegistryValueKind valueKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value, valuetype Microsoft.Win32.RegistryValueKind valueKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object, valueKind As RegistryValueKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value, Microsoft::Win32::RegistryValueKind valueKind);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj * Microsoft.Win32.RegistryValueKind -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value, valueKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="valueKind" Type="Microsoft.Win32.RegistryValueKind" />
      </Parameters>
      <Docs>
        <param name="keyName">Der vollständige Registrierungspfad des Schlüssels, beginnend mit einem gültigen Registrierungsstamm (z. B. "HKEY_CURRENT_USER").</param>
        <param name="valueName">Der Name des Name-/Wert-Paars.</param>
        <param name="value">Der zu speichernde Wert.</param>
        <param name="valueKind">Der beim Speichern der Daten zu verwendende Registrierungsdatentyp.</param>
        <summary>Legt unter Verwendung des angegebenen Registrierungsdatentyps das Name-/Wert-Paar für den angegebenen Registrierungsschlüssel fest. Wenn der angegebene Schlüssel nicht vorhanden ist, wird er erstellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], `valueName` Parameter ist nicht mehr auf ein Maximum von 255 Zeichen beschränkt jedoch den `keyName` Parameter weiterhin auf 255 Zeichen beschränkt.  
  
 Da viele Werte in jedem Schlüssel in der Registrierung gespeichert werden können, müssen Sie verwenden die `valueName` Parameter zum Angeben eines bestimmten Werts festlegen möchten.  
  
> [!NOTE]
>  Ein Registrierungsschlüssel kann es sich um einen Wert enthalten, die nicht mit einem beliebigen Namen zugeordnet ist. Wenn es sich bei diesen unbenannten Wert in den Registrierungs-Editor angezeigt wird, wird die Zeichenfolge "(Standard)" anstelle eines Namens angezeigt. Um dies unbenannten Wert festzulegen, geben Sie entweder `null` oder eine leere Zeichenfolge ("") für `valueName`.  
  
 Wenn `valueName` existiert nicht in den Schlüssel, wird er erstellt und der zugehörige Wert wird festgelegt, um `value`.  
  
 Wenn `keyName` gibt einen Unterschlüssel, die nicht vorhanden ist, wird der Unterschlüssel im angegebenen Stammverzeichnis erstellt. Beispielsweise erstellt die Zeichenfolge "HKEY_CURRENT_USER\MyTestKey" in Visual Basic den Unterschlüssel "MyTestKey" in den Stamm von HKEY_CURRENT_USER. Die Zeichenfolge "HKEY_CURRENT_USER\MyTestKey\Key2\Key3" wird die geschachtelte Unterschlüssel "MyTestKey", "MyTestKey\Key2" und "MyTestKey\Key2\Key3" erstellt.  
  
 Gültiges Stammzertifizierungsstellen-Namen enthalten HKEY_CURRENT_USER "," HKEY_LOCAL_MACHINE "," HKEY_CLASSES_ROOT "," HKEY_USERS "," HKEY_PERFORMANCE_DATA "," HKEY_CURRENT_CONFIG, und "HKEY_DYN_DATA.  
  
> [!NOTE]
>  Die <xref:Microsoft.Win32.Registry.SetValue%2A> Methode öffnet einen Registrierungsschlüssel, legt den Wert fest und schließt den Schlüssel jedes Mal, die sie aufgerufen wird. Wenn Sie eine große Anzahl von Werten ändern müssen die <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> Methode bietet möglicherweise eine bessere Leistung. Die <xref:Microsoft.Win32.RegistryKey> Klasse stellt auch Methoden, mit denen Sie einen Registrierungsschlüssel, um den Datentyp eines Werts zu testen, bevor Sie sie abrufen und Löschen von Schlüsseln eine Zugriffssteuerungsliste (ACL) hinzufügen können.  
  
 Wenn der Typ des angegebenen `value` entspricht nicht dem angegebenen `valueKind`, und die Daten können nicht konvertiert, <xref:System.ArgumentException> ausgelöst. Sie können z. B. Speichern einer <xref:System.Int64?displayProperty=nameWithType> als eine <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>, jedoch nur, wenn sein Wert kleiner als der Maximalwert ist eine <xref:System.Int32?displayProperty=nameWithType>. Kann nicht gespeichert werden als einen einzelnen Zeichenfolgenwert ein <xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Wenn geschachtelte Werte übergeben werden, für die <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType> oder <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>, die Konvertierung erfolgt mit der invarianten Kultur.  
  
> [!NOTE]
>  Klicken Sie auf Windows 98 und Windows Millennium Edition (Windows Me) die Registrierung ist nicht Unicode und nicht alle Unicode-Zeichen sind für alle Codepages gültig. Ein Unicode-Zeichen, die für die aktuelle Codepage ungültig ist, wird durch die beste Übereinstimmung ersetzt. Es werden keine Ausnahmen ausgelöst.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Werte verschiedener Datentypen in einem Beispielschlüssel, den Schlüssel erstellt, macht dies auch, und klicken Sie dann Ruft ab und zeigt die Werte gespeichert. Im Beispiel wird veranschaulicht, speichern und Abrufen von Standard (namenlos) Name/Wert-Paar, und die Verwendung von `defaultValue` Wenn Name/Wert-Paar ist nicht vorhanden.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyName" /> beginnt nicht mit einem gültigen Registrierungsstamm.  
  
- oder -  
 <paramref name="keyName" /> überschreitet die maximal zulässige Länge (255 Zeichen).  
  
- oder -  
Der Typ von <paramref name="value" /> stimmt nicht mit dem durch <paramref name="valueKind" /> angegebenen Registrierungsdatentyp überein. Die Daten konnten daher nicht ordnungsgemäß konvertiert werden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der <see cref="T:Microsoft.Win32.RegistryKey" /> ist schreibgeschützt. Es ist kein Schreibzugriff möglich, d. h. es handelt sich z. B. um einen Knoten auf Stammebene oder um einen Schlüssel, der nicht mit Schreibzugriff geöffnet wurde.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Erstellen oder Ändern von Registrierungsschlüsseln.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">den angegebene Registrierungsschlüssel zu ändern, falls vorhanden, oder die Registrierungsschlüssel zu erstellen, wenn es nicht bereits vorhanden ist. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Users">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey Users;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey Users" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.Users" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Users As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ Users;" />
      <MemberSignature Language="F#" Value=" staticval mutable Users : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.Users" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Enthält Informationen über die Standardkonfiguration des Benutzer. Dieses Feld liest den Basisschlüssel HKEY_USERS der Windows-Registrierung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Schlüssel enthält einen Branch für jeden Benutzer des Computers. Die Standardkonfiguration ist für neue Benutzer auf dem lokalen Computer und für den aktuellen Standardbenutzer bereitgestellt, wenn der Benutzer Einstellungen nicht geändert hat. Da Windows 98 / ME unterstützt auch Registry.Users, Anwendungen können die benutzerspezifische Informationen die gleiche Weise, wie unter Windows 2000 zugreifen. Jedes Benutzers-Informationen werden in einer separaten Datei gespeichert, die lokal oder auf einem Netzwerkserver gespeichert werden können. Windows 98 / ME können kopieren Sie diese Datei zum aktuellen System des Benutzers, damit Einstellungen mit dem Benutzer von einem Computer auf einen anderen verschieben können.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie die Unterschlüssel des Schlüssels abrufen, und gibt deren Namen auf dem Bildschirm. Verwenden der <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> Methode zum Erstellen einer Instanz des betreffenden Unterschlüssels von Interesse sind. Anschließend können Sie andere Vorgänge im <xref:Microsoft.Win32.RegistryKey> diesen Schlüssel zu bearbeiten.  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>