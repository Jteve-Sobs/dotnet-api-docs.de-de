<Type Name="Registry" FullName="Microsoft.Win32.Registry">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d3285d1e778628339c22d54f5aec6bdd96ffc281" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36725557" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Registry" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Registry extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.Registry" />
  <TypeSignature Language="VB.NET" Value="Public Class Registry" />
  <TypeSignature Language="C++ CLI" Value="public ref class Registry abstract sealed" />
  <TypeSignature Language="F#" Value="type Registry = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides <see cref="T:Microsoft.Win32.RegistryKey" /> objects that represent the root keys in the Windows registry, and <see langword="static" /> methods to access key/value pairs.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Klasse stellt den Satz von standard-Stammzertifizierungsstellen Schlüssel gefunden wird, in der Registrierung auf Computern, auf denen Windows ausgeführt wird. Die Registrierung ist eine Aufbewahrung Informationen zu Anwendungen, Benutzer und System-Standardeinstellungen. Beispielsweise können Anwendungen verwenden Sie die Registrierung zum Speichern von Informationen, die nach dem Schließen der Anwendung beibehalten werden muss, und die gleiche Informationen zugreifen, wenn die Anwendung geladen wird. Sie können z. B. Farbe Voreinstellungen, Bildschirmpositionen oder die Größe des Fensters speichern. Sie können diese Daten für jeden Benutzer steuern, indem Sie die Informationen in einem anderen Speicherort in der Registrierung gespeichert.  
  
 Die Basis- oder Stammnamespace <xref:Microsoft.Win32.RegistryKey> Instanzen, die von verfügbar gemacht werden die `Registry` Klasse skizziert werden die grundlegenden Speichermechanismus für Unterschlüssel und Werte in der Registrierung. Alle Schlüssel sind schreibgeschützt, da die Registrierung von deren Existenz abhängt. Die Schlüssel verfügbar gemacht werden, indem `Registry` sind:  
  
 <xref:Microsoft.Win32.Registry.CurrentUser>  
 Speichert Informationen zu den benutzereinstellungen.  
  
 <xref:Microsoft.Win32.Registry.LocalMachine>  
 Speichert die Konfigurationsinformationen für den lokalen Computer.  
  
 <xref:Microsoft.Win32.Registry.ClassesRoot>  
 Speichert Informationen über Typen (oder Klassen) und ihre Eigenschaften.  
  
 <xref:Microsoft.Win32.Registry.Users>  
 Speichert Informationen über die Standardkonfiguration für den Benutzer.  
  
 <xref:Microsoft.Win32.Registry.PerformanceData>  
 Speichert Leistungsinformationen für Softwarekomponenten an.  
  
 <xref:Microsoft.Win32.Registry.CurrentConfig>  
 Speichert Hardwareinformationen für nicht-benutzerspezifische.  
  
 <xref:Microsoft.Win32.Registry.DynData>  
 Dynamische Daten gespeichert.  
  
 Nachdem Sie den Stammschlüssel identifiziert haben, unter dem Store/Informationen aus der Registrierung abgerufen werden sollen, können Sie die <xref:Microsoft.Win32.RegistryKey> -Klasse zum Hinzufügen oder Entfernen der Unterschlüssel, und bearbeiten Sie die Werte für einen bestimmten Schlüssel.  
  
 Hardwaregeräte können Informationen in der Registrierung automatisch mit der Plug & Play-Schnittstelle platzieren. Software für die Installation von Gerätetreibern kann Informationen in der Registrierung durch Schreiben in standard-APIs platzieren.  
  
## <a name="static-methods-for-getting-and-setting-values"></a>Statische Methoden zum Abrufen und Festlegen von Werten  
 In .NET Framework, Version 2.0 die <xref:Microsoft.Win32.Registry> Klasse enthält auch `static` <xref:Microsoft.Win32.Registry.GetValue%2A> und <xref:Microsoft.Win32.Registry.SetValue%2A> Methoden zum Festlegen und Abrufen von Werten von Registrierungsschlüsseln. Diese Methoden öffnen und schließen Registrierungsschlüssel jede Zeit, sie verwendet werden, damit sie keine durchführen, sowie analoge Methoden in der <xref:Microsoft.Win32.RegistryKey> Klasse, die beim Zugriff auf eine große Anzahl von Werten.  
  
 Die <xref:Microsoft.Win32.RegistryKey> Klasse bietet auch Methoden, die Ihnen ermöglichen, legen Sie die Windows-zugriffssteuerungssicherheit für den Registrierungsschlüssel, um den Datentyp eines Werts zu testen, bevor sie abrufen und Schlüssel zu löschen.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Das erste Beispiel veranschaulicht den Stammschlüssel, und das zweite Beispiel veranschaulicht die `static` <xref:Microsoft.Win32.Registry.GetValue%2A> und <xref:Microsoft.Win32.Registry.SetValue%2A> Methoden.  
  
 Beispiel 1  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Unterschlüssel des Schlüssels HKEY_USERS abgerufen und Drucken ihren Namen auf dem Bildschirm. Verwenden der <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> Methode zum Erstellen einer Instanz des betreffenden Unterschlüssels von Interesse sind. Anschließend können Sie andere Vorgänge in `RegistryKey` diesen Schlüssel zu bearbeiten.  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 Beispiel 2  
  
 Im folgenden Codebeispiel wird speichert Werte verschiedener Datentypen in eine Beispielschlüssel, die beim Erstellen des Schlüssels, da es tut, und klicken Sie dann Ruft ab und die Werte zeigt an. Im Beispiel wird veranschaulicht, speichern und Abrufen der Standardwert (namenlos) Name/Wert-Paar sowie die Verwendung von `defaultValue` Wenn ein Name/Wert-Paar ist nicht vorhanden.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.RegistryHive" />
    <altmember cref="T:Microsoft.Win32.RegistryKey" />
  </Docs>
  <Members>
    <Member MemberName="ClassesRoot">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey ClassesRoot;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey ClassesRoot" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.ClassesRoot" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClassesRoot As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ ClassesRoot;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClassesRoot : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.ClassesRoot" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Defines the types (or classes) of documents and the properties associated with those types. This field reads the Windows registry base key HKEY_CLASSES_ROOT.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sowohl herkömmliche und OLE-Anwendungen verwenden die Daten, die unter diesem Schlüssel gespeichert ist. Dieser Schlüssel stellt auch Abwärtskompatibilität mit der Windows 3.1-Registrierungsdatenbank durch Speichern von Informationen für DDE und OLE-Unterstützung bereit. Dateianzeige und Benutzererweiterungen-Schnittstelle, speichern ihre OLE-Klassenbezeichner in diesem Schlüssel und Verarbeitungsserver sind in diesem Schlüssel registriert.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht das Abrufen der Unterschlüssel, und gibt deren Namen auf dem Bildschirm. Verwenden der <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> Methode zum Erstellen einer Instanz des betreffenden Unterschlüssels von Interesse sind. Anschließend können Sie andere Vorgänge in <xref:Microsoft.Win32.RegistryKey> diesen Schlüssel zu bearbeiten.  
  
 [!code-cpp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.ClassesRoot Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentConfig">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentConfig;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentConfig" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentConfig" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentConfig As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentConfig;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentConfig : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentConfig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contains configuration information pertaining to the hardware that is not specific to the user. This field reads the Windows registry base key HKEY_CURRENT_CONFIG.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member wird in einen Unterschlüssel zugeordnet <xref:Microsoft.Win32.Registry.LocalMachine>.  
  
 Ein Beispiel zur Verwendung dieses Members ist eine Anwendung, die speichert einen anderen Servernamen für ihre Daten, je nachdem, ob das System mit einem Netzwerk verbunden ist.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht das Abrufen der Unterschlüssel, und gibt deren Namen auf dem Bildschirm. Verwenden der <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> Methode zum Erstellen einer Instanz des betreffenden Unterschlüssels von Interesse sind. Anschließend können Sie andere Vorgänge in <xref:Microsoft.Win32.RegistryKey> diesen Schlüssel zu bearbeiten.  
  
 [!code-cpp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentConfig Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUser">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentUser;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentUser" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentUser" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentUser As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentUser;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentUser : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentUser" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contains information about the current user preferences. This field reads the Windows registry base key HKEY_CURRENT_USER</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In diesem Schlüssel gespeicherten Informationen enthält die Einstellungen der Umgebungsvariablen und die Daten über die Programmgruppen, Farben, Drucker, Netzwerkverbindungen und Anwendungseinstellungen. Dieser Schlüssel erleichtert die Einstellungen des aktuellen Benutzers herstellen. In diesem Schlüssel speichern Softwareherstellern Einstellungen für die aktuelle benutzerspezifische in ihren Anwendungen verwendet werden. Microsoft, erstellt z. B. den HKEY_CURRENT_USER\Software\Microsoft-Schlüssel für ihre Anwendungen mit jeder Anwendung, erstellen einen eigenen Unterschlüssel unter dem Schlüssel von Microsoft verwenden.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht das Abrufen der Unterschlüssel, und gibt deren Namen auf dem Bildschirm. Verwenden der <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> Methode zum Erstellen einer Instanz des betreffenden Unterschlüssels von Interesse sind. Anschließend können Sie andere Vorgänge in <xref:Microsoft.Win32.RegistryKey> diesen Schlüssel zu bearbeiten.  
  
 [!code-cpp[Classic Registry.CurrentUser Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentUser Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentUser Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey DynData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey DynData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.DynData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DynData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ DynData;" />
      <MemberSignature Language="F#" Value=" staticval mutable DynData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.DynData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use PerformanceData instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contains dynamic registry data. This field reads the Windows registry base key HKEY_DYN_DATA.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Registrierung von Windows 98 und Windows Me unterstützt sowohl statische Daten (die auf dem Datenträger in der Registrierung gespeichert ist) als auch dynamische Daten (die häufig, z. B. Leistungsstatistiken ändert). Diese dynamische Datenbereich ist der Mechanismus, der mit virtuellen Gerätetreibern (VxDs) zum Bereitstellen von Daten in Echtzeit kann in Win32-Anwendungen, die als auch lokal ausgeführt werden können. Darüber hinaus können den Systemmonitor Leistungsstatistiken auf Windows 98 und Windows Me Remotesystemen bereitstellen.  
  
 VxDs sind nicht auf Leistungsdaten beschränkt. Sie können keine Daten bereitstellen, die sie aus Ring 0 an Ring 3 effizient zu übergeben, ohne beanspruchen die CPU möchten. Die Registrierung unterstützt dynamische Daten synchronisierungsleistung, da einen Zeiger auf eine Funktion, die einen Wert (oder viele Werte) zurückgibt. Beim Abfragen einer Registrierungswerte-Aufruf verknüpft sind mit einem dynamischen Schlüssel, dass die Funktion aufgerufen wird, um den gewünschten Wert bzw. Werte zurückzugeben.  
  
> [!NOTE]
>  Dynamische Schlüssel wurden in Microsoft Windows 95, dynamische Registrierungsdaten behandeln eingeführt. Sie werden nur in Windows 98 und Windows Me unterstützt.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht das Abrufen der Unterschlüssel, und gibt deren Namen auf dem Bildschirm. Verwenden der <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> Methode zum Erstellen einer Instanz des betreffenden Unterschlüssels von Interesse sind. Anschließend können Sie andere Vorgänge in <xref:Microsoft.Win32.RegistryKey> diesen Schlüssel zu bearbeiten. Beachten Sie, dass in diesem Beispiel keine Ergebnisse zurückgeben kann, da möglicherweise keine dynamische Daten verfügbar, oder Sie möglicherweise nicht Windows 98 führen / Me. Mithilfe dieses Schlüssels kann dazu führen, dass einen Fehler auf anderen Systemen.  
  
 [!code-cpp[Classic Registry.DynData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.DynData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.DynData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.DynData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The operating system does not support dynamic data; that is, it is not Windows 98, Windows 98 Second Edition, or Windows Millennium Edition (Windows Me).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public static object GetValue (string keyName, string valueName, object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetValue(string keyName, string valueName, object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetValue (keyName As String, valueName As String, defaultValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member GetValue : string * string * obj -&gt; obj" Usage="Microsoft.Win32.Registry.GetValue (keyName, valueName, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="keyName">The full registry path of the key, beginning with a valid registry root, such as "HKEY_CURRENT_USER".</param>
        <param name="valueName">The name of the name/value pair.</param>
        <param name="defaultValue">The value to return if <c>valueName</c> does not exist.</param>
        <summary>Retrieves the value associated with the specified name, in the specified registry key. If the name is not found in the specified key, returns a default value that you provide, or <see langword="null" /> if the specified key does not exist.</summary>
        <returns>
          <see langword="null" /> if the subkey specified by <paramref name="keyName" /> does not exist; otherwise, the value associated with <paramref name="valueName" />, or <paramref name="defaultValue" /> if <paramref name="valueName" /> is not found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Zeichenfolge `valueName` ist nicht in der Groß-/Kleinschreibung beachtet.  
  
> [!NOTE]
>  Ein Registrierungsschlüssel kann einen Wert enthalten, die nicht mit einem beliebigen Namen verknüpft ist. Wenn dies der unbenannten Wert in den Registrierungs-Editor angezeigt wird, wird die Zeichenfolge "(Standard)" anstelle eines Namens angezeigt. Um diesen unbenannten Wert abzurufen, geben Sie entweder `null` oder eine leere Zeichenfolge ("") für `valuName`.  
  
 Gültiges Stammzertifizierungsstellen-Namen sind HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG und HKEY_DYN_DATA. In Visual Basic greift z. B. die Zeichenfolge "HKEY_CURRENT_USER\MyTestKey" Schlüssel/Wert-Paare für den Unterschlüssel "MyTestKey" im Stamm HKEY_CURRENT_USER an.  
  
 Wenn die <xref:Microsoft.Win32.RegistryKey.GetValue%2A> Methode ruft erweiterbare Zeichenfolgenwerte ab (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), erweitert es Umgebungszeichenfolgen mit Daten aus der lokalen Umgebung. Wenn Sie ein Wert mit erweiterbare Verweise auf Umgebungsvariablen als Zeichenfolge gespeichert wurde (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>), und nicht als eine erweiterbare Zeichenfolge (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), <xref:Microsoft.Win32.RegistryKey.GetValue%2A> nicht erweitert. Solch eine Zeichenfolge können erweitert werden, nach dem Abruf durch den Aufruf der <xref:System.Environment.ExpandEnvironmentVariables%2A?displayProperty=nameWithType> Methode.  
  
> [!NOTE]
>  Die empfohlene Methode zum Abrufen von Daten aus HKEY_PERFORMANCE_DATA ist die Verwendung der <xref:System.Diagnostics.PerformanceCounter> Klasse statt auf den <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType> Methode.  
  
 Die <xref:Microsoft.Win32.Registry.GetValue%2A> und <xref:Microsoft.Win32.Registry.SetValue%2A> Methoden öffnen und schließen Registrierungsschlüssel jedes Mal, sie verwendet werden, damit sie keine durchführen, sowie die Methoden der <xref:Microsoft.Win32.RegistryKey> Klasse, wenn Sie eine große Anzahl von Werten zugreifen.  
  
 <xref:Microsoft.Win32.RegistryKey> Außerdem bietet Methoden, mit die Sie einen Registrierungsschlüssel, so testen Sie den Datentyp eines Werts vor dem Abrufen und Löschen von Schlüsseln eine Zugriffssteuerungsliste (ACL) hinzufügen können.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird speichert Werte verschiedener Datentypen in eine Beispielschlüssel, die beim Erstellen des Schlüssels, da es tut, und klicken Sie dann Ruft ab und die Werte zeigt an. Im Beispiel wird veranschaulicht, speichern und Abrufen der Standardwert (namenlos) Name/Wert-Paar sowie die Verwendung von `defaultValue` Wenn ein Name/Wert-Paar ist nicht vorhanden.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to read from the registry key.</exception>
        <exception cref="T:System.IO.IOException">The <see cref="T:Microsoft.Win32.RegistryKey" /> that contains the specified value has been marked for deletion.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyName" /> does not begin with a valid registry root.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">aus der Registrierung zu lesen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Um einen Registrierungsschlüssel des Typs REG_EXPAND_SZ zu lesen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LocalMachine">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey LocalMachine;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey LocalMachine" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.LocalMachine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LocalMachine As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ LocalMachine;" />
      <MemberSignature Language="F#" Value=" staticval mutable LocalMachine : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.LocalMachine" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contains the configuration data for the local machine. This field reads the Windows registry base key HKEY_LOCAL_MACHINE.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LocalMachine` enthält fünf Schlüssel:  
  
 Hardware  
 Beschreibt die physische Hardware auf dem Computer, die Art der Verwendung von Gerätetreibern, Hardware und die Zuordnungen und die verknüpften Daten, die Kernelmodustreiber mit Benutzermoduscode verknüpfen. Alle Daten in diesem Schlüssel wird neu erstellt jedes Mal, wenn das System gestartet wird. Der Unterschlüssel Description beschreibt die eigentliche Computerhardware. Der Unterschlüssel DeviceMap enthält verschiedene Daten in Formaten, die spezifisch für bestimmte Klassen von Treibern. Der Unterschlüssel beschreibt ResourceMap, welche Gerätetreiber welche Hardwareressourcen Anspruch. Das Windows NT-Diagnose-Programm (Winmsdp.exe) kann an seinen Inhalt in einem einfach zu lesende Formular melden.  
  
 SAM  
 Die Datenbank der Verzeichnisdienste der Sicherheitsinformationen für Benutzer- und Gruppenkonten und für die Domänen in Windows 2000 Server (SAM ist die Sicherheit die Sicherheitskontenverwaltung, als das Directory Services-Datenbank bezeichnet).  
  
 Sicherheit  
 Enthält die lokale Sicherheitsrichtlinie, z. B. bestimmte Benutzerrechte. Dieser Schlüssel wird nur von Windows 2000-Sicherheitssubsystem verwendet.  
  
 Software  
 Die pro Computer Software-Datenbank. Dieser Schlüssel enthält Daten zur Software, die auf dem lokalen Computer, zusammen mit verschiedenen Elemente von sonstige Konfigurationsdaten installiert.  
  
 System  
 Steuerelemente des Systemstarts, das Laden der Gerätetreiber, Windows 2000-Dienste und das Verhalten des Betriebssystems.  
  
 Gemäß der Konvention werden ähnliche Daten im vorhanden <xref:Microsoft.Win32.Registry.CurrentUser> und wählen Sie unter <xref:Microsoft.Win32.Registry.LocalMachine>, die Daten in <xref:Microsoft.Win32.Registry.CurrentUser> hat Vorrang vor. Allerdings können Werte in diesem Schlüssel auch erweitern (Daten in Registry.LocalMachine statt Ersetzen). Darüber hinaus sind einige Elemente (z. B. Gerätetreiber Einträge laden) bedeutungslos, wenn sie außerhalb von Registry.LocalMachine auftreten.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht das Abrufen der Unterschlüssel, und gibt deren Namen auf dem Bildschirm. Verwenden der <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> Methode zum Erstellen einer Instanz des betreffenden Unterschlüssels von Interesse sind. Anschließend können Sie andere Vorgänge in <xref:Microsoft.Win32.RegistryKey> diesen Schlüssel zu bearbeiten.  
  
 [!code-cpp[Classic Registry.LocalMachine Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.LocalMachine Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.LocalMachine Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformanceData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey PerformanceData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey PerformanceData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.PerformanceData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PerformanceData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ PerformanceData;" />
      <MemberSignature Language="F#" Value=" staticval mutable PerformanceData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.PerformanceData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contains performance information for software components. This field reads the Windows registry base key HKEY_PERFORMANCE_DATA.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jede Softwarekomponente erstellt Schlüssel für seine Objekte, Leistungsindikatoren, wenn er installiert ist, und schreibt Leistungsindikatordaten erfasst werden, während er ausgeführt wird. Sie können diese Daten zugreifen, wie andere Registrierungsdaten mithilfe der <xref:Microsoft.Win32.RegistryKey> Funktionen.  
  
 Obwohl Sie die Registrierung zum Sammeln von Leistungsdaten verwenden, ist die Daten nicht in der Registrierungsdatenbank gespeichert. Stattdessen bewirkt, dass Zugriff auf die Registrierung mit diesem Schlüssel das System zum Erfassen der Daten aus der entsprechenden Objekt-Manager.  
  
 Verwenden Sie zum Abrufen von Daten aus dem lokalen System die <xref:Microsoft.Win32.RegistryKey.GetValue%2A> Methode mit dem Schlüssel Registry.PerformanceData. Beim erste Aufruf wird den Schlüssel (Sie müssen nicht explizit zuerst öffnen, den Schlüssel) geöffnet. Allerdings werden Sie unbedingt die <xref:Microsoft.Win32.RegistryKey.Close%2A> Methode, um das Handle für den Schlüssel zu schließen, wenn Sie nach dem Erhalt der Leistungsdaten sind. Der Benutzer nicht installieren oder entfernen eine Softwarekomponente, während Leistungsdaten verwendet werden.  
  
 Um Leistungsdaten von einem Remotesystem zu erhalten, verwenden Sie die <xref:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey%2A> Methode mit den Namen des remote-System und dem Schlüssel Registry.PerformanceData. Dieser Aufruf ruft einen Schlüssel, der die Leistungsdaten für den remote-System darstellt. Um die Daten abzurufen, rufen Sie <xref:Microsoft.Win32.RegistryKey.GetValue%2A> über diesen Schlüssel, statt über dem Schlüssel Registry.PerformanceData.  
  
> [!NOTE]
>  Unter Windows Server 2003 muss ein Benutzer mindestens der Gruppe Systemmonitorbenutzer angehören, Zugriff auf Basis Unterschlüssel.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht das Abrufen der Unterschlüssel, und gibt deren Namen auf dem Bildschirm. Verwenden der <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> Methode zum Erstellen einer Instanz des betreffenden Unterschlüssels von Interesse sind. Anschließend können Sie andere Vorgänge in <xref:Microsoft.Win32.RegistryKey> diesen Schlüssel zu bearbeiten. Beachten Sie, dass in diesem Beispiel wird häufig keine Ergebnisse zurückgegeben werden, da möglicherweise keine Leistungsdaten.  
  
 [!code-cpp[Classic Registry.PerformanceData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.PerformanceData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.PerformanceData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sets the value of a name/value pair in a registry key.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird speichert Werte verschiedener Datentypen in eine Beispielschlüssel, die beim Erstellen des Schlüssels, da es tut, und klicken Sie dann Ruft ab und die Werte zeigt an. Im Beispiel wird veranschaulicht, speichern und Abrufen der Standardwert (namenlos) Name/Wert-Paar sowie die Verwendung von `defaultValue` Wenn ein Name/Wert-Paar ist nicht vorhanden.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="keyName">The full registry path of the key, beginning with a valid registry root, such as "HKEY_CURRENT_USER".</param>
        <param name="valueName">The name of the name/value pair.</param>
        <param name="value">The value to be stored.</param>
        <summary>Sets the specified name/value pair on the specified registry key. If the specified key does not exist, it is created.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], die `valueName` Parameter ist nicht mehr auf maximal 255 Zeichen beschränkt, jedoch die `keyName` Parameter weiterhin auf 255 Zeichen beschränkt.  
  
 Da viele Werte in jedem Schlüssel in der Registrierung gespeichert werden können, müssen Sie verwenden die `valueName` Parameter zum Angeben eines bestimmten Werts festgelegt werden sollen.  
  
> [!NOTE]
>  Ein Registrierungsschlüssel kann einen Wert enthalten, die nicht mit einem beliebigen Namen verknüpft ist. Wenn dies der unbenannten Wert in den Registrierungs-Editor angezeigt wird, wird die Zeichenfolge "(Standard)" anstelle eines Namens angezeigt. Um diesen unbenannten Wert festzulegen, geben Sie entweder `null` oder eine leere Zeichenfolge ("") für `valueName`.  
  
 Wenn `valueName` existiert nicht im Schlüssel erstellt und der zugehörige Wert wird festgelegt, um `value`.  
  
 Wenn `keyName` einen Unterschlüssel, die nicht vorhanden ist, gibt der Unterschlüssel ist im angegebenen Stammverzeichnis erstellt. Beispielsweise wird die Zeichenfolge "HKEY_CURRENT_USER\MyTestKey" in Visual Basic den Unterschlüssel "MyTestKey" im Stamm HKEY_CURRENT_USER erstellt. Die Zeichenfolge "HKEY_CURRENT_USER\MyTestKey\Key2\Key3" erstellt die geschachtelten Unterschlüssel "MyTestKey", "MyTestKey\Key2" und "MyTestKey\Key2\Key3".  
  
 Gültiges Stammzertifizierungsstellen-Namen enthalten HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG und HKEY_DYN_DATA.  
  
> [!NOTE]
>  Die <xref:Microsoft.Win32.Registry.SetValue%2A> -Methode öffnet einen Registrierungsschlüssel, legt den Wert fest, und schließt den Schlüssel jedes Mal aufgerufen wird. Wenn Sie eine große Anzahl von Werten ändern müssen die <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> Methode bietet möglicherweise eine bessere Leistung. Die <xref:Microsoft.Win32.RegistryKey> Klasse bietet auch Methoden, mit denen Sie einen Registrierungsschlüssel, so testen Sie den Datentyp eines Werts vor dem Abrufen und Löschen von Schlüsseln eine Zugriffssteuerungsliste (ACL) hinzufügen können.  
  
 Diese Überladung der <xref:Microsoft.Win32.Registry.SetValue%2A> 64-Bit-Ganzzahlen als Zeichenfolgen speichert (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>). Zum Speichern von 64-Bit-Zahlen als <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType> verwenden Sie die Werte, die <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> -methodenüberladung.  
  
 Diese Überladung der <xref:Microsoft.Win32.Registry.SetValue%2A> speichert alle Zeichenfolgenwerte als <xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType> Objekte, selbst wenn sie erweiterbare Verweise auf Umgebungsvariablen enthalten. Zum Speichern von Zeichenfolgenwerten als erweiterbarer Zeichenfolgen (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), verwenden Sie die <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> -methodenüberladung.  
  
 Diese Überladung entspricht dem Aufrufen der <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> methodenüberladung mit <xref:Microsoft.Win32.RegistryValueKind.Unknown?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Unter Windows 98 und Windows Millennium Edition (Windows Me) die Registrierung ist nicht Unicode, und nicht alle Unicode-Zeichen sind für alle Codepages gültig. Ein Unicode-Zeichen, die für die aktuelle Codepage ungültig ist, wird durch die beste Übereinstimmung ersetzt. Es werden keine Ausnahmen ausgelöst.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird speichert Werte verschiedener Datentypen in eine Beispielschlüssel, die beim Erstellen des Schlüssels, da es tut, und klicken Sie dann Ruft ab und die Werte zeigt an. Im Beispiel wird veranschaulicht, speichern und Abrufen der Standardwert (namenlos) Name/Wert-Paar sowie die Verwendung von `defaultValue` Wenn ein Name/Wert-Paar ist nicht vorhanden.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyName" /> does not begin with a valid registry root.  -or-  <paramref name="keyName" /> is longer than the maximum length allowed (255 characters).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The <see cref="T:Microsoft.Win32.RegistryKey" /> is read-only, and thus cannot be written to; for example, it is a root-level node.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to create or modify registry keys.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">den angegebene Registrierungsschlüssel zu ändern, wenn er vorhanden ist, oder der Registrierungsschlüssel erstellt, wenn sie nicht bereits vorhanden ist. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value, Microsoft.Win32.RegistryValueKind valueKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value, valuetype Microsoft.Win32.RegistryValueKind valueKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object, valueKind As RegistryValueKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value, Microsoft::Win32::RegistryValueKind valueKind);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj * Microsoft.Win32.RegistryValueKind -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value, valueKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="valueName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="valueKind" Type="Microsoft.Win32.RegistryValueKind" />
      </Parameters>
      <Docs>
        <param name="keyName">The full registry path of the key, beginning with a valid registry root, such as "HKEY_CURRENT_USER".</param>
        <param name="valueName">The name of the name/value pair.</param>
        <param name="value">The value to be stored.</param>
        <param name="valueKind">The registry data type to use when storing the data.</param>
        <summary>Sets the name/value pair on the specified registry key, using the specified registry data type. If the specified key does not exist, it is created.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], die `valueName` Parameter ist nicht mehr auf maximal 255 Zeichen beschränkt, jedoch die `keyName` Parameter weiterhin auf 255 Zeichen beschränkt.  
  
 Da viele Werte in jedem Schlüssel in der Registrierung gespeichert werden können, müssen Sie verwenden die `valueName` Parameter zum Angeben eines bestimmten Werts festgelegt werden sollen.  
  
> [!NOTE]
>  Ein Registrierungsschlüssel kann einen Wert enthalten, die nicht mit einem beliebigen Namen verknüpft ist. Wenn dies der unbenannten Wert in den Registrierungs-Editor angezeigt wird, wird die Zeichenfolge "(Standard)" anstelle eines Namens angezeigt. Um diesen unbenannten Wert festzulegen, geben Sie entweder `null` oder eine leere Zeichenfolge ("") für `valueName`.  
  
 Wenn `valueName` existiert nicht im Schlüssel erstellt und der zugehörige Wert wird festgelegt, um `value`.  
  
 Wenn `keyName` einen Unterschlüssel, die nicht vorhanden ist, gibt der Unterschlüssel ist im angegebenen Stammverzeichnis erstellt. Beispielsweise wird die Zeichenfolge "HKEY_CURRENT_USER\MyTestKey" in Visual Basic den Unterschlüssel "MyTestKey" im Stamm HKEY_CURRENT_USER erstellt. Die Zeichenfolge "HKEY_CURRENT_USER\MyTestKey\Key2\Key3" erstellt die geschachtelten Unterschlüssel "MyTestKey", "MyTestKey\Key2" und "MyTestKey\Key2\Key3".  
  
 Gültiges Stammzertifizierungsstellen-Namen enthalten HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG und HKEY_DYN_DATA.  
  
> [!NOTE]
>  Die <xref:Microsoft.Win32.Registry.SetValue%2A> -Methode öffnet einen Registrierungsschlüssel, legt den Wert fest, und schließt den Schlüssel jedes Mal aufgerufen wird. Wenn Sie eine große Anzahl von Werten ändern müssen die <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> Methode bietet möglicherweise eine bessere Leistung. Die <xref:Microsoft.Win32.RegistryKey> Klasse bietet auch Methoden, mit denen Sie einen Registrierungsschlüssel, so testen Sie den Datentyp eines Werts vor dem Abrufen und Löschen von Schlüsseln eine Zugriffssteuerungsliste (ACL) hinzufügen können.  
  
 Wenn der Typ des angegebenen `value` entspricht nicht dem angegebenen `valueKind`, und die Daten nicht konvertiert, <xref:System.ArgumentException> ausgelöst wird. Sie können z. B. speichern eine <xref:System.Int64?displayProperty=nameWithType> als eine <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>, jedoch nur, wenn der Wert kleiner als der maximale Wert von ist einer <xref:System.Int32?displayProperty=nameWithType>. Sie können keinen einzelnen Zeichenfolgenwert als Speichern einer <xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Wenn geschachtelte Werte übergeben werden, für die <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType> oder <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>, die Konvertierung erfolgt mit der invarianten Kultur.  
  
> [!NOTE]
>  Unter Windows 98 und Windows Millennium Edition (Windows Me) die Registrierung ist nicht Unicode, und nicht alle Unicode-Zeichen sind für alle Codepages gültig. Ein Unicode-Zeichen, die für die aktuelle Codepage ungültig ist, wird durch die beste Übereinstimmung ersetzt. Es werden keine Ausnahmen ausgelöst.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird speichert Werte verschiedener Datentypen in eine Beispielschlüssel, die beim Erstellen des Schlüssels, da es tut, und klicken Sie dann Ruft ab und die Werte zeigt an. Im Beispiel wird veranschaulicht, speichern und Abrufen der Standardwert (namenlos) Name/Wert-Paar sowie die Verwendung von `defaultValue` Wenn ein Name/Wert-Paar ist nicht vorhanden.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keyName" /> does not begin with a valid registry root.  -or-  <paramref name="keyName" /> is longer than the maximum length allowed (255 characters).  -or-  The type of <paramref name="value" /> did not match the registry data type specified by <paramref name="valueKind" />, therefore the data could not be converted properly.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The <see cref="T:Microsoft.Win32.RegistryKey" /> is read-only, and thus cannot be written to; for example, it is a root-level node, or the key has not been opened with write access.</exception>
        <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to create or modify registry keys.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">den angegebene Registrierungsschlüssel zu ändern, wenn er vorhanden ist, oder der Registrierungsschlüssel erstellt, wenn sie nicht bereits vorhanden ist. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Users">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey Users;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey Users" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.Users" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Users As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ Users;" />
      <MemberSignature Language="F#" Value=" staticval mutable Users : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.Users" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Contains information about the default user configuration. This field reads the Windows registry base key HKEY_USERS.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Schlüssel wird eine Verzweigung für jeden Benutzer des Computers enthält. Die Standardkonfiguration ist für neue Benutzer auf dem lokalen Computer und für den aktuellen Benutzer standardmäßig bereitgestellt, wenn der Benutzer die Einstellungen nicht geändert wurde. Da Windows 98 / ME unterstützt auch Registry.Users, Anwendungen über Zugriff auf die benutzerspezifische Informationen genauso wie sie unter Windows 2000. Informationen des Benutzers wird in einer separaten Datei gespeichert, die lokal oder auf einem Netzwerkserver gespeichert werden können. Windows 98 / ME können diese Datei zum aktuellen System des Benutzers kopieren, sodass Einstellungen mit dem Benutzer von einem Computer auf einen anderen verschieben können.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht das Abrufen der Unterschlüssel, und gibt deren Namen auf dem Bildschirm. Verwenden der <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> Methode zum Erstellen einer Instanz des betreffenden Unterschlüssels von Interesse sind. Anschließend können Sie andere Vorgänge in <xref:Microsoft.Win32.RegistryKey> diesen Schlüssel zu bearbeiten.  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>