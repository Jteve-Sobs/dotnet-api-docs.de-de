<Type Name="Guid" FullName="System.Guid">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0f2f68c04fd6bcd04969ac58271b7345a766231d" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39886339" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Guid : IComparable, IComparable&lt;Guid&gt;, IEquatable&lt;Guid&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Guid extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Guid&gt;, class System.IEquatable`1&lt;valuetype System.Guid&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Guid" />
  <TypeSignature Language="VB.NET" Value="Public Structure Guid&#xA;Implements IComparable, IComparable(Of Guid), IEquatable(Of Guid), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Guid : IComparable, IComparable&lt;Guid&gt;, IEquatable&lt;Guid&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type Guid = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Guid&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Guid&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine GUID dar (Globally Unique Identifier, globaler eindeutiger Bezeichner).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine GUID ist eine 128-Bit-Ganzzahl (16 Bytes), die für alle Computer und Netzwerke verwendet werden kann, wo ein eindeutiger Bezeichner erforderlich ist. Ein solcher Bezeichner ist eine sehr geringe Wahrscheinlichkeit besteht, wird dupliziert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Runtime.InteropServices.GuidAttribute?displayProperty=nameWithType> Klasse, um eine GUID einer Schnittstelle und eine benutzerdefinierte Klasse zugewiesen werden. Der Wert der GUID abgerufen, durch den Aufruf der <xref:System.Attribute.GetCustomAttribute%2A> -Methode, und vergleicht ihn mit zwei anderen GUIDs zu bestimmen, ob diese gleich sind.  
  
 [!code-cpp[Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Guid/CPP/Guids.cpp#1)]
 [!code-csharp[Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Guid/CS/Guids.cs#1)]
 [!code-vb[Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Guid/VB/Guids.vb#1)]  
  
 Beachten Sie, dass die <xref:System.Runtime.InteropServices.GuidAttribute> Attribut wird normalerweise in einer Anwendung verwendet, um einen Typ für COM verfügbar zu machen Wenn Sie dieses Beispiel zu kompilieren, können Sie Ausführen den [Assembly Registration-Tool (Regasm.exe)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md) für die generierte Assembly zum Erstellen von Registrierungsdatei (reg), und geben Sie Bibliotheksdateien (.tlb). Die REG-Datei kann verwendet werden, um die Co-Klasse in der Registrierung zu registrieren, und die TLB-Datei kann Metadaten für COM-Interop bereitstellen.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Guid" />-Struktur.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Guid (byte[] b);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (b As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Guid(cli::array &lt;System::Byte&gt; ^ b);" />
      <MemberSignature Language="F#" Value="new Guid : byte[] -&gt; Guid" Usage="new System.Guid b" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="b" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="b">Ein aus 16 Elementen bestehendes Bytearray mit Werten, mit denen die GUID initialisiert wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Guid" />-Struktur unter Verwendung des angegebenen Bytearrays.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="b" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="b" /> hat keine Länge von 16 Bytes.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Guid (ReadOnlySpan&lt;byte&gt; b);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.#ctor(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (b As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Guid(ReadOnlySpan&lt;System::Byte&gt; b);" />
      <MemberSignature Language="F#" Value="new Guid : ReadOnlySpan&lt;byte&gt; -&gt; Guid" Usage="new System.Guid b" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="b" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="b">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Guid (string g);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string g) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (g As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Guid(System::String ^ g);" />
      <MemberSignature Language="F#" Value="new Guid : string -&gt; Guid" Usage="new System.Guid g" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="g" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="g">Eine Zeichenfolge, die eine GUID in einem der folgenden Formate enthält ("z" stellt eine Hexadezimalziffer dar, bei der die Groß- und Kleinschreibung nicht berücksichtigt wird): 
32 aufeinander folgende Ziffern: 
zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz 
- oder - 
Gruppen von 8, 4, 4, 4 und 12 Ziffern, die durch Bindestriche verbunden sind. Die gesamte GUID kann optional in zueinander passende geschweifte oder einfache Klammern eingeschlossen werden: 
zzzzzzzz-zzzz-zzzz-zzzz-zzzzzzzzzzzz 
- oder - 
{zzzzzzzz-zzzz-zzzz-zzzz-zzzzzzzzzzzz} 
- oder - 
(zzzzzzzz-zzzz-zzzz-zzzz-zzzzzzzzzzzz) 
- oder - 
Gruppen von 8, 4 und 4 Ziffern und eine Untergruppe von acht Gruppen zu je 2 Ziffern mit dem Präfix "0x" bzw. "0X", die durch Kommas getrennt sind. Die gesamte GUID und die Untergruppe wird in zueinander passende Klammern eingeschlossen: 
{0xzzzzzzzz, 0xzzzz, 0xzzzz,{0xzz,0xzz,0xzz,0xzz,0xzz,0xzz,0xzz,0xzz}} 
Dabei sind die Klammern, die Kommas und die "0x"-Präfixe erforderlich. Eingebettete Leerzeichen werden ignoriert. Führende Nullen in einer Gruppe werden ignoriert.  
  
Die in einer Gruppe angezeigten Ziffern stellen die maximale Anzahl der in einer Gruppe zulässigen auswertbaren Ziffern dar. Sie können dabei eine Anzahl von Ziffern zwischen 1 und der für eine Gruppe angezeigten Anzahl angeben. Die angegebenen Ziffern werden dabei als die zuletzt stehenden Ziffern der Gruppe ausgewertet.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Guid" />-Struktur unter Verwendung des von der angegebenen Zeichenfolge dargestellten Werts.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die alphabetischen Hexadezimalzeichen in die `g` Parameter wird die Groß- und Kleinbuchstaben. Beispielsweise stellen die folgenden Zeichenfolgen dieselbe GUID dar:  
  
 "ca761232ed4211cebacd00aa0057b223"  
  
 "CA761232-ED42-11CE-BACD-00AA0057B223"  
  
 "{CA761232-ED42-11CE-BACD-00AA0057B223}"  
  
 "(CA761232-ED42-11CE-BACD-00AA0057B223)"  
  
 "{0xCA761232, 0xED42, 0x11CE, {0xBA, 0xCD, 0 x 00, 0xAA, 0 x 00, 0x57, 0xB2, 0 x 23}}"  
  
   
  
## Examples  
 Das folgende Beispiel übergibt die Zeichenfolge aufgeführt, die im Abschnitt "Hinweise", um die <xref:System.Guid.%23ctor%28System.String%29> Konstruktor.  
  
 [!code-csharp[System.Guid.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.guid.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Guid.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.guid.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="g" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Das Format von <paramref name="g" /> ist ungültig.</exception>
        <exception cref="T:System.OverflowException">Das Format von <paramref name="g" /> ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Guid (int a, short b, short c, byte[] d);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 a, int16 b, int16 c, unsigned int8[] d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.#ctor(System.Int32,System.Int16,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (a As Integer, b As Short, c As Short, d As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Guid(int a, short b, short c, cli::array &lt;System::Byte&gt; ^ d);" />
      <MemberSignature Language="F#" Value="new Guid : int * int16 * int16 * byte[] -&gt; Guid" Usage="new System.Guid (a, b, c, d)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="a" Type="System.Int32" />
        <Parameter Name="b" Type="System.Int16" />
        <Parameter Name="c" Type="System.Int16" />
        <Parameter Name="d" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="a">Die ersten 4 Bytes der GUID.</param>
        <param name="b">Die nächsten 2 Bytes der GUID.</param>
        <param name="c">Die nächsten 2 Bytes der GUID.</param>
        <param name="d">Die restlichen 8 Bytes der GUID.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Guid" />-Struktur unter Verwendung der angegebenen Ganzzahlen und des angegebenen Bytearrays.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 `Guid(1,2,3,new byte[]{0,1,2,3,4,5,6,7})` erstellt eine <xref:System.Guid> , die "00000001-0002-0003-0001-020304050607" entspricht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="d" /> hat keine Länge von 8 Bytes.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Guid (int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 a, int16 b, int16 c, unsigned int8 d, unsigned int8 e, unsigned int8 f, unsigned int8 g, unsigned int8 h, unsigned int8 i, unsigned int8 j, unsigned int8 k) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.#ctor(System.Int32,System.Int16,System.Int16,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (a As Integer, b As Short, c As Short, d As Byte, e As Byte, f As Byte, g As Byte, h As Byte, i As Byte, j As Byte, k As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Guid(int a, short b, short c, System::Byte d, System::Byte e, System::Byte f, System::Byte g, System::Byte h, System::Byte i, System::Byte j, System::Byte k);" />
      <MemberSignature Language="F#" Value="new Guid : int * int16 * int16 * byte * byte * byte * byte * byte * byte * byte * byte -&gt; Guid" Usage="new System.Guid (a, b, c, d, e, f, g, h, i, j, k)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="a" Type="System.Int32" />
        <Parameter Name="b" Type="System.Int16" />
        <Parameter Name="c" Type="System.Int16" />
        <Parameter Name="d" Type="System.Byte" />
        <Parameter Name="e" Type="System.Byte" />
        <Parameter Name="f" Type="System.Byte" />
        <Parameter Name="g" Type="System.Byte" />
        <Parameter Name="h" Type="System.Byte" />
        <Parameter Name="i" Type="System.Byte" />
        <Parameter Name="j" Type="System.Byte" />
        <Parameter Name="k" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="a">Die ersten 4 Bytes der GUID.</param>
        <param name="b">Die nächsten 2 Bytes der GUID.</param>
        <param name="c">Die nächsten 2 Bytes der GUID.</param>
        <param name="d">Das nächste Byte der GUID.</param>
        <param name="e">Das nächste Byte der GUID.</param>
        <param name="f">Das nächste Byte der GUID.</param>
        <param name="g">Das nächste Byte der GUID.</param>
        <param name="h">Das nächste Byte der GUID.</param>
        <param name="i">Das nächste Byte der GUID.</param>
        <param name="j">Das nächste Byte der GUID.</param>
        <param name="k">Das nächste Byte der GUID.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Guid" />-Struktur unter Verwendung der angegebenen Ganzzahlen und der angegebenen Bytes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Angeben der einzelnen Bytes auf diese Weise kann verwendet werden, um Byte-Order-Einschränkungen (big-Endian oder little-Endian-Bytereihenfolge) für bestimmte Arten von Computern zu umgehen.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine GUID, dessen Zeichenfolgendarstellung "0000000a-000b-000c-0001-020304050607" wird, erstellt.  
  
 [!code-csharp[System.Guid.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.guid.ctor/cs/ctor2.cs#2)]
 [!code-vb[System.Guid.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.guid.ctor/vb/ctor2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Guid (uint a, ushort b, ushort c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 a, unsigned int16 b, unsigned int16 c, unsigned int8 d, unsigned int8 e, unsigned int8 f, unsigned int8 g, unsigned int8 h, unsigned int8 i, unsigned int8 j, unsigned int8 k) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.#ctor(System.UInt32,System.UInt16,System.UInt16,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (a As UInteger, b As UShort, c As UShort, d As Byte, e As Byte, f As Byte, g As Byte, h As Byte, i As Byte, j As Byte, k As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Guid(System::UInt32 a, System::UInt16 b, System::UInt16 c, System::Byte d, System::Byte e, System::Byte f, System::Byte g, System::Byte h, System::Byte i, System::Byte j, System::Byte k);" />
      <MemberSignature Language="F#" Value="new Guid : uint32 * uint16 * uint16 * byte * byte * byte * byte * byte * byte * byte * byte -&gt; Guid" Usage="new System.Guid (a, b, c, d, e, f, g, h, i, j, k)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="a" Type="System.UInt32" />
        <Parameter Name="b" Type="System.UInt16" />
        <Parameter Name="c" Type="System.UInt16" />
        <Parameter Name="d" Type="System.Byte" />
        <Parameter Name="e" Type="System.Byte" />
        <Parameter Name="f" Type="System.Byte" />
        <Parameter Name="g" Type="System.Byte" />
        <Parameter Name="h" Type="System.Byte" />
        <Parameter Name="i" Type="System.Byte" />
        <Parameter Name="j" Type="System.Byte" />
        <Parameter Name="k" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="a">Die ersten 4 Bytes der GUID.</param>
        <param name="b">Die nächsten 2 Bytes der GUID.</param>
        <param name="c">Die nächsten 2 Bytes der GUID.</param>
        <param name="d">Das nächste Byte der GUID.</param>
        <param name="e">Das nächste Byte der GUID.</param>
        <param name="f">Das nächste Byte der GUID.</param>
        <param name="g">Das nächste Byte der GUID.</param>
        <param name="h">Das nächste Byte der GUID.</param>
        <param name="i">Das nächste Byte der GUID.</param>
        <param name="j">Das nächste Byte der GUID.</param>
        <param name="k">Das nächste Byte der GUID.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Guid" />-Struktur unter Verwendung der angegebenen Ganzzahlen ohne Vorzeichen und der angegebenen Bytes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch Angeben der Bytes auf diese Weise werden die Bytereihenfolge-Probleme vermeidet.  
  
   
  
## Examples  
 GUID(0xA,0xb,0xc,0,1,2,3,4,5,6,7) erstellt eine <xref:System.Guid> , die "0000000a-000b-000c-0001-020304050607" entspricht.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt oder <see cref="T:System.Guid" /> und gibt eine Angabe über das Verhältnis der entsprechenden Werte zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (Guid value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Guid value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.CompareTo(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Guid) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(Guid value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : Guid -&gt; int&#xA;override this.CompareTo : Guid -&gt; int" Usage="guid.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="value">Ein mit dieser Instanz zu vergleichendes Objekt.</param>
        <summary>Vergleicht diese Instanz mit einem angegebenen <see cref="T:System.Guid" />-Objekt, und gibt eine Angabe über das Verhältnis der entsprechenden Werte zurück.</summary>
        <returns>Eine Zahl mit Vorzeichen, die das Verhältnis zwischen dem Wert dieser Instanz und <paramref name="value" /> angibt.  
  
 <list type="table"><listheader><term> Rückgabewert  </term><description> Beschreibung  </description></listheader><item><term> Eine negative ganze Zahl  </term><description> Diese Instanz ist kleiner als <paramref name="value" />.  </description></item><item><term> 0 (null)  </term><description> Diese Instanz ist gleich <paramref name="value" />.  </description></item><item><term> Eine positive ganze Zahl  </term><description> Diese Instanz ist größer als <paramref name="value" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Guid.CompareTo%2A> Methode vergleicht die GUIDs, als wären sie Werte bereitgestellt, um die <xref:System.Guid.%23ctor%28System.Int32%2CSystem.Int16%2CSystem.Int16%2CSystem.Byte%5B%5D%29> Konstruktor wie folgt:  
  
-   Es vergleicht die <xref:System.UInt32> Werte und gibt ein Ergebnis zurück, wenn sie ungleich sind. Wenn sie gleich sind, führt es den nächsten Vergleich.  
  
-   Er vergleicht die ersten <xref:System.UInt16> Werte und gibt ein Ergebnis zurück, wenn sie ungleich sind. Wenn sie gleich sind, führt es den nächsten Vergleich.  
  
-   Es vergleicht die zweite <xref:System.UInt16> Werte und gibt ein Ergebnis zurück, wenn sie ungleich sind. Wenn sie gleich sind, führt es den nächsten Vergleich.  
  
-   Wenn führt einen Byte-pro-Byte-Vergleich, der nächsten acht <xref:System.Byte> Werte. Wenn sie das erste ungleichen Paar trifft, wird das Ergebnis zurückgegeben. Andernfalls wird 0, um anzugeben, dass die beiden <xref:System.Guid> Werte gleich sind.  
  
 Beachten Sie, die die letzten acht Bytes in eine Zeichenfolgendarstellung von Vorkommen einer <xref:System.Guid> in umgekehrter Reihenfolge von niedrige Byte zu hohen Byte. Z. B. in eine Zeichenfolgendarstellung der <xref:System.Guid> Wert "01e75c83-c6f5-4192-b57e-7427cec5560d", die letzten acht Bytes sind "b57e 7427cec5560d." Das heißt, verglichen werden die letzten acht Bytes auf Byte-pro-Byte-Basis von links nach rechts beginnend mit 0xb5 festgelegt ist.  
  
 Wenn zwei GUIDs gleich Werte für eine Komponente, vergleicht die Methode die nächste Komponente. Wenn eine Komponente, deren Werte ungleich sind, gefunden wird, wird das Ergebnis zurückgegeben.  
  
 Diese Methode implementiert die <xref:System.IComparable%601?displayProperty=nameWithType> -Schnittstelle und führt etwas bessere Leistung als die <xref:System.Guid.CompareTo%2A?displayProperty=nameWithType> Methode, da es keine konvertieren die `value` Parameter, um eine <xref:System.Guid> Wert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Guid.CompareTo%28System.Guid%29> Methode, um einen GUID-Wert mit zwei ähnliche GUID-Werten verglichen werden soll.  
  
 [!code-csharp[System.Guid.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.guid.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Guid.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.guid.compareto/vb/compareto2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="guid.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Ein Vergleichsobjekt oder <see langword="null" />.</param>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt und gibt eine Angabe über das Verhältnis der entsprechenden Werte zurück.</summary>
        <returns>Eine Zahl mit Vorzeichen, die das Verhältnis zwischen dem Wert dieser Instanz und <paramref name="value" /> angibt.  
  
 <list type="table"><listheader><term> Rückgabewert  </term><description> Beschreibung  </description></listheader><item><term> Eine negative ganze Zahl  </term><description> Diese Instanz ist kleiner als <paramref name="value" />.  </description></item><item><term> 0 (null)  </term><description> Diese Instanz ist gleich <paramref name="value" />.  </description></item><item><term> Eine positive ganze Zahl  </term><description> Diese Instanz ist größer als <paramref name="value" /> oder <paramref name="value" /> ist <see langword="null" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `value` -Parameter muss sein `null` oder eine Instanz von <xref:System.Guid>ist, andernfalls wird eine Ausnahme ausgelöst. Jede Instanz von <xref:System.Guid>, unabhängig von seinem Wert wird als größer betrachtet `null`.  
  
 Die <xref:System.Guid.CompareTo%2A> Methode vergleicht die GUIDs, als wären sie Werte bereitgestellt, um die <xref:System.Guid.%23ctor%2A> Konstruktor wie folgt:  
  
-   Es vergleicht die <xref:System.Int32> Werte und gibt ein Ergebnis zurück, wenn sie ungleich sind. Wenn sie gleich sind, führt es den nächsten Vergleich.  
  
-   Er vergleicht die ersten <xref:System.Int16> Werte und gibt ein Ergebnis zurück, wenn sie ungleich sind. Wenn sie gleich sind, führt es den nächsten Vergleich.  
  
-   Es vergleicht die zweite <xref:System.Int16> Werte und gibt ein Ergebnis zurück, wenn sie ungleich sind. Wenn sie gleich sind, führt es den nächsten Vergleich.  
  
-   Wenn führt einen Byte-pro-Byte-Vergleich, der nächsten acht <xref:System.Byte> Werte. Wenn sie das erste ungleichen Paar trifft, wird das Ergebnis zurückgegeben. Andernfalls wird 0, um anzugeben, dass die beiden <xref:System.Guid> Werte gleich sind.  
  
 Wenn zwei GUIDs gleich Werte für eine Komponente, vergleicht die Methode die nächste Komponente. Wenn eine Komponente, deren Werte ungleich sind, gefunden wird, wird das Ergebnis zurückgegeben.  
  
 Beachten Sie, die die letzten acht Bytes in eine Zeichenfolgendarstellung von Vorkommen einer <xref:System.Guid> in umgekehrter Reihenfolge von niedrige Byte zu hohen Byte. Z. B. in eine Zeichenfolgendarstellung der <xref:System.Guid> Wert "01e75c83-c6f5-4192-b57e-7427cec5560d", die letzten acht Bytes sind "b57e 7427cec5560d."  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Runtime.InteropServices.GuidAttribute> Attribut einer Klasse eine GUID zugewiesen. Der Wert dieser GUID abgerufen, durch den Aufruf der <xref:System.Attribute.GetCustomAttribute%2A?displayProperty=nameWithType> -Methode und übergeben die <xref:System.Runtime.InteropServices.GuidAttribute.Value%2A> -Eigenschaft des zurückgegebenen <xref:System.Runtime.InteropServices.GuidAttribute> -Objekt an die <xref:System.Guid.Parse%2A> Methode. Es vergleicht dann diese GUID mit einem Array von Werten.  
  
 [!code-csharp[System.Guid.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.guid.compareto/cs/compareto1.cs#2)]
 [!code-vb[System.Guid.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.guid.compareto/vb/compareto1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> ist kein <see cref="T:System.Guid" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly Guid Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Guid Empty" />
      <MemberSignature Language="DocId" Value="F:System.Guid.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As Guid " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Guid Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : Guid" Usage="System.Guid.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Eine schreibgeschützte Instanz der <see cref="T:System.Guid" />-Struktur, in der alle Werte 0 (null) sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können eine GUID mit dem Wert vergleichen die <xref:System.Guid.Empty?displayProperty=nameWithType> Feld, um zu bestimmen, ob eine GUID ungleich NULL ist. Im folgenden Beispiel wird die <xref:System.Guid.op_Equality%2A> Operator zum Vergleichen von zwei GUID-Werten mit <xref:System.Guid.Empty?displayProperty=nameWithType> zu bestimmen, ob sie ausschließlich aus Nullen bestehen aus.  
  
 [!code-csharp[System.Guid.Empty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.guid.empty/cs/empty.cs#1)]
 [!code-vb[System.Guid.Empty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.guid.empty/vb/empty.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei Instanzen von <see cref="T:System.Guid" /> denselben Wert darstellen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (Guid g);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Guid g) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.Equals(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (g As Guid) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Guid g);" />
      <MemberSignature Language="F#" Value="override this.Equals : Guid -&gt; bool" Usage="guid.Equals g" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="g">Ein mit dieser Instanz zu vergleichendes Objekt.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz und ein angegebenes <see cref="T:System.Guid" />-Objekt den gleichen Wert darstellen.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="g" /> gleich dieser Instanz ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwei <xref:System.Guid> Objekte verfügen über identische Bytewerte gleich sind.  
  
 Diese Methode ist geringfügig besser als die <xref:System.Guid.Equals%2A> Methode, da es keinen in Box die `g` Parameter.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Guid.Equals(System.Object)" />
        <altmember cref="Overload:System.Guid.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="guid.Equals o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Das Objekt, das mit dieser Instanz verglichen werden soll.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz gleich einem angegebenen Objekt ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="o" /> eine <see cref="T:System.Guid" /> ist, die denselben Wert wie diese Instanz hat, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwei <xref:System.Guid> Objekte verfügen über identische Bytewerte gleich sind.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="guid.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für diese Instanz zurück.</summary>
        <returns>Der Hashcode für diese Instanz.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewGuid">
      <MemberSignature Language="C#" Value="public static Guid NewGuid ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid NewGuid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.NewGuid" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NewGuid () As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid NewGuid();" />
      <MemberSignature Language="F#" Value="static member NewGuid : unit -&gt; Guid" Usage="System.Guid.NewGuid " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Guid" />-Struktur.</summary>
        <returns>Ein neues GUID-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine praktische `static` -Methode, die Sie aufrufen können, dass ein neues <xref:System.Guid>. Die Methode umschließt einen Aufruf der Windows [CoCreateGuid](http://msdn.microsoft.com/library/windows/desktop/ms688568.aspx) Funktion. Das zurückgegebene <xref:System.Guid> ist garantiert nicht gleich <xref:System.Guid.Empty?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird erstellt und zeigt die Werte von zwei <xref:System.Guid> Objekte.  
  
 [!code-csharp[system.guid.newguid#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.guid.newguid/cs/ng.cs#1)]
 [!code-vb[system.guid.newguid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.guid.newguid/vb/ng.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Guid a, Guid b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Guid a, valuetype System.Guid b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.op_Equality(System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As Guid, b As Guid) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Guid a, Guid b);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Guid * Guid -&gt; bool" Usage="a = b" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Guid" />
        <Parameter Name="b" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="a">Das erste zu vergleichende Objekt.</param>
        <param name="b">Das zweite zu vergleichende Objekt.</param>
        <summary>Gibt an, ob die Werte von zwei angegebenen <see cref="T:System.Guid" />-Objekten gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="a" /> und <paramref name="b" /> gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[Die entsprechende Methode für diesen Operator ist <xref:System.Guid.Equals%28System.Object%29?displayProperty=nameWithType>  
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Guid.op_Equality%2A> Operator zum Vergleichen von zwei GUID-Werten mit <xref:System.Guid.Empty?displayProperty=nameWithType> zu bestimmen, ob sie ausschließlich aus Nullen bestehen aus.  
  
 [!code-csharp[System.Guid.Empty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.guid.empty/cs/empty.cs#1)]
 [!code-vb[System.Guid.Empty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.guid.empty/vb/empty.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Guid a, Guid b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Guid a, valuetype System.Guid b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.op_Inequality(System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As Guid, b As Guid) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Guid a, Guid b);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Guid * Guid -&gt; bool" Usage="System.Guid.op_Inequality (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Guid" />
        <Parameter Name="b" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="a">Das erste zu vergleichende Objekt.</param>
        <param name="b">Das zweite zu vergleichende Objekt.</param>
        <summary>Gibt an, ob die Werte von zwei angegebenen <see cref="T:System.Guid" />-Objekten ungleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="a" /> und <paramref name="b" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[Die entsprechende Methode für diesen Operator ist <xref:System.Guid.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static Guid Parse (ReadOnlySpan&lt;char&gt; input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.Parse(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (input As ReadOnlySpan(Of Char)) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid Parse(ReadOnlySpan&lt;char&gt; input);" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; -&gt; Guid" Usage="System.Guid.Parse input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static Guid Parse (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid Parse(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (input As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid Parse(System::String ^ input);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; Guid" Usage="System.Guid.Parse input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die zu konvertierende Zeichenfolge.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer GUID in die entsprechende <see cref="T:System.Guid" />-Struktur.</summary>
        <returns>Eine Struktur, die den analysierten Wert enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Guid.Parse%2A> Methode entfernt alle führenden oder nachfolgenden Leerzeichen aus `input` und konvertiert die Zeichenfolgendarstellung einer GUID, um eine <xref:System.Guid> Wert. Diese Methode kann Zeichenfolgen in einem der fünf Formate erzeugten konvertieren die <xref:System.Guid.ToString%28System.String%29> und <xref:System.Guid.ToString%28System.String%2CSystem.IFormatProvider%29> Methoden, wie in der folgenden Tabelle gezeigt.  
  
|Bezeichner|Beschreibung |Format|  
|---------------|-----------------|------------|  
|`N`|32 Ziffern|00000000000000000000000000000000|  
|`D`|32 Ziffern durch Bindestriche getrennt|00000000-0000-0000-0000-000000000000|  
|`B`|32 Ziffern durch Bindestriche, eingeschlossen in geschweiften Klammern getrennt|{00000000-0000-0000-0000-000000000000}|  
|`P`|32 Ziffern durch Bindestriche, eingeschlossen in Klammern getrennt|(00000000-0000-0000-0000-000000000000)|  
|`X`|Vier Hexadezimalwerte in geschweiften Klammern, wobei der vierte Wert eine Teilmenge von acht Hexadezimalwerten ist, die auch in geschweifte Klammern eingeschlossen ist|{0 x 00000000 "," 0 x 0000 "," 0 x 0000, {0 x 00, 0 x 00, 0 x 00, 0 x 00, 0 x 00, 0 x 00, 0 x 00, 0 x 00}}|  
  
 Löst die Methode eine <xref:System.FormatException> ist dies nicht die Zeichenfolge erfolgreich analysiert. Hier sind einige der Gründe, warum dieser Fall eintreten könnte:  
  
-   `input` enthält Zeichen, die nicht Teil des Satzes der hexadezimalen Zeichen sind.  
  
-   `input` enthält zu viele oder zu wenige numerische Zeichen.  
  
-   `input` verfügt über zu viele oder zu wenige, die nicht numerischen Zeichen, die für ein bestimmtes Format geeignet.  
  
-   `input` befindet sich nicht in eines der Formate, die erkannt werden, indem die <xref:System.Guid.ToString%2A> Methode und in der vorherigen Tabelle aufgeführt.  
  
 Verwenden der <xref:System.Guid.TryParse%2A> Methode, um alle fehlerhaften Analyseoperationen ohne eine Ausnahme behandeln zu müssen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine neue GUID, konvertiert es in drei separaten zeichenfolgendarstellungen durch Aufrufen der <xref:System.Guid.ToString%28System.String%29> -Methode mit dem "B", "D", und "X" Formatbezeichner, und ruft dann die <xref:System.Guid.Parse%2A> Methode zum Konvertieren von Zeichenfolgen zurück, in <xref:System.Guid> Werte.  
  
 [!code-csharp[System.Guid.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.guid.parse/cs/parseex1.cs#3)]
 [!code-vb[System.Guid.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.guid.parse/vb/parseex1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="input" /> weist kein erkanntes Format auf.</exception>
        <altmember cref="M:System.Guid.TryParse(System.String,System.Guid@)" />
        <altmember cref="M:System.Guid.ToString" />
      </Docs>
    </Member>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static Guid ParseExact (ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; format);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid ParseExact(valuetype System.ReadOnlySpan`1&lt;char&gt; input, valuetype System.ReadOnlySpan`1&lt;char&gt; format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.ParseExact(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (input As ReadOnlySpan(Of Char), format As ReadOnlySpan(Of Char)) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid ParseExact(ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; format);" />
      <MemberSignature Language="F#" Value="static member ParseExact : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; Guid" Usage="System.Guid.ParseExact (input, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="input">To be added.</param>
        <param name="format">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static Guid ParseExact (string input, string format);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid ParseExact(string input, string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.ParseExact(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (input As String, format As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid ParseExact(System::String ^ input, System::String ^ format);" />
      <MemberSignature Language="F#" Value="static member ParseExact : string * string -&gt; Guid" Usage="System.Guid.ParseExact (input, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Die zu konvertierende GUID.</param>
        <param name="format">Einer der folgenden Bezeichner, der das beim Interpretieren von <c>input</c> zu verwendende genaue Format angibt: „N“, „D“, „B“, „P“ oder „X“.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer GUID in die entsprechende <see cref="T:System.Guid" />-Struktur, vorausgesetzt, dass die Zeichenfolge das angegebene Format hat.</summary>
        <returns>Eine Struktur, die den analysierten Wert enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Guid.ParseExact%2A> Methode erfordert die Zeichenfolge zu konvertierende werden in dem vom angegebenen Format genau den `format` Parameter, nachdem führende und nachfolgende Leerzeichen entfernt wurden. Die folgende Tabelle zeigt die zulässigen Formatbezeichner für das `format` Parameter. "0" dar eine Ziffer; Bindestriche ("-"), geschweifte Klammern ("{", "}"), und die Klammern ("(",")") wie dargestellt angezeigt werden.  
  
|Bezeichner|Formatieren von das `input` Parameter|  
|---------------|-------------------------------------|  
|N|32 Ziffern:<br /><br /> 00000000000000000000000000000000|  
|D|32 Ziffern durch Bindestriche getrennt sind:<br /><br /> 00000000-0000-0000-0000-000000000000|  
|B|32 Ziffern getrennt durch Bindestriche in geschweifte Klammern eingeschlossen:<br /><br /> {00000000-0000-0000-0000-000000000000}|  
|P|32 Ziffern getrennt durch Bindestriche in Klammern eingeschlossen:<br /><br /> (00000000-0000-0000-0000-000000000000)|  
|X|Vier Hexadezimalwerte in geschweiften Klammern, wobei der vierte Wert eine Teilmenge von acht Hexadezimalwerten ist, die auch in geschweifte Klammern eingeschlossen ist:<br /><br /> {0 x 00000000 "," 0 x 0000 "," 0 x 0000, {0 x 00, 0 x 00, 0 x 00, 0 x 00, 0 x 00, 0 x 00, 0 x 00, 0 x 00}}|  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Guid.ToString%28System.String%29> -Methode mit jedem unterstützten Formatbezeichner um ein Array von Zeichenfolgen zu generieren, die eine einzelne GUID darstellen. Diese werden dann zum Übergeben der <xref:System.Guid.ParseExact%2A> -Methode, die nur die Zeichenfolge erfolgreich analysiert wird, die dem Formatbezeichner "B" entspricht.  
  
 [!code-csharp[System.Guid.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.guid.parse/cs/parseexactex1.cs#4)]
 [!code-vb[System.Guid.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.guid.parse/vb/parseexactex1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> oder <paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="input" /> entspricht nicht dem von <paramref name="format" /> angegebenen Format.</exception>
        <altmember cref="M:System.Guid.TryParseExact(System.String,System.String,System.Guid@)" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IFormattable.ToString">
      <MemberSignature Language="C#" Value="string IFormattable.ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IFormattable.ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.System#IFormattable#ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (format As String, provider As IFormatProvider) As String Implements IFormattable.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IFormattable.ToString(System::String ^ format, IFormatProvider ^ provider) = IFormattable::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.ToByteArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ToByteArray();" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : unit -&gt; byte[]" Usage="guid.ToByteArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein aus 16 Elementen bestehendes Bytearray zurück, das den Wert dieser Instanz enthält.</summary>
        <returns>Ein aus 16 Elementen bestehendes Bytearray.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Können Sie das Bytearray, das von dieser Methode zurückgegeben wird, für den Roundtrip eine <xref:System.Guid> -Wert durch Aufrufen der <xref:System.Guid.%23ctor%28System.Byte%5B%5D%29> Konstruktor.  
  
 Beachten Sie, dass die Reihenfolge der Bytes im zurückgegebenen Bytearray unterscheidet die angegebene Zeichenfolgendarstellung einer <xref:System.Guid> Wert. Die Reihenfolge der Beginn vier-Byte-Gruppe und die nächsten beiden 2-Byte-Gruppen wird rückgängig gemacht, während die Reihenfolge der letzten 2-Byte-Gruppe und die schließende 6-Byte-Gruppe identisch ist. Dies wird im Beispiel veranschaulicht.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Guid.NewGuid%2A> Methode zum Erstellen einer <xref:System.Guid> -Wert, und ruft dann die <xref:System.Guid.ToByteArray%2A> Methode zur Darstellung der <xref:System.Guid> Wert als Bytearray. Anschließend werden beide Werte in der Konsole angezeigt. Zum Schluss instanziiert ein neues <xref:System.Guid> Wert vom die Byte-Array und ruft seine <xref:System.Guid.Equals%28System.Guid%29> Methode, um anzugeben, dass die beiden <xref:System.Guid> Werte sind identisch.  
  
 [!code-csharp[System.Guid.ToByteArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.guid.tobytearray/cs/tobytearray3.cs#1)]
 [!code-vb[System.Guid.ToByteArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.guid.tobytearray/vb/tobytearray3.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine Zeichenfolgendarstellung des Werts dieser Instanz der <see cref="T:System.Guid" />-Struktur zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="guid.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Zeichenfolgendarstellung des Werts dieser Instanz im Registrierungsformat zurück.</summary>
        <returns>Der Wert dieser <see cref="T:System.Guid" />, wie folgt mit dem Formatbezeichner "D" formatiert: 
 <c>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</c>  
  
Dabei wird der Wert der GUID als Folge von hexadezimalen, klein geschriebenen Ziffern in Gruppen von 8, 4, 4, 4 und 12 Ziffern dargestellt, die durch Bindestriche voneinander getrennt sind. Ein Beispiel eines Rückgabewerts ist "382c74c3-721d-4f34-80e5-57657b6cbc27". Um die Hexadezimalzeichen von a bis f in Großbuchstaben zu konvertieren, rufen Sie die <see cref="M:System.String.ToUpper" />- Methode  auf der zurückgegebenen Zeichenfolge auf.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bietet es sich um ein Standard-GUID-Format, das ausreichend für die typische Verwendung ist; jedoch andere Versionen dieser Methode, die in Anspruch nehmen eine `format` Parameter angeben, einige allgemeine Formatvarianten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="guid.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Ein einzelner Formatbezeichner, der angibt, wie der Wert dieser <see cref="T:System.Guid" /> formatiert wird. Der <c>format</c>-Parameter kann „N“, „D“, „B“, „P“ oder „X“ sein. Wenn <c>format</c><see langword="null" /> oder eine leere Zeichenfolge ist (""), wird „D“ verwendet.</param>
        <summary>Gibt eine Zeichenfolgendarstellung des Werts dieser <see cref="T:System.Guid" />-Instanz entsprechend dem angegebenen Formatbezeichner zurück.</summary>
        <returns>Der Wert dieser <see cref="T:System.Guid" />, der als Folge von hexadezimalen, kleingeschriebenen Ziffern im angegebenen Format dargestellt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle zeigt die zulässigen Formatbezeichner für das `format` Parameter. "0" dar eine Ziffer; Bindestriche ("-"), geschweifte Klammern ("{", "}"), und die Klammern ("(",")") wie dargestellt angezeigt werden.  
  
|Bezeichner|Format des Rückgabewerts|  
|---------------|----------------------------|  
|`N`|32 Ziffern:<br /><br /> 00000000000000000000000000000000|  
|`D`|32 Ziffern durch Bindestriche getrennt sind:<br /><br /> 00000000-0000-0000-0000-000000000000|  
|`B`|32 Ziffern getrennt durch Bindestriche in geschweifte Klammern eingeschlossen:<br /><br /> {00000000-0000-0000-0000-000000000000}|  
|`P`|32 Ziffern getrennt durch Bindestriche in Klammern eingeschlossen:<br /><br /> (00000000-0000-0000-0000-000000000000)|  
|`X`|Vier Hexadezimalwerte in geschweiften Klammern, wobei der vierte Wert eine Teilmenge von acht Hexadezimalwerten ist, die auch in geschweifte Klammern eingeschlossen ist:<br /><br /> {0 x 00000000 "," 0 x 0000 "," 0 x 0000, {0 x 00, 0 x 00, 0 x 00, 0 x 00, 0 x 00, 0 x 00, 0 x 00, 0 x 00}}|  
  
 Die hexadezimalen Ziffern a bis f sind Kleinbuchstaben in der zurückgegebenen Zeichenfolge. Um diese in Großbuchstaben zu konvertieren, rufen die <xref:System.String.ToUpper%2A?displayProperty=nameWithType> Methode für die zurückgegebene Zeichenfolge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Wert von <paramref name="format" /> lautet nicht <see langword="null" />, eine leere Zeichenfolge (""), "N", "D", "B", "P" oder "X".</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="guid.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Ein einzelner Formatbezeichner, der angibt, wie der Wert dieser <see cref="T:System.Guid" /> formatiert wird. Der <c>format</c>-Parameter kann „N“, „D“, „B“, „P“ oder „X“ sein. Wenn <c>format</c><see langword="null" /> oder eine leere Zeichenfolge ist (""), wird „D“ verwendet.</param>
        <param name="provider">(Reserviert) Ein Objekt, das kulturabhängige Formatierungsinformationen bereitstellt.</param>
        <summary>Gibt eine Zeichenfolgendarstellung des Werts dieser Instanz der <see cref="T:System.Guid" />-Klasse entsprechend dem angegebenen Formatbezeichner und den angegebenen kulturspezifischen Formatinformationen zurück.</summary>
        <returns>Der Wert dieser <see cref="T:System.Guid" />, der als Folge von hexadezimalen, kleingeschriebenen Ziffern im angegebenen Format dargestellt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `provider` -Parameter ist für die zukünftige Verwendung reserviert und trägt nicht zur Ausführung dieser Methode. Sie können übergeben `null` im Aufruf Methode.  
  
 Die folgende Tabelle zeigt die zulässigen Formatbezeichner für das `format` Parameter. "0" dar eine Ziffer; Bindestriche ("-"), geschweifte Klammern ("{", "}"), und die Klammern ("(",")") wie dargestellt angezeigt werden.  
  
|Bezeichner|Format des Rückgabewerts|  
|---------------|----------------------------|  
|`N`|32 Ziffern:<br /><br /> 00000000000000000000000000000000|  
|`D`|32 Ziffern durch Bindestriche getrennt sind:<br /><br /> 00000000-0000-0000-0000-000000000000|  
|`B`|32 Ziffern getrennt durch Bindestriche in geschweifte Klammern eingeschlossen:<br /><br /> {00000000-0000-0000-0000-000000000000}|  
|`P`|32 Ziffern getrennt durch Bindestriche in Klammern eingeschlossen:<br /><br /> (00000000-0000-0000-0000-000000000000)|  
|`X`|Vier Hexadezimalwerte in geschweiften Klammern, wobei der vierte Wert eine Teilmenge von acht Hexadezimalwerten ist, die auch in geschweifte Klammern eingeschlossen ist:<br /><br /> {0 x 00000000 "," 0 x 0000 "," 0 x 0000, {0 x 00, 0 x 00, 0 x 00, 0 x 00, 0 x 00, 0 x 00, 0 x 00, 0 x 00}}|  
  
 Die hexadezimalen Ziffern a bis f sind Kleinbuchstaben in der zurückgegebenen Zeichenfolge. Um diese in Großbuchstaben zu konvertieren, rufen die <xref:System.String.ToUpper%2A?displayProperty=nameWithType> Methode für die zurückgegebene Zeichenfolge.  
  
 Da die `provider` Parameter wird ignoriert, können sie eine benutzerdefinierte formatierungslösung bereitzustellen. Zur Darstellung eine <xref:System.Guid> Wert als Zeichenfolge in ein Format, das von der GUID Standardformatzeichenfolgen, Aufruf nicht unterstützt wird die <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> -Methode mit einer `provider` -Objekt, das implementiert die <xref:System.ICustomFormatter> und <xref:System.IFormatProvider> Schnittstellen. Weitere Informationen finden Sie im Abschnitt "Benutzerdefinierte-Formatierung mit ICustomFormatter" in der [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md) Artikel.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Wert von <paramref name="format" /> lautet nicht <see langword="null" />, eine leere Zeichenfolge (""), "N", "D", "B", "P" oder "X".</exception>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="guid.TryFormat (destination, charsWritten, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; input, out Guid result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; input, [out] valuetype System.Guid&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.TryParse(System.ReadOnlySpan{System.Char},System.Guid@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (input As ReadOnlySpan(Of Char), ByRef result As Guid) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; input, [Runtime::InteropServices::Out] Guid % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.Guid.TryParse (input, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Guid" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string input, out Guid result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string input, [out] valuetype System.Guid&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.TryParse(System.String,System.Guid@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (input As String, ByRef result As Guid) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ input, [Runtime::InteropServices::Out] Guid % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.Guid.TryParse (input, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="result" Type="System.Guid" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Die zu konvertierende GUID.</param>
        <param name="result">Die Struktur, die den analysierten Wert enthalten wird. Wenn die Methode <see langword="true" /> zurückgibt, enthält <c>result</c> eine gültige <see cref="T:System.Guid" />. Wenn die Methode <see langword="false" /> zurückgibt, enthält <c>result</c> eine gültige <see cref="F:System.Guid.Empty" />.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer GUID in die entsprechende <see cref="T:System.Guid" />-Struktur.</summary>
        <returns>
          <see langword="true" />, wenn der Analysevorgang erfolgreich war, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode entspricht der <xref:System.Guid.Parse%2A> -Methode, außer dass anstelle von der analysierten GUID wird `false` Wenn `input` ist `null` oder nicht in einem anerkannten Format, und keine Ausnahme ausgelöst. Es entfernt führenden oder nachfolgenden Leerzeichen aus `input` und konvertiert Zeichenfolgen in einem der fünf Formate erkannt werden, indem die <xref:System.Guid.ToString%28System.String%29> und <xref:System.Guid.ToString%28System.String%2CSystem.IFormatProvider%29> Methoden, wie in der folgenden Tabelle gezeigt.  
  
|Bezeichner|Beschreibung |Format|  
|---------------|-----------------|------------|  
|`N`|32 Ziffern|00000000000000000000000000000000|  
|`D`|32 Ziffern durch Bindestriche getrennt|00000000-0000-0000-0000-000000000000|  
|`B`|32 Ziffern durch Bindestriche, eingeschlossen in geschweiften Klammern getrennt|{00000000-0000-0000-0000-000000000000}|  
|`P`|32 Ziffern durch Bindestriche, eingeschlossen in Klammern getrennt|(00000000-0000-0000-0000-000000000000)|  
|`X`|Vier Hexadezimalwerte in geschweiften Klammern, wobei der vierte Wert eine Teilmenge von acht Hexadezimalwerten ist, die auch in geschweifte Klammern eingeschlossen ist|{0 x 00000000 "," 0 x 0000 "," 0 x 0000, {0 x 00, 0 x 00, 0 x 00, 0 x 00, 0 x 00, 0 x 00, 0 x 00, 0 x 00}}|  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine neue GUID, konvertiert es in drei separaten zeichenfolgendarstellungen durch Aufrufen der <xref:System.Guid.ToString%28System.String%29> -Methode mit dem "B", "D", und "X" Formatbezeichner, und ruft dann die <xref:System.Guid.TryParse%2A> Methode zum Konvertieren von Zeichenfolgen zurück, in <xref:System.Guid> Werte.  
  
 [!code-csharp[System.Guid.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.guid.parse/cs/tryparseex1.cs#2)]
 [!code-vb[System.Guid.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.guid.parse/vb/tryparseex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Guid.Parse(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryParseExact">
      <MemberSignature Language="C#" Value="public static bool TryParseExact (ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; format, out Guid result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParseExact(valuetype System.ReadOnlySpan`1&lt;char&gt; input, valuetype System.ReadOnlySpan`1&lt;char&gt; format, [out] valuetype System.Guid&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.TryParseExact(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Guid@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParseExact (input As ReadOnlySpan(Of Char), format As ReadOnlySpan(Of Char), ByRef result As Guid) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParseExact(ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; format, [Runtime::InteropServices::Out] Guid % result);" />
      <MemberSignature Language="F#" Value="static member TryParseExact : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.Guid.TryParseExact (input, format, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Guid" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">To be added.</param>
        <param name="format">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParseExact">
      <MemberSignature Language="C#" Value="public static bool TryParseExact (string input, string format, out Guid result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParseExact(string input, string format, [out] valuetype System.Guid&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.TryParseExact(System.String,System.String,System.Guid@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParseExact (input As String, format As String, ByRef result As Guid) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParseExact(System::String ^ input, System::String ^ format, [Runtime::InteropServices::Out] Guid % result);" />
      <MemberSignature Language="F#" Value="static member TryParseExact : string * string *  -&gt; bool" Usage="System.Guid.TryParseExact (input, format, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="result" Type="System.Guid" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Die zu konvertierende GUID.</param>
        <param name="format">Einer der folgenden Bezeichner, der das beim Interpretieren von <c>input</c> zu verwendende genaue Format angibt: „N“, „D“, „B“, „P“ oder „X“.</param>
        <param name="result">Die Struktur, die den analysierten Wert enthalten wird. Wenn die Methode <see langword="true" /> zurückgibt, enthält <c>result</c> eine gültige <see cref="T:System.Guid" />. Wenn die Methode <see langword="false" /> zurückgibt, enthält <c>result</c> eine gültige <see cref="F:System.Guid.Empty" />.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer GUID in die entsprechende <see cref="T:System.Guid" />-Struktur, vorausgesetzt, dass die Zeichenfolge das angegebene Format hat.</summary>
        <returns>
          <see langword="true" />, wenn der Analysevorgang erfolgreich war, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei dieser Methode muss die Zeichenfolge zu konvertierende werden in dem vom angegebenen Format genau den `format` Parameter, nachdem führende und nachfolgende Leerzeichen entfernt wurden. Es gibt `false` Wenn `input` ist `null` oder befindet sich nicht in dem vom angegebenen Format `format`, und keine Ausnahme ausgelöst.  
  
 Die folgende Tabelle zeigt die zulässigen Formatbezeichner für das `format` Parameter. "0" dar eine Ziffer; Bindestriche ("-"), geschweifte Klammern ("{", "}"), und die Klammern ("(",")") wie dargestellt angezeigt werden.  
  
|Bezeichner|Formatieren von das `input` Parameter|  
|---------------|-------------------------------------|  
|N|32 Ziffern:<br /><br /> 00000000000000000000000000000000|  
|D|32 Ziffern durch Bindestriche getrennt sind:<br /><br /> 00000000-0000-0000-0000-000000000000|  
|B|32 Ziffern getrennt durch Bindestriche in geschweifte Klammern eingeschlossen:<br /><br /> {00000000-0000-0000-0000-000000000000}|  
|P|32 Ziffern getrennt durch Bindestriche in Klammern eingeschlossen:<br /><br /> (00000000-0000-0000-0000-000000000000)|  
|X|Vier Hexadezimalwerte in geschweiften Klammern, wobei der vierte Wert eine Teilmenge von acht Hexadezimalwerten ist, die auch in geschweifte Klammern eingeschlossen ist:<br /><br /> {0 x 00000000 "," 0 x 0000 "," 0 x 0000, {0 x 00, 0 x 00, 0 x 00, 0 x 00, 0 x 00, 0 x 00, 0 x 00, 0 x 00}}|  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Guid.ToString%28System.String%29> -Methode mit jedem unterstützten Formatbezeichner um ein Array von Zeichenfolgen zu generieren, die eine einzelne GUID darstellen. Diese werden dann zum Übergeben der <xref:System.Guid.TryParseExact%2A> -Methode, die die Zeichenfolge erfolgreich analysiert wird, die dem Formatbezeichner "B" entspricht.  
  
 [!code-csharp[System.Guid.Parse#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.guid.parse/cs/tryparseexactex1.cs#5)]
 [!code-vb[System.Guid.Parse#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.guid.parse/vb/tryparseexactex1.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Guid.ParseExact(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.TryWriteBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryWriteBytes(Span&lt;System::Byte&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.TryWriteBytes : Span&lt;byte&gt; -&gt; bool" Usage="guid.TryWriteBytes destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>