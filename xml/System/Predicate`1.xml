<Type Name="Predicate&lt;T&gt;" FullName="System.Predicate&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0bf692e28849c9f448cfadbe41cc30dbc02d2d96" /><Meta Name="ms.sourcegitcommit" Value="397961a0164281b579f68064c3bb66c071f374d9" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/14/2020" /><Meta Name="ms.locfileid" Value="86312003" /></Metadata><TypeSignature Language="C#" Value="public delegate bool Predicate&lt;in T&gt;(T obj);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed Predicate`1&lt;- T&gt; extends System.MulticastDelegate" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:System.Predicate`1" />
  <TypeSignature Language="VB.NET" Value="Public Delegate Function Predicate(Of In T)(obj As T) As Boolean " FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public delegate bool Predicate(T obj);" />
  <TypeSignature Language="F#" Value="type Predicate&lt;'T&gt; = delegate of 'T -&gt; bool" />
  <TypeSignature Language="C#" Value="public delegate bool Predicate&lt;T&gt;(T obj);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed Predicate`1&lt;T&gt; extends System.MulticastDelegate" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5" />
  <TypeSignature Language="VB.NET" Value="Public Delegate Function Predicate(Of T)(obj As T) As Boolean " FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <TypeParameters>
    <TypeParameter Name="T">
      <Constraints>
        <ParameterAttribute>Contravariant</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Delegate</BaseTypeName>
  </Base>
  <Parameters>
    <Parameter Name="obj" Type="T" />
  </Parameters>
  <ReturnValue>
    <ReturnType>System.Boolean</ReturnType>
  </ReturnValue>
  <Docs>
    <typeparam name="T">Der Typ des zu vergleichenden Objekts.</typeparam>
    <param name="obj">Das Objekt, das mit den Kriterien verglichen werden soll, die innerhalb der durch diesen Delegaten dargestellten Methode definiert sind.</param>
    <summary>Stellt die Methode dar, die einen Satz von Kriterien definiert und ermittelt, ob das angegebene Objekt diese Kriterien erfüllt.</summary>
    <returns><see langword="true" />, wenn <paramref name="obj" /> die innerhalb der durch diesen Delegaten dargestellten Methode definierten Kriterien erfüllt, andernfalls <see langword="false" />.</returns>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Delegat wird von mehreren Methoden der <xref:System.Array> -Klasse und der- <xref:System.Collections.Generic.List%601> Klasse verwendet, um nach Elementen in der Auflistung zu suchen.  
  
 Der Delegat wird in der Regel <xref:System.Predicate%601> durch einen Lambda Ausdruck dargestellt. Da für den Lambda-Ausdruck lokale Variablen verfügbar sind, ist es einfach, auf eine Bedingung zu testen, die zur Kompilierzeit nicht genau bekannt ist. Dies wird im folgenden Beispiel simuliert, das eine Klasse definiert, die `HockeyTeam` Informationen über ein National Hockey-Liga-Team und das Jahr enthält, in dem es gegründet wurde. Im Beispiel wird ein Array von ganzzahligen Werten definiert, die Jahre darstellen, und nach dem Zufallsprinzip wird ein Element des Arrays zugewiesen. dabei handelt es sich um eine Variable, die sich `foundedBeforeYear` lokal auf die-Methode des Beispiels bezieht `Main` . Da lokale Variablen für einen Lambda-Ausdruck verfügbar sind, kann der an die-Methode weiter gegebene Lambda-Ausdruck <xref:System.Collections.Generic.List%601.FindAll%2A?displayProperty=nameWithType> `HockeyTeam` für jedes Team, das am oder vor diesem Jahr basiert, ein-Objekt zurückgeben.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Predicate`1/cs/predicate1.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Predicate`1/vb/predicate1.vb" id="Snippet3":::
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein-Delegat <xref:System.Predicate%601> mit der- <xref:System.Array.Find%2A?displayProperty=nameWithType> Methode verwendet, um ein Array von Strukturen zu durchsuchen <xref:System.Drawing.Point> . Das Beispiel definiert explizit einen Delegaten <xref:System.Predicate%601> mit dem Namen `predicate` und weist ihm eine Methode `FindPoints` mit dem Namen zu, die zurückgibt, `true` Wenn das Produkt der <xref:System.Drawing.Point.X%2A?displayProperty=nameWithType> <xref:System.Drawing.Point.Y%2A?displayProperty=nameWithType> Felder und größer als 100.000 ist. Beachten Sie, dass es üblich ist, einen Lambda-Ausdruck zu verwenden, anstatt explizit einen Delegaten vom Typ zu definieren <xref:System.Predicate%601> , wie das zweite Beispiel veranschaulicht.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Predicate`1/cs/predicateex2.cs" interactive="try-dotnet" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Predicate`1/vb/predicateex2.vb" id="Snippet4":::
  
 Das folgende Beispiel ist mit dem vorherigen Beispiel identisch, mit dem Unterschied, dass ein Lambda-Ausdruck verwendet wird, um den Delegaten darzustellen <xref:System.Predicate%601> .  Jedes Element des `points` Arrays wird an den Lambda-Ausdruck übermittelt, bis der Ausdruck ein Element findet, das die Suchkriterien erfüllt. In diesem Fall gibt der Lambda-Ausdruck zurück, `true` Wenn das Produkt der X-und Y-Felder größer als 100.000 ist.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Predicate`1/cs/predicateex1.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Predicate`1/vb/predicateex1.vb" id="Snippet2"::: 
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
  </Docs>
</Type>
