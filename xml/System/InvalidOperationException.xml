<Type Name="InvalidOperationException" FullName="System.InvalidOperationException">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2ae40b84e46667617b6aaac9cd9e2cc0d420fdb1" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37480687" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class InvalidOperationException : SystemException" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit InvalidOperationException extends System.SystemException" />
  <TypeSignature Language="DocId" Value="T:System.InvalidOperationException" />
  <TypeSignature Language="VB.NET" Value="Public Class InvalidOperationException&#xA;Inherits SystemException" />
  <TypeSignature Language="C++ CLI" Value="public ref class InvalidOperationException : SystemException" />
  <TypeSignature Language="F#" Value="type InvalidOperationException = class&#xA;    inherit SystemException" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Die Ausnahme, die ausgelöst wird, wenn der Aufruf einer Methode aufgrund des aktuellen Zustands des Objekts ungültig ist.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.InvalidOperationException> ist in Fällen verwendet werden, wenn Fehler beim Aufrufen einer Methode, die nicht durch ungültige Argumente verursacht wird. Es wird in der Regel ausgelöst, wenn der Zustand eines Objekts den Methodenaufruf nicht unterstützen kann. Z. B. eine <xref:System.InvalidOperationException> Ausnahme wird von Methoden wie z.B.:  
  
-   <xref:System.Collections.IEnumerator.MoveNext%2A?displayProperty=nameWithType> Wenn Objekte von einer Sammlung nach der Erstellung des Enumerators geändert werden. Weitere Informationen finden Sie unter [Ändern einer sammlungssatzkonfiguration beim Durchlaufen sie](#Iterating).  
  
-   <xref:System.Resources.ResourceSet.GetString%2A?displayProperty=nameWithType> Wenn der Ressourcensatz, bevor geschlossen wird ist der Methodenaufruf erfolgt.  
  
-   <xref:System.Xml.Linq.XContainer.Add%2A?displayProperty=nameWithType>, wenn das Objekt oder die Objekte hinzugefügt werden nicht ordnungsgemäß strukturierten XML-Dokument ergeben würde.  
  
-   Eine Methode, mit dem versucht wird, um die Benutzeroberfläche von einem Thread, der nicht im Hauptfenster oder UI-Thread zu bearbeiten.  
  
> [!IMPORTANT]
>  Da die <xref:System.InvalidOperationException> Ausnahme kann ausgelöst werden in einer Vielzahl von Situationen, es ist wichtig, lesen Sie die Ausnahmemeldung, die zurückgegeben werden, indem die <xref:System.Exception.Message%2A> Eigenschaft.  
  
 In diesem Abschnitt  
  
 [Einige häufige Ursachen für "InvalidOperationException"-Ausnahmen](#Causes)   
 [Aktualisieren einen UI-Thread von einem nicht-UI-thread](#UI)  
 [Ändern einer sammlungssatzkonfiguration beim Durchlaufen Sie](#Iterating)  
 [Sortieren von einem Array oder einer Auflistung, deren Objekte können nicht verglichen werden](#Sorting)  
 [Ein Typ Nullable Umwandlung&lt;T&gt; , die null ist, um deren zugrunde liegender Typ](#Nullable)   
 [Eine System.Linq.Enumerable-Methode für eine leere Auflistung aufgerufen](#Empty)  
 [Aufrufen von Enumerable.Single oder Enumerable.SingleOrDefault auf eine Sequenz ohne ein element](#Single)  
 [Dynamische anwendungsdomänenübergreifender Feldzugriff](#Emit)  
[Auslösen einer InvalidOperationException-Ausnahme](#Throwing)  
[Verschiedene Informationen](#Misc)  
  
<a name="Causes"></a>   
## <a name="some-common-causes-of-invalidoperationexception-exceptions"></a>Einige häufige Ursachen für "InvalidOperationException"-Ausnahmen  
 Die folgenden Abschnitte zeigen, wie einige allgemeine in der in Fällen <xref:System.InvalidOperationException> Ausnahme wird ausgelöst, in einer app. Wie Sie das Problem behandeln, hängt von der besonderen Situation ab. In den meisten Fällen führt jedoch zu die Ausnahme vom Entwicklerfehler, und die <xref:System.InvalidOperationException> Ausnahme erwartet und vermieden werden kann.  
  
<a name="UI"></a>   
### <a name="updating-a-ui-thread-from-a-non-ui-thread"></a>Aktualisieren einen UI-Thread von einem nicht-UI-thread  
 Arbeitsthreads werden häufig verwendet, um einige Hintergrundarbeit auszuführen, die umfasst das Sammeln von Daten in der Benutzeroberfläche einer Anwendung angezeigt werden. Jedoch. Die meisten GUI (grafische Benutzeroberfläche)-Anwendungsframeworks für .NET Framework, z. B. Windows Forms und Windows Presentation Foundation (WPF), können Sie Zugriff auf GUI-Objekte nur aus dem Thread, der erstellt und verwaltet die Benutzeroberfläche (der Hauptwarteschlange oder UI-Thread). Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn Sie versuchen, ein Element der Benutzeroberfläche aus einem anderen Thread als dem UI-Thread zuzugreifen.  Der Text der Ausnahmemeldung wird in der folgenden Tabelle angezeigt.  
  
|Anwendungstyp|Meldung|  
|----------------------|-------------|  
|WPF-app|**Der aufrufende Thread kann nicht auf dieses Objekt zugreifen, da ein anderer Thread es besitzt.**|  
|UWP-app|**Die Anwendung, die eine Schnittstelle, die gemarshallt wurde für einen anderen Thread aufgerufen wird.**|  
|Windows Forms-app|**Threadübergreifender Vorgang ungültig: Steuerelement "TextBox1" zugegriffen werden, von einem anderen Thread als dem Thread, der es erstellt wurde.**|  
  
 Benutzeroberflächen-Frameworks für .NET Framework implementieren eine *Dispatcher* Muster, umfasst eine Methode zum Überprüfen, ob ein Aufruf an ein Mitglied eines Benutzeroberflächenelements auf dem UI-Thread ausgeführt wird, und andere Methoden, um den Aufruf im UI-Thread zu planen:  
  
-   In WPF-Anwendungen rufen die <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A?displayProperty=nameWithType> Methode, um zu bestimmen, ob eine Methode in einem nicht-UI-Thread ausgeführt wird. Es gibt `true` , wenn die Methode in der UI-Thread ausgeführt wird und `false` andernfalls. Rufen Sie eine der Überladungen der <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=nameWithType> Methode, um den Anruf an den UI-Thread zu planen.  
  
-   Rufen Sie in der UWP-apps, die [CoreDispatcher.HasThreadAccess](https://msdn.microsoft.com/library/windows/apps/windows.ui.core.coredispatcher.hasthreadaccess.aspx) Methode, um zu bestimmen, ob eine Methode in einem nicht-UI-Thread ausgeführt wird. Rufen Sie die [CoreDispatcher.RunAsync](https://msdn.microsoft.com/library/windows/apps/windows.ui.core.coredispatcher.runasync.aspx) Methode, die ein Delegat, der den UI-Thread aktualisiert. Verwenden Sie den Befehl  
  
-   In Windows Forms-Anwendungen verwenden die <xref:System.Windows.Forms.Control.InvokeRequired%2A?displayProperty=nameWithType> Eigenschaft, um zu bestimmen, ob eine Methode in einem nicht-UI-Thread ausgeführt wird. Rufen Sie eine der Überladungen der <xref:System.Windows.Forms.Control.Invoke%2A?displayProperty=nameWithType> Methode, die ein Delegat, der den UI-Thread aktualisiert.  
  
 Die folgenden Beispiele veranschaulichen die <xref:System.InvalidOperationException> Ausnahme wird ausgelöst, wenn Sie versuchen, ein Element von einem anderen Thread als dem Thread der Benutzeroberfläche zu aktualisieren, die sie erstellt haben.  Jedes Beispiel erfordert die Erstellung von zwei Steuerelemente:  
  
-   Ein Textfeld-Steuerelement mit dem Namen `textBox1`.  Sie sollten in einer Windows Forms-app Festlegen seiner <xref:System.Windows.Forms.TextBox.Multiline%2A> Eigenschaft `true`.  
  
-   Ein Schaltflächen-Steuerelement, das mit dem Namen `threadExampleBtn`. Im Beispiel wird einen Ereignishandler `ThreadsExampleBtn_Click`, für der Schaltfläche " `Click` Ereignis.  
  
 In jedem Fall die `threadExampleBtn_Click` -Ereignishandler ruft die `DoSomeWork` -Methode zweimal. Der erste Aufruf synchron ausgeführt und erfolgreich abgeschlossen wird. Aber der zweite Aufruf, da er auf einem Thread eines Threadpools, asynchron ausgeführt wird versucht, zur Aktualisierung der Benutzeroberfläche von einem nicht-UI-Thread. Dies führt zu einem <xref:System.InvalidOperationException> Ausnahme.  
  
 WPF und UWP-apps  
 [!code-csharp[System.InvalidOperationException.Threading.WPF1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf1/cs/MainWindow.xaml.cs#1)]
 [!code-vb[System.InvalidOperationException.Threading.WPF1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf1/vb/MainWindow.xaml.vb#1)]  
  
 Die folgende Version der `DoSomeWork` Methode keine Ausnahme in einer WPF-Anwendung.  
  
 [!code-csharp[System.InvalidOperationException.Threading.WPF2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf2/cs/MainWindowDispatcher.xaml.cs#3)]
 [!code-vb[System.InvalidOperationException.Threading.WPF2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf2/vb/MainWindowDispatcher.xaml.vb#3)]  
  
 Die folgende Version der `DoSomeWork` Methode keine Ausnahme in einer UWP-app.  
  
 [!code-csharp[System.InvalidOperationException.Threading.UWP#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception.threading.uwp/cs/MainPage.xaml.cs#4)]
 [!code-vb[System.InvalidOperationException.Threading.UWP#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception.threading.uwp/vb/MainPage.xaml.vb#4)]  
  
 Windows Forms-Anwendungen  
 [!code-csharp[System.InvalidOperationException.Threading.WF#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf/cs/Form1.cs#2)]
 [!code-vb[System.InvalidOperationException.Threading.WF#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf/vb/Form1.vb#2)]  
  
 Die folgende Version der `DoSomeWork` Methode keine Ausnahme in einer Windows Forms-app.  
  
 [!code-csharp[System.InvalidOperationException.Threading.WF2#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf2/cs/Form1.cs#5)]
 [!code-vb[System.InvalidOperationException.Threading.WF2#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf2/vb/Form1.vb#5)]  
  
<a name="Iterating"></a>   
### <a name="changing-a-collection-while-iterating-it"></a>Ändern einer sammlungssatzkonfiguration beim Durchlaufen Sie  
 Die `foreach` -Anweisung in c# oder `For Each` -Anweisung in Visual Basic wird verwendet, um der Member einer Auflistung durchlaufen und zu lesen oder ändern die einzelnen Elemente. Jedoch kann verwendet werden, hinzufügen oder Entfernen von Elementen aus der Auflistung. Dies löst dies eine <xref:System.InvalidOperationException> -Ausnahme mit einer Nachricht, die ähnlich ist, ist "**Auflistung wurde geändert; Enumerationsvorgang kann nicht ausgeführt werden. **"  
  
 Im folgenden Beispiel wird eine Auflistung von ganzen Zahlen der versucht, das Quadrat der jede ganze Zahl, die der Auflistung hinzugefügt. Löst das Beispiel einer <xref:System.InvalidOperationException> mit dem ersten Aufruf der <xref:System.Collections.Generic.List%601.Add%2A?displayProperty=nameWithType> Methode.  
  
 [!code-csharp[System.InvalidOperationException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating1.cs#1)]
 [!code-vb[System.InvalidOperationException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating1.vb#1)]  
  
 Sie können die Ausnahme in einem der zwei Möglichkeiten, je nach Anwendungslogik entfernen:  
  
-   Wenn die Auflistung beim Durchlaufen sie Elemente hinzugefügt werden müssen, können Sie sie durchlaufen, Index mithilfe der `for` -Anweisung anstelle von `foreach` oder `For Each`. Im folgenden Beispiel wird die für die Anweisung, um das Quadrat der Zahlen in der Auflistung in der Auflistung hinzufügen.  
  
     [!code-csharp[System.InvalidOperationException#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating2.cs#2)]
     [!code-vb[System.InvalidOperationException#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating2.vb#2)]  
  
     Beachten Sie, dass Sie die Anzahl der Iterationen herstellen müssen, vor dem Durchlaufen der Auflistung durch ein Indikator innerhalb der Schleife, die die Appropraitely Schleife beendet wird, durch Iteration rückwärts, von `Count` – 1 auf 0 (null) oder, wie im Beispiel durch das Zuweisen der Zahl der Elemente im Array, an eine Variable, und verwenden, um die Obergrenze der Schleife herzustellen. Wenn ein Element der Auflistung bei jeder Iteration hinzugefügt wird, führt andernfalls eine Endlosschleife.  
  
-   Ist dies nicht erforderlich, um die Auflistung beim Durchlaufen sie Elemente hinzuzufügen, können Sie speichern die Elemente in eine temporäre Sammlung hinzugefügt werden, die Sie hinzufügen, beim Durchlaufen der Auflistung abgeschlossen ist.  Im folgenden Beispiel wird dieser Ansatz, fügen das Quadrat der Zahlen in einer Auflistung in eine temporäre Sammlung zu, und klicken Sie dann auf die Sammlungen in ein einzelnes Array-Objekt zu kombinieren.  
  
     [!code-csharp[System.InvalidOperationException#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating3.cs#3)]
     [!code-vb[System.InvalidOperationException#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating3.vb#3)]  
  
<a name="Sorting"></a>   
### <a name="sorting-an-array-or-collection-whose-objects-cannot-be-compared"></a>Sortieren von einem Array oder einer Auflistung, deren Objekte können nicht verglichen werden  
 Allgemeine Methoden, wie z. B. Sortieren der <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> Methode oder die <xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType> -Methode in der Regel erforderlich, mindestens eine der zu sortierenden Objekte implementieren die <xref:System.IComparable%601> oder <xref:System.IComparable> Schnittstelle. Wenn nicht der Fall, der Sammlung oder des Arrays kann nicht sortiert werden, und die Methode löst eine <xref:System.InvalidOperationException> Ausnahme. Das folgende Beispiel definiert eine `Person` -Klasse speichert zwei `Person` Objekte in einem generischen <xref:System.Collections.Generic.List%601> -Objekt, und versucht, sie zu sortieren. Wie die Ausgabe des Beispiels zeigt, wird durch den Aufruf der <xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType> -Methode löst eine <xref:System.InvalidOperationException>.  
  
 [!code-csharp[System.InvalidOperationException#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort1.cs#12)]
 [!code-vb[System.InvalidOperationException#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort1.vb#12)]  
  
 Sie können die Ausnahme in einem von drei Arten vermeiden:  
  
-   Wenn Sie den Typ, die Sie sortieren besitzen können (d.h., wenn Sie Quellcode steuern) möchten, können Sie ändern, implementiert die <xref:System.IComparable%601> oder <xref:System.IComparable> Schnittstelle. Dies erfordert, dass Sie implementieren die <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> oder <xref:System.IComparable.CompareTo%2A> Methode. Hinzufügen einer schnittstellenimplementierung zu einem vorhandenen Typ ist keine unterbrechende Änderung.  
  
     Im folgenden Beispiel wird dieser Ansatz zu einem <xref:System.IComparable%601> Implementierung für die `Person` Klasse. Können Sie weiterhin die Auflistung oder allgemeine Sortieren des Arrays-Methode aufrufen und wie die Ausgabe des Beispiels zeigt, wird die Sammlung erfolgreich sortiert.  
  
     [!code-csharp[System.InvalidOperationException#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort2.cs#13)]
     [!code-vb[System.InvalidOperationException#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort2.vb#13)]  
  
-   Wenn Sie den Quellcode für den Typ, die für Sie sortieren möchten ändern können, können Sie definieren, dass eine spezielle Sortierung-Klasse, implementiert die <xref:System.Collections.Generic.IComparer%601> Schnittstelle.  Sie können eine Überladung von Aufrufen der `Sort` Methode, enthält ein <xref:System.Collections.Generic.IComparer%601> Parameter. Dieser Ansatz ist besonders nützlich, wenn Sie eine spezialisierte Klasse für die Sortierung zu entwickeln, die Objekte, die auf der Grundlage mehrerer Kriterien sortieren möchten.  
  
     Im folgenden Beispiel wird den Ansatz von Entwickeln eines benutzerdefinierten `PersonComparer` -Klasse, die zum Sortieren verwendet wird `Person` Sammlungen.  Anschließend übergibt eine Instanz dieser Klasse, die <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29?displayProperty=nameWithType> Methode.  
  
     [!code-csharp[System.InvalidOperationException#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort3.cs#14)]
     [!code-vb[System.InvalidOperationException#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort3.vb#14)]  
  
-   Wenn Sie den Quellcode für den Typ ändern, können Sie sortieren möchten, können Sie erstellen eine <xref:System.Comparison%601> Delegat, der die Sortierung. Die Signatur des Delegaten ist.  
  
    ```vb  
    Function Comparison(Of T)(x As T, y As T) As Integer  
    ```  
  
    ```csharp  
    int Comparison<T>(T x, T y)  
    ```  
  
     Im folgenden Beispiel wird die Vorgehensweise, durch die Definition einer `PersonComparison` Methode, entspricht die <xref:System.Comparison%601> Signatur des Delegaten.  Anschließend übergibt es dieses Delegaten, um die <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29?displayProperty=nameWithType> Methode.  
  
     [!code-csharp[System.InvalidOperationException#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort4.cs#15)]
     [!code-vb[System.InvalidOperationException#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort4.vb#15)]  
  
<a name="Nullable"></a>   
### <a name="casting-a-nullablet-that-is-null-to-its-underlying-type"></a>Ein Typ Nullable Umwandlung\<T >, die null ist, um deren zugrunde liegender Typ  
 Umwandeln möchten eine <xref:System.Nullable%601> Wert, der `null` in den zugrunde liegenden Typ löst eine <xref:System.InvalidOperationException> Ausnahme und zeigt die Fehlermeldung "**auf NULL festlegbare Objekt muss einen Wert aufweisen.**  
  
 Das folgende Beispiel löst eine <xref:System.InvalidOperationException> Ausnahme aus, wenn versucht wird, durchlaufen Sie ein Array, umfasst eine `Nullable(Of Integer)` Wert.  
  
 [!code-csharp[System.InvalidOperationException#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Nullable1.cs#4)]
 [!code-vb[System.InvalidOperationException#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Nullable1.vb#4)]  
  
 Um die Ausnahme zu verhindern:  
  
-   Verwenden der <xref:System.Nullable%601.HasValue%2A?displayProperty=nameWithType> Eigenschaft, um nur die Elemente auszuwählen, die nicht `null`.  
  
-   Rufen Sie eine der der <xref:System.Nullable%601.GetValueOrDefault%2A?displayProperty=nameWithType> bereitzustellenden Überladungen einen Standardwert für eine `null` Wert.  
  
 Im folgende Beispiel wird sowohl zum Vermeiden der <xref:System.InvalidOperationException> Ausnahme.  
  
 [!code-csharp[System.InvalidOperationException#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Nullable2.cs#5)]
 [!code-vb[System.InvalidOperationException#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Nullable2.vb#5)]  
  
<a name="Empty"></a>   
### <a name="calling-a-systemlinqenumerable-method-on-an-empty-collection"></a>Eine System.Linq.Enumerable-Methode für eine leere Auflistung aufgerufen  
 Die <xref:System.Linq.Enumerable.Aggregate%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Max%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Min%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>, und <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> Methoden führen Vorgänge für eine Sequenz, und geben ein Einzelergebnis zurück.   Einige Überladungen dieser Methoden lösen eine <xref:System.InvalidOperationException> Ausnahme aus, wenn die Sequenz leer ist, während andere Überladungen geben Folgendes zurück `null`. Die <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> Methode löst auch aus einer <xref:System.InvalidOperationException> Ausnahme aus, wenn die Sequenz mehr als ein Element enthält.  
  
> [!NOTE]
>  Die meisten Methoden, die Auslösen einer <xref:System.InvalidOperationException> Ausnahme sind Überladungen. Achten Sie darauf, dass Sie das Verhalten der Überladung verstehen, die Sie auswählen.  
  
 Die folgende Tabelle enthält die ausnahmemeldungen, die von der <xref:System.InvalidOperationException> Exception-Objekte, die durch Aufrufe von einige ausgelöst <xref:System.Linq.Enumerable?displayProperty=nameWithType> Methoden.  
  
|Methode|Meldung|  
|------------|-------------|  
|`Aggregate` <br /> `Average` <br /> `Last` <br /> `Max` <br /> `Min`|**Sequenz enthält keine Elemente**|  
|`First`|**Die Sequenz enthält kein übereinstimmendes element**|  
|`Single` <br /> `SingleOrDefault`|**Sequenz enthält mehrere übereinstimmende Elemente**|  
  
 Wie Sie beseitigen oder die Ausnahme behandeln hängt von Ihrer Anwendung Annahmen und für die bestimmte Methode, die Sie aufrufen.  
  
-   Wenn Sie absichtlich eine der folgenden Methoden aufrufen, ohne eine Überprüfung auf eine leere Sequenz, werden Sie davon aus, dass die Sequenz nicht leer ist und eine leere Sequenz ein unerwartetes Ereignis ist. In diesem Fall eignet sich das Abfangen oder Auslösen der Ausnahme.  
  
-   Wenn dem Fehler zu prüfen, eine leere Sequenz unbeabsichtigten war, können Sie eine der Überladungen der Aufrufen der <xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType> -Überladung verwenden, um zu bestimmen, ob eine Sequenz Elemente enthält.  
  
    > [!TIP]
    >  Aufrufen der <xref:System.Linq.Enumerable.Any%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> Methode vor Erstellung einer Sequenz kann die Leistung verbessern, wenn die zu verarbeitenden Daten möglicherweise eine große Anzahl von Elementen enthält oder enthalten Wenn die Operation, die die Sequenz generiert, teuer ist.  
  
-   Wenn Sie z. B. eine Methode aufgerufen haben <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType>, oder <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>, können Sie eine alternative Methode, wie z. B. ersetzen <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.LastOrDefault%2A?displayProperty=nameWithType>, oder <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>, einen Standardwert, anstatt ein Element der Sequenz zurückgibt.  
  
 Die Beispiele enthalten zusätzliche Details.  
  
 Im folgenden Beispiel wird die <xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType> Methode, um den Durchschnitt einer Sequenz zu berechnen, deren Werte größer als 4 sind. Da keine Werte aus dem ursprünglichen Array nicht, 4 überschreiten, sind keine Werte in der Sequenz enthalten ist und die Methode löst eine <xref:System.InvalidOperationException> Ausnahme.  
  
 [!code-csharp[System.InvalidOperationException#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable1.cs#6)]
 [!code-vb[System.InvalidOperationException#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable1.vb#6)]  
  
 Die Ausnahme kann behoben werden, durch den Aufruf der <xref:System.Linq.Enumerable.Any%2A> Methode, um zu bestimmen, ob die Sequenz Elemente enthält, bevor die Sequenz, wie im folgenden Beispiel gezeigt Aufrufen der Methode, die verarbeitet werden.  
  
 [!code-csharp[System.InvalidOperationException#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable2.cs#7)]
 [!code-vb[System.InvalidOperationException#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable2.vb#7)]  
  
 Die <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> Methode gibt das erste Element in einer Sequenz oder das erste Element in eine Sequenz, die eine angegebene Bedingung erfüllt. Wenn die Sequenz leer ist, und verfügt daher nicht über ein erstes Element, löst eine <xref:System.InvalidOperationException> Ausnahme.  
  
 Im folgenden Beispiel die <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> -Methode löst eine <xref:System.InvalidOperationException> Ausnahme, da das DbQueryResults Array kein Element größer als 4 enthält.  
  
 [!code-csharp[System.InvalidOperationException#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable3.cs#8)]
 [!code-vb[System.InvalidOperationException#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable3.vb#8)]  
  
 Rufen Sie die <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType> Methode anstelle von <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> zum Zurückgeben eines angegebenen Werts oder Standardwerts. Wenn die Methode ein erstes Element in der Sequenz nicht gefunden wird, wird der Standardwert für diesen Datentyp zurückgegeben.  Der Standardwert ist `null` für einen Verweistyp Null für einen numerischen Datentyp aufweisen, und <xref:System.DateTime.MinValue?displayProperty=nameWithType> für die <xref:System.DateTime> Typ.  
  
> [!NOTE]
>  Interpretieren von zurückgegebenen Wert die <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType> Methode wird häufig dadurch erschwert, dass der Standardwert des Typs einen gültigen Wert in der Sequenz sein kann. In diesem Fall Sie einen Aufruf der <xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType> Methode, um zu bestimmen, ob die Sequenz gültige Member vor dem Aufruf verfügt der <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> Methode.  
  
 Im folgenden Beispiel wird die <xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> Methode, um zu verhindern, dass die <xref:System.InvalidOperationException> Ausnahme, die im vorherigen Beispiel.  
  
 [!code-csharp[System.InvalidOperationException#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable4.cs#9)]
 [!code-vb[System.InvalidOperationException#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable4.vb#9)]  
  
<a name="Single"></a>   
### <a name="calling-enumerablesingle-or-enumerablesingleordefault-on-a-sequence-without-one-element"></a>Aufrufen von Enumerable.Single oder Enumerable.SingleOrDefault auf eine Sequenz ohne ein element  
 Die <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> Methode gibt das einzige Element einer Sequenz, das einzige Element einer Sequenz, die eine angegebene Bedingung erfüllen.    Wenn keine Elemente in der Sequenz vorhanden sind, oder wenn mehr als ein Element vorhanden ist, die Methode löst eine <xref:System.InvalidOperationException> Ausnahme.  
  
 Sie können die <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> -Methode zur Rückgabe eines Standardwert, anstatt eine Ausnahme auszulösen, wenn die Sequenz keine Elemente enthält. Allerdings die <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> Methode löst immer noch aus einem <xref:System.InvalidOperationException> Ausnahme aus, wenn die Sequenz mehr als ein Element enthält.  
  
 Die folgende Tabelle enthält die ausnahmemeldungen, die von der <xref:System.InvalidOperationException> Exception-Objekte, die ausgelöst wird, durch Aufrufe der <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> und <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> Methoden.  
  
|Methode|Meldung|  
|------------|-------------|  
|`Single`|**Die Sequenz enthält kein übereinstimmendes element**|  
|`Single` <br /> `SingleOrDefault`|**Sequenz enthält mehrere übereinstimmende Elemente**|  
  
 Im folgenden Beispiel der Aufruf der <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> -Methode löst eine <xref:System.InvalidOperationException> Ausnahme, da die Sequenz nicht über ein Element größer als 4 verfügt.  
  
 [!code-csharp[System.InvalidOperationException#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable5.cs#10)]
 [!code-vb[System.InvalidOperationException#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable5.vb#10)]  
  
 Im folgenden Beispiel wird versucht, um zu verhindern, dass die <xref:System.InvalidOperationException> Ausnahme wird ausgelöst, wenn eine Sequenz leer ist, indem Sie stattdessen Aufrufen der <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> Methode. Aber da dieser Sequenz mehrere Elemente zurückgibt, deren Wert größer als 2 ist, außerdem löst eine <xref:System.InvalidOperationException> Ausnahme.  
  
 [!code-csharp[System.InvalidOperationException#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable6.cs#11)]
 [!code-vb[System.InvalidOperationException#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable6.vb#11)]  
  
 Aufrufen der <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> Methode wird davon ausgegangen, dass entweder eine Sequenz oder die Sequenz, die angegebenen Kriterien erfüllt nur ein einziges Element enthält.  <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> geht davon aus einer Sequenz mit keinem oder einem Ergebnis, aber nicht mehr. Wenn diese Annahme eine bewusste ihrerseits ist aus, und diese Bedingungen nicht erfüllt, auslösen oder abfangen, die resultierende <xref:System.InvalidOperationException> eignet. Andernfalls, oder wenn Sie erwarten, dass ungültige Bedingungen häufig auftritt, sollten Sie erwägen, mithilfe eines anderen <xref:System.Linq.Enumerable> -Methode, wie z. B. <xref:System.Linq.Enumerable.FirstOrDefault%2A> oder <xref:System.Linq.Enumerable.Where%2A>.  
  
<a name="Emit"></a>   
### <a name="dynamic-cross-application-domain-field-access"></a>Dynamische anwendungsdomänenübergreifender Feldzugriff  
 Die <xref:System.Reflection.Emit.OpCodes.Ldflda?displayProperty=nameWithType> Microsoft intermediate Language (MSIL)-Anweisung löst einen <xref:System.InvalidOperationException> -Ausnahme aus, wenn das Objekt, das mit dem Feld, dessen Adresse Sie abrufen möchten, nicht innerhalb der Anwendungsdomäne ist in der Ihr Code ausgeführt wird. Die Adresse eines Felds kann nur von der Anwendungsdomäne zugegriffen werden, in dem er sich befindet.  
  
<a name="Throwing"></a>   
## <a name="throwing-an-invalidoperationexception-exception"></a>Auslösen einer InvalidOperationException-Ausnahme  
 Lösen Sie eine <xref:System.InvalidOperationException> Ausnahme nur, wenn der Zustand des Objekts aus irgendeinem Grund nicht mit einen bestimmten Methodenaufruf unterstützt. D. h. Aufruf der Methode in einigen Fällen oder Kontexten gültig ist, ist jedoch ungültig in anderen.  
  
 Wenn der Methodenaufruf aufgrund von ungültigen Argumenten ist <xref:System.ArgumentException> oder eine der davon abgeleiteten Klassen, <xref:System.ArgumentNullException> oder <xref:System.ArgumentOutOfRangeException>, stattdessen ausgelöst werden soll.  
  
<a name="Misc"></a>   
## <a name="miscellaneous-information"></a>Verschiedene Informationen  
 <xref:System.InvalidOperationException> wird verwendet, mit dem Wert 0 x 80131509 HRESULT COR_E_INVALIDOPERATION.  
  
 Eine Liste der anfänglichen Eigenschaftswerte für eine Instanz von <xref:System.InvalidOperationException>, finden Sie unter den <xref:System.InvalidOperationException.%23ctor%2A> Konstruktoren.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Exception" />
    <altmember cref="T:System.Collections.IEnumerator" />
    <altmember cref="T:System.Resources.ResourceSet" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.InvalidOperationException" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.InvalidOperationException" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert die <xref:System.Exception.Message%2A> -Eigenschaft der neuen Instanz auf eine vom System bereitgestellten Meldung, die den Fehler beschreibt, wie z. B. "der angeforderte Vorgang ausgeführt werden darf nicht." Diese Meldung berücksichtigt die aktuelle Systemkultur.  
  
 In der folgenden Tabelle werden die anfänglichen Eigenschaftenwerte für eine <xref:System.InvalidOperationException>-Instanz aufgeführt.  
  
|Eigenschaft|Wert|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Ein NULL-Verweis (`Nothing` in Visual Basic).|  
|<xref:System.Exception.Message%2A>|Die lokalisierte Zeichenfolge mit der Fehlermeldung.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : string -&gt; InvalidOperationException" Usage="new System.InvalidOperationException message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Die Meldung, in der der Fehler beschrieben wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.InvalidOperationException" />-Klasse mit einer angegebenen Fehlermeldung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert die <xref:System.Exception.Message%2A?displayProperty=nameWithType> Eigenschaft der neuen Ausnahme mit der `message` Parameter. Der Inhalt der `message` soll in verständlicher Sprache gehalten sein. Der Aufrufer dieses Konstruktors muss sicherstellen, dass diese Zeichenfolge für die aktuelle Systemkultur lokalisiert wurde.  
  
 In der folgenden Tabelle werden die anfänglichen Eigenschaftenwerte für eine <xref:System.InvalidOperationException>-Instanz aufgeführt.  
  
|Eigenschaft|Wert|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Ein NULL-Verweis (`Nothing` in Visual Basic).|  
|<xref:System.Exception.Message%2A>|Die Zeichenfolge der Fehlermeldung.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected InvalidOperationException (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; InvalidOperationException(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; InvalidOperationException" Usage="new System.InvalidOperationException (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Das Objekt, das die Daten des serialisierten Objekts enthält.</param>
        <param name="context">Die Kontextinformationen zur Quelle bzw. zum Ziel.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.InvalidOperationException" />-Klasse mit serialisierten Daten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor wird während der Deserialisierung aufgerufen, um das über einen Stream übertragene Ausnahmeobjekt wiederherzustellen. Weitere Informationen finden Sie unter [XML- und SOAP-Serialisierung](~/docs/standard/serialization/xml-and-soap-serialization.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : string * Exception -&gt; InvalidOperationException" Usage="new System.InvalidOperationException (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">Die Fehlermeldung, in der die Ursache der Ausnahme erklärt wird.</param>
        <param name="innerException">Die Ausnahme, die die Ursache der aktuellen Ausnahme ist. Wenn der Parameter <c>innerException</c> kein NULL-Verweis ist (<see langword="Nothing" /> in Visual Basic), wird die aktuelle Ausnahme in einem <see langword="catch" />-Block ausgelöst, der die innere Ausnahme behandelt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.InvalidOperationException" />-Klasse mit einer angegebenen Fehlermeldung und einem Verweis auf die innere Ausnahme, die diese Ausnahme ausgelöst hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Ausnahme, die als direktes Ergebnis einer vorhergehenden Ausnahme ausgelöst wird, muss in der <xref:System.Exception.InnerException%2A>-Eigenschaft über einen Verweis auf die vorhergehende Ausnahme verfügen. Die <xref:System.Exception.InnerException%2A>-Eigenschaft gibt denselben Wert zurück, der an den Konstruktor übergeben wurde, bzw. einen NULL-Verweis (`Nothing` in Visual Basic), wenn die <xref:System.Exception.InnerException%2A>-Eigenschaft nicht den Wert für die innere Ausnahme für den Konstruktor bereitstellt.  
  
 In der folgenden Tabelle werden die anfänglichen Eigenschaftenwerte für eine <xref:System.InvalidOperationException>-Instanz aufgeführt.  
  
|Eigenschaft|Wert|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Der Verweis auf die interne Ausnahme.|  
|<xref:System.Exception.Message%2A>|Die Zeichenfolge der Fehlermeldung.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Exception" />
      </Docs>
    </Member>
  </Members>
</Type>