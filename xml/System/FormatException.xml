<Type Name="FormatException" FullName="System.FormatException">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a71878af9c3e979a3e4f6795cdfab98dff08723e" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86602086" /></Metadata><TypeSignature Language="C#" Value="public class FormatException : Exception" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FormatException extends System.Exception" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.FormatException" />
  <TypeSignature Language="VB.NET" Value="Public Class FormatException&#xA;Inherits Exception" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public ref class FormatException : Exception" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type FormatException = class&#xA;    inherit Exception" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public class FormatException : SystemException" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FormatException extends System.SystemException" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public Class FormatException&#xA;Inherits SystemException" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class FormatException : SystemException" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type FormatException = class&#xA;    inherit SystemException" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit FormatException extends System.SystemException" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
    <BaseTypeName FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Die Ausnahme, die ausgelöst wird, wenn das Format eines Arguments ungültig ist, oder wenn eine <see href="https://docs.microsoft.com/dotnet/standard/base-types/composite-formatting">kombinierte Formatierungszeichenfolge</see> nicht wohlgeformt ist.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine- <xref:System.FormatException> Ausnahme kann aus einem der folgenden Gründe ausgelöst werden:  
  
-   Beim Abrufen einer Methode, die eine Zeichenfolge in einen anderen Datentyp konvertiert, entspricht die Zeichenfolge nicht dem erforderlichen Muster. Dies tritt normalerweise auf, wenn einige Methoden der <xref:System.Convert> -Klasse und die `Parse` -Methode und die- `ParseExact` Methode einiger Typen aufgerufen werden.  
  
     In den meisten Fällen, insbesondere wenn die Zeichenfolge, die Sie konvertieren, von einem Benutzer eingegeben oder aus einer Datei gelesen wird, sollten Sie einen `try/catch` -Block verwenden und die Ausnahme behandeln, <xref:System.FormatException> Wenn die Konvertierung nicht erfolgreich ist. Sie können den-Befehl auch durch einen-oder eine- `TryParse` `TryParseExact` Methode ersetzen, sofern vorhanden. Eine- <xref:System.FormatException> Ausnahme, die ausgelöst wird, wenn Sie versuchen, eine vordefinierte oder hart codierte Zeichenfolge zu analysieren, weist jedoch auf einen Programmfehler hin. In diesem Fall sollten Sie den Fehler korrigieren und die Ausnahme nicht behandeln.  
  
     Die Konvertierung einer Zeichenfolge in die folgenden Typen im- <xref:System> Namespace kann eine- <xref:System.FormatException> Ausnahme auslösen:  
  
    -   <xref:System.Boolean>. Die <xref:System.Boolean.Parse%28System.String%29?displayProperty=nameWithType> -Methode und die- <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> Methode erfordern, dass die Zeichenfolge in "true", "true", "false" oder "false" konvertiert wird. Jeder andere Wert löst eine- <xref:System.FormatException> Ausnahme aus.  
  
    -   <xref:System.DateTime> und <xref:System.DateTimeOffset>. Alle Datums-und Uhrzeit Daten werden basierend auf den Formatierungs Konventionen einer bestimmten Kultur interpretiert: entweder die aktuelle Thread Kultur (oder in einigen Fällen die Kultur der aktuellen Anwendungsdomäne), die invariante Kultur oder eine angegebene Kultur. Wenn Sie die <xref:System.DateTime.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> -Methode und die-Methode aufzurufen <xref:System.DateTimeOffset.ParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> , müssen Datums-und Uhrzeitangaben auch *genau* mit einem Muster übereinstimmen, das durch eine oder mehrere [Standardformat](/dotnet/standard/base-types/standard-date-and-time-format-strings) Zeichenfolgen oder [benutzerdefinierte Format](/dotnet/standard/base-types/custom-date-and-time-format-strings) Zeichenfolgen angegeben wird. Wenn Sie keinem erwarteten kulturspezifischen Muster entspricht, wird eine- <xref:System.FormatException> Ausnahme ausgelöst. Dies bedeutet, dass Datums-und Uhrzeit Daten, die in einem kulturspezifischen Format auf einem System gespeichert sind, möglicherweise nicht erfolgreich auf einem anderen System analysiert werden.  
  
         Weitere Informationen zum Überprüfen von Datums-und Uhrzeitangaben finden Sie unter "Auswerten von [Datums-und Uhrzeit](/dotnet/standard/base-types/parsing-datetime) Zeichenfolgen und der Dokumentation für die Methode, die die Ausnahme ausgelöst hat  
  
    -   **GUIDs.** Die Zeichen folgen Darstellung einer GUID muss aus 32 hexadezimalen Ziffern (0-F) bestehen, und Sie muss in einem der fünf Formate vorliegen, die von der-Methode ausgegeben werden <xref:System.Guid.ToString%2A?displayProperty=nameWithType> . Weitere Informationen finden Sie unter der Methode <xref:System.Guid.Parse%2A?displayProperty=nameWithType>.  
  
    -   **Numerische Typen, einschließlich aller ganzzahligen Ganzzahlen, ganzzahlige Ganzzahlen und Gleit Komma Typen.** Die Zeichenfolge, die analysiert werden soll, muss aus den lateinischen Ziffern 0-9 bestehen. Möglicherweise sind auch positive oder negative Vorzeichen, Dezimaltrennzeichen, Gruppen Trennzeichen und Währungssymbole zulässig. Wenn Sie versuchen, eine Zeichenfolge zu analysieren, die ein anderes Zeichen enthält, wird immer eine- <xref:System.FormatException> Ausnahme ausgelöst.  
  
         Alle numerischen Zeichen folgen werden basierend auf den Formatierungs Konventionen einer bestimmten Kultur interpretiert: entweder die aktuelle Thread Kultur (oder in einigen Fällen die Kultur der aktuellen Anwendungsdomäne), die invariante Kultur oder eine angegebene Kultur. Demzufolge kann eine numerische Zeichenfolge, die mithilfe der Konventionen einer Kultur analysiert wird, fehlschlagen, wenn die Konventionen einer anderen verwendet werden.  
  
         Weitere Informationen zum Auswerten numerischer Zeichen folgen finden Sie unter "auswerten [numerischer](/dotnet/standard/base-types/parsing-numeric) Zeichen folgen" und in der Dokumentation für die jeweilige Methode, die die Ausnahme ausgelöst hat.  
  
    -   **Zeitintervalle.** Die zu analysierende Zeichenfolge muss entweder das festgelegte Kultur unabhängige Format oder in einem Kultur abhängigen Format aufweisen, das von der aktuellen Thread Kultur (oder in einigen Fällen der aktuellen Anwendungs Domänen Kultur), der invarianten Kultur oder einer angegebenen Kultur definiert wird. Wenn die Zeichenfolge nicht in einem geeigneten Format vorliegt oder wenn die Komponenten der Tage, Stunden und Minuten des Zeitintervalls nicht vorhanden sind, löst die-Methode eine- <xref:System.FormatException> Ausnahme aus. Weitere Informationen finden Sie in der Dokumentation für die-Methode, die <xref:System.TimeSpan> die Ausnahme ausgelöst hat.  
  
-   Ein Typ implementiert die- <xref:System.IFormattable> Schnittstelle, die Format Zeichenfolgen unterstützt, die definieren, wie ein Objekt in seine Zeichen folgen Darstellung konvertiert wird, und eine ungültige Format Zeichenfolge wird verwendet Dies wird am häufigsten bei einem Formatierungs Vorgang durchläuft. Im folgenden Beispiel wird die Standardformat Zeichenfolge "Q" in einer zusammengesetzten Format Zeichenfolge verwendet, um eine Zahl zu formatieren. "Q" ist jedoch keine gültige [Standardformat Zeichenfolge](/dotnet/standard/base-types/standard-numeric-format-strings).  
  
     [!code-csharp[System.FormatException#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.formatexception/cs/iformattable1.cs#7)]
     [!code-vb[System.FormatException#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.formatexception/vb/iformattable1.vb#7)]  
  
     Diese Ausnahme resultiert aus einem Codierungsfehler. Um den Fehler zu beheben, entfernen Sie entweder die Format Zeichenfolge, oder ersetzen Sie einen gültigen. Im folgenden Beispiel wird der Fehler korrigiert, indem die ungültige Format Zeichenfolge durch die Format Zeichenfolge "C" (Currency) ersetzt wird.  
  
     [!code-csharp[System.FormatException#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.formatexception/cs/iformattable2.cs#8)]
     [!code-vb[System.FormatException#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.formatexception/vb/iformattable2.vb#8)]  
  
     Eine- <xref:System.FormatException> Ausnahme kann auch durch das Analysieren von Methoden ausgelöst werden, z. b. <xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType> und <xref:System.Guid.ParseExact%2A?displayProperty=nameWithType> , bei denen die Zeichenfolge analysiert werden muss, damit Sie exakt dem durch eine Format Zeichenfolge angegebenen Muster entspricht. Im folgenden Beispiel wird erwartet, dass die Zeichen folgen Darstellung einer GUID dem Muster entspricht, das von der Standardformat Zeichenfolge "G" angegeben wird. Die <xref:System.Guid> -Implementierung der-Struktur <xref:System.IFormattable> unterstützt jedoch nicht die Format Zeichenfolge "G".  
  
     [!code-csharp[System.FormatException#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.formatexception/cs/iformattable3.cs#9)]
     [!code-vb[System.FormatException#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.formatexception/vb/iformattable3.vb#9)]  
  
     Diese Ausnahme resultiert auch aus einem Codierungsfehler. Um dies zu korrigieren, geben Sie eine-Methode für die-Methode an, die kein genaues Format erfordert, wie z <xref:System.DateTime.Parse%2A?displayProperty=nameWithType> <xref:System.Guid.Parse%2A?displayProperty=nameWithType> . b. oder. Im folgenden Beispiel wird der Fehler korrigiert, indem die-Methode aufgerufen wird <xref:System.Guid.Parse%2A?displayProperty=nameWithType> .  
  
     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.formatexception/cs/iformattable4.cs" interactive="try-dotnet" id="Snippet10":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.formatexception/vb/iformattable4.vb" id="Snippet10":::
  
-   Mindestens ein Index der Format Elemente in einer zusammen [gesetzten Format Zeichenfolge](/dotnet/standard/base-types/composite-formatting) ist größer als die Indizes der Elemente in der Objektliste oder im Parameter Array. Im folgenden Beispiel ist der größte Index eines Format Elements in der Format Zeichenfolge 3. Da die Indizes der Elemente in der Objektliste Null basiert sind, erfordert diese Format Zeichenfolge, dass die Objektliste vier Elemente aufweist. Stattdessen enthält Sie nur drei, `dat` , `temp` und `scale` , sodass der Code <xref:System.FormatException> zur Laufzeit zu einer-Ausnahme führt:.  
  
     [!code-csharp[System.FormatException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.formatexception/cs/example1.cs#1)]
     [!code-vb[System.FormatException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.formatexception/vb/example1.vb#1)]  
  
     In diesem Fall ist die <xref:System.FormatException> Ausnahme das Ergebnis eines Entwickler Fehlers. Er sollte korrigiert und nicht in einem-Block behandelt werden `try/catch` , indem sichergestellt wird, dass jedes Element in der Objektliste dem Index eines Format Elements entspricht. Um dieses Beispiel zu korrigieren, ändern Sie den Index des zweiten Format Elements, um auf die Variable zu verweisen `dat` , und verringern Sie den Index der einzelnen nachfolgenden Formatierungs Elemente um 1.  
  
     [!code-csharp[System.FormatException#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.formatexception/cs/example2.cs#2)]
     [!code-vb[System.FormatException#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.formatexception/vb/example2.vb#2)]  
  
-   Die kombinierte Format Zeichenfolge ist nicht wohl geformt. In diesem Fall ist die <xref:System.FormatException> Ausnahme immer das Ergebnis eines Entwickler Fehlers. Er sollte korrigiert und nicht in einem-Block behandelt werden `try/catch` .  
  
     Wenn Sie versuchen, Literale geschweifte Klammern in eine Zeichenfolge einzubeziehen, wie im folgenden Beispiel dargestellt, wird die Ausnahme ausgelöst.  
  
     [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
     [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
     Die empfohlene Vorgehensweise zum Einschließen von literalklammern in einer zusammengesetzten Format Zeichenfolge besteht darin, Sie in die Objektliste einzubeziehen und Format Elemente zu verwenden, um Sie in die Ergebnis Zeichenfolge einzufügen. Beispielsweise können Sie die vorherige kombinierte Format Zeichenfolge ändern, wie hier gezeigt.  
  
     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs" interactive="try-dotnet-method" id="Snippet24":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb" id="Snippet24":::
  
     Die Ausnahme wird auch ausgelöst, wenn die Format Zeichenfolge ein Typo enthält. Der folgende-Befehl gibt <xref:System.String.Format%2A?displayProperty=nameWithType> eine schließende geschweifte Klammer aus und verbindet eine öffnende geschweifte Klammer mit einer schließenden Klammer.  
  
     [!code-csharp[System.FormatException#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.formatexception/cs/example3.cs#3)]
     [!code-vb[System.FormatException#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.formatexception/vb/example3.vb#3)]  
  
     Stellen Sie sicher, dass alle öffnenden und schließenden Klammern übereinstimmen, um den Fehler zu beheben  
  
     [!code-csharp[System.FormatException#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.formatexception/cs/example3.cs#4)]
     [!code-vb[System.FormatException#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.formatexception/vb/example3.vb#4)]  
  
-   Sie haben die Objektliste in einer zusammengesetzten Formatierungs Methode als stark typisiertes Parameter Array bereitgestellt, und die <xref:System.FormatException> Ausnahme gibt an, dass der Index von einem oder mehreren Format Elementen die Anzahl der Argumente in der Objektliste überschreitet. Dies liegt daran, dass keine explizite Konvertierung zwischen Array Typen vorhanden ist. Daher behandelt der Compiler das Array nicht als Parameter Array, sondern als einzelnes Argument. Beispielsweise löst der folgende Aufrufen der- <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> Methode eine- <xref:System.FormatException> Ausnahme aus, obwohl der höchste Index der Format Elemente 3 ist und das Parameter Array vom Typ <xref:System.Int32> vier Elemente aufweist.  
  
     [!code-csharp[System.FormatException#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.formatexception/cs/qa1.cs#5)]
     [!code-vb[System.FormatException#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.formatexception/vb/qa1.vb#5)]  
  
     Anstatt diese Ausnahme zu behandeln, sollten Sie die Ursache beseitigen. Da weder Visual Basic noch c# ein ganzzahliges Array in ein Objekt Array konvertieren kann, müssen Sie die Konvertierung selbst durchführen, bevor Sie die Methode für die kombinierte Formatierung aufrufen. Der folgende Code zeigt ein Implementierungsbeispiel.  
  
     :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.formatexception/cs/qa2.cs" interactive="try-dotnet" id="Snippet6":::
     :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.formatexception/vb/qa2.vb" id="Snippet6":::
  
 <xref:System.FormatException>verwendet das HRESULT-COR_E_FORMAT, das den Wert 0x80131537 hat.  
  
 Die <xref:System.FormatException> -Klasse wird von abgeleitet <xref:System.Exception> und fügt keine eindeutigen Member hinzu. Eine Liste der anfänglichen Eigenschaftswerte für eine Instanz von <xref:System.FormatException>, finden Sie unter den <xref:System.FormatException.%23ctor%2A> Konstruktoren.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Exception" />
    <related type="Article" href="/dotnet/standard/exceptions/">Behandeln und Auslösen von Ausnahmen</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.FormatException" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FormatException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.FormatException.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FormatException();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.FormatException" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert die <xref:System.Exception.Message%2A> -Eigenschaft der neuen Instanz mit einer vom System bereitgestellten Meldung, die den Fehler beschreibt, z. b. "Ungültiges Format". Diese Meldung berücksichtigt die aktuelle Systemkultur.  
  
 In der folgenden Tabelle werden die anfänglichen Eigenschaftenwerte für eine <xref:System.FormatException>-Instanz aufgeführt.  
  
|Eigenschaft|Wert|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Ein NULL-Verweis (`Nothing` in Visual Basic).|  
|<xref:System.Exception.Message%2A>|Die lokalisierte Zeichenfolge mit der Fehlermeldung.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FormatException (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.FormatException.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FormatException(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new FormatException : string -&gt; FormatException" Usage="new System.FormatException message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Die Meldung, in der der Fehler beschrieben wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.FormatException" />-Klasse mit einer angegebenen Fehlermeldung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert die- <xref:System.Exception.Message%2A?displayProperty=nameWithType> Eigenschaft der neuen Ausnahme mit dem- `message` Parameter. Der Inhalt der `message` soll in verständlicher Sprache gehalten sein. Der Aufrufer dieses Konstruktors ist erforderlich, um sicherzustellen, dass diese Zeichenfolge für die aktuelle Systemkultur lokalisiert wurde.  
  
 In der folgenden Tabelle werden die anfänglichen Eigenschaftenwerte für eine <xref:System.FormatException>-Instanz aufgeführt.  
  
|Eigenschaft|Wert|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Ein NULL-Verweis (`Nothing` in Visual Basic).|  
|<xref:System.Exception.Message%2A>|Die Zeichenfolge der Fehlermeldung.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected FormatException (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.FormatException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; FormatException(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new FormatException : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; FormatException" Usage="new System.FormatException (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="info">Das Objekt, das die Daten des serialisierten Objekts enthält.</param>
        <param name="context">Die Kontextinformationen zur Quelle bzw. zum Ziel.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.FormatException" />-Klasse mit serialisierten Daten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor wird während der Deserialisierung aufgerufen, um das über einen Datenstrom übertragene Ausnahmeobjekt wieder zusammenzusetzen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FormatException (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.FormatException.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FormatException(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new FormatException : string * Exception -&gt; FormatException" Usage="new System.FormatException (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">Die Fehlermeldung, in der die Ursache der Ausnahme erklärt wird.</param>
        <param name="innerException">Die Ausnahme, die die Ursache der aktuellen Ausnahme ist. Wenn der <paramref name="innerException" />-Parameter kein NULL-Verweis ist (<see langword="Nothing" /> in Visual Basic), wird die aktuelle Ausnahme in einem <see langword="catch" />-Block ausgelöst, der die innere Ausnahme behandelt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.FormatException" />-Klasse mit einer angegebenen Fehlermeldung und einem Verweis auf die innere Ausnahme, die diese Ausnahme ausgelöst hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Ausnahme, die als direktes Ergebnis einer vorhergehenden Ausnahme ausgelöst wird, muss in der <xref:System.Exception.InnerException%2A>-Eigenschaft über einen Verweis auf die vorhergehende Ausnahme verfügen. Die <xref:System.Exception.InnerException%2A>-Eigenschaft gibt denselben Wert zurück, der an den Konstruktor übergeben wurde, bzw. einen NULL-Verweis (`Nothing` in Visual Basic), wenn die <xref:System.Exception.InnerException%2A>-Eigenschaft nicht den Wert für die innere Ausnahme für den Konstruktor bereitstellt.  
  
 In der folgenden Tabelle werden die anfänglichen Eigenschaftenwerte für eine <xref:System.FormatException>-Instanz aufgeführt.  
  
|Eigenschaft|Wert|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Der Verweis auf die interne Ausnahme.|  
|<xref:System.Exception.Message%2A>|Die Zeichenfolge der Fehlermeldung.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Exception" />
        <related type="Article" href="/dotnet/standard/exceptions/">Behandeln und Auslösen von Ausnahmen</related>
      </Docs>
    </Member>
  </Members>
</Type>
