<Type Name="Delegate" FullName="System.Delegate">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3c84214616227ed5b97a228457da5e5046b56ee0" /><Meta Name="ms.sourcegitcommit" Value="a372e6accee5099e1c114f8589ca6b4537f1caaa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/20/2020" /><Meta Name="ms.locfileid" Value="88655336" /></Metadata><TypeSignature Language="C#" Value="public abstract class Delegate" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Delegate extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type Delegate = class" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Delegate = class&#xA;    interface ICloneable&#xA;    interface ISerializable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen Delegaten dar, der eine Datenstruktur ist, die auf eine statische Methode oder eine Klasseninstanz und eine Instanzmethode dieser Klasse verweist.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Delegate> Klasse ist die Basisklasse für Delegattypen. Allerdings können nur das System und die Compiler explizit von der- <xref:System.Delegate> Klasse oder von der-Klasse abgeleitet werden <xref:System.MulticastDelegate> . Es ist auch nicht zulässig, einen neuen Typ von einem Delegattyp abzuleiten. Die <xref:System.Delegate> Klasse wird nicht als Delegattyp betrachtet. Sie ist eine Klasse, die zum Ableiten von Delegattypen verwendet wird.  
  
 In den meisten Sprachen `delegate` wird ein Schlüsselwort implementiert, und Compiler für diese Sprachen können von der-Klasse abgeleitet werden <xref:System.MulticastDelegate> . Daher sollten Benutzer das `delegate` von der Sprache bereitgestellte Schlüsselwort verwenden.  
  
> [!NOTE]
>  Der Common Language Runtime stellt eine- `Invoke` Methode für jeden Delegattyp mit der gleichen Signatur wie der Delegat bereit. Diese Methode muss nicht explizit aus c#, Visual Basic oder Visual C++ aufgerufen werden, da Sie von den Compilern automatisch aufgerufen wird. Die- `Invoke` Methode ist hilfreich bei der [Reflektion](/dotnet/framework/reflection-and-codedom/reflection) , wenn Sie die Signatur des Delegattyps suchen möchten.  
  
 Der Common Language Runtime stellt jeden Delegattyp mit `BeginInvoke` -und- `EndInvoke` Methoden bereit, um den asynchronen Aufruf des Delegaten zu aktivieren. Weitere Informationen zu diesen Methoden finden Sie unter [Asynchrones Aufrufen synchroner Methoden](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously).  
  
 Durch die Deklaration eines Delegattyps wird ein Vertrag festgelegt, der die Signatur von mindestens einer Methode angibt. Ein Delegat ist eine Instanz eines Delegattyps, der über Verweise auf verfügt:  
  
-   Eine Instanzmethode eines Typs und ein Zielobjekt, das diesem Typ zugeordnet werden kann.  
  
-   Eine Instanzmethode eines Typs, bei der der ausgeblendete `this` Parameter in der Liste formaler Parameter verfügbar gemacht wird. Der Delegat wird als Open instance-Delegat bezeichnet.  
  
-   Eine statische Methode.  
  
-   Eine statische Methode und ein Zielobjekt, die dem ersten Parameter der Methode zugewiesen werden können. Der Delegat wird als erstes Argument geschlossen.  
  
 Weitere Informationen zur Delegatbindung finden Sie unter der- <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> Methoden Überladung.  
  
> [!NOTE]
>  In den .NET Framework Versionen 1,0 und 1,1 kann ein Delegat nur dann eine Methode darstellen, wenn die Signatur der Methode exakt mit der Signatur übereinstimmt, die durch den Delegattyp angegeben wird. Folglich werden nur das erste und dritte Zeichen in der vorangehenden Liste unterstützt, und das erste Aufzählungs Zeichen erfordert eine genaue Typübereinstimmung.  
  
 Wenn ein Delegat eine Instanzmethode darstellt, die über seinem ersten Argument geschlossen wurde (der häufigste Fall), speichert der Delegat einen Verweis auf den Einstiegspunkt der Methode und einen Verweis auf ein Objekt, das als Ziel bezeichnet wird. es handelt sich um einen Typ, der dem Typ zugewiesen werden kann, der die Methode definiert hat. Wenn ein Delegat eine Open instance-Methode darstellt, wird ein Verweis auf den Einstiegspunkt der Methode gespeichert. Die Delegatsignatur muss den Hidden- `this` Parameter in der formalen Parameterliste enthalten. in diesem Fall hat der Delegat keinen Verweis auf ein Zielobjekt, und ein Zielobjekt muss bereitgestellt werden, wenn der Delegat aufgerufen wird.  
  
 Wenn ein Delegat eine statische Methode darstellt, speichert der Delegat einen Verweis auf den Einstiegspunkt der Methode. Wenn ein Delegat eine statische Methode darstellt, die über seinem ersten Argument geschlossen wurde, speichert der Delegat einen Verweis auf den Einstiegspunkt der Methode und einen Verweis auf ein Zielobjekt, das dem Typ des ersten Arguments der Methode zugewiesen werden kann. Wenn der Delegat aufgerufen wird, empfängt das erste Argument der statischen Methode das Zielobjekt.  
  
 Die Aufruf Liste eines Delegaten ist eine geordnete Gruppe von Delegaten, in der jedes Element der Liste genau eine der Methoden aufruft, die durch den Delegaten dargestellt werden. Eine Aufruf Liste kann doppelte Methoden enthalten. Bei einem Aufruf werden Methoden in der Reihenfolge aufgerufen, in der Sie in der Aufruf Liste angezeigt werden. Ein Delegat versucht, jede Methode in der Aufruf Liste aufzurufen. Duplikate werden einmal für jedes Mal aufgerufen, wenn Sie in der Aufruf Liste angezeigt werden. Delegaten sind unveränderlich. nach der Erstellung wird die Aufruf Liste eines Delegaten nicht geändert.  
  
 Delegaten werden als Multicast oder kombinierbar bezeichnet, da ein Delegat eine oder mehrere Methoden aufrufen kann und in Kombination von Vorgängen verwendet werden kann.  
  
 Beim Kombinieren von Vorgängen wie und werden vorhandene Delegaten <xref:System.Delegate.Combine%2A> <xref:System.Delegate.Remove%2A> nicht geändert. Stattdessen gibt ein solcher Vorgang einen neuen Delegaten zurück, der die Ergebnisse des Vorgangs, einen unveränderten Delegaten oder enthält `null` . Ein Kombinations Vorgang gibt zurück `null` , wenn das Ergebnis des Vorgangs ein Delegat ist, der nicht auf mindestens eine Methode verweist. Ein kombinierter Vorgang gibt einen unveränderten Delegaten zurück, wenn der angeforderte Vorgang keine Auswirkung hat.  
  
> [!NOTE]
>  Verwaltete Sprachen verwenden die <xref:System.Delegate.Combine%2A> <xref:System.Delegate.Remove%2A> Methoden und zum Implementieren von delegatvorgängen. Beispiele hierfür sind die `AddHandler` -und `RemoveHandler` -Anweisungen in Visual Basic und die Operatoren + = und-= für Delegattypen in c#.  
  
 Beginnend mit [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] können generische Delegattypen über Variante Typparameter verfügen. Kontra Variante Typparameter können als Parametertypen des Delegaten verwendet werden, und ein kovariant-Typparameter kann als Rückgabetyp verwendet werden. Diese Funktion ermöglicht es, dass generische Delegattypen, die aus der gleichen generischen Typdefinition erstellt werden, Zuweisungs kompatibel sind, wenn ihre Typargumente Verweis Typen mit einer Vererbungs Beziehung sind, wie in [Kovarianz und Kontra Varianz](/dotnet/standard/generics/covariance-and-contravariance)erläutert.  
  
> [!NOTE]
>  Generische Delegaten, die aufgrund von Varianz Zuweisungs kompatibel sind, sind nicht notwendigerweise kombinierbar. Damit die Typen kombinierbar sind, müssen Sie exakt übereinstimmen. Nehmen wir beispielsweise an, dass eine Klasse mit dem Namen `Derived` von einer Klasse mit dem Namen abgeleitet ist `Base` . Ein Delegat vom Typ `Action<Base>` ( `Action(Of Base)` in Visual Basic) kann einer Variablen vom Typ zugewiesen werden. die beiden Delegaten können jedoch nicht `Action<Derived>` kombiniert werden, da die Typen nicht exakt übereinstimmen.  
  
 Wenn eine aufgerufene Methode eine Ausnahme auslöst, wird die Ausführung der Methode beendet, die Ausnahme wird an den Aufrufer des Delegaten zurückgegeben, und die verbleibenden Methoden in der Aufruf Liste werden nicht aufgerufen. Das Abfangen der Ausnahme im Aufrufer ändert dieses Verhalten nicht.  
  
 Wenn die Signatur der von einem Delegaten aufgerufenen Methoden einen Rückgabewert enthält, gibt der Delegat den Rückgabewert des letzten Elements in der Aufruf Liste zurück. Wenn die Signatur einen Parameter enthält, der als Verweis übergeben wird, ist der endgültige Wert des Parameters das Ergebnis jeder Methode in der Aufruf Liste, die sequenziell ausgeführt wird und den Wert des Parameters aktualisiert.  
  
 Die nächstliegende Entsprechung eines Delegaten in C ist ein Funktionszeiger. Ein Delegat kann eine statische Methode oder eine Instanzmethode darstellen. Wenn der Delegat eine Instanzmethode darstellt, speichert der Delegat nicht nur einen Verweis auf den Einstiegspunkt der Methode, sondern auch einen Verweis auf die Klasseninstanz. Im Gegensatz zu Funktions Zeigern sind Delegaten objektorientiert und typsicher.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie einen Delegaten mit dem Namen definieren `myMethodDelegate` . Instanzen dieses Delegaten werden für eine Instanzmethode und eine statische Methode der-Klasse erstellt `mySampleClass` . Der Delegat für die Instanzmethode erfordert eine Instanz von `mySampleClass` . Die- `mySampleClass` Instanz wird in einer Variablen mit dem Namen gespeichert `mySC` .  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb" id="Snippet1":::

 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
    <related type="Article" href="/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously">Asynchrones Aufrufen von synchronen Methoden</related>
    <related type="Article" href="/dotnet/csharp/programming-guide/delegates/">Delegaten (C#-Programmierhandbuch)</related>
    <related type="Article" href="/dotnet/visual-basic/programming-guide/language-features/delegates/">Delegaten (Visual Basic)</related>
    <related type="Article" href="/cpp/dotnet/how-to-define-and-use-delegates-cpp-cli">Gewusst wie: Definieren und Verwenden von Delegaten (C++/CLI)</related>
    <related type="Article" href="/dotnet/standard/events/">Behandeln und Auslösen von Ereignissen</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert einen neuen Delegaten.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : obj * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="target">Die Klasseninstanz, für die der Delegat <paramref name="method" /> aufruft.</param>
        <param name="method">Der Name der Instanzenmethode, die durch den Delegaten dargestellt wird.</param>
        <summary>Initialisiert einen Delegaten, der die angegebene Instanzenmethode für die angegebene Klasseninstanz aufruft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor kann nicht im Anwendungscode verwendet werden. Um einen Delegaten durch Angabe des Namens einer Instanzmethode zu erstellen, verwenden Sie eine Überladung der <xref:System.Delegate.CreateDelegate%2A> -Methode, die einen Methodennamen und ein Zielobjekt angibt. Beispielsweise erstellt die- <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29> Methoden Überladung einen Delegaten für eine Instanzmethode mit einem angegebenen Namen.  
  
 Dieser Konstruktor erstellt nur Delegaten für Instanzmethoden. Eine Instanzmethode ist eine Methode, die einer Instanz einer-Klasse zugeordnet ist. eine statische Methode ist eine Methode, die der Klasse selbst zugeordnet ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Beim Binden an die Zielmethode ist ein Fehler aufgetreten.</exception>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : Type * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="target">Der <see cref="T:System.Type" />, der die Klasse darstellt, die <paramref name="method" /> definiert.</param>
        <param name="method">Der Name der statischen Methode, die durch den Delegaten dargestellt wird.</param>
        <summary>Initialisiert einen Delegaten, der die angegebene statische Methode der angegebenen Klasse aufruft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor kann nicht im Anwendungscode verwendet werden. Um einen Delegaten zu erstellen, indem Sie den Namen einer statischen Methode angeben, verwenden Sie eine Überladung der- <xref:System.Delegate.CreateDelegate%2A> Methode, die einen Methodennamen angibt, aber kein Zielobjekt angibt. Beispielsweise erstellt die- <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29> Methoden Überladung einen statischen Delegaten für eine Methode mit einem angegebenen Namen.  
  
 Dieser Konstruktor erstellt Delegaten nur für statische Methoden. Eine Instanzmethode ist eine Methode, die einer Instanz einer-Klasse zugeordnet ist. eine statische Methode ist eine Methode, die der Klasse selbst zugeordnet ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> ist keine <see langword="RuntimeType" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- oder - 
 <paramref name="target" /> entspricht einem offenen generischen Typ.</exception>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="delegate.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine flache Kopie des Delegaten.</summary>
        <returns>Eine flache Kopie des Delegaten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Klon hat dieselbe <xref:System.Type> , eine Ziel-, Methoden-und Aufruf Liste wie der ursprüngliche Delegat.  
  
 Eine flache Kopie erstellt eine neue Instanz desselben Typs wie das ursprüngliche Objekt und kopiert dann die nicht statischen Felder des ursprünglichen Objekts. Wenn das Feld ein Werttyp ist, wird eine Bit-für-Bit-Kopie des Felds ausgeführt. Wenn das Feld ein Referenztyp ist, wird der Verweis kopiert, aber das referenzierte Objekt ist nicht. Daher zeigen der Verweis im ursprünglichen Objekt und der Verweis im Klon auf dasselbe Objekt. Im Gegensatz dazu dupliziert eine tiefe Kopie eines Objekts alle Elemente, die direkt oder indirekt durch die Felder im-Objekt referenziert werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verkettet die Aufruflisten der angegebenen Multicastdelegaten.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate[] -&gt; Delegate" Usage="System.Delegate.Combine delegates" />
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate[] delegates);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (delegates As Delegate()) As Delegate" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(cli::array &lt;Delegate ^&gt; ^ delegates);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">Das zu kombinierende Array von Delegaten.</param>
        <summary>Verkettet die Aufruflisten eines Arrays von Delegaten.</summary>
        <returns>Ein neuer Delegat mit einer Aufrufliste, die aus der Verkettung der Aufruflisten der Delegaten im <paramref name="delegates" />-Array besteht. Gibt <see langword="null" /> zurück, wenn <paramref name="delegates" /><see langword="null" /> ist, <paramref name="delegates" /> 0 Elemente enthält oder jeder Eintrag in <paramref name="delegates" /><see langword="null" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das `delegates` Array Einträge enthält, die sind `null` , werden diese Einträge ignoriert.  
  
 Die Aufruf Liste kann doppelte Einträge enthalten. Das heißt, Einträge, die auf dieselbe Methode für dasselbe Objekt verweisen.  
  
> [!NOTE]
>  Generische Delegaten, die aufgrund von Varianz Zuweisungs kompatibel sind, sind nicht notwendigerweise kombinierbar. Damit die Typen kombinierbar sind, müssen Sie exakt übereinstimmen. Nehmen wir beispielsweise an, dass eine Klasse mit dem Namen `Derived` von einer Klasse mit dem Namen abgeleitet ist `Base` . Ein Delegat vom Typ `Action<Base>` ( `Action(Of Base)` in Visual Basic) kann einer Variablen vom Typ zugewiesen werden `Action<Derived>` , wie in [Kovarianz und Kontra Varianz](/dotnet/standard/generics/covariance-and-contravariance)erläutert, aber die beiden Delegaten können nicht kombiniert werden, da die Typen nicht exakt übereinstimmen.  
  
 <xref:System.Delegate.Combine%2A> ist nützlich zum Erstellen von Ereignis Handlern, die bei jedem Auftreten eines Ereignisses mehrere Methoden aufzurufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nicht alle Einträge ungleich null in <paramref name="delegates" /> sind Instanzen des gleichen Delegattyps.</exception>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Combine (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">Der Delegat, dessen Aufrufliste die erste Liste ist.</param>
        <param name="b">Der Delegat, dessen Aufrufliste die letzte Liste ist.</param>
        <summary>Verkettet die Aufruflisten zweier Delegaten.</summary>
        <returns>Eine neuer Delegat mit einer Aufrufliste, die aus der Verkettung der Aufruflisten von <paramref name="a" /> und <paramref name="b" /> in dieser Reihenfolge besteht. Gibt <paramref name="a" /> zurück, wenn <paramref name="b" /> gleich <see langword="null" /> ist, gibt <paramref name="b" /> zurück, wenn <paramref name="a" /> ein NULL-Verweis ist, und gibt einen NULL-Verweis zurück, wenn <paramref name="a" /> und <paramref name="b" /> NULL-Verweise sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Aufruf Liste kann doppelte Einträge enthalten. Das heißt, Einträge, die auf dieselbe Methode für dasselbe Objekt verweisen.  
  
> [!NOTE]
>  Generische Delegaten, die aufgrund von Varianz Zuweisungs kompatibel sind, sind nicht notwendigerweise kombinierbar. Damit die Typen kombinierbar sind, müssen Sie exakt übereinstimmen. Nehmen wir beispielsweise an, dass eine Klasse mit dem Namen `Derived` von einer Klasse mit dem Namen abgeleitet ist `Base` . Ein Delegat vom Typ `Action<Base>` ( `Action(Of Base)` in Visual Basic) kann einer Variablen vom Typ zugewiesen werden `Action<Derived>` , wie in [Kovarianz und Kontra Varianz](/dotnet/standard/generics/covariance-and-contravariance)erläutert, aber die beiden Delegaten können nicht kombiniert werden, da die Typen nicht exakt übereinstimmen.  
  
 <xref:System.Delegate.Combine%2A> ist nützlich zum Erstellen von Ereignis Handlern, die bei jedem Auftreten eines Ereignisses mehrere Methoden aufzurufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Sowohl <paramref name="a" /> als auch <paramref name="b" /> sind nicht gleich <see langword="null" />, und <paramref name="a" /> und <paramref name="b" /> sind keine Instanzen desselben Delegatentyps.</exception>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate? d);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member CombineImpl : Delegate -&gt; Delegate&#xA;override this.CombineImpl : Delegate -&gt; Delegate" Usage="delegate.CombineImpl d" />
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="d">Der Multicastdelegat, dessen Aufrufliste an das Ende der Aufrufliste des aktuellen Multicastdelegaten angefügt werden soll.</param>
        <summary>Verkettet die Aufruflisten des angegebenen und des aktuellen Multicastdelegaten.</summary>
        <returns>Eine neuer Multicastdelegat, dessen Aufrufliste aus der Verkettung der Aufrufliste des aktuellen Multicastdelegaten mit der Aufrufliste von <paramref name="d" /> besteht, oder der aktuelle Multicastdelegat, wenn <paramref name="d" /><see langword="null" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gilt nur, wenn der aktuelle Delegat Multicast (combinable) ist.  
  
 Die aktuelle Implementierung löst einfach eine aus <xref:System.MulticastNotSupportedException> .  
  
 Die Aufruf Liste kann doppelte Einträge enthalten. Das heißt, Einträge, die auf dieselbe Methode für dasselbe Objekt verweisen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException">Wird immer ausgelöst.</exception>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen Delegaten vom angegebenen Typs.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDelegate (type As Type, method As MethodInfo) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="type">Der <see cref="T:System.Type" /> des zu erstellenden Delegaten.</param>
        <param name="method">Die <see cref="T:System.Reflection.MethodInfo" />, die die statische Methode oder Instanzmethode beschreibt, die der Delegat darstellen soll. In .NET Framework, Version 1.0 und 1.1, werden nur statische Methoden unterstützt.</param>
        <summary>Erstellt einen Delegaten vom angegebenen Typ, der die angegebene statische Methode darstellen soll.</summary>
        <returns>Ein Delegat vom angegebenen Typ, der die angegebene statische Methode darstellen soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In den .NET Framework, Version 1,0 und 1,1, erstellt diese Methoden Überladung Delegaten nur für statische Methoden. In der .NET Framework Version 2,0 kann diese Methoden Überladung auch Open instance-Methoden Delegaten erstellen. Das heißt, Delegaten, die explizit das ausgeblendete erste Argument der Instanzmethoden bereitstellen. Eine ausführliche Erläuterung finden <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> Sie in der allgemeineren Methoden Überladung, mit der Sie alle Kombinationen offener oder geschlossener Delegaten für Instanzen oder statische Methoden erstellen und optional ein erstes Argument angeben können.  
  
> [!NOTE]
>  Diese Methoden Überladung sollte verwendet werden, wenn der Delegat nicht über das erste Argument geschlossen wird, da er in diesem Fall etwas schneller ist.  
  
 Diese Methoden Überladung entspricht dem Aufrufen der <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> -Methoden Überladung und der Angabe `true` von für `throwOnBindFailure` .  
  
> [!NOTE]
>  Ab [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] kann diese Methode verwendet werden, um auf nicht öffentliche Methoden zuzugreifen, wenn der <xref:System.Security.Permissions.ReflectionPermission> Aufrufer mit dem-Flag erteilt wurde, <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> und wenn der Berechtigungs Satz der nicht öffentlichen Methoden auf den Berechtigungs Satz des Aufrufers oder auf eine Teilmenge des Aufrufers beschränkt ist. (Siehe [Sicherheitsüberlegungen für die Reflektion](/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
## <a name="compatible-parameter-types-and-return-type"></a>Kompatible Parameter Typen und Rückgabetyp  
 In der .NET Framework Version 2,0 müssen die Parametertypen und der Rückgabetyp eines Delegaten, der mit dieser Methoden Überladung erstellt wurde, mit den Parametertypen und dem Rückgabetyp der Methode kompatibel sein, die der Delegat darstellt. die Typen müssen nicht exakt übereinstimmen. Dies stellt eine Lockerung des Bindungs Verhaltens in den .NET Framework Version 1,0 und 1,1 dar, bei denen die Typen genau übereinstimmen müssen.  
  
 Ein Parameter eines Delegaten ist mit dem entsprechenden Parameter einer Methode kompatibel, wenn der Typ des Delegatenparameters restriktiver ist als der Methodenparameter, da so gewährleistet ist, dass ein an den Delegaten übergebenes Argument problemlos an die Methode weitergeleitet werden kann.  
  
 Ebenso ist der Rückgabetyp eines Delegaten kompatibel mit dem Rückgabetyp einer Methode, wenn der Rückgabetyp der Methode restriktiver ist als der Rückgabetyp des Delegaten, da so gewährleistet ist, dass der Rückgabewert der Methode problemlos in den Rückgabetyp des Delegaten umgewandelt werden kann.  
  
 Beispielsweise kann ein Delegat mit einem Parameter vom Typ <xref:System.Collections.Hashtable> und dem Rückgabetyp <xref:System.Object> eine Methode mit einem Parameter vom Typ <xref:System.Object> und einen Rückgabewert des Typs darstellen <xref:System.Collections.Hashtable> .  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Im ersten Beispiel werden die beiden Arten von Delegaten veranschaulicht, die mit dieser Methoden Überladung erstellt werden können: offen über eine Instanzmethode und öffnen über eine statische Methode.  
  
 Im zweiten Codebeispiel werden kompatible Parametertypen und Rückgabe Typen veranschaulicht.  
  
 **Beispiel 1**  
  
 Im folgenden Codebeispiel werden die zwei Möglichkeiten veranschaulicht, wie ein Delegat mit dieser Überladung der-Methode erstellt werden kann <xref:System.Delegate.CreateDelegate%2A> .  
  
> [!NOTE]
>  Es gibt zwei über Ladungen der- <xref:System.Delegate.CreateDelegate%2A> Methode, die ein, <xref:System.Reflection.MethodInfo> aber kein erstes Argument angeben. ihre Funktionalität ist identisch, mit dem Unterschied, dass Sie angeben können, ob bei Bindungs Fehlern eine Ausnahme ausgelöst werden soll, die andere immer auslöst. In diesem Codebeispiel werden beide über Ladungen verwendet.  
  
 Im Beispiel wird eine-Klasse `C` mit einer statischen `M2` -Methode und einer Instanzmethode `M1` und zwei Delegattypen deklariert: `D1` nimmt eine Instanz von `C` und eine Zeichenfolge an und `D2` nimmt eine Zeichenfolge an.  
  
 Eine zweite Klasse mit `Example` dem Namen enthält den Code, mit dem die Delegaten erstellt werden.  
  
-   Ein Delegat vom Typ `D1` , der eine Open instance-Methode darstellt, wird für die Instanzmethode erstellt `M1` . Wenn der Delegat aufgerufen wird, muss eine-Instanz übermittelt werden.  
  
-   Ein Delegat vom Typ `D2` , der eine offene statische Methode darstellt, wird für die statische Methode erstellt `M2` .  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Beispiel 2**  
  
 Im folgenden Codebeispiel wird die Kompatibilität von Parametertypen und Rückgabe Typen veranschaulicht.  
  
 Im Codebeispiel wird eine Basisklasse mit dem Namen `Base` und eine Klasse mit dem Namen definiert `Derived` , die von abgeleitet wird `Base` . Die abgeleitete Klasse verfügt über eine `static` `Shared` -Methode (in Visual Basic) mit dem Namen, die einen `MyMethod` Parameter vom Typ `Base` und den Rückgabetyp aufweist `Derived` . Das Codebeispiel definiert auch einen Delegaten `Example` mit dem Namen, der einen Parameter vom Typ `Derived` und den Rückgabetyp hat `Base` .  
  
 Das Codebeispiel veranschaulicht, dass der Delegat mit dem Namen `Example` zur Darstellung der-Methode verwendet werden kann `MyMethod` . Die-Methode kann aus folgenden Gründen an den-Delegaten gebunden werden:  
  
-   Der Parametertyp des Delegaten ( `Derived` ) ist restriktiver als der Parametertyp von `MyMethod` ( `Base` ), sodass es immer sicher ist, das-Argument des Delegaten an zu übergeben `MyMethod` .  
  
-   Der Rückgabetyp von `MyMethod` ( `Derived` ) ist restriktiver als der Parametertyp des Delegaten ( `Base` ), sodass es immer sicher ist, den Rückgabetyp der Methode in den Rückgabetyp des Delegaten umzuwandeln.  
  
 Das Codebeispiel erzeugt keine Ausgabe.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> erbt nicht <see cref="T:System.MulticastDelegate" />.  
  
- oder - 
 <paramref name="type" /> ist keine <see langword="RuntimeType" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- oder - 
 <paramref name="method" /> ist keine statische Methode und die .NET Framework-Version ist 1.0 oder 1.1.  
  
- oder - 
 <paramref name="method" /> kann nicht gebunden werden.  
  
- oder - 
 <paramref name="method" /> ist keine <see langword="RuntimeMethodInfo" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">Die <see langword="Invoke" />-Methode von <paramref name="type" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <paramref name="method" />.</exception>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object? firstArgument, System.Reflection.MethodInfo method);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDelegate (type As Type, firstArgument As Object, method As MethodInfo) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method)" />
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="firstArgument" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="type">Der <see cref="T:System.Type" /> des zu erstellenden Delegaten.</param>
        <param name="firstArgument">Das Objekt, an das der Delegat gebunden ist, oder <see langword="null" />, um <paramref name="method" /> als <see langword="static" /> (<see langword="Shared" /> in Visual Basic) zu behandeln.</param>
        <param name="method">Die <see cref="T:System.Reflection.MethodInfo" />, die die statische Methode oder Instanzmethode beschreibt, die der Delegat darstellen soll.</param>
        <summary>Erstellt einen Delegaten vom angegebenen Typ, der die angegebene statische Methode oder Instanzmethode mit dem angegebenen ersten Argument darstellt.</summary>
        <returns>Ein Delegat vom angegebenen Typ, der die angegebene statische Methode oder Instanzmethode darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen dieser Methoden Überladung entspricht dem Aufrufen der <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> -Methoden Überladung und der Angabe `true` von für `throwOnBindFailure` . Diese beiden über Ladungen stellen die flexibelste Möglichkeit zum Erstellen von Delegaten dar. Sie können Sie verwenden, um Delegaten für statische Methoden oder Instanzmethoden zu erstellen und optional das erste Argument anzugeben.  
  
> [!NOTE]
>  Wenn Sie kein erstes Argument angeben, verwenden Sie die- <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> Methoden Überladung, um die Leistung zu verbessern.  
  
 Der Delegattyp und die Methode müssen über kompatible Rückgabe Typen verfügen. Das heißt, der Rückgabetyp von `method` muss dem Rückgabetyp von zugewiesen werden können `type` .  
  
 Wenn `firstArgument` angegeben wird, wird Sie an jedes Mal übergeben, wenn der Delegat `method` aufgerufen wird `firstArgument` . wird als an den Delegaten gebunden, und der Delegat wird als das erste Argument geschlossen. Wenn `method` `static` ( `Shared` in Visual Basic) ist, enthält die Argumentliste, die beim Aufrufen des Delegaten angegeben wird, alle Parameter Außer dem ersten; Wenn `method` eine Instanzmethode ist, wird an den ausgeblendeten `firstArgument` Instanzparameter (dargestellt durch `this` in c# oder `Me` in Visual Basic) übergeben.  
  
 Wenn `firstArgument` angegeben wird, muss der erste Parameter von `method` ein Verweistyp sein, und er `firstArgument` muss mit diesem Typ kompatibel sein.  
  
> [!IMPORTANT]
>  Wenn `method` `static` ( `Shared` in Visual Basic) und der erste Parameter vom Typ oder ist <xref:System.Object> <xref:System.ValueType> , `firstArgument` kann ein Werttyp sein. In diesem Fall `firstArgument` wird automatisch per Boxing versehen. Das automatische Boxing erfolgt nicht für andere Argumente, wie dies in einem c#-oder Visual Basic-Funktions aufruffall der Fall wäre.  
  
 Wenn `firstArgument` ein NULL-Verweis ist und `method` eine Instanzmethode ist, hängt das Ergebnis von den Signaturen des Delegattyps `type` und von ab `method` :  
  
-   Wenn die Signatur von explizit den ausgeblendeten `type` ersten Parameter von einschließt `method` , wird der Delegat als eine Open instance-Methode bezeichnet. Wenn der Delegat aufgerufen wird, wird das erste Argument in der Argumentliste an den ausgeblendeten Instanzparameter von übergeben `method` .  
  
-   Wenn die Signaturen von `method` und entsprechen (d. h. `type` alle Parametertypen sind kompatibel), wird der Delegat als ein NULL-Verweis geschlossen. Das Aufrufen des Delegaten ähnelt dem Aufrufen einer Instanzmethode für eine NULL-Instanz, was nicht besonders nützlich ist.  
  
 Wenn `firstArgument` ein NULL-Verweis ist und `method` statisch ist, hängt das Ergebnis von den Signaturen des Delegattyps `type` und von ab `method` :  
  
-   Wenn die Signatur von und mit der Entsprechung identisch ist (d. h. `method` `type` alle Parametertypen sind kompatibel), wird der Delegat als eine offene statische Methode bezeichnet. Dies ist der häufigste Fall bei statischen Methoden. In diesem Fall können Sie eine etwas bessere Leistung erzielen, indem Sie die- <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> Methoden Überladung verwenden.  
  
-   Wenn die Signatur von `type` mit dem zweiten Parameter von beginnt `method` und die restlichen Parametertypen kompatibel sind, wird der Delegat als ein NULL-Verweis geschlossen. Wenn der Delegat aufgerufen wird, wird ein NULL-Verweis an den ersten Parameter von übergeben `method` .  
  
> [!NOTE]
>  Ab [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] kann diese Methode verwendet werden, um auf nicht öffentliche Methoden zuzugreifen, wenn der <xref:System.Security.Permissions.ReflectionPermission> Aufrufer mit dem-Flag erteilt wurde, <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> und wenn der Berechtigungs Satz der nicht öffentlichen Methoden auf den Berechtigungs Satz des Aufrufers oder auf eine Teilmenge des Aufrufers beschränkt ist. (Siehe [Sicherheitsüberlegungen für die Reflektion](/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
## <a name="compatible-parameter-types-and-return-type"></a>Kompatible Parameter Typen und Rückgabetyp  
 Die Parametertypen und der Rückgabetyp eines Delegaten müssen mit den Parametertypen und dem Rückgabetyp der Methode kompatibel sein, die der Delegat darstellt. die Typen müssen nicht exakt übereinstimmen.  
  
> [!NOTE]
>  In den .NET Framework Version 1,0 und 1,1 müssen die Typen exakt übereinstimmen.  
  
 Ein Parameter eines Delegaten ist mit dem entsprechenden Parameter einer Methode kompatibel, wenn der Typ des Delegatenparameters restriktiver ist als der Methodenparameter, da so gewährleistet ist, dass ein an den Delegaten übergebenes Argument problemlos an die Methode weitergeleitet werden kann.  
  
 Ebenso ist der Rückgabetyp eines Delegaten kompatibel mit dem Rückgabetyp einer Methode, wenn der Rückgabetyp der Methode restriktiver ist als der Rückgabetyp des Delegaten, da so gewährleistet ist, dass der Rückgabewert der Methode problemlos in den Rückgabetyp des Delegaten umgewandelt werden kann.  
  
 Beispielsweise kann ein Delegat mit einem Parameter vom Typ <xref:System.Collections.Hashtable> und dem Rückgabetyp <xref:System.Object> eine Methode mit einem Parameter vom Typ <xref:System.Object> und einen Rückgabewert des Typs darstellen <xref:System.Collections.Hashtable> .  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Bestimmen der Methoden, die ein Delegat darstellen kann  
 Eine weitere nützliche Methode, um die von dieser Überladung bereitgestellte Flexibilität zu betrachten <xref:System.Delegate.CreateDelegate%2A> , besteht darin, dass jeder angegebene Delegat vier verschiedene Kombinationen von Methoden Signatur und Methodenart (statisch und Instanz) darstellen kann. Beachten Sie einen Delegattyp `D` mit einem Argument vom Typ `C` . Im folgenden `D` wird beschrieben, welche Methoden darstellen können. der Rückgabetyp wird ignoriert, da er in allen Fällen abgeglichen werden muss:  
  
-   `D` kann jede Instanzmethode darstellen, die genau ein Argument vom Typ hat `C` , unabhängig davon, zu welchem Typ die Instanzmethode gehört. Wenn <xref:System.Delegate.CreateDelegate%2A> aufgerufen wird, `firstArgument` ist eine Instanz des Typs `method` , zu der gehört, und der resultierende Delegat wird als für diese Instanz geschlossen bezeichnet. (Triviale `D` können auch über einen NULL-Verweis geschlossen werden, wenn `firstArgument` ein NULL-Verweis ist.)  
  
-   `D` kann eine Instanzmethode von darstellen `C` , die keine Argumente aufweist. Wenn <xref:System.Delegate.CreateDelegate%2A> aufgerufen wird, `firstArgument` ist ein NULL-Verweis. Der resultierende Delegat stellt eine Open instance-Methode dar, und eine Instanz von `C` muss jedes Mal bereitgestellt werden, wenn Sie aufgerufen wird.  
  
-   `D` kann eine statische Methode darstellen, die ein Argument vom Typ annimmt `C` , und diese Methode kann zu einem beliebigen Typ gehören. Wenn <xref:System.Delegate.CreateDelegate%2A> aufgerufen wird, `firstArgument` ist ein NULL-Verweis. Der resultierende Delegat stellt eine offene statische Methode dar, und eine Instanz von `C` muss jedes Mal angegeben werden, wenn Sie aufgerufen wird.  
  
-   `D` kann eine statische Methode darstellen, die dem Typ angehört `F` und zwei Argumente vom Typ `F` und vom Typ aufweist `C` . Wenn <xref:System.Delegate.CreateDelegate%2A> aufgerufen wird, `firstArgument` ist eine Instanz von `F` . Der resultierende Delegat stellt eine statische Methode dar, die über diese Instanz von geschlossen wird `F` . Beachten Sie, dass die statische Methode in dem Fall, in dem `F` und `C` denselben Typ haben, über zwei Argumente dieses Typs verfügt. (In diesem Fall `D` wird über einen NULL-Verweis geschlossen, wenn `firstArgument` ein NULL-Verweis ist.)  
  
   
  
## Examples  
 Dieser Abschnitt enthält drei Codebeispiele. Im ersten Beispiel werden die vier Arten von Delegaten veranschaulicht, die erstellt werden können: geschlossen über eine Instanzmethode, öffnen über eine Instanzmethode, öffnen über eine statische Methode und schließen über eine statische Methode.  
  
 Im zweiten Codebeispiel werden kompatible Parametertypen und Rückgabe Typen veranschaulicht.  
  
 Das dritte Codebeispiel definiert einen einzelnen Delegattyp und zeigt alle Methoden an, die der Delegattyp darstellen kann.  
  
 **Beispiel 1**  
  
 Im folgenden Codebeispiel werden die vier Möglichkeiten veranschaulicht, wie ein Delegat mit dieser Überladung der-Methode erstellt werden kann <xref:System.Delegate.CreateDelegate%2A> .  
  
> [!NOTE]
>  Es gibt zwei über Ladungen der <xref:System.Delegate.CreateDelegate%2A> -Methode, die `firstArgument` und a angeben <xref:System.Reflection.MethodInfo> . ihre Funktionalität ist identisch, mit dem Unterschied, dass Sie angeben können, ob bei Bindungs Fehlern eine Ausnahme ausgelöst werden soll, die andere immer auslöst. In diesem Codebeispiel werden beide über Ladungen verwendet.  
  
 Im Beispiel wird eine-Klasse `C` mit einer statischen `M2` -Methode und einer Instanzmethode `M1` und drei Delegattypen deklariert: `D1` nimmt eine Instanz von `C` und eine Zeichenfolge an, `D2` nimmt eine Zeichenfolge an und `D3` weist keine Argumente auf.  
  
 Eine zweite Klasse mit `Example` dem Namen enthält den Code, mit dem die Delegaten erstellt werden.  
  
-   Ein Delegat vom Typ `D2` , geschlossen für eine Instanz von `C` , wird für die Instanzmethode erstellt `M1` . Sie wird mit anderen Zeichen folgen aufgerufen, um anzuzeigen, dass die gebundene Instanz von `C` immer verwendet wird.  
  
-   Ein Delegat vom Typ `D1` , der eine Open instance-Methode darstellt, wird für die Instanzmethode erstellt `M1` . Wenn der Delegat aufgerufen wird, muss eine-Instanz übermittelt werden.  
  
-   Ein Delegat vom Typ `D2` , der eine offene statische Methode darstellt, wird für die statische Methode erstellt `M2` .  
  
-   Schließlich wird ein Delegat vom Typ `D3` , der über eine Zeichenfolge geschlossen wurde, für die statische Methode erstellt `M2` . Die-Methode wird aufgerufen, um anzuzeigen, dass Sie die gebundene Zeichenfolge verwendet.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Beispiel 2**  
  
 Im folgenden Codebeispiel wird die Kompatibilität von Parametertypen und Rückgabe Typen veranschaulicht.  
  
> [!NOTE]
>  Dieses Codebeispiel verwendet die- <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> Methoden Überladung. Die Verwendung anderer über Ladungen, die sich übernehmen, <xref:System.Reflection.MethodInfo> ist ähnlich.  
  
 Im Codebeispiel wird eine Basisklasse mit dem Namen `Base` und eine Klasse mit dem Namen definiert `Derived` , die von abgeleitet wird `Base` . Die abgeleitete Klasse verfügt über eine `static` `Shared` -Methode (in Visual Basic) mit dem Namen, die einen `MyMethod` Parameter vom Typ `Base` und den Rückgabetyp aufweist `Derived` . Das Codebeispiel definiert auch einen Delegaten `Example` mit dem Namen, der einen Parameter vom Typ `Derived` und den Rückgabetyp hat `Base` .  
  
 Das Codebeispiel veranschaulicht, dass der Delegat mit dem Namen `Example` zur Darstellung der-Methode verwendet werden kann `MyMethod` . Die-Methode kann aus folgenden Gründen an den-Delegaten gebunden werden:  
  
-   Der Parametertyp des Delegaten ( `Derived` ) ist restriktiver als der Parametertyp von `MyMethod` ( `Base` ), sodass es immer sicher ist, das-Argument des Delegaten an zu übergeben `MyMethod` .  
  
-   Der Rückgabetyp von `MyMethod` ( `Derived` ) ist restriktiver als der Parametertyp des Delegaten ( `Base` ), sodass es immer sicher ist, den Rückgabetyp der Methode in den Rückgabetyp des Delegaten umzuwandeln.  
  
 Das Codebeispiel erzeugt keine Ausgabe.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Beispiel 3**  
  
 Im folgenden Codebeispiel werden alle Methoden gezeigt, die ein einzelner Delegattyp darstellen kann. dabei wird die-Methode verwendet, <xref:System.Delegate.CreateDelegate%2A> um die Delegaten zu erstellen.  
  
> [!NOTE]
>  Es gibt zwei über Ladungen der <xref:System.Delegate.CreateDelegate%2A> -Methode, die `firstArgument` und a angeben <xref:System.Reflection.MethodInfo> . ihre Funktionalität ist identisch, mit dem Unterschied, dass Sie angeben können, ob bei Bindungs Fehlern eine Ausnahme ausgelöst werden soll, die andere immer auslöst. In diesem Codebeispiel werden beide über Ladungen verwendet.  
  
 Im Codebeispiel werden zwei Klassen, `C` und `F` , sowie ein Delegattyp `D` mit einem Argument vom Typ definiert `C` . Die Klassen verfügen über übereinstimmende statische und Instanzmethoden `M1` , `M3` und `M4` , und die-Klasse `C` verfügt auch über eine Instanzmethode `M2` , die keine Argumente aufweist.  
  
 Eine dritte Klasse mit `Example` dem Namen enthält den Code, mit dem die Delegaten erstellt werden.  
  
-   Delegaten werden für die Instanzmethode `M1` vom Typ und vom Typ erstellt `C` `F` ; jede wird über eine Instanz des jeweiligen Typs geschlossen. Methode `M1` des Typs `C` zeigt die `ID` Eigenschaften der gebundenen Instanz und des Arguments an.  
  
-   Ein Delegat wird für die-Methode `M2` des Typs erstellt `C` . Dies ist ein Open instance-Delegat, bei dem das-Argument des Delegaten das ausgeblendete erste Argument der Instanzmethode darstellt. Die Methode hat keine anderen Argumente. Sie wird aufgerufen, als ob es sich um eine statische Methode handelt.  
  
-   Delegaten werden für eine statische Methode `M3` vom Typ `C` und Typ erstellt `F` . Dies sind offene statische Delegaten.  
  
-   Zum Schluss werden Delegaten für die statische Methode `M4` vom Typ `C` und Typ erstellt `F` . jede Methode weist den deklarierenden Typ als erstes Argument auf, und es wird eine Instanz des Typs bereitgestellt, sodass die Delegaten über ihren ersten Argumenten geschlossen werden. Methode `M4` des Typs `C` zeigt die `ID` Eigenschaften der gebundenen Instanz und des Arguments an.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> erbt nicht <see cref="T:System.MulticastDelegate" />.  
  
- oder - 
 <paramref name="type" /> ist keine <see langword="RuntimeType" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- oder - 
 <paramref name="method" /> kann nicht gebunden werden.  
  
- oder - 
 <paramref name="method" /> ist keine <see langword="RuntimeMethodInfo" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">Die <see langword="Invoke" />-Methode von <paramref name="type" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <paramref name="method" />.</exception>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDelegate (type As Type, target As Object, method As String) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="type">Der <see cref="T:System.Type" /> des zu erstellenden Delegaten.</param>
        <param name="target">Die Klasseninstanz, für die <paramref name="method" /> aufgerufen wird.</param>
        <param name="method">Der Name der Instanzenmethode, die durch den Delegaten dargestellt werden soll.</param>
        <summary>Erstellt einen Delegaten vom angegebenen Typ, der die angegebene Instanzenmethode darstellt, die für die angegebene Klasseninstanz aufgerufen werden soll.</summary>
        <returns>Ein Delegat vom angegebenen Typ, der die angegebene Instanzenmethode darstellt, die für die angegebene Klasseninstanz aufgerufen werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt nur Delegaten für Instanzmethoden. Eine Instanzmethode ist eine Methode, die einer Instanz einer-Klasse zugeordnet ist. eine statische Methode ist eine Methode, die der Klasse selbst zugeordnet ist.  
  
 Diese Methoden Überladung entspricht dem Aufrufen der <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> -Methoden Überladung, wobei `false` für `ignoreCase` und für angegeben wird `true` `throwOnBindFailure` .  
  
> [!NOTE]
>  Ab [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] kann diese Methode verwendet werden, um auf nicht öffentliche Methoden zuzugreifen, wenn der <xref:System.Security.Permissions.ReflectionPermission> Aufrufer mit dem-Flag erteilt wurde, <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> und wenn der Berechtigungs Satz der nicht öffentlichen Methoden auf den Berechtigungs Satz des Aufrufers oder auf eine Teilmenge des Aufrufers beschränkt ist. (Siehe [Sicherheitsüberlegungen für die Reflektion](/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="target" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> erbt nicht <see cref="T:System.MulticastDelegate" />.  
  
- oder - 
 <paramref name="type" /> ist keine <see langword="RuntimeType" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- oder - 
 <paramref name="method" /> ist keine Instanzenmethode.  
  
- oder - 
 <paramref name="method" /> kann nicht gebunden werden, z. B. weil sie nicht gefunden wurde.</exception>
        <exception cref="T:System.MissingMethodException">Die <see langword="Invoke" />-Methode von <paramref name="type" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <paramref name="method" />.</exception>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate? CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDelegate (type As Type, method As MethodInfo, throwOnBindFailure As Boolean) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method, throwOnBindFailure)" />
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="type">Der <see cref="T:System.Type" /> des zu erstellenden Delegaten.</param>
        <param name="method">Die <see cref="T:System.Reflection.MethodInfo" />, die die statische Methode oder Instanzmethode beschreibt, die der Delegat darstellen soll.</param>
        <param name="throwOnBindFailure"><see langword="true" />, um eine Ausnahme auszulösen, wenn <paramref name="method" /> nicht gebunden werden kann, andernfalls <see langword="false" />.</param>
        <summary>Erstellt einen Delegaten vom angegeben Typ zum Darstellen der angegebenen statischen Methode mit dem angegebenen Verhalten bei Bindungsfehlern.</summary>
        <returns>Ein Delegat vom angegebenen Typ, der die angegebene statische Methode darstellen soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methoden Überladung kann offene statische Methoden Delegaten und Open instance-Methoden Delegaten erstellen, d. h. Delegaten, die das verborgene erste Argument der Instanzmethoden verfügbar machen. Eine ausführliche Erläuterung finden <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> Sie in der allgemeineren Methoden Überladung, mit der Sie alle Kombinationen offener oder geschlossener Delegaten für Instanzen oder statische Methoden erstellen können.  
  
> [!NOTE]
>  Diese Methoden Überladung sollte verwendet werden, wenn der Delegat nicht über das erste Argument geschlossen wird, da er in diesem Fall etwas schneller ist.  
  
> [!NOTE]
>  Ab [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] kann diese Methode verwendet werden, um auf nicht öffentliche Methoden zuzugreifen, wenn der <xref:System.Security.Permissions.ReflectionPermission> Aufrufer mit dem-Flag erteilt wurde, <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> und wenn der Berechtigungs Satz der nicht öffentlichen Methoden auf den Berechtigungs Satz des Aufrufers oder auf eine Teilmenge des Aufrufers beschränkt ist. (Siehe [Sicherheitsüberlegungen für die Reflektion](/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
## <a name="compatible-parameter-types-and-return-type"></a>Kompatible Parameter Typen und Rückgabetyp  
 Die Parametertypen und der Rückgabetyp eines Delegaten müssen mit den Parametertypen und dem Rückgabetyp der Methode kompatibel sein, die der Delegat darstellt. die Typen müssen nicht exakt übereinstimmen.  
  
> [!NOTE]
>  In den .NET Framework Version 1,0 und 1,1 müssen die Typen exakt übereinstimmen.  
  
 Ein Parameter eines Delegaten ist mit dem entsprechenden Parameter einer Methode kompatibel, wenn der Typ des Delegatenparameters restriktiver ist als der Methodenparameter, da so gewährleistet ist, dass ein an den Delegaten übergebenes Argument problemlos an die Methode weitergeleitet werden kann.  
  
 Ebenso ist der Rückgabetyp eines Delegaten kompatibel mit dem Rückgabetyp einer Methode, wenn der Rückgabetyp der Methode restriktiver ist als der Rückgabetyp des Delegaten, da so gewährleistet ist, dass der Rückgabewert der Methode problemlos in den Rückgabetyp des Delegaten umgewandelt werden kann.  
  
 Beispielsweise kann ein Delegat mit einem Parameter vom Typ <xref:System.Collections.Hashtable> und dem Rückgabetyp <xref:System.Object> eine Methode mit einem Parameter vom Typ <xref:System.Object> und einen Rückgabewert des Typs darstellen <xref:System.Collections.Hashtable> .  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Im ersten Beispiel werden die beiden Arten von Delegaten veranschaulicht, die mit dieser Methoden Überladung erstellt werden können: offen über eine Instanzmethode und öffnen über eine statische Methode.  
  
 Im zweiten Codebeispiel werden kompatible Parametertypen und Rückgabe Typen veranschaulicht.  
  
 **Beispiel 1**  
  
 Im folgenden Codebeispiel werden die zwei Möglichkeiten veranschaulicht, wie ein Delegat mit dieser Überladung der-Methode erstellt werden kann <xref:System.Delegate.CreateDelegate%2A> .  
  
> [!NOTE]
>  Es gibt zwei über Ladungen der- <xref:System.Delegate.CreateDelegate%2A> Methode, die ein, <xref:System.Reflection.MethodInfo> aber kein erstes Argument angeben. ihre Funktionalität ist identisch, mit dem Unterschied, dass Sie angeben können, ob bei Bindungs Fehlern eine Ausnahme ausgelöst werden soll, die andere immer auslöst. In diesem Codebeispiel werden beide über Ladungen verwendet.  
  
 Im Beispiel wird eine-Klasse `C` mit einer statischen `M2` -Methode und einer Instanzmethode `M1` und zwei Delegattypen deklariert: `D1` nimmt eine Instanz von `C` und eine Zeichenfolge an und `D2` nimmt eine Zeichenfolge an.  
  
 Eine zweite Klasse mit `Example` dem Namen enthält den Code, mit dem die Delegaten erstellt werden.  
  
-   Ein Delegat vom Typ `D1` , der eine Open instance-Methode darstellt, wird für die Instanzmethode erstellt `M1` . Wenn der Delegat aufgerufen wird, muss eine-Instanz übermittelt werden.  
  
-   Ein Delegat vom Typ `D2` , der eine offene statische Methode darstellt, wird für die statische Methode erstellt `M2` .  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Beispiel 2**  
  
 Im folgenden Codebeispiel wird die Kompatibilität von Parametertypen und Rückgabe Typen veranschaulicht.  
  
> [!NOTE]
>  Dieses Codebeispiel verwendet die- <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> Methoden Überladung. Die Verwendung anderer über Ladungen, die sich übernehmen, <xref:System.Reflection.MethodInfo> ist ähnlich.  
  
 Im Codebeispiel wird eine Basisklasse mit dem Namen `Base` und eine Klasse mit dem Namen definiert `Derived` , die von abgeleitet wird `Base` . Die abgeleitete Klasse verfügt über eine `static` `Shared` -Methode (in Visual Basic) mit dem Namen, die einen `MyMethod` Parameter vom Typ `Base` und den Rückgabetyp aufweist `Derived` . Das Codebeispiel definiert auch einen Delegaten `Example` mit dem Namen, der einen Parameter vom Typ `Derived` und den Rückgabetyp hat `Base` .  
  
 Das Codebeispiel veranschaulicht, dass der Delegat mit dem Namen `Example` zur Darstellung der-Methode verwendet werden kann `MyMethod` . Die-Methode kann aus folgenden Gründen an den-Delegaten gebunden werden:  
  
-   Der Parametertyp des Delegaten ( `Derived` ) ist restriktiver als der Parametertyp von `MyMethod` ( `Base` ), sodass es immer sicher ist, das-Argument des Delegaten an zu übergeben `MyMethod` .  
  
-   Der Rückgabetyp von `MyMethod` ( `Derived` ) ist restriktiver als der Parametertyp des Delegaten ( `Base` ), sodass es immer sicher ist, den Rückgabetyp der Methode in den Rückgabetyp des Delegaten umzuwandeln.  
  
 Das Codebeispiel erzeugt keine Ausgabe.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> erbt nicht <see cref="T:System.MulticastDelegate" />.  
  
- oder - 
 <paramref name="type" /> ist keine <see langword="RuntimeType" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- oder - 
 <paramref name="method" /> kann nicht gebunden werden, und <paramref name="throwOnBindFailure" /> ist <see langword="true" />.  
  
- oder - 
 <paramref name="method" /> ist keine <see langword="RuntimeMethodInfo" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">Die <see langword="Invoke" />-Methode von <paramref name="type" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <paramref name="method" />.</exception>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDelegate (type As Type, target As Type, method As String) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="type">Der <see cref="T:System.Type" /> des zu erstellenden Delegaten.</param>
        <param name="target">Der <see cref="T:System.Type" />, der die Klasse darstellt, die von <paramref name="method" /> implementiert wird.</param>
        <param name="method">Der Name der statischen Methode, die durch den Delegaten dargestellt werden soll.</param>
        <summary>Erstellt einen Delegaten vom angegebenen Typ, der die angegebene statische Methode der angegebenen Klasse darstellt.</summary>
        <returns>Ein Delegat vom angegebenen Typ, der die angegebene statische Methode der angegebenen Klasse darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt Delegaten nur für statische Methoden. Eine Instanzmethode ist eine Methode, die einer Instanz einer-Klasse zugeordnet ist. eine statische Methode ist eine Methode, die der Klasse selbst zugeordnet ist.  
  
 Diese Methoden Überladung entspricht dem Aufrufen der <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> -Methoden Überladung, wobei `false` für `ignoreCase` und für angegeben wird `true` `throwOnBindFailure` .  
  
> [!NOTE]
>  Ab [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] kann diese Methode verwendet werden, um auf nicht öffentliche Methoden zuzugreifen, wenn der <xref:System.Security.Permissions.ReflectionPermission> Aufrufer mit dem-Flag erteilt wurde, <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> und wenn der Berechtigungs Satz der nicht öffentlichen Methoden auf den Berechtigungs Satz des Aufrufers oder auf eine Teilmenge des Aufrufers beschränkt ist. (Siehe [Sicherheitsüberlegungen für die Reflektion](/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="target" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> erbt nicht <see cref="T:System.MulticastDelegate" />.  
  
- oder - 
 <paramref name="type" /> ist keine <see langword="RuntimeType" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- oder - 
 <paramref name="target" /> ist keine <see langword="RuntimeType" />.  
  
- oder - 
 <paramref name="target" /> ist ein offener generischer Typ. Das bedeutet, die <see cref="P:System.Type.ContainsGenericParameters" />-Eigenschaft ist <see langword="true" />.  
  
- oder - 
 <paramref name="method" /> ist keine <see langword="static" />-Methode (<see langword="Shared" />-Methode in Visual Basic).  
  
- oder - 
 <paramref name="method" /> kann nicht gebunden werden, z. B. weil sie nicht gefunden wurde, und <paramref name="throwOnBindFailure" /> ist gleich <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">Die <see langword="Invoke" />-Methode von <paramref name="type" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <paramref name="method" />.</exception>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate? CreateDelegate (Type type, object? firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDelegate (type As Type, firstArgument As Object, method As MethodInfo, throwOnBindFailure As Boolean) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method, throwOnBindFailure)" />
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="firstArgument" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="type">Ein <see cref="T:System.Type" />, der den Typ des zu erstellenden Delegaten darstellt.</param>
        <param name="firstArgument">Ein <see cref="T:System.Object" />, das das erste Argument der Methode ist, die der Delegat darstellt. Bei Instanzmethoden muss dieses mit dem Instanztyp kompatibel sein.</param>
        <param name="method">Die <see cref="T:System.Reflection.MethodInfo" />, die die statische Methode oder Instanzmethode beschreibt, die der Delegat darstellen soll.</param>
        <param name="throwOnBindFailure"><see langword="true" />, um eine Ausnahme auszulösen, wenn <paramref name="method" /> nicht gebunden werden kann, andernfalls <see langword="false" />.</param>
        <summary>Erstellt einen Delegaten vom angegebenen Typ, der die angegebene statische Methode oder Instanzmethode mit dem angegebenen ersten Argument und dem angegebenen Verhalten bei Bindungsfehlern darstellt.</summary>
        <returns>Ein Delegat des angegebenen Typs, der die angegebene statische Methode oder Instanzmethode darstellt, oder <see langword="null" />, wenn <paramref name="throwOnBindFailure" /><see langword="false" /> ist und der Delegat nicht an <paramref name="method" /> gebunden werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methoden Überladung und die- <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> Methoden Überladung, die immer bei Bindungs Fehlern auslöst, stellen die flexibelste Möglichkeit dar, Delegaten zu erstellen. Sie können Sie zum Erstellen von Delegaten für statische Methoden oder Instanzmethoden mit oder ohne erstes Argument verwenden.  
  
> [!NOTE]
>  Wenn Sie kein erstes Argument angeben, verwenden Sie die- <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> Methoden Überladung, um die Leistung zu verbessern.  
  
 Der Delegattyp und die Methode müssen über kompatible Rückgabe Typen verfügen. Das heißt, der Rückgabetyp von `method` muss dem Rückgabetyp von zugewiesen werden können `type` .  
  
 Wenn `firstArgument` angegeben wird, wird Sie an jedes Mal übergeben, wenn der Delegat `method` aufgerufen wird `firstArgument` . wird als an den Delegaten gebunden, und der Delegat wird als das erste Argument geschlossen. Wenn `method` `static` ( `Shared` in Visual Basic) ist, enthält die Argumentliste, die beim Aufrufen des Delegaten angegeben wird, alle Parameter Außer dem ersten; Wenn `method` eine Instanzmethode ist, wird an den ausgeblendeten `firstArgument` Instanzparameter (dargestellt durch `this` in c# oder `Me` in Visual Basic) übergeben.  
  
 Wenn `firstArgument` angegeben wird, muss der erste Parameter von `method` ein Verweistyp sein, und er `firstArgument` muss mit diesem Typ kompatibel sein.  
  
> [!IMPORTANT]
>  Wenn `method` `static` ( `Shared` in Visual Basic) und der erste Parameter vom Typ oder ist <xref:System.Object> <xref:System.ValueType> , `firstArgument` kann ein Werttyp sein. In diesem Fall `firstArgument` wird automatisch per Boxing versehen. Das automatische Boxing erfolgt nicht für andere Argumente, wie dies in einem c#-oder Visual Basic-Funktions aufruffall der Fall wäre.  
  
 Wenn `firstArgument` ein NULL-Verweis ist und `method` eine Instanzmethode ist, hängt das Ergebnis von den Signaturen des Delegattyps `type` und von ab `method` :  
  
-   Wenn die Signatur von explizit den ausgeblendeten `type` ersten Parameter von einschließt `method` , wird der Delegat als eine Open instance-Methode bezeichnet. Wenn der Delegat aufgerufen wird, wird das erste Argument in der Argumentliste an den ausgeblendeten Instanzparameter von übergeben `method` .  
  
-   Wenn die Signaturen von `method` und entsprechen (d. h. `type` alle Parametertypen sind kompatibel), wird der Delegat als ein NULL-Verweis geschlossen. Das Aufrufen des Delegaten ähnelt dem Aufrufen einer Instanzmethode für eine NULL-Instanz, was nicht besonders nützlich ist.  
  
 Wenn `firstArgument` ein NULL-Verweis ist und `method` statisch ist, hängt das Ergebnis von den Signaturen des Delegattyps `type` und von ab `method` :  
  
-   Wenn die Signatur von und mit der Entsprechung identisch ist (d. h. `method` `type` alle Parametertypen sind kompatibel), wird der Delegat als eine offene statische Methode bezeichnet. Dies ist der häufigste Fall bei statischen Methoden. In diesem Fall können Sie eine etwas bessere Leistung erzielen, indem Sie die- <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> Methoden Überladung verwenden.  
  
-   Wenn die Signatur von `type` mit dem zweiten Parameter von beginnt `method` und die restlichen Parametertypen kompatibel sind, wird der Delegat als ein NULL-Verweis geschlossen. Wenn der Delegat aufgerufen wird, wird ein NULL-Verweis an den ersten Parameter von übergeben `method` .  
  
> [!NOTE]
>  Ab [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] kann diese Methode verwendet werden, um auf nicht öffentliche Methoden zuzugreifen, wenn der <xref:System.Security.Permissions.ReflectionPermission> Aufrufer mit dem-Flag erteilt wurde, <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> und wenn der Berechtigungs Satz der nicht öffentlichen Methoden auf den Berechtigungs Satz des Aufrufers oder auf eine Teilmenge des Aufrufers beschränkt ist. (Siehe [Sicherheitsüberlegungen für die Reflektion](/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
## <a name="compatible-parameter-types-and-return-type"></a>Kompatible Parameter Typen und Rückgabetyp  
 Die Parametertypen und der Rückgabetyp eines Delegaten müssen mit den Parametertypen und dem Rückgabetyp der Methode kompatibel sein, die der Delegat darstellt. die Typen müssen nicht exakt übereinstimmen.  
  
> [!NOTE]
>  In den .NET Framework Version 1,0 und 1,1 müssen die Typen genau übereinstimmen.  
  
 Ein Parameter eines Delegaten ist mit dem entsprechenden Parameter einer Methode kompatibel, wenn der Typ des Delegatenparameters restriktiver ist als der Methodenparameter, da so gewährleistet ist, dass ein an den Delegaten übergebenes Argument problemlos an die Methode weitergeleitet werden kann.  
  
 Ebenso ist der Rückgabetyp eines Delegaten kompatibel mit dem Rückgabetyp einer Methode, wenn der Rückgabetyp der Methode restriktiver ist als der Rückgabetyp des Delegaten, da so gewährleistet ist, dass der Rückgabewert der Methode problemlos in den Rückgabetyp des Delegaten umgewandelt werden kann.  
  
 Beispielsweise kann ein Delegat mit einem Parameter vom Typ <xref:System.Collections.Hashtable> und dem Rückgabetyp <xref:System.Object> eine Methode mit einem Parameter vom Typ <xref:System.Object> und einen Rückgabewert des Typs darstellen <xref:System.Collections.Hashtable> .  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Bestimmen der Methoden, die ein Delegat darstellen kann  
 Eine weitere nützliche Methode, um die von dieser Überladung bereitgestellte Flexibilität zu betrachten <xref:System.Delegate.CreateDelegate%2A> , besteht darin, dass jeder angegebene Delegat vier verschiedene Kombinationen von Methoden Signatur und Methodenart (statisch und Instanz) darstellen kann. Beachten Sie einen Delegattyp `D` mit einem Argument vom Typ `C` . Im folgenden `D` wird beschrieben, welche Methoden darstellen können. der Rückgabetyp wird ignoriert, da er in allen Fällen abgeglichen werden muss:  
  
-   `D` kann jede Instanzmethode darstellen, die genau ein Argument vom Typ hat `C` , unabhängig davon, zu welchem Typ die Instanzmethode gehört. Wenn <xref:System.Delegate.CreateDelegate%2A> aufgerufen wird, `firstArgument` ist eine Instanz des Typs `method` , zu der gehört, und der resultierende Delegat wird als für diese Instanz geschlossen bezeichnet. (Triviale `D` können auch über einen NULL-Verweis geschlossen werden, wenn `firstArgument` ist `null` .)  
  
-   `D` kann eine Instanzmethode von darstellen `C` , die keine Argumente aufweist. Wenn <xref:System.Delegate.CreateDelegate%2A> aufgerufen wird, `firstArgument` ist ein NULL-Verweis. Der resultierende Delegat stellt eine Open instance-Methode dar, und eine Instanz von `C` muss jedes Mal bereitgestellt werden, wenn Sie aufgerufen wird.  
  
-   `D` kann eine statische Methode darstellen, die ein Argument vom Typ annimmt `C` , und diese Methode kann zu einem beliebigen Typ gehören. Wenn <xref:System.Delegate.CreateDelegate%2A> aufgerufen wird, `firstArgument` ist ein NULL-Verweis. Der resultierende Delegat stellt eine offene statische Methode dar, und eine Instanz von `C` muss jedes Mal angegeben werden, wenn Sie aufgerufen wird.  
  
-   `D` kann eine statische Methode darstellen, die dem Typ angehört `F` und zwei Argumente vom Typ `F` und vom Typ aufweist `C` . Wenn <xref:System.Delegate.CreateDelegate%2A> aufgerufen wird, `firstArgument` ist eine Instanz von `F` . Der resultierende Delegat stellt eine statische Methode dar, die über diese Instanz von geschlossen wird `F` . Beachten Sie, dass die statische Methode in dem Fall, in dem `F` und `C` denselben Typ haben, über zwei Argumente dieses Typs verfügt. (In diesem Fall `D` wird über einen NULL-Verweis geschlossen, wenn `firstArgument` ist `null` .)  
  
   
  
## Examples  
 Dieser Abschnitt enthält drei Codebeispiele. Im ersten Beispiel werden die vier Arten von Delegaten veranschaulicht, die erstellt werden können: geschlossen über eine Instanzmethode, öffnen über eine Instanzmethode, öffnen über eine statische Methode und schließen über eine statische Methode.  
  
 Im zweiten Codebeispiel werden kompatible Parametertypen und Rückgabe Typen veranschaulicht.  
  
 Das dritte Codebeispiel definiert einen einzelnen Delegattyp und zeigt alle Methoden an, die der Delegattyp darstellen kann.  
  
 **Beispiel 1**  
  
 Im folgenden Codebeispiel werden die vier Möglichkeiten veranschaulicht, wie ein Delegat mit dieser Überladung der-Methode erstellt werden kann <xref:System.Delegate.CreateDelegate%2A> .  
  
> [!NOTE]
>  Es gibt zwei über Ladungen der <xref:System.Delegate.CreateDelegate%2A> -Methode, die `firstArgument` und a angeben <xref:System.Reflection.MethodInfo> . ihre Funktionalität ist identisch, mit dem Unterschied, dass Sie angeben können, ob bei Bindungs Fehlern eine Ausnahme ausgelöst werden soll, die andere immer auslöst. In diesem Codebeispiel werden beide über Ladungen verwendet.  
  
 Im Beispiel wird eine-Klasse `C` mit einer statischen `M2` -Methode und einer Instanzmethode `M1` und drei Delegattypen deklariert: `D1` nimmt eine Instanz von `C` und eine Zeichenfolge an, `D2` nimmt eine Zeichenfolge an und `D3` weist keine Argumente auf.  
  
 Eine zweite Klasse mit `Example` dem Namen enthält den Code, mit dem die Delegaten erstellt werden.  
  
-   Ein Delegat vom Typ `D2` , geschlossen für eine Instanz von `C` , wird für die Instanzmethode erstellt `M1` . Sie wird mit anderen Zeichen folgen aufgerufen, um anzuzeigen, dass die gebundene Instanz von `C` immer verwendet wird.  
  
-   Ein Delegat vom Typ `D1` , der eine Open instance-Methode darstellt, wird für die Instanzmethode erstellt `M1` . Wenn der Delegat aufgerufen wird, muss eine-Instanz übermittelt werden.  
  
-   Ein Delegat vom Typ `D2` , der eine offene statische Methode darstellt, wird für die statische Methode erstellt `M2` .  
  
-   Schließlich wird ein Delegat vom Typ `D3` , der über eine Zeichenfolge geschlossen wurde, für die statische Methode erstellt `M2` . Die-Methode wird aufgerufen, um anzuzeigen, dass Sie die gebundene Zeichenfolge verwendet.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Beispiel 2**  
  
 Im folgenden Codebeispiel wird die Kompatibilität von Parametertypen und Rückgabe Typen veranschaulicht.  
  
> [!NOTE]
>  Dieses Codebeispiel verwendet die- <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> Methoden Überladung. Die Verwendung anderer über Ladungen, die sich übernehmen, <xref:System.Reflection.MethodInfo> ist ähnlich.  
  
 Im Codebeispiel wird eine Basisklasse mit dem Namen `Base` und eine Klasse mit dem Namen definiert `Derived` , die von abgeleitet wird `Base` . Die abgeleitete Klasse verfügt über eine `static` `Shared` -Methode (in Visual Basic) mit dem Namen, die einen `MyMethod` Parameter vom Typ `Base` und den Rückgabetyp aufweist `Derived` . Das Codebeispiel definiert auch einen Delegaten `Example` mit dem Namen, der einen Parameter vom Typ `Derived` und den Rückgabetyp hat `Base` .  
  
 Das Codebeispiel veranschaulicht, dass der Delegat mit dem Namen `Example` zur Darstellung der-Methode verwendet werden kann `MyMethod` . Die-Methode kann aus folgenden Gründen an den-Delegaten gebunden werden:  
  
-   Der Parametertyp des Delegaten ( `Derived` ) ist restriktiver als der Parametertyp von `MyMethod` ( `Base` ), sodass es immer sicher ist, das-Argument des Delegaten an zu übergeben `MyMethod` .  
  
-   Der Rückgabetyp von `MyMethod` ( `Derived` ) ist restriktiver als der Parametertyp des Delegaten ( `Base` ), sodass es immer sicher ist, den Rückgabetyp der Methode in den Rückgabetyp des Delegaten umzuwandeln.  
  
 Das Codebeispiel erzeugt keine Ausgabe.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Beispiel 3**  
  
 Im folgenden Codebeispiel werden alle Methoden gezeigt, die ein einzelner Delegattyp darstellen kann.  
  
> [!NOTE]
>  Es gibt zwei über Ladungen der <xref:System.Delegate.CreateDelegate%2A> -Methode, die `firstArgument` und a angeben <xref:System.Reflection.MethodInfo> . ihre Funktionalität ist identisch, mit dem Unterschied, dass Sie angeben können, ob bei Bindungs Fehlern eine Ausnahme ausgelöst werden soll, die andere immer auslöst. In diesem Codebeispiel werden beide über Ladungen verwendet.  
  
 Im Codebeispiel werden zwei Klassen, `C` und `F` , sowie ein Delegattyp `D` mit einem Argument vom Typ definiert `C` . Die Klassen verfügen über übereinstimmende statische und Instanzmethoden `M1` , `M3` und `M4` , und die-Klasse `C` verfügt auch über eine Instanzmethode `M2` , die keine Argumente aufweist.  
  
 Eine dritte Klasse mit `Example` dem Namen enthält den Code, mit dem die Delegaten erstellt werden.  
  
-   Delegaten werden für die Instanzmethode `M1` vom Typ und vom Typ erstellt `C` `F` ; jede wird über eine Instanz des jeweiligen Typs geschlossen. Methode `M1` des Typs `C` zeigt die `ID` Eigenschaften der gebundenen Instanz und des Arguments an.  
  
-   Ein Delegat wird für die-Methode `M2` des Typs erstellt `C` . Dies ist ein Open instance-Delegat, bei dem das-Argument des Delegaten das ausgeblendete erste Argument der Instanzmethode darstellt. Die Methode hat keine anderen Argumente.  
  
-   Delegaten werden für eine statische Methode `M3` vom Typ `C` und Typ erstellt `F` . Dies sind offene statische Delegaten.  
  
-   Zum Schluss werden Delegaten für die statische Methode `M4` vom Typ `C` und Typ erstellt `F` . jede Methode weist den deklarierenden Typ als erstes Argument auf, und es wird eine Instanz des Typs bereitgestellt, sodass die Delegaten über ihren ersten Argumenten geschlossen werden. Methode `M4` des Typs `C` zeigt die `ID` Eigenschaften der gebundenen Instanz und des Arguments an.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> erbt nicht <see cref="T:System.MulticastDelegate" />.  
  
- oder - 
 <paramref name="type" /> ist keine <see langword="RuntimeType" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- oder - 
 <paramref name="method" /> kann nicht gebunden werden, und <paramref name="throwOnBindFailure" /> ist <see langword="true" />.  
  
- oder - 
 <paramref name="method" /> ist keine <see langword="RuntimeMethodInfo" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">Die <see langword="Invoke" />-Methode von <paramref name="type" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <paramref name="method" />.</exception>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDelegate (type As Type, target As Object, method As String, ignoreCase As Boolean) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="type">Der <see cref="T:System.Type" /> des zu erstellenden Delegaten.</param>
        <param name="target">Die Klasseninstanz, für die <paramref name="method" /> aufgerufen wird.</param>
        <param name="method">Der Name der Instanzenmethode, die durch den Delegaten dargestellt werden soll.</param>
        <param name="ignoreCase">Ein boolescher Wert, der angibt, ob die Groß- und Kleinschreibung beim Vergleichen des Methodennamens berücksichtigt werden soll.</param>
        <summary>Erstellt einen Delegaten vom angegebenen Typ, der die angegebene Instanzenmethode darstellt, die für die angegebene Klasseninstanz aufgerufen werden soll, wobei die Groß- und Kleinschreibung den Angaben entsprechend berücksichtigt bzw. nicht berücksichtigt wird.</summary>
        <returns>Ein Delegat vom angegebenen Typ, der die angegebene Instanzenmethode darstellt, die für die angegebene Klasseninstanz aufgerufen werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt nur Delegaten für Instanzmethoden. Eine Instanzmethode ist eine Methode, die einer Instanz einer-Klasse zugeordnet ist. eine statische Methode ist eine Methode, die der Klasse selbst zugeordnet ist.  
  
 Diese Methoden Überladung entspricht dem Aufrufen der- <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> Methoden Überladung und gibt `true` für an `throwOnBindFailure` .  
  
> [!NOTE]
>  Ab [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] kann diese Methode verwendet werden, um auf nicht öffentliche Methoden zuzugreifen, wenn der <xref:System.Security.Permissions.ReflectionPermission> Aufrufer mit dem-Flag erteilt wurde, <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> und wenn der Berechtigungs Satz der nicht öffentlichen Methoden auf den Berechtigungs Satz des Aufrufers oder auf eine Teilmenge des Aufrufers beschränkt ist. (Siehe [Sicherheitsüberlegungen für die Reflektion](/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="target" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> erbt nicht <see cref="T:System.MulticastDelegate" />.  
  
- oder - 
 <paramref name="type" /> ist keine <see langword="RuntimeType" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- oder - 
 <paramref name="method" /> ist keine Instanzenmethode.  
  
- oder - 
 <paramref name="method" /> kann nicht gebunden werden, z. B. weil sie nicht gefunden wurde.</exception>
        <exception cref="T:System.MissingMethodException">Die <see langword="Invoke" />-Methode von <paramref name="type" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <paramref name="method" />.</exception>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDelegate (type As Type, target As Type, method As String, ignoreCase As Boolean) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="type">Der <see cref="T:System.Type" /> des zu erstellenden Delegaten.</param>
        <param name="target">Der <see cref="T:System.Type" />, der die Klasse darstellt, die von <paramref name="method" /> implementiert wird.</param>
        <param name="method">Der Name der statischen Methode, die durch den Delegaten dargestellt werden soll.</param>
        <param name="ignoreCase">Ein boolescher Wert, der angibt, ob die Groß- und Kleinschreibung beim Vergleichen des Methodennamens berücksichtigt werden soll.</param>
        <summary>Erstellt einen Delegaten vom angegebenen Typ, der die angegebene statische Methode der angegebenen Klasse mit der angegebenen Berücksichtigung von Groß- und Kleinschreibung darstellt.</summary>
        <returns>Ein Delegat vom angegebenen Typ, der die angegebene statische Methode der angegebenen Klasse darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt Delegaten nur für statische Methoden. Eine Instanzmethode ist eine Methode, die einer Instanz einer-Klasse zugeordnet ist. eine statische Methode ist eine Methode, die der Klasse selbst zugeordnet ist.  
  
 Diese Methoden Überladung entspricht dem Aufrufen der- <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> Methoden Überladung und gibt `true` für an `throwOnBindFailure` .  
  
> [!NOTE]
>  Ab [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] kann diese Methode verwendet werden, um auf nicht öffentliche Methoden zuzugreifen, wenn der <xref:System.Security.Permissions.ReflectionPermission> Aufrufer mit dem-Flag erteilt wurde, <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> und wenn der Berechtigungs Satz der nicht öffentlichen Methoden auf den Berechtigungs Satz des Aufrufers oder auf eine Teilmenge des Aufrufers beschränkt ist. (Siehe [Sicherheitsüberlegungen für die Reflektion](/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="target" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> erbt nicht <see cref="T:System.MulticastDelegate" />.  
  
- oder - 
 <paramref name="type" /> ist keine <see langword="RuntimeType" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- oder - 
 <paramref name="target" /> ist keine <see langword="RuntimeType" />.  
  
- oder - 
 <paramref name="target" /> ist ein offener generischer Typ. Das bedeutet, die <see cref="P:System.Type.ContainsGenericParameters" />-Eigenschaft ist <see langword="true" />.  
  
- oder - 
 <paramref name="method" /> ist keine <see langword="static" />-Methode (<see langword="Shared" />-Methode in Visual Basic).  
  
- oder - 
 <paramref name="method" /> kann nicht gebunden werden, z. B. weil sie nicht gefunden wurde.</exception>
        <exception cref="T:System.MissingMethodException">Die <see langword="Invoke" />-Methode von <paramref name="type" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <paramref name="method" />.</exception>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate? CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDelegate (type As Type, target As Object, method As String, ignoreCase As Boolean, throwOnBindFailure As Boolean) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="type">Der <see cref="T:System.Type" /> des zu erstellenden Delegaten.</param>
        <param name="target">Die Klasseninstanz, für die <paramref name="method" /> aufgerufen wird.</param>
        <param name="method">Der Name der Instanzenmethode, die durch den Delegaten dargestellt werden soll.</param>
        <param name="ignoreCase">Ein boolescher Wert, der angibt, ob die Groß- und Kleinschreibung beim Vergleichen des Methodennamens berücksichtigt werden soll.</param>
        <param name="throwOnBindFailure"><see langword="true" />, um eine Ausnahme auszulösen, wenn <paramref name="method" /> nicht gebunden werden kann, andernfalls <see langword="false" />.</param>
        <summary>Erstellt einen Delegaten vom angegebenen Typ, der die angegebene Instanzenmethode darstellt, die für die angegebene Klasseninstanz aufgerufen werden soll, wobei die Groß- und Kleinschreibung und das Verhalten bei Bindungsfehlern den Angaben entsprechend berücksichtigt bzw. nicht berücksichtigt wird.</summary>
        <returns>Ein Delegat vom angegebenen Typ, der die angegebene Instanzenmethode darstellt, die für die angegebene Klasseninstanz aufgerufen werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt nur Delegaten für Instanzmethoden. Eine Instanzmethode ist eine Methode, die einer Instanz einer-Klasse zugeordnet ist. eine statische Methode ist eine Methode, die der Klasse selbst zugeordnet ist.  
  
> [!NOTE]
>  Ab [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] kann diese Methode verwendet werden, um auf nicht öffentliche Methoden zuzugreifen, wenn der <xref:System.Security.Permissions.ReflectionPermission> Aufrufer mit dem-Flag erteilt wurde, <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> und wenn der Berechtigungs Satz der nicht öffentlichen Methoden auf den Berechtigungs Satz des Aufrufers oder auf eine Teilmenge des Aufrufers beschränkt ist. (Siehe [Sicherheitsüberlegungen für die Reflektion](/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="target" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> erbt nicht <see cref="T:System.MulticastDelegate" />.  
  
- oder - 
 <paramref name="type" /> ist keine <see langword="RuntimeType" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- oder - 
 <paramref name="method" /> ist keine Instanzenmethode.  
  
- oder - 
 <paramref name="method" /> kann nicht gebunden werden, z. B. weil sie nicht gefunden wurde, und <paramref name="throwOnBindFailure" /> ist gleich <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">Die <see langword="Invoke" />-Methode von <paramref name="type" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <paramref name="method" />.</exception>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate? CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDelegate (type As Type, target As Type, method As String, ignoreCase As Boolean, throwOnBindFailure As Boolean) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="type">Der <see cref="T:System.Type" /> des zu erstellenden Delegaten.</param>
        <param name="target">Der <see cref="T:System.Type" />, der die Klasse darstellt, die von <paramref name="method" /> implementiert wird.</param>
        <param name="method">Der Name der statischen Methode, die durch den Delegaten dargestellt werden soll.</param>
        <param name="ignoreCase">Ein boolescher Wert, der angibt, ob die Groß- und Kleinschreibung beim Vergleichen des Methodennamens berücksichtigt werden soll.</param>
        <param name="throwOnBindFailure"><see langword="true" />, um eine Ausnahme auszulösen, wenn <paramref name="method" /> nicht gebunden werden kann, andernfalls <see langword="false" />.</param>
        <summary>Erstellt einen Delegaten vom angegebenen Typ, der die angegebene statische Methode der angegebenen Klasse darstellt, wobei die Groß- und Kleinschreibung und das Verhalten bei Bindungsfehlern den Angaben entsprechend berücksichtigt bzw. nicht berücksichtigt wird.</summary>
        <returns>Ein Delegat vom angegebenen Typ, der die angegebene statische Methode der angegebenen Klasse darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt Delegaten nur für statische Methoden. Eine Instanzmethode ist eine Methode, die einer Instanz einer-Klasse zugeordnet ist. eine statische Methode ist eine Methode, die der Klasse selbst zugeordnet ist.  
  
> [!NOTE]
>  Ab [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] kann diese Methode verwendet werden, um auf nicht öffentliche Methoden zuzugreifen, wenn der <xref:System.Security.Permissions.ReflectionPermission> Aufrufer mit dem-Flag erteilt wurde, <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> und wenn der Berechtigungs Satz der nicht öffentlichen Methoden auf den Berechtigungs Satz des Aufrufers oder auf eine Teilmenge des Aufrufers beschränkt ist. (Siehe [Sicherheitsüberlegungen für die Reflektion](/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="target" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> erbt nicht <see cref="T:System.MulticastDelegate" />.  
  
- oder - 
 <paramref name="type" /> ist keine <see langword="RuntimeType" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- oder - 
 <paramref name="target" /> ist keine <see langword="RuntimeType" />.  
  
- oder - 
 <paramref name="target" /> ist ein offener generischer Typ. Das bedeutet, die <see cref="P:System.Type.ContainsGenericParameters" />-Eigenschaft ist <see langword="true" />.  
  
- oder - 
 <paramref name="method" /> ist keine <see langword="static" />-Methode (<see langword="Shared" />-Methode in Visual Basic).  
  
- oder - 
 <paramref name="method" /> kann nicht gebunden werden, z. B. weil sie nicht gefunden wurde, und <paramref name="throwOnBindFailure" /> ist gleich <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">Die <see langword="Invoke" />-Methode von <paramref name="type" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <paramref name="method" />.</exception>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.DynamicInvoke : obj[] -&gt; obj" Usage="delegate.DynamicInvoke args" />
      <MemberSignature Language="C#" Value="public object DynamicInvoke (object[] args);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (args As Object()) As Object" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">Ein Array von Objekten, das die Argumente darstellt, die der durch den aktuellen Delegaten dargestellten Methode übergeben werden.  
  
- oder - 
 <see langword="null" />, wenn die durch den aktuellen Delegaten dargestellte Methode keine Argumente erfordert.</param>
        <summary>Ruft die durch den aktuellen Delegaten dargestellte Methode dynamisch (mit später Bindung) auf.</summary>
        <returns>Das Objekt, das von der durch den Delegaten dargestellten Methode zurückgegeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft die <xref:System.Delegate.DynamicInvokeImpl%2A>-Methode auf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Der Aufrufer verfügt nicht über Zugriff auf die Methode, die durch den Delegaten dargestellt wird (wenn die Methode z.B. privat ist).  
  
- oder - 
Anzahl, Reihenfolge oder Typ der in <paramref name="args" /> aufgeführten Parameter ist ungültig.</exception>
        <exception cref="T:System.ArgumentException">Die durch den Delegaten dargestellte Methode wird für ein Objekt oder eine Klasse aufgerufen, die die Methode nicht unterstützt.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Die durch den Delegaten dargestellte Methode ist eine Instanzenmethode, und das Zielobjekt ist <see langword="null" />.  
  
- oder - 
Eine der gekapselten Methoden löst eine Ausnahme aus.</exception>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member DynamicInvokeImpl : obj[] -&gt; obj&#xA;override this.DynamicInvokeImpl : obj[] -&gt; obj" Usage="delegate.DynamicInvokeImpl args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="args">Ein Array von Objekten, das die Argumente darstellt, die der durch den aktuellen Delegaten dargestellten Methode übergeben werden.  
  
- oder - 
 <see langword="null" />, wenn die durch den aktuellen Delegaten dargestellte Methode keine Argumente erfordert.</param>
        <summary>Ruft die durch den aktuellen Delegaten dargestellte Methode dynamisch (mit später Bindung) auf.</summary>
        <returns>Das Objekt, das von der durch den Delegaten dargestellten Methode zurückgegeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode implementiert die Methode <xref:System.Delegate.DynamicInvoke%2A> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Der Aufrufer verfügt nicht über Zugriff auf die Methode, die durch den Delegaten dargestellt wird (wenn die Methode z.B. privat ist).  
  
- oder - 
Anzahl, Reihenfolge oder Typ der in <paramref name="args" /> aufgeführten Parameter ist ungültig.</exception>
        <exception cref="T:System.ArgumentException">Die durch den Delegaten dargestellte Methode wird für ein Objekt oder eine Klasse aufgerufen, die die Methode nicht unterstützt.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Die durch den Delegaten dargestellte Methode ist eine Instanzenmethode, und das Zielobjekt ist <see langword="null" />.  
  
- oder - 
Eine der gekapselten Methoden löst eine Ausnahme aus.</exception>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="delegate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, das mit dem aktuellen Delegaten verglichen werden soll.</param>
        <summary>Bestimmt, ob das angegebene Objekt und der aktuelle Delegat vom gleichen Typ sind und die gleichen Ziele, Methoden und Aufruflisten besitzen.</summary>
        <returns><see langword="true" />, wenn <paramref name="obj" /> und der aktuelle Delegat die gleichen Ziele, Methoden und Aufruflisten aufweisen; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die beiden Delegaten nicht denselben Typ haben, werden Sie nicht als gleich betrachtet.  
  
> [!IMPORTANT]
>  In den .NET Framework, Version 1,0 und 1,1, wurden zwei Delegaten als gleich betrachtet, wenn Ihre Ziele, Methoden und Aufruf Listen gleich waren, auch wenn die Delegaten von unterschiedlichen Typen waren.  
  
 Die Methoden und Ziele werden wie folgt auf Gleichheit verglichen:  
  
-   Wenn die beiden verglichenen Methoden statisch sind und dieselbe Methode in derselben Klasse sind, werden die Methoden als gleich betrachtet, und die Ziele werden ebenfalls als gleich betrachtet.  
  
-   Wenn die beiden verglichenen Methoden Instanzmethoden sind und dieselbe Methode für dasselbe Objekt sind, werden die Methoden als gleich betrachtet, und die Ziele werden ebenfalls als gleich betrachtet.  
  
-   Andernfalls werden die Methoden nicht als gleich betrachtet, und die Ziele werden ebenfalls nicht als gleich betrachtet.  
  
 Zwei Aufruf Listen werden nur dann als identisch betrachtet, wenn Sie dieselbe Reihenfolge aufweisen und die entsprechenden Elemente aus den beiden Listen dieselbe Methode und dasselbe Ziel darstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Der Aufrufer verfügt nicht über Zugriff auf die Methode, die durch den Delegaten dargestellt wird (wenn die Methode z.B. privat ist).</exception>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="delegate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Hashcode für den Delegaten zurück.</summary>
        <returns>Ein Hashcode für den Delegaten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert dieser Methode darf aus zwei Gründen nicht beibehalten werden. Zuerst kann die Hash Funktion einer Klasse geändert werden, um eine bessere Verteilung zu generieren, wobei alle Werte aus der alten Hash Funktion nutzlos werden. Zweitens stellt die Standard Implementierung dieser Klasse nicht sicher, dass der gleiche Wert von unterschiedlichen Instanzen zurückgegeben wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberSignature Language="F#" Value="abstract member GetInvocationList : unit -&gt; Delegate[]&#xA;override this.GetInvocationList : unit -&gt; Delegate[]" Usage="delegate.GetInvocationList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Aufrufliste des Delegaten zurück.</summary>
        <returns>Ein Array von Delegaten, das die Aufrufliste des aktuellen Delegaten darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Delegat im Array stellt genau eine Methode dar.  
  
 Die Reihenfolge der Delegaten im-Array entspricht der Reihenfolge, in der der aktuelle Delegat die Methoden aufruft, die diese Delegaten darstellen.  
  
   
  
## Examples  
 Im folgenden Beispiel werden einem Delegaten drei Methoden zugewiesen. Anschließend wird die-  <xref:System.Delegate.GetInvocationList%2A> Methode aufgerufen, um die Gesamtzahl der dem Delegaten zugewiesenen Methoden zu erhalten, die Delegaten in umgekehrter Reihenfolge auszuführen und die Methoden auszuführen, deren Name nicht die Teil Zeichenfolge "file" enthält.  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : unit -&gt; System.Reflection.MethodInfo" Usage="delegate.GetMethodImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die statische Methode ab, die durch den aktuellen Delegaten dargestellt wird.</summary>
        <returns>Eine <see cref="T:System.Reflection.MethodInfo" />, die die durch den aktuellen Delegaten dargestellte statische Methode beschreibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gilt nur, wenn der aktuelle Delegat eine statische Methode darstellt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Der Aufrufer verfügt nicht über Zugriff auf die Methode, die durch den Delegaten dargestellt wird (wenn die Methode z.B. privat ist).</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="delegate.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="info">Wird nicht unterstützt.</param>
        <param name="context">Wird nicht unterstützt.</param>
        <summary>Wird nicht unterstützt.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode wird nicht unterstützt.</exception>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Method : System.Reflection.MethodInfo" Usage="System.Delegate.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Methode ab, die durch den Delegaten dargestellt wird.</summary>
        <value>Eine <see cref="T:System.Reflection.MethodInfo" />, die die durch den Delegaten dargestellte Methode beschreibt.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">Der Aufrufer verfügt nicht über Zugriff auf die Methode, die durch den Delegaten dargestellt wird (wenn die Methode z.B. privat ist).</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Delegate * Delegate -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">Der erste der zu vergleichenden Delegaten.</param>
        <param name="d2">Der zweite der zu vergleichenden Delegaten.</param>
        <summary>Bestimmt, ob die angegebenen Delegaten gleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="d1" /> und <paramref name="d2" /> gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwei Delegaten desselben Typs mit denselben Zielen, Methoden und Aufruf Listen werden als gleich betrachtet.  
  
 Wenn die beiden Delegaten nicht denselben Typ haben, werden Sie nicht als gleich betrachtet.  
  
> [!IMPORTANT]
>  In den .NET Framework, Version 1,0 und 1,1, wurden zwei Delegaten als gleich betrachtet, wenn Ihre Ziele, Methoden und Aufruf Listen gleich waren, auch wenn die Delegaten von unterschiedlichen Typen waren.  
  
 Die Methoden und Ziele werden wie folgt auf Gleichheit verglichen:  
  
-   Wenn die beiden verglichenen Methoden statisch sind und dieselbe Methode in derselben Klasse sind, werden die Methoden als gleich betrachtet, und die Ziele werden ebenfalls als gleich betrachtet.  
  
-   Wenn die beiden verglichenen Methoden Instanzmethoden sind und dieselbe Methode für dasselbe Objekt sind, werden die Methoden als gleich betrachtet, und die Ziele werden ebenfalls als gleich betrachtet.  
  
-   Andernfalls werden die Methoden nicht als gleich betrachtet, und die Ziele werden ebenfalls nicht als gleich betrachtet.  
  
 Zwei Aufruf Listen werden als identisch betrachtet, wenn Sie dieselbe Reihenfolge aufweisen und die entsprechenden Elemente aus den beiden Listen dieselbe Methode und dasselbe Ziel darstellen.  
  
 Die äquivalente Methode für diesen Operator ist. <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Delegate * Delegate -&gt; bool" Usage="System.Delegate.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">Der erste der zu vergleichenden Delegaten.</param>
        <param name="d2">Der zweite der zu vergleichenden Delegaten.</param>
        <summary>Bestimmt, ob die angegebenen Delegaten ungleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="d1" /> und <paramref name="d2" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwei Delegaten werden als ungleich betrachtet, wenn Sie unterschiedliche Typen aufweisen oder über unterschiedliche Methoden, andere Ziele oder andere Aufruf Listen verfügen.  
  
 Wenn die beiden Delegaten nicht denselben Typ haben, werden Sie nicht als gleich betrachtet.  
  
> [!IMPORTANT]
>  In den .NET Framework, Version 1,0 und 1,1, werden zwei Delegaten als gleich betrachtet, wenn Ihre Ziele, Methoden und Aufruf Listen gleich sind, auch wenn die Delegaten von unterschiedlichen Typen waren.  
  
 Die Methoden und Ziele werden wie folgt auf Gleichheit verglichen:  
  
-   Wenn die beiden verglichenen Methoden statisch sind und dieselbe Methode in derselben Klasse sind, werden die Methoden als gleich betrachtet, und die Ziele werden ebenfalls als gleich betrachtet.  
  
-   Wenn die beiden verglichenen Methoden Instanzmethoden sind und dieselbe Methode für dasselbe Objekt sind, werden die Methoden als gleich betrachtet, und die Ziele werden ebenfalls als gleich betrachtet.  
  
-   Andernfalls werden die Methoden nicht als gleich betrachtet, und die Ziele werden ebenfalls nicht als gleich betrachtet.  
  
 Zwei Aufruf Listen sind nicht gleich, wenn Sie unterschiedliche Größen haben, wenn Sie anders angeordnet sind, oder wenn mindestens ein Element aus einer Liste eine Methode oder ein Ziel darstellt, das sich von dem entsprechenden Element in der anderen Liste unterscheidet.  
  
 Die äquivalente Methode für diesen Operator ist. <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member Remove : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Remove (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Der Delegat, aus dem die Aufrufliste von <paramref name="value" /> entfernt werden soll.</param>
        <param name="value">Der Delegat, von dem die Aufrufliste stammt, die aus der Aufrufliste von <paramref name="source" /> entfernt werden soll.</param>
        <summary>Entfernt das letzte Vorkommen der Aufrufliste eines Delegaten aus der Aufrufliste eines anderen Delegaten.</summary>
        <returns>Ein neuer Delegat mit einer Aufrufliste, die aus der Aufrufliste von <paramref name="source" /> besteht, aus der das letzte Vorkommen der Aufrufliste von <paramref name="value" /> entfernt wurde, falls sich die Aufrufliste von <paramref name="value" /> in der Aufrufliste von <paramref name="source" /> befand. Gibt <paramref name="source" /> zurück, wenn <paramref name="value" /><see langword="null" /> ist oder die Aufrufliste von <paramref name="value" /> sich nicht innerhalb der Aufrufliste von <paramref name="source" /> befand. Gibt einen NULL-Verweis zurück, wenn die Aufrufliste von <paramref name="value" /> gleich der Aufrufliste von <paramref name="source" /> ist oder <paramref name="source" /> ein NULL-Verweis ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Aufruf Liste von `value` einem zusammenhängenden Satz von Elementen in der Aufruf Liste von entspricht `source` , wird die Aufruf Liste von in `value` der Aufruf Liste von aufgeführt `source` . Wenn die Aufruf Liste von mehrmals `value` in der Aufruf Liste von auftritt `source` , wird das letzte Vorkommen entfernt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Der Aufrufer verfügt nicht über Zugriff auf die Methode, die durch den Delegaten dargestellt wird (wenn die Methode z.B. privat ist).</exception>
        <exception cref="T:System.ArgumentException">Die Delegattypen stimmen nicht überein.</exception>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveAll : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.RemoveAll (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Der Delegat, aus dem die Aufrufliste von <paramref name="value" /> entfernt werden soll.</param>
        <param name="value">Der Delegat, von dem die Aufrufliste stammt, die aus der Aufrufliste von <paramref name="source" /> entfernt werden soll.</param>
        <summary>Entfernt alle Vorkommen der Aufrufliste eines Delegaten aus der Aufrufliste eines anderen Delegaten.</summary>
        <returns>Ein neuer Delegat mit einer Aufrufliste, die aus der Aufrufliste von <paramref name="source" /> besteht, aus der alle Vorkommen der Aufrufliste von <paramref name="value" /> entfernt wurden, falls sich die Aufrufliste von <paramref name="value" /> in der Aufrufliste von <paramref name="source" /> befand. Gibt <paramref name="source" /> zurück, wenn <paramref name="value" /><see langword="null" /> ist oder die Aufrufliste von <paramref name="value" /> sich nicht innerhalb der Aufrufliste von <paramref name="source" /> befand. Gibt einen NULL-Verweis zurück, wenn die Aufrufliste von <paramref name="value" /> gleich der Aufrufliste von <paramref name="source" /> ist, wenn <paramref name="source" /> nur eine Reihe von Aufruflisten enthält, die gleich der Aufrufliste von <paramref name="value" /> sind, oder <paramref name="source" /> ein NULL-Verweis ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Aufruf Liste von `value` einem zusammenhängenden Satz von Elementen in der Aufruf Liste von entspricht `source` , wird die Aufruf Liste von in `value` der Aufruf Liste von aufgeführt `source` . Wenn die Aufruf Liste von mehrmals `value` in der Aufruf Liste von vorkommt `source` , werden alle Vorkommen entfernt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Der Aufrufer verfügt nicht über Zugriff auf die Methode, die durch den Delegaten dargestellt wird (wenn die Methode z.B. privat ist).</exception>
        <exception cref="T:System.ArgumentException">Die Delegattypen stimmen nicht überein.</exception>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate? RemoveImpl (Delegate d);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member RemoveImpl : Delegate -&gt; Delegate&#xA;override this.RemoveImpl : Delegate -&gt; Delegate" Usage="delegate.RemoveImpl d" />
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="d">Der Delegat, von dem die Aufrufliste stammt, die aus der Aufrufliste des aktuellen Delegaten entfernt werden soll.</param>
        <summary>Entfernt die Aufrufliste eines Delegaten aus der Aufrufliste eines anderen Delegaten.</summary>
        <returns>Ein neuer Delegat mit einer Aufrufliste, die aus der Aufrufliste des aktuellen Delegaten besteht, aus der die Aufrufliste von <paramref name="value" /> entfernt wurde, falls sich die Aufrufliste von <paramref name="value" /> in der Aufrufliste des aktuellen Delegaten befand. Gibt den aktuellen Delegaten zurück, wenn <paramref name="value" /><see langword="null" /> ist oder wenn die Aufrufliste von <paramref name="value" /> nicht innerhalb der Aufrufliste des aktuellen Delegaten gefunden wurde. Gibt <see langword="null" /> zurück, wenn die Aufrufliste von <paramref name="value" /> gleich der Aufrufliste des aktuellen Delegaten ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Aufruf Liste von `value` einem zusammenhängenden Satz von Elementen in der Aufruf Liste des aktuellen Delegaten entspricht, wird die Aufruf Liste von `value` in der Aufruf Liste des aktuellen Delegaten als Vorkommen bezeichnet. Wenn die Aufruf Liste von mehrmals `value` in der Aufruf Liste des aktuellen Delegaten vorkommt, wird das letzte Vorkommen entfernt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Der Aufrufer verfügt nicht über Zugriff auf die Methode, die durch den Delegaten dargestellt wird (wenn die Methode z.B. privat ist).</exception>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target : obj" Usage="System.Delegate.Target" />
      <MemberSignature Language="C#" Value="public object? Target { get; }" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Klasseninstanz ab, für die der aktuelle Delegat die Instanzenmethode aufruft.</summary>
        <value>Das Objekt, für das der aktuelle Delegat die Instanzmethode aufruft, wenn der Delegat eine Instanzmethode darstellt, <see langword="null" />, wenn der Delegat eine statische Methode darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Instanzmethode ist eine Methode, die einer Instanz einer-Klasse zugeordnet ist. eine statische Methode ist eine Methode, die der Klasse selbst zugeordnet ist.  
  
 Wenn der Delegat eine oder mehrere Instanzmethoden aufruft, gibt diese Eigenschaft das Ziel der letzten Instanzmethode in der Aufruf Liste zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
