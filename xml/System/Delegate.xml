<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Delegate.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac53f0536eac77f3171e3a7eeb74486cfcf863ec3d8.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3f0536eac77f3171e3a7eeb74486cfcf863ec3d8</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Delegate">
          <source>Represents a delegate, which is a data structure that refers to a static method or to a class instance and an instance method of that class.</source>
          <target state="translated">Stellt einen Delegaten dar. Hierbei handelt es sich um eine Datenstruktur, die auf eine statische Methode oder auf eine Klasseninstanz und eine Instanzenmethode dieser Klasse verweist.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> class is the base class for delegate types.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> Klasse ist die Basisklasse für Delegattypen.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>However, only the system and compilers can derive explicitly from the <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> class or from the <ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph> class.</source>
          <target state="translated">Allerdings nur die System- und die Compiler können explizit aus Ableiten der <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> Klasse oder aus der <ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>It is also not permissible to derive a new type from a delegate type.</source>
          <target state="translated">Es ist auch nicht zulässig, einen neuen Typ von einem Delegattyp als Typ abgeleitet werden.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> class is not considered a delegate type; it is a class used to derive delegate types.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> Klasse gilt einen Delegattyp; es ist eine Klasse, die zum Ableiten von Delegattypen verwendet.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Most languages implement a <ph id="ph1">`delegate`</ph> keyword, and compilers for those languages are able to derive from the <ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph> class; therefore, users should use the <ph id="ph3">`delegate`</ph> keyword provided by the language.</source>
          <target state="translated">Implementieren die meisten Sprachen eine <ph id="ph1">`delegate`</ph> -Schlüsselwort, und Compiler für diese Sprachen sind in der Lage, leiten Sie von der <ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph> Klasse, daher kann Benutzer verwenden sollen die <ph id="ph3">`delegate`</ph> Schlüsselwort, die von der Sprache bereitgestellt.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The common language runtime provides an <ph id="ph1">`Invoke`</ph> method for each delegate type, with the same signature as the delegate.</source>
          <target state="translated">Die common Language Runtime bietet eine <ph id="ph1">`Invoke`</ph> Methode für jeden Delegaten, mit der gleichen Signatur wie der Delegat.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>You do not have to call this method explicitly from C#, Visual Basic, or Visual C++, because the compilers call it automatically.</source>
          <target state="translated">Sie müssen nicht diese Methode explizit von c#, Visual Basic oder Visual C++ aufrufen, da der Compiler automatisch aufrufen.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The <ph id="ph1">`Invoke`</ph> method is useful in <bpt id="p1">[</bpt>reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/reflection.md)</ept> when you want to find the signature of the delegate type.</source>
          <target state="translated">Die <ph id="ph1">`Invoke`</ph> Methode eignet sich für <bpt id="p1">[</bpt>Reflektion<ept id="p1">](~/docs/framework/reflection-and-codedom/reflection.md)</ept> Wenn Sie die Signatur des Delegattyps suchen möchten.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The common language runtime provides each delegate type with <ph id="ph1">`BeginInvoke`</ph> and <ph id="ph2">`EndInvoke`</ph> methods, to enable asynchronous invocation of the delegate.</source>
          <target state="translated">Die common Language Runtime bietet jedem Delegattyp <ph id="ph1">`BeginInvoke`</ph> und <ph id="ph2">`EndInvoke`</ph> Methoden, um asynchrone Aufruf des Delegaten zu aktivieren.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>For more information about these methods, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">Weitere Informationen zu diesen Methoden finden Sie unter <bpt id="p1">[</bpt>Aufrufen synchroner Methoden asynchron<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The declaration of a delegate type establishes a contract that specifies the signature of one or more methods.</source>
          <target state="translated">Die Deklaration eines Delegattyps richtet einen Vertrag, der die Signatur der eine oder mehrere Methoden angibt.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A delegate is an instance of a delegate type that has references to:</source>
          <target state="translated">Ein Delegat ist eine Instanz von einem Delegattyp als Typ, der Verweise auf verfügt:</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>An instance method of a type and a target object assignable to that type.</source>
          <target state="translated">Eine Instanzmethode eines Typs und ein Zielobjekt, die diesem Typ zugeordnet werden kann.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>An instance method of a type, with the hidden <ph id="ph1">`this`</ph> parameter exposed in the formal parameter list.</source>
          <target state="translated">Eine Instanzmethode eines Typs, mit der ausgeblendeten <ph id="ph1">`this`</ph> verfügbar gemacht werden, in der Liste der formalen Parameter.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The delegate is said to be an open instance delegate.</source>
          <target state="translated">Der Delegat wird als eine offene Instanz Delegaten werden.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A static method.</source>
          <target state="translated">Eine statische Methode.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A static method and a target object assignable to the first parameter of the method.</source>
          <target state="translated">Eine statische Methode und ein Zielobjekt, das den ersten Parameter der Methode zugeordnet werden kann.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The delegate is said to be closed over its first argument.</source>
          <target state="translated">Der Delegat wird als über das erste Argument geschlossen werden.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>For more information on delegate binding, see the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload.</source>
          <target state="translated">Weitere Informationen zu delegatbindung, finden Sie unter der <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> -methodenüberladung.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>In the .NET Framework versions 1.0 and 1.1, a delegate can represent a method only if the signature of the method exactly matches the signature specified by the delegate type.</source>
          <target state="translated">Ein Delegat kann in der .NET Framework-Versionen 1.0 und 1.1 eine Methode darstellen, nur, wenn die Signatur der Methode genau die von dem Typ des Delegaten angegebenen Signatur übereinstimmt.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Thus, only the first and third bullets in the preceding list are supported, and the first bullet requires an exact type match.</source>
          <target state="translated">Daher werden nur die ersten und dritten Aufzählungszeichen in der vorangehenden Liste unterstützt und das erste Aufzählungszeichen erfordert einer genauen Übereinstimmung.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When a delegate represents an instance method closed over its first argument (the most common case), the delegate stores a reference to the method's entry point and a reference to an object, called the target, which is of a type assignable to the type that defined the method.</source>
          <target state="translated">Wenn ein Delegat die Instanzenmethode, die über das erste Argument (die am häufigsten vorkommen) geschlossen darstellt, speichert der Delegaten einen Verweis auf den Einstiegspunkt der Methode und einem Verweis auf ein Objekt, das als Ziel bezeichnet, also einen Typ in den Typ zugewiesen werden, die definiert die Methode.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When a delegate represents an open instance method, it stores a reference to the method's entry point.</source>
          <target state="translated">Wenn ein Delegat eine offene Instanzmethode darstellt, speichert er einen Verweis auf den Einstiegspunkt der Methode.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The delegate signature must include the hidden <ph id="ph1">`this`</ph> parameter in its formal parameter list; in this case, the delegate does not have a reference to a target object, and a target object must be supplied when the delegate is invoked.</source>
          <target state="translated">Die Signatur des Delegaten muss dem Ausblend-enthalten <ph id="ph1">`this`</ph> Parameter in der Liste der formalen Parameter; in diesem Fall der Delegaten verfügt nicht über einen Verweis auf ein Zielobjekt und ein Zielobjekt muss angegeben werden, wenn der Delegat aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When a delegate represents a static method, the delegate stores a reference to the method's entry point.</source>
          <target state="translated">Wenn ein Delegat eine statische Methode darstellt, speichert der Delegaten einen Verweis auf den Einstiegspunkt der Methode.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When a delegate represents a static method closed over its first argument, the delegate stores a reference to the method's entry point and a reference to a target object assignable to the type of the method's first argument.</source>
          <target state="translated">Wenn ein Delegat eine statische Methode, die über das erste Argument geschlossen darstellt, speichert den Delegaten einen Verweis auf den Einstiegspunkt der Methode und einem Verweis auf ein Zielobjekt, das den Typ des ersten Arguments der Methode zugeordnet werden kann.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When the delegate is invoked, the first argument of the static method receives the target object.</source>
          <target state="translated">Wenn der Delegat aufgerufen wird, empfängt das erste Argument der statischen Methode des Zielobjekts.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The invocation list of a delegate is an ordered set of delegates in which each element of the list invokes exactly one of the methods represented by the delegate.</source>
          <target state="translated">Die Aufrufliste eines Delegaten ist eine geordnete Menge von Delegaten, in denen jedes Element der Liste genau einem der durch den Delegaten dargestellten Methoden aufruft.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>An invocation list can contain duplicate methods.</source>
          <target state="translated">Eine Aufrufliste kann doppelte Methoden enthalten.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>During an invocation, methods are invoked in the order in which they appear in the invocation list.</source>
          <target state="translated">Während eines Aufrufs werden Methoden in der Reihenfolge aufgerufen, in denen sie in der Aufrufliste angezeigt werden.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A delegate attempts to invoke every method in its invocation list; duplicates are invoked once for each time they appear in the invocation list.</source>
          <target state="translated">Ein Delegat versucht, jede Methode in der Aufrufliste aufrufen. Duplikate werden aufgerufen, nachdem für jedes Mal, die sie in der Aufrufliste angezeigt werden.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Delegates are immutable; once created, the invocation list of a delegate does not change.</source>
          <target state="translated">Delegaten sind unveränderlich. nach der Erstellung wird die Aufrufliste eines Delegaten nicht geändert.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Delegates are referred to as multicast, or combinable, because a delegate can invoke one or more methods and can be used in combining operations.</source>
          <target state="translated">Delegaten werden bezeichnet als Multicast- oder combinable, da ein Delegat eine oder mehrere Methoden aufrufen kann und kann in Kombination von Vorgängen verwendet werden.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Combining operations, such as <ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Delegate.Remove%2A&gt;</ph>, do not alter existing delegates.</source>
          <target state="translated">Kombinieren von Operationen, wie z. B. <ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Delegate.Remove%2A&gt;</ph>, vorhandene Delegaten nicht geändert.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Instead, such an operation returns a new delegate that contains the results of the operation, an unchanged delegate, or <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Stattdessen gibt einen neuen Delegaten mit den Ergebnissen des Vorgangs, eines unverändert Delegaten oder <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A combining operation returns <ph id="ph1">`null`</ph> when the result of the operation is a delegate that does not reference at least one method.</source>
          <target state="translated">Gibt eine Operation zum Kombinieren <ph id="ph1">`null`</ph> Wenn das Ergebnis des Vorgangs ist ein Delegat, der nicht über mindestens eine Methode verweist.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A combining operation returns an unchanged delegate when the requested operation has no effect.</source>
          <target state="translated">Eine Operation zum Kombinieren gibt einen unverändert Delegaten zurück, wenn der angeforderte Vorgang keine Auswirkung hat.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Managed languages use the <ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Delegate.Remove%2A&gt;</ph> methods to implement delegate operations.</source>
          <target state="translated">Verwaltete Sprachen verwenden die <ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Delegate.Remove%2A&gt;</ph> Methoden an Delegaten Vorgänge zu implementieren.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Examples include the <ph id="ph1">`AddHandler`</ph> and <ph id="ph2">`RemoveHandler`</ph> statements in Visual Basic and the += and -= operators on delegate types in C#.</source>
          <target state="translated">Beispiele hierfür sind die <ph id="ph1">`AddHandler`</ph> und <ph id="ph2">`RemoveHandler`</ph> Anweisungen in Visual Basic und die Operatoren += und -= auf Delegattypen in C# geschrieben.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, generic delegate types can have variant type parameters.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, generischen Delegattypen können über Variante Typparameter verfügen.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Contravariant type parameters can be used as parameter types of the delegate, and a covariant type parameter can be used as the return type.</source>
          <target state="translated">Kontravariante Typparameter als Parametertypen des Delegaten verwendet werden können, und kann ein kovarianten Typparameter als Rückgabetyp verwendet werden.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>This feature allows generic delegate types that are constructed from the same generic type definition to be assignment-compatible if their type arguments are reference types with an inheritance relationship, as explained in <bpt id="p1">[</bpt>Covariance and Contravariance<ept id="p1">](~/docs/standard/generics/covariance-and-contravariance.md)</ept>.</source>
          <target state="translated">Dieses Feature ermöglicht den generischen Delegaten Typen, die erstellt werden, aus der gleichen generischen Typdefinition werden zuweisungskompatibel, wenn ihre Typargumente mit einer vererbungsbeziehung Verweistypen sind, wie in beschrieben <bpt id="p1">[</bpt>Kovarianz und Kontravarianz<ept id="p1">](~/docs/standard/generics/covariance-and-contravariance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</source>
          <target state="translated">Generische Delegaten, die zuweisungskompatibel sind aufgrund von Varianz sind nicht notwendigerweise kombinierbar.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>To be combinable, the types must match exactly.</source>
          <target state="translated">Um combinable sein, müssen die Typen genau übereinstimmen.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>For example, suppose that a class named <ph id="ph1">`Derived`</ph> is derived from a class named <ph id="ph2">`Base`</ph>.</source>
          <target state="translated">Nehmen wir beispielsweise an, dass eine Klasse mit dem Namen <ph id="ph1">`Derived`</ph> stammt aus einer Klasse mit dem Namen <ph id="ph2">`Base`</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A delegate of type <ph id="ph1">`Action&lt;Base&gt;`</ph> (<ph id="ph2">`Action(Of Base)`</ph> in Visual Basic) can be assigned to a variable of type <ph id="ph3">`Action&lt;Derived&gt;`</ph>, but the two delegates cannot be combined because the types do not match exactly.</source>
          <target state="translated">Ein Delegat des Typs <ph id="ph1">`Action&lt;Base&gt;`</ph> (<ph id="ph2">`Action(Of Base)`</ph> in Visual Basic) kann eine Variable vom Typ zugewiesen werden <ph id="ph3">`Action&lt;Derived&gt;`</ph>, aber die beiden Delegaten können nicht kombiniert werden, da die Typen nicht genau übereinstimmen.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>If an invoked method throws an exception, the method stops executing, the exception is passed back to the caller of the delegate, and remaining methods in the invocation list are not invoked.</source>
          <target state="translated">Wenn eine aufgerufene Methode eine Ausnahme auslöst, die Ausführung die Methode beendet wird, wird die Ausnahme an den Aufrufer des Delegaten übergeben und verbleibende Methoden in der Aufrufliste werden nicht aufgerufen.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Catching the exception in the caller does not alter this behavior.</source>
          <target state="translated">Abfangen der Ausnahme im Aufrufer wird dieses Verhalten nicht geändert werden.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When the signature of the methods invoked by a delegate includes a return value, the delegate returns the return value of the last element in the invocation list.</source>
          <target state="translated">Wenn die Signatur der Methoden aufgerufen, indem ein Delegat einen Rückgabewert enthält, gibt der Delegat den Rückgabewert des letzten Elements in der Aufrufliste zurück.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When the signature includes a parameter that is passed by reference, the final value of the parameter is the result of every method in the invocation list executing sequentially and updating the parameter's value.</source>
          <target state="translated">Wenn die Signatur einen Parameter als Verweis übergeben wird enthält, ist der endgültige Wert des Parameters das Ergebnis jeder Methode in der Aufrufliste sequenziell ausgeführt, und aktualisieren den Wert des Parameters an.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The closest equivalent of a delegate in C or C++ is a function pointer.</source>
          <target state="translated">Die nächste Entsprechung eines Delegaten in C oder C++ ist ein Funktionszeiger.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>A delegate can represent a static method or an instance method.</source>
          <target state="translated">Ein Delegat kann es sich um eine statische Methode oder Instanzmethode darstellen.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>When the delegate represents an instance method, the delegate stores not only a reference to the method's entry point, but also a reference to the class instance.</source>
          <target state="translated">Wenn der Delegat eine Instanzmethode darstellt, speichert der Delegat nicht nur einen Verweis auf den Einstiegspunkt der Methode, sondern auch einen Verweis auf die Klasseninstanz.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Unlike function pointers, delegates are object oriented and type safe.</source>
          <target state="translated">Im Gegensatz zu Funktionszeigern sind Delegaten objektorientiert sind und typsicher.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The following example shows how to define a delegate named <ph id="ph1">`myMethodDelegate`</ph>.</source>
          <target state="translated">Im folgende Beispiel wird gezeigt, wie ein Delegat mit dem Namen definieren <ph id="ph1">`myMethodDelegate`</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>Instances of this delegate are created for an instance method and a static method of the nested <ph id="ph1">`mySampleClass`</ph> class.</source>
          <target state="translated">Instanzen dieses Delegaten werden für eine Instanzmethode aufrufen und eine statische Methode der geschachtelten erstellt <ph id="ph1">`mySampleClass`</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The delegate for the instance method requires an instance of <ph id="ph1">`mySampleClass`</ph>.</source>
          <target state="translated">Der Delegat für die Instanzmethode erfordert eine Instanz von <ph id="ph1">`mySampleClass`</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Delegate">
          <source>The <ph id="ph1">`mySampleClass`</ph> instance is saved in a variable named <ph id="ph2">`mySC`</ph>.</source>
          <target state="translated">Die <ph id="ph1">`mySampleClass`</ph> Instanz wird gespeichert, in einer Variablen namens <ph id="ph2">`mySC`</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="T:System.Delegate">
          <source>Initializes a new delegate.</source>
          <target state="translated">Initialisiert einen neuen Delegaten.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>The class instance on which the delegate invokes <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Die Klasseninstanz, für die der Delegat <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> aufruft.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>The name of the instance method that the delegate represents.</source>
          <target state="translated">Der Name der Instanzenmethode, die durch den Delegaten dargestellt wird.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>Initializes a delegate that invokes the specified instance method on the specified class instance.</source>
          <target state="translated">Initialisiert einen Delegaten, der die angegebene Instanzenmethode für die angegebene Klasseninstanz aufruft.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>This constructor cannot be used in application code.</source>
          <target state="translated">Dieser Konstruktor kann nicht im Anwendungscode verwendet werden.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>To create a delegate by specifying the name of an instance method, use an overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specifies a method name and a target object.</source>
          <target state="translated">Um einen Delegaten erstellen, indem der Name der Instanzenmethode, verwenden Sie eine Überladung der <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> Methode, die einen Methodennamen und einem Zielobjekt angibt.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>For example, the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29&gt;</ph> method overload creates a delegate for an instance method with a specified name.</source>
          <target state="translated">Z. B. die <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29&gt;</ph> methodenüberladung erstellt einen Delegaten für eine Instanzmethode mit dem angegebenen Namen.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>This constructor creates delegates for instance methods only.</source>
          <target state="translated">Dieser Konstruktor erstellt nur Delegaten für die Instanz.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">Eine Instanzmethode ist eine Methode, die eine Instanz einer Klasse zugeordnet ist. eine statische Methode ist eine Methode, die die Klasse selbst zugeordnet ist.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>There was an error binding to the target method.</source>
          <target state="translated">Beim Binden an die Zielmethode ist ein Fehler aufgetreten.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Object,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the class that defines <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, der die Klasse darstellt, die <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> definiert.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>The name of the static method that the delegate represents.</source>
          <target state="translated">Der Name der statischen Methode, die durch den Delegaten dargestellt wird.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>Initializes a delegate that invokes the specified static method from the specified class.</source>
          <target state="translated">Initialisiert einen Delegaten, der die angegebene statische Methode der angegebenen Klasse aufruft.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>This constructor cannot be used in application code.</source>
          <target state="translated">Dieser Konstruktor kann nicht im Anwendungscode verwendet werden.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>To create a delegate by specifying the name of a static method, use an overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specifies a method name but does not specify a target object.</source>
          <target state="translated">Um einen Delegaten zu erstellen, indem der Name einer statischen Methode verwendet eine Überladung der <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> -Methode, die einen Methodennamen angibt, jedoch kein Zielobjekt angegeben.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>For example, the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29&gt;</ph> method overload creates a static delegate for a method with a specified name.</source>
          <target state="translated">Z. B. die <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29&gt;</ph> methodenüberladung erstellt einen statischen Delegaten für eine Methode mit dem angegebenen Namen.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>This constructor creates delegates for static methods only.</source>
          <target state="translated">Dieser Konstruktor erstellt die Delegaten für nur statische Methoden.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">Eine Instanzmethode ist eine Methode, die eine Instanz einer Klasse zugeordnet ist. eine statische Methode ist eine Methode, die die Klasse selbst zugeordnet ist.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> ist keine <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Siehe <bpt id="p1">[</bpt>Laufzeittypen in Reflektion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> represents an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> entspricht einem offenen generischen Typ.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.#ctor(System.Type,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Delegate.Clone">
          <source>Creates a shallow copy of the delegate.</source>
          <target state="translated">Erstellt eine flache Kopie des Delegaten.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Delegate.Clone">
          <source>A shallow copy of the delegate.</source>
          <target state="translated">Eine flache Kopie des Delegaten.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>The clone has the same <ph id="ph1">&lt;xref:System.Type&gt;</ph>, target, method, and invocation list as the original delegate.</source>
          <target state="translated">Der Klon hat die gleiche <ph id="ph1">&lt;xref:System.Type&gt;</ph>, Ziel, Methode und der Aufruf Liste wie der ursprüngliche Delegat.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>A shallow copy creates a new instance of the same type as the original object, and then copies the nonstatic fields of the original object.</source>
          <target state="translated">Eine flache Kopie erstellt eine neue Instanz des gleichen Typs wie das ursprüngliche Objekt, und klicken Sie dann die nicht statische Felder des ursprünglichen Objekts kopiert.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>If the field is a value type, a bit-by-bit copy of the field is performed.</source>
          <target state="translated">Wenn das Feld ein Werttyp ist, erfolgt eine Bit für Bit-Kopie des Felds.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>If the field is a reference type, the reference is copied but the referred object is not; therefore, the reference in the original object and the reference in the clone point to the same object.</source>
          <target state="translated">Wenn das Feld ein Verweistyp ist, wird der Verweis kopiert, aber das referenzierte Objekt ist nicht; Zeigen Sie daher den Verweis in das ursprüngliche Objekt und der Verweis in den Klon auf dasselbe Objekt.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>In contrast, a deep copy of an object duplicates everything directly or indirectly referenced by the fields in the object.</source>
          <target state="translated">Im Gegensatz dazu dupliziert eine tiefe Kopie eines Objekts wird alles, was auf die die Felder im Objekt direkt oder indirekt verweist.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Clone">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="T:System.Delegate">
          <source>Concatenates the invocation lists of the specified multicast (combinable) delegates.</source>
          <target state="translated">Verkettet die Aufruflisten der angegebenen Multicastdelegaten.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>The array of delegates to combine.</source>
          <target state="translated">Das zu kombinierende Array von Delegaten.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>Concatenates the invocation lists of an array of delegates.</source>
          <target state="translated">Verkettet die Aufruflisten eines Arrays von Delegaten.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>A new delegate with an invocation list that concatenates the invocation lists of the delegates in the <ph id="ph1">&lt;paramref name="delegates" /&gt;</ph> array.</source>
          <target state="translated">Ein neuer Delegat mit einer Aufrufliste, die aus der Verkettung der Aufruflisten der Delegaten im <ph id="ph1">&lt;paramref name="delegates" /&gt;</ph>-Array besteht.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>Returns <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="delegates" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, if <ph id="ph4">&lt;paramref name="delegates" /&gt;</ph> contains zero elements, or if every entry in <ph id="ph5">&lt;paramref name="delegates" /&gt;</ph> is <ph id="ph6">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurück, wenn <ph id="ph2">&lt;paramref name="delegates" /&gt;</ph> <ph id="ph3">&lt;see langword="null" /&gt;</ph> ist, <ph id="ph4">&lt;paramref name="delegates" /&gt;</ph> 0 Elemente enthält oder jeder Eintrag in <ph id="ph5">&lt;paramref name="delegates" /&gt;</ph> <ph id="ph6">&lt;see langword="null" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>If the <ph id="ph1">`delegates`</ph> array contains entries that are <ph id="ph2">`null`</ph>, those entries are ignored.</source>
          <target state="translated">Wenn die <ph id="ph1">`delegates`</ph> Array enthält Einträge, die <ph id="ph2">`null`</ph>, diese Einträge werden ignoriert.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</source>
          <target state="translated">Die Aufrufliste kann doppelte Einträge enthalten; d. h. Einträge, die auf die gleiche Methode, die für dasselbe Objekt verweisen.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</source>
          <target state="translated">Generische Delegaten, die zuweisungskompatibel sind aufgrund von Varianz sind nicht notwendigerweise kombinierbar.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>To be combinable, the types must match exactly.</source>
          <target state="translated">Um combinable sein, müssen die Typen genau übereinstimmen.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>For example, suppose that a class named <ph id="ph1">`Derived`</ph> is derived from a class named <ph id="ph2">`Base`</ph>.</source>
          <target state="translated">Nehmen wir beispielsweise an, dass eine Klasse mit dem Namen <ph id="ph1">`Derived`</ph> stammt aus einer Klasse mit dem Namen <ph id="ph2">`Base`</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>A delegate of type <ph id="ph1">`Action&lt;Base&gt;`</ph> (<ph id="ph2">`Action(Of Base)`</ph> in Visual Basic) can be assigned to a variable of type <ph id="ph3">`Action&lt;Derived&gt;`</ph>, as explained in <bpt id="p1">[</bpt>Covariance and Contravariance<ept id="p1">](~/docs/standard/generics/covariance-and-contravariance.md)</ept>, but the two delegates cannot be combined because the types do not match exactly.</source>
          <target state="translated">Ein Delegat des Typs <ph id="ph1">`Action&lt;Base&gt;`</ph> (<ph id="ph2">`Action(Of Base)`</ph> in Visual Basic) kann eine Variable vom Typ zugewiesen werden <ph id="ph3">`Action&lt;Derived&gt;`</ph>, wie im <bpt id="p1">[</bpt>Kovarianz und Kontravarianz<ept id="p1">](~/docs/standard/generics/covariance-and-contravariance.md)</ept>, aber die beiden Delegaten können nicht kombiniert werden, da die Typen werden nicht exakt überein.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source><ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> is useful for creating event handlers that call multiple methods each time an event occurs.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> eignet sich für das Erstellen von Ereignishandlern, die bei Aufruf, dass mehrere Methoden ein Ereignisses Zeit.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>Not all the non-null entries in <ph id="ph1">&lt;paramref name="delegates" /&gt;</ph> are instances of the same delegate type.</source>
          <target state="translated">Nicht alle Einträge ungleich null in <ph id="ph1">&lt;paramref name="delegates" /&gt;</ph> sind Instanzen des gleichen Delegattyps.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>The delegate whose invocation list comes first.</source>
          <target state="translated">Der Delegat, dessen Aufrufliste die erste Liste ist.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>The delegate whose invocation list comes last.</source>
          <target state="translated">Der Delegat, dessen Aufrufliste die letzte Liste ist.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>Concatenates the invocation lists of two delegates.</source>
          <target state="translated">Verkettet die Aufruflisten zweier Delegaten.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>A new delegate with an invocation list that concatenates the invocation lists of <ph id="ph1">&lt;paramref name="a" /&gt;</ph> and <ph id="ph2">&lt;paramref name="b" /&gt;</ph> in that order.</source>
          <target state="translated">Eine neuer Delegat mit einer Aufrufliste, die aus der Verkettung der Aufruflisten von <ph id="ph1">&lt;paramref name="a" /&gt;</ph> und <ph id="ph2">&lt;paramref name="b" /&gt;</ph> in dieser Reihenfolge besteht.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>Returns <ph id="ph1">&lt;paramref name="a" /&gt;</ph> if <ph id="ph2">&lt;paramref name="b" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, returns <ph id="ph4">&lt;paramref name="b" /&gt;</ph> if <ph id="ph5">&lt;paramref name="a" /&gt;</ph> is a null reference, and returns a null reference if both <ph id="ph6">&lt;paramref name="a" /&gt;</ph> and <ph id="ph7">&lt;paramref name="b" /&gt;</ph> are null references.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;paramref name="a" /&gt;</ph> zurück, wenn <ph id="ph2">&lt;paramref name="b" /&gt;</ph> gleich <ph id="ph3">&lt;see langword="null" /&gt;</ph> ist, gibt <ph id="ph4">&lt;paramref name="b" /&gt;</ph> zurück, wenn <ph id="ph5">&lt;paramref name="a" /&gt;</ph> ein NULL-Verweis ist, und gibt einen NULL-Verweis zurück, wenn <ph id="ph6">&lt;paramref name="a" /&gt;</ph> und <ph id="ph7">&lt;paramref name="b" /&gt;</ph> NULL-Verweise sind.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</source>
          <target state="translated">Die Aufrufliste kann doppelte Einträge enthalten; d. h. Einträge, die auf die gleiche Methode, die für dasselbe Objekt verweisen.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</source>
          <target state="translated">Generische Delegaten, die zuweisungskompatibel sind aufgrund von Varianz sind nicht notwendigerweise kombinierbar.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>To be combinable, the types must match exactly.</source>
          <target state="translated">Um combinable sein, müssen die Typen genau übereinstimmen.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>For example, suppose that a class named <ph id="ph1">`Derived`</ph> is derived from a class named <ph id="ph2">`Base`</ph>.</source>
          <target state="translated">Nehmen wir beispielsweise an, dass eine Klasse mit dem Namen <ph id="ph1">`Derived`</ph> stammt aus einer Klasse mit dem Namen <ph id="ph2">`Base`</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>A delegate of type <ph id="ph1">`Action&lt;Base&gt;`</ph> (<ph id="ph2">`Action(Of Base)`</ph> in Visual Basic) can be assigned to a variable of type <ph id="ph3">`Action&lt;Derived&gt;`</ph>, as explained in <bpt id="p1">[</bpt>Covariance and Contravariance<ept id="p1">](~/docs/standard/generics/covariance-and-contravariance.md)</ept>, but the two delegates cannot be combined because the types do not match exactly.</source>
          <target state="translated">Ein Delegat des Typs <ph id="ph1">`Action&lt;Base&gt;`</ph> (<ph id="ph2">`Action(Of Base)`</ph> in Visual Basic) kann eine Variable vom Typ zugewiesen werden <ph id="ph3">`Action&lt;Derived&gt;`</ph>, wie im <bpt id="p1">[</bpt>Kovarianz und Kontravarianz<ept id="p1">](~/docs/standard/generics/covariance-and-contravariance.md)</ept>, aber die beiden Delegaten können nicht kombiniert werden, da die Typen werden nicht exakt überein.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source><ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> is useful for creating event handlers that call multiple methods each time an event occurs.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Delegate.Combine%2A&gt;</ph> eignet sich für das Erstellen von Ereignishandlern, die bei Aufruf, dass mehrere Methoden ein Ereignisses Zeit.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>Both <ph id="ph1">&lt;paramref name="a" /&gt;</ph> and <ph id="ph2">&lt;paramref name="b" /&gt;</ph> are not <ph id="ph3">&lt;see langword="null" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="a" /&gt;</ph> and <ph id="ph5">&lt;paramref name="b" /&gt;</ph> are not instances of the same delegate type.</source>
          <target state="translated">Sowohl <ph id="ph1">&lt;paramref name="a" /&gt;</ph> als auch <ph id="ph2">&lt;paramref name="b" /&gt;</ph> sind nicht gleich <ph id="ph3">&lt;see langword="null" /&gt;</ph>, und <ph id="ph4">&lt;paramref name="a" /&gt;</ph> und <ph id="ph5">&lt;paramref name="b" /&gt;</ph> sind keine Instanzen desselben Delegatentyps.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Combine(System.Delegate,System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>The multicast (combinable) delegate whose invocation list to append to the end of the invocation list of the current multicast (combinable) delegate.</source>
          <target state="translated">Der Multicastdelegat, dessen Aufrufliste an das Ende der Aufrufliste des aktuellen Multicastdelegaten angefügt werden soll.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>Concatenates the invocation lists of the specified multicast (combinable) delegate and the current multicast (combinable) delegate.</source>
          <target state="translated">Verkettet die Aufruflisten des angegebenen und des aktuellen Multicastdelegaten.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>A new multicast (combinable) delegate with an invocation list that concatenates the invocation list of the current multicast (combinable) delegate and the invocation list of <ph id="ph1">&lt;paramref name="d" /&gt;</ph>, or the current multicast (combinable) delegate if <ph id="ph2">&lt;paramref name="d" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Eine neuer Multicastdelegat, dessen Aufrufliste aus der Verkettung der Aufrufliste des aktuellen Multicastdelegaten mit der Aufrufliste von <ph id="ph1">&lt;paramref name="d" /&gt;</ph> besteht, oder der aktuelle Multicastdelegat, wenn <ph id="ph2">&lt;paramref name="d" /&gt;</ph><ph id="ph3">&lt;see langword="null" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>This method applies only if the current delegate is multicast (combinable).</source>
          <target state="translated">Diese Methode gilt nur, wenn der aktuelle Delegat multicast vorliegt (combinable).</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>The current implementation simply throws a <ph id="ph1">&lt;xref:System.MulticastNotSupportedException&gt;</ph>.</source>
          <target state="translated">Die aktuelle Implementierung löst einfach eine <ph id="ph1">&lt;xref:System.MulticastNotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</source>
          <target state="translated">Die Aufrufliste kann doppelte Einträge enthalten; d. h. Einträge, die auf die gleiche Methode, die für dasselbe Objekt verweisen.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>Always thrown.</source>
          <target state="translated">Wird immer ausgelöst.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CombineImpl(System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="T:System.Delegate">
          <source>Creates a delegate of the specified type.</source>
          <target state="translated">Erstellt einen Delegaten vom angegebenen Typs.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> des zu erstellenden Delegaten.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> describing the static or instance method the delegate is to represent.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, die die statische Methode oder Instanzmethode beschreibt, die der Delegat darstellen soll.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>Only static methods are supported in the .NET Framework version 1.0 and 1.1.</source>
          <target state="translated">In .NET Framework, Version 1.0 und 1.1, werden nur statische Methoden unterstützt.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>Creates a delegate of the specified type to represent the specified static method.</source>
          <target state="translated">Erstellt einen Delegaten vom angegebenen Typ, der die angegebene statische Methode darstellen soll.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>A delegate of the specified type to represent the specified static method.</source>
          <target state="translated">Ein Delegat vom angegebenen Typ, der die angegebene statische Methode darstellen soll.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>In the .NET Framework version 1.0 and 1.1, this method overload creates delegates for static methods only.</source>
          <target state="translated">In .NET Framework, Version 1.0 und 1.1 erstellt diese methodenüberladung Delegate für nur statische Methoden.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>In the .NET Framework version 2.0, this method overload also can create open instance method delegates; that is, delegates that explicitly supply the hidden first argument of instance methods.</source>
          <target state="translated">In .NET Framework, Version 2.0 kann diese methodenüberladung auch offenen Instanz Methode Delegaten erstellen. d. h. Instanz Delegaten, die explizit, das verborgene erste Argument der angeben Methoden.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>For a detailed explanation, see the more general <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload, which allows you to create all combinations of open or closed delegates for instance or static methods, and optionally to specify a first argument.</source>
          <target state="translated">Eine ausführliche Erläuterung finden Sie unter die allgemeinere <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29&gt;</ph> methodenüberladung, dem Sie alle Kombinationen von offenen und geschlossenen Delegaten für die Instanz oder statische Methoden und optional ein erstes Argument angeben kann.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>This method overload should be used when the delegate is not closed over its first argument, because it is somewhat faster in that case.</source>
          <target state="translated">Diese methodenüberladung sollte verwendet werden, wenn der Delegat nicht über dem ersten Argument geschlossen wird, da in diesem Fall etwas schneller ist.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload and specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnBindFailure`</ph>.</source>
          <target state="translated">Überladung dieser Methode entspricht dem Aufrufen der <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> methodenüberladung und Angeben von <ph id="ph2">`true`</ph> für <ph id="ph3">`throwOnBindFailure`</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Methode kann verwendet werden, auf nicht öffentliche Methoden zuzugreifen, wenn der Aufrufer erteilt wurde <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit dem <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> kennzeichnen und erteilen Sie der Berechtigungssatz für die nicht öffentlichen Methoden an des Aufrufers beschränkt ist Set- oder eine Teilmenge davon.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsüberlegungen für die Reflektion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein. </target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>Compatible Parameter Types and Return Type</source>
          <target state="translated">Kompatible Parametertypen und den Rückgabetyp</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>In the .NET Framework version 2.0, the parameter types and return type of a delegate created using this method overload must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</source>
          <target state="translated">In .NET Framework, Version 2.0 muss die Parametertypen und den Rückgabetyp eines Delegaten mit der Überladung dieser Methode erstellt kompatibel mit den Parametertypen und den Rückgabetyp der Methode, die der Delegat darstellt; die Typen müssen nicht exakt übereinstimmen.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>This represents a relaxation of the binding behavior in the .NET Framework version 1.0 and 1.1, where the types must match exactly.</source>
          <target state="translated">Dies stellt eine Lockerung der das Bindungsverhalten in .NET Framework, Version 1.0 und 1.1, bei denen die Typen genau übereinstimmen müssen.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</source>
          <target state="translated">Ein Parameter eines Delegaten ist mit dem entsprechenden Parameter einer Methode kompatibel, wenn der Typ des Delegatenparameters restriktiver ist als der Methodenparameter, da so gewährleistet ist, dass ein an den Delegaten übergebenes Argument problemlos an die Methode weitergeleitet werden kann.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</source>
          <target state="translated">Ebenso ist der Rückgabetyp eines Delegaten kompatibel mit dem Rückgabetyp einer Methode, wenn der Rückgabetyp der Methode restriktiver ist als der Rückgabetyp des Delegaten, da so gewährleistet ist, dass der Rückgabewert der Methode problemlos in den Rückgabetyp des Delegaten umgewandelt werden kann.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>For example, a delegate with a parameter of type <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> and a return type of <ph id="ph2">&lt;xref:System.Object&gt;</ph> can represent a method with a parameter of type <ph id="ph3">&lt;xref:System.Object&gt;</ph> and a return value of type <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Angenommen, ein Delegat mit einem Parameter vom Typ <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> und dem Rückgabetyp des <ph id="ph2">&lt;xref:System.Object&gt;</ph> kann eine Methode mit einem Parameter vom Typ darstellen <ph id="ph3">&lt;xref:System.Object&gt;</ph> sowie einen Rückgabewert vom Typ <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>This section contains two code examples.</source>
          <target state="translated">Dieser Abschnitt enthält zwei Codebeispiele.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The first example demonstrates the two kinds of delegates that can be created with this method overload: open over an instance method and open over a static method.</source>
          <target state="translated">Das erste Beispiel veranschaulicht die zwei Arten von Delegaten, die Überladung dieser Methode erstellt werden können: Öffnen Sie über eine Instanzmethode und über eine statische Methode.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The second code example demonstrates compatible parameter types and return types.</source>
          <target state="translated">Im zweiten Codebeispiel wird veranschaulicht, kompatible Parametertypen und Rückgabetypen.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><bpt id="p1">**</bpt>Example 1<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Beispiel 1<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The following code example demonstrates the two ways a delegate can be created using this overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, die zwei Möglichkeiten, ein Delegaten erstellt werden kann, verwenden diese Überladung von, der <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>There are two overloads of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specify a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> but not a first argument; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</source>
          <target state="translated">Es gibt zwei Überladungen der der <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> Methode, die angeben, ein <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> jedoch kein erstes Argument; ihre Funktionalität ist identisch, außer dass Ihnen die ermöglicht Angabe, ob bei Bindungsfehlern ausgelöst, und die andere immer löst.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>This code example uses both overloads.</source>
          <target state="translated">Dieses Codebeispiel verwendet beide Überladungen.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The example declares a class <ph id="ph1">`C`</ph> with a static method <ph id="ph2">`M2`</ph> and an instance method <ph id="ph3">`M1`</ph>, and two delegate types: <ph id="ph4">`D1`</ph> takes an instance of <ph id="ph5">`C`</ph> and a string, and <ph id="ph6">`D2`</ph> takes a string.</source>
          <target state="translated">Im Beispiel wird eine Klasse deklariert <ph id="ph1">`C`</ph> mit einer statischen Methode <ph id="ph2">`M2`</ph> und eine Instanzenmethode <ph id="ph3">`M1`</ph>, und zwei Delegattypen: <ph id="ph4">`D1`</ph> akzeptiert eine Instanz von <ph id="ph5">`C`</ph> und eine Zeichenfolge, und <ph id="ph6">`D2`</ph> nimmt eine Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>A second class named <ph id="ph1">`Example`</ph> contains the code that creates the delegates.</source>
          <target state="translated">Eine zweite Klasse <ph id="ph1">`Example`</ph> enthält den Code, der den Delegaten erstellt.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>A delegate of type <ph id="ph1">`D1`</ph>, representing an open instance method, is created for the instance method <ph id="ph2">`M1`</ph>.</source>
          <target state="translated">Ein Delegat des Typs <ph id="ph1">`D1`</ph>, der eine offene Instanzmethode darstellt, wird für die Instanzmethode erstellt <ph id="ph2">`M1`</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>An instance must be passed when the delegate is invoked.</source>
          <target state="translated">Eine Instanz muss übergeben werden, wenn der Delegat aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>A delegate of type <ph id="ph1">`D2`</ph>, representing an open static method, is created for the static method <ph id="ph2">`M2`</ph>.</source>
          <target state="translated">Ein Delegat des Typs <ph id="ph1">`D2`</ph>, eine offene statische Methode darstellt, wird für die statische Methode erstellt <ph id="ph2">`M2`</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><bpt id="p1">**</bpt>Example 2<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Beispiel 2<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The following code example demonstrates compatibility of parameter types and return types.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, die Kompatibilität der Parametertypen und Rückgabetypen.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The code example defines a base class named <ph id="ph1">`Base`</ph> and a class named <ph id="ph2">`Derived`</ph> that derives from <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">Das Codebeispiel definiert eine Basisklasse, die mit dem Namen <ph id="ph1">`Base`</ph> und eine Klasse namens <ph id="ph2">`Derived`</ph> abgeleitet, die <ph id="ph3">`Base`</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The derived class has a <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) method named <ph id="ph3">`MyMethod`</ph> with one parameter of type <ph id="ph4">`Base`</ph> and a return type of <ph id="ph5">`Derived`</ph>.</source>
          <target state="translated">Die abgeleitete Klasse verfügt über eine <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) Methode mit dem Namen <ph id="ph3">`MyMethod`</ph> mit einem Parameter vom Typ <ph id="ph4">`Base`</ph> und dem Rückgabetyp der <ph id="ph5">`Derived`</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The code example also defines a delegate named <ph id="ph1">`Example`</ph> that has one parameter of type <ph id="ph2">`Derived`</ph> and a return type of <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">Das Codebeispiel definiert auch einen Delegaten mit dem Namen <ph id="ph1">`Example`</ph> , die einen Parameter des Typs hat <ph id="ph2">`Derived`</ph> und dem Rückgabetyp der <ph id="ph3">`Base`</ph>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The code example demonstrates that the delegate named <ph id="ph1">`Example`</ph> can be used to represent the method <ph id="ph2">`MyMethod`</ph>.</source>
          <target state="translated">Im Codebeispiel wird veranschaulicht, dass der Delegat mit dem Namen <ph id="ph1">`Example`</ph> können verwendet werden, um die Methode darstellen <ph id="ph2">`MyMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The method can be bound to the delegate because:</source>
          <target state="translated">Die Methode kann an den Delegaten gebunden werden, da:</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The parameter type of the delegate (<ph id="ph1">`Derived`</ph>) is more restrictive than the parameter type of <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>), so that it is always safe to pass the argument of the delegate to <ph id="ph4">`MyMethod`</ph>.</source>
          <target state="translated">Der Parametertyp des Delegaten (<ph id="ph1">`Derived`</ph>) ist stärker eingeschränkt als der Parametertyp der <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>), sodass es immer sicher, das Argument des Delegaten zu übergeben sind <ph id="ph4">`MyMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The return type of <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) is more restrictive than the parameter type of the delegate (<ph id="ph3">`Base`</ph>), so that it is always safe to cast the return type of the method to the return type of the delegate.</source>
          <target state="translated">Der Rückgabetyp der <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) ist stärker eingeschränkt als der Parametertyp des Delegaten (<ph id="ph3">`Base`</ph>), sodass immer den Rückgabetyp der Methode in den Rückgabetyp des Delegaten umgewandelt werden kann.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The code example produces no output.</source>
          <target state="translated">Das Codebeispiel erzeugt keine Ausgabe.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> erbt nicht <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist keine <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Siehe <bpt id="p1">[</bpt>Laufzeittypen in Reflektion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a static method, and the .NET Framework version is 1.0 or 1.1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist keine statische Methode und die .NET Framework-Version ist 1.0 oder 1.1.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> kann nicht gebunden werden.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist keine <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Siehe <bpt id="p1">[</bpt>Laufzeittypen in Reflektion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">Die <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph>-Methode von <ph id="ph2">&lt;paramref name="type" /&gt;</ph> wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> des zu erstellenden Delegaten.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The object to which the delegate is bound, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> to treat <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> as <ph id="ph2">&lt;see langword="static" /&gt;</ph> (<ph id="ph3">&lt;see langword="Shared" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Das Objekt, an das der Delegat gebunden ist, oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>, um <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> als <ph id="ph2">&lt;see langword="static" /&gt;</ph> (<ph id="ph3">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) zu behandeln.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> describing the static or instance method the delegate is to represent.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, die die statische Methode oder Instanzmethode beschreibt, die der Delegat darstellen soll.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument.</source>
          <target state="translated">Erstellt einen Delegaten vom angegebenen Typ, der die angegebene statische Methode oder Instanzmethode mit dem angegebenen ersten Argument darstellt.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A delegate of the specified type that represents the specified static or instance method.</source>
          <target state="translated">Ein Delegat vom angegebenen Typ, der die angegebene statische Methode oder Instanzmethode darstellt.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Calling this method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload and specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnBindFailure`</ph>.</source>
          <target state="translated">Das Aufrufen dieser methodenüberladung entspricht dem Aufrufen der <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> methodenüberladung und Angeben von <ph id="ph2">`true`</ph> für <ph id="ph3">`throwOnBindFailure`</ph>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>These two overloads provide the most flexible way to create delegates.</source>
          <target state="translated">Diese zwei Überladungen bereitstellen, die flexibelste Möglichkeit zum Erstellen von Delegaten.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>You can use them to create delegates for either static or instance methods, and optionally to specify the first argument.</source>
          <target state="translated">Sie können Delegaten für statische oder Instanzmethoden zu erstellen und optional an das erste Argument verwenden.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If you do not supply a first argument, use the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload for better performance.</source>
          <target state="translated">Wenn Sie ein erstes Argument nicht angeben, verwenden Sie die <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> methodenüberladung für eine bessere Leistung.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The delegate type and the method must have compatible return types.</source>
          <target state="translated">Der Delegattyp und die Methode müssen kompatibel Rückgabetypen aufweisen.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>That is, the return type of <ph id="ph1">`method`</ph> must be assignable to the return type of <ph id="ph2">`type`</ph>.</source>
          <target state="translated">D. h., der Rückgabetyp der <ph id="ph1">`method`</ph> muss der Rückgabetyp der zugewiesen werden <ph id="ph2">`type`</ph>.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If <ph id="ph1">`firstArgument`</ph> is supplied, it is passed to <ph id="ph2">`method`</ph> every time the delegate is invoked; <ph id="ph3">`firstArgument`</ph> is said to be bound to the delegate, and the delegate is said to be closed over its first argument.</source>
          <target state="translated">Wenn <ph id="ph1">`firstArgument`</ph> wird angegeben, erfolgt eine Übergabe an <ph id="ph2">`method`</ph> jedes Mal, wenn der Delegat aufgerufen wird. <ph id="ph3">`firstArgument`</ph> gilt als an den Delegaten gebunden werden und der Delegat wird als über das erste Argument geschlossen werden.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If <ph id="ph1">`method`</ph> is <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic), the argument list supplied when invoking the delegate includes all parameters except the first; if <ph id="ph4">`method`</ph> is an instance method, then <ph id="ph5">`firstArgument`</ph> is passed to the hidden instance parameter (represented by <ph id="ph6">`this`</ph> in C#, or by <ph id="ph7">`Me`</ph> in Visual Basic).</source>
          <target state="translated">Wenn <ph id="ph1">`method`</ph> ist <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic), wird das Argument beim Aufrufen des Delegaten bereitgestellte Liste enthält alle Parameter außer der ersten; Wenn <ph id="ph4">`method`</ph> eine Instanzmethode ist, dann ist <ph id="ph5">`firstArgument`</ph> an der ausgeblendeten Instanz übergeben wird Parameter (dargestellt durch <ph id="ph6">`this`</ph> in c# oder durch <ph id="ph7">`Me`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If <ph id="ph1">`firstArgument`</ph> is supplied, the first parameter of <ph id="ph2">`method`</ph> must be a reference type, and <ph id="ph3">`firstArgument`</ph> must be compatible with that type.</source>
          <target state="translated">Wenn <ph id="ph1">`firstArgument`</ph> angegeben wird, der erste Parameter der <ph id="ph2">`method`</ph> muss ein Verweistyp sein und <ph id="ph3">`firstArgument`</ph> muss mit diesem Typ kompatibel sein.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If <ph id="ph1">`method`</ph> is <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) and its first parameter is of type <ph id="ph4">&lt;xref:System.Object&gt;</ph> or <ph id="ph5">&lt;xref:System.ValueType&gt;</ph>, then <ph id="ph6">`firstArgument`</ph> can be a value type.</source>
          <target state="translated">Wenn <ph id="ph1">`method`</ph> ist <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) und der erste Parameter ist vom Typ <ph id="ph4">&lt;xref:System.Object&gt;</ph> oder <ph id="ph5">&lt;xref:System.ValueType&gt;</ph>, klicken Sie dann <ph id="ph6">`firstArgument`</ph> kann ein Werttyp sein.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>In this case <ph id="ph1">`firstArgument`</ph> is automatically boxed.</source>
          <target state="translated">In diesem Fall <ph id="ph1">`firstArgument`</ph> automatisch mittels Boxing konvertiert.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Automatic boxing does not occur for any other arguments, as it would in a C# or Visual Basic function call.</source>
          <target state="translated">Automatische Boxing erfolgt für alle anderen Argumente nicht, wie es in einem C#- oder Visual Basic-Funktion aufrufen.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If <ph id="ph1">`firstArgument`</ph> is a null reference and <ph id="ph2">`method`</ph> is an instance method, the result depends on the signatures of the delegate type <ph id="ph3">`type`</ph> and of <ph id="ph4">`method`</ph>:</source>
          <target state="translated">Wenn <ph id="ph1">`firstArgument`</ph> ist ein null-Verweis und <ph id="ph2">`method`</ph> eine Instanzmethode ist, ist das Ergebnis hängt von den Signaturen des Delegattyps <ph id="ph3">`type`</ph> und <ph id="ph4">`method`</ph>:</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If the signature of <ph id="ph1">`type`</ph> explicitly includes the hidden first parameter of <ph id="ph2">`method`</ph>, the delegate is said to represent an open instance method.</source>
          <target state="translated">Wenn die Signatur der <ph id="ph1">`type`</ph> explizit schließt ausgeblendete ersten Parameters der <ph id="ph2">`method`</ph>, Delegaten gesagt, dass eine offene Instanzmethode darstellt.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>When the delegate is invoked, the first argument in the argument list is passed to the hidden instance parameter of <ph id="ph1">`method`</ph>.</source>
          <target state="translated">Wenn der Delegat aufgerufen wird, wird das erste Argument in der Argumentliste übergeben, auf den ausgeblendeten Instanzparameter <ph id="ph1">`method`</ph>.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If the signatures of <ph id="ph1">`method`</ph> and <ph id="ph2">`type`</ph> match (that is, all parameter types are compatible), then the delegate is said to be closed over a null reference.</source>
          <target state="translated">Wenn die Signaturen der <ph id="ph1">`method`</ph> und <ph id="ph2">`type`</ph> entsprechen (d. h., alle Parametertypen sind kompatibel), und klicken Sie dann der Delegaten gesagt, dass er über ein null-Verweis geschlossen werden.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Invoking the delegate is like calling an instance method on a null instance, which is not a particularly useful thing to do.</source>
          <target state="translated">Aufrufen des Delegaten entspricht dem Aufrufen einer Instanzmethode auf eine null-Instanz, die eine besonders nützlich, wenn man nicht ist.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If <ph id="ph1">`firstArgument`</ph> is a null reference and <ph id="ph2">`method`</ph> is static, the result depends on the signatures of the delegate type <ph id="ph3">`type`</ph> and of <ph id="ph4">`method`</ph>:</source>
          <target state="translated">Wenn <ph id="ph1">`firstArgument`</ph> ist ein null-Verweis und <ph id="ph2">`method`</ph> ist statisch, das Ergebnis hängt von den Signaturen des Delegattyps <ph id="ph3">`type`</ph> und <ph id="ph4">`method`</ph>:</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If the signature of <ph id="ph1">`method`</ph> and <ph id="ph2">`type`</ph> match (that is, all parameter types are compatible), the delegate is said to represent an open static method.</source>
          <target state="translated">Wenn die Signatur der <ph id="ph1">`method`</ph> und <ph id="ph2">`type`</ph> entsprechen (d. h., alle Parametertypen sind kompatibel), der Delegat wird als eine offene statische Methode darstellen.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>This is the most common case for static methods.</source>
          <target state="translated">Dies ist der häufigste Fall für statische Methoden.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>In this case, you can get slightly better performance by using the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload.</source>
          <target state="translated">In diesem Fall erhalten Sie eine etwas bessere Leistung mithilfe der <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> -methodenüberladung.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>If the signature of <ph id="ph1">`type`</ph> begins with the second parameter of <ph id="ph2">`method`</ph> and the rest of the parameter types are compatible, then the delegate is said to be closed over a null reference.</source>
          <target state="translated">Wenn die Signatur der <ph id="ph1">`type`</ph> beginnt mit der zweite Parameter der <ph id="ph2">`method`</ph> der Rest der Parametertypen kompatibel sind, und der Delegat wird als über ein null-Verweis geschlossen werden.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>When the delegate is invoked, a null reference is passed to the first parameter of <ph id="ph1">`method`</ph>.</source>
          <target state="translated">Wenn der Delegat aufgerufen wird, wird ein null-Verweis auf den ersten Parameter übergeben <ph id="ph1">`method`</ph>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Methode kann verwendet werden, auf nicht öffentliche Methoden zuzugreifen, wenn der Aufrufer erteilt wurde <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit dem <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> kennzeichnen und erteilen Sie der Berechtigungssatz für die nicht öffentlichen Methoden an des Aufrufers beschränkt ist Set- oder eine Teilmenge davon.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsüberlegungen für die Reflektion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein. </target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Compatible Parameter Types and Return Type</source>
          <target state="translated">Kompatible Parametertypen und den Rückgabetyp</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</source>
          <target state="translated">Die Parametertypen und den Rückgabetyp eines Delegaten müssen mit den Parametertypen und den Rückgabetyp der Methode, die der Delegat darstellt kompatibel sein. die Typen müssen nicht exakt übereinstimmen.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>In the .NET Framework version 1.0 and 1.1, the types must match exactly.</source>
          <target state="translated">In .NET Framework, Version 1.0 und 1.1 müssen die Typen genau übereinstimmen.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</source>
          <target state="translated">Ein Parameter eines Delegaten ist mit dem entsprechenden Parameter einer Methode kompatibel, wenn der Typ des Delegatenparameters restriktiver ist als der Methodenparameter, da so gewährleistet ist, dass ein an den Delegaten übergebenes Argument problemlos an die Methode weitergeleitet werden kann.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</source>
          <target state="translated">Ebenso ist der Rückgabetyp eines Delegaten kompatibel mit dem Rückgabetyp einer Methode, wenn der Rückgabetyp der Methode restriktiver ist als der Rückgabetyp des Delegaten, da so gewährleistet ist, dass der Rückgabewert der Methode problemlos in den Rückgabetyp des Delegaten umgewandelt werden kann.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>For example, a delegate with a parameter of type <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> and a return type of <ph id="ph2">&lt;xref:System.Object&gt;</ph> can represent a method with a parameter of type <ph id="ph3">&lt;xref:System.Object&gt;</ph> and a return value of type <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Angenommen, ein Delegat mit einem Parameter vom Typ <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> und dem Rückgabetyp des <ph id="ph2">&lt;xref:System.Object&gt;</ph> kann eine Methode mit einem Parameter vom Typ darstellen <ph id="ph3">&lt;xref:System.Object&gt;</ph> sowie einen Rückgabewert vom Typ <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Determining the Methods a Delegate Can Represent</source>
          <target state="translated">Bestimmen die Methoden kann ein Delegat darstellen.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Another useful way to think of the flexibility provided by this overload of <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is that any given delegate can represent four different combinations of method signature and method kind (static versus instance).</source>
          <target state="translated">Eine andere hilfreiche Möglichkeit, um die Flexibilität, die von dieser Überladung von vorstellen <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> darin, dass jeder angegebene Delegat vier verschiedene Kombinationen der Methodensignatur und die Methodenart (statisch oder Instanz) darstellen kann.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Consider a delegate type <ph id="ph1">`D`</ph> with one argument of type <ph id="ph2">`C`</ph>.</source>
          <target state="translated">Betrachten Sie einen Delegattyp <ph id="ph1">`D`</ph> mit einem Argument des Typs <ph id="ph2">`C`</ph>.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The following describes the methods <ph id="ph1">`D`</ph> can represent, ignoring the return type since it must match in all cases:</source>
          <target state="translated">Im folgenden werden die Methoden beschrieben <ph id="ph1">`D`</ph> darstellen kann, wird den Rückgabetyp wird ignoriert, da es in allen Fällen entsprechen muss:</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">`D`</ph> can represent any instance method that has exactly one argument of type <ph id="ph2">`C`</ph>, regardless of what type the instance method belongs to.</source>
          <target state="translated"><ph id="ph1">`D`</ph> kann Instanzmethode mit genau ein Argument des Typs darstellen <ph id="ph2">`C`</ph>, unabhängig davon, welchen Typ die Instanzmethode angehört.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is an instance of the type <ph id="ph3">`method`</ph> belongs to, and the resulting delegate is said to be closed over that instance.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> aufgerufen wird, <ph id="ph2">`firstArgument`</ph> ist eine Instanz des Typs <ph id="ph3">`method`</ph> gehört, und der resultierende Delegat herrscht die verbreitete über diese Instanz geschlossen werden.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>(Trivially, <ph id="ph1">`D`</ph> can also be closed over a null reference if <ph id="ph2">`firstArgument`</ph> is a null reference.)</source>
          <target state="translated">(Trivial, <ph id="ph1">`D`</ph> kann auch über ein null-Verweis geschlossen werden, wenn <ph id="ph2">`firstArgument`</ph> ein null-Verweis ist.)</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">`D`</ph> can represent an instance method of <ph id="ph2">`C`</ph> that has no arguments.</source>
          <target state="translated"><ph id="ph1">`D`</ph> kann eine Instanzmethode darstellen <ph id="ph2">`C`</ph> , die keine Argumente verfügt.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is a null reference.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> aufgerufen wird, <ph id="ph2">`firstArgument`</ph> ist ein null-Verweis.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The resulting delegate represents an open instance method, and an instance of <ph id="ph1">`C`</ph> must be supplied each time it is invoked.</source>
          <target state="translated">Der resultierende Delegat stellt eine offene Instanz-Methode und einer Instanz von <ph id="ph1">`C`</ph> muss angegeben werden, bei jedem Aufruf erfolgte.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">`D`</ph> can represent a static method that takes one argument of type <ph id="ph2">`C`</ph>, and that method can belong to any type.</source>
          <target state="translated"><ph id="ph1">`D`</ph> eine statische Methode, die ein Argument des Typs darstellen kann <ph id="ph2">`C`</ph>, und dass die Methode auf einen beliebigen Typ angehören kann.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is a null reference.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> aufgerufen wird, <ph id="ph2">`firstArgument`</ph> ist ein null-Verweis.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The resulting delegate represents an open static method, and an instance of <ph id="ph1">`C`</ph> must be supplied each time it is invoked.</source>
          <target state="translated">Der resultierende Delegat stellt eine offene statische Methode und einer Instanz von <ph id="ph1">`C`</ph> muss angegeben werden, bei jedem Aufruf erfolgte.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">`D`</ph> can represent a static method that belongs to type <ph id="ph2">`F`</ph> and has two arguments, of type <ph id="ph3">`F`</ph> and type <ph id="ph4">`C`</ph>.</source>
          <target state="translated"><ph id="ph1">`D`</ph> kann eine statische Methode, die zum Typ gehört darstellen <ph id="ph2">`F`</ph> und verfügt über zwei Argumente, des Typs <ph id="ph3">`F`</ph> und Typ <ph id="ph4">`C`</ph>.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is an instance of <ph id="ph3">`F`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> aufgerufen wird, <ph id="ph2">`firstArgument`</ph> ist eine Instanz der <ph id="ph3">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The resulting delegate represents a static method that is closed over that instance of <ph id="ph1">`F`</ph>.</source>
          <target state="translated">Der resultierende Delegat stellt eine statische Methode, die über diese Instanz geschlossen wird <ph id="ph1">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Note that in the case where <ph id="ph1">`F`</ph> and <ph id="ph2">`C`</ph> are the same type, the static method has two arguments of that type.</source>
          <target state="translated">Beachten Sie, dass im Fall, in dem <ph id="ph1">`F`</ph> und <ph id="ph2">`C`</ph> denselben Typ aufweisen, der die statische Methode verfügt über zwei Argumente des Typs.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>(In this case, <ph id="ph1">`D`</ph> is closed over a null reference if <ph id="ph2">`firstArgument`</ph> is a null reference.)</source>
          <target state="translated">(In diesem Fall <ph id="ph1">`D`</ph> ist über ein null-Verweis geschlossen, wenn <ph id="ph2">`firstArgument`</ph> ein null-Verweis ist.)</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>This section contains three code examples.</source>
          <target state="translated">Dieser Abschnitt enthält drei Codebeispiele.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The first example demonstrates the four kinds of delegates that can be created: closed over an instance method, open over an instance method, open over a static method, and closed over a static method.</source>
          <target state="translated">Das erste Beispiel veranschaulicht die vier Arten von Delegaten, die erstellt werden können: über eine Instanzmethode ist, öffnen Sie über eine Instanzmethode ist, öffnen Sie über eine statische Methode geschlossen und über eine statische Methode geschlossen.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The second code example demonstrates compatible parameter types and return types.</source>
          <target state="translated">Im zweiten Codebeispiel wird veranschaulicht, kompatible Parametertypen und Rückgabetypen.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The third code example defines a single delegate type, and shows all the methods that delegate type can represent.</source>
          <target state="translated">Das dritte Codebeispiel definiert einen einzelne Delegattyp und zeigt, dass alle Methoden, die Delegattyp darstellen können.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><bpt id="p1">**</bpt>Example 1<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Beispiel 1<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The following code example demonstrates the four ways a delegate can be created using this overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, der ein Delegaten erstellt werden kann, verwenden diese Überladung von vier Arten der <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>There are two overloads of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specify <ph id="ph2">`firstArgument`</ph> and a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</source>
          <target state="translated">Es gibt zwei Überladungen der <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> Methode, die angeben <ph id="ph2">`firstArgument`</ph> und ein <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; ihre Funktionalität ist identisch, außer dass Ihnen die ermöglicht Angabe, ob bei Bindungsfehlern ausgelöst, und die andere immer löst.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>This code example uses both overloads.</source>
          <target state="translated">Dieses Codebeispiel verwendet beide Überladungen.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The example declares a class <ph id="ph1">`C`</ph> with a static method <ph id="ph2">`M2`</ph> and an instance method <ph id="ph3">`M1`</ph>, and three delegate types: <ph id="ph4">`D1`</ph> takes an instance of <ph id="ph5">`C`</ph> and a string, <ph id="ph6">`D2`</ph> takes a string, and <ph id="ph7">`D3`</ph> has no arguments.</source>
          <target state="translated">Im Beispiel wird eine Klasse deklariert <ph id="ph1">`C`</ph> mit einer statischen Methode <ph id="ph2">`M2`</ph> und eine Instanzenmethode <ph id="ph3">`M1`</ph>, sowie drei Delegattypen: <ph id="ph4">`D1`</ph> akzeptiert eine Instanz von <ph id="ph5">`C`</ph> und eine Zeichenfolge, <ph id="ph6">`D2`</ph> akzeptiert eine Zeichenfolge und <ph id="ph7">`D3`</ph>besitzt keine Argumente.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A second class named <ph id="ph1">`Example`</ph> contains the code that creates the delegates.</source>
          <target state="translated">Eine zweite Klasse <ph id="ph1">`Example`</ph> enthält den Code, der den Delegaten erstellt.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A delegate of type <ph id="ph1">`D2`</ph>, closed over an instance of <ph id="ph2">`C`</ph>, is created for the instance method <ph id="ph3">`M1`</ph>.</source>
          <target state="translated">Ein Delegat des Typs <ph id="ph1">`D2`</ph>, über eine Instanz des geschlossenen <ph id="ph2">`C`</ph>, wird für die Instanzmethode erstellt <ph id="ph3">`M1`</ph>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>It is invoked with different strings, to show that the bound instance of <ph id="ph1">`C`</ph> is always used.</source>
          <target state="translated">Wird aufgerufen, mit anderen Zeichenfolgen, um anzugeben, dass die gebundene Instanz von <ph id="ph1">`C`</ph> wird immer verwendet.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A delegate of type <ph id="ph1">`D1`</ph>, representing an open instance method, is created for the instance method <ph id="ph2">`M1`</ph>.</source>
          <target state="translated">Ein Delegat des Typs <ph id="ph1">`D1`</ph>, der eine offene Instanzmethode darstellt, wird für die Instanzmethode erstellt <ph id="ph2">`M1`</ph>.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>An instance must be passed when the delegate is invoked.</source>
          <target state="translated">Eine Instanz muss übergeben werden, wenn der Delegat aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A delegate of type <ph id="ph1">`D2`</ph>, representing an open static method, is created for the static method <ph id="ph2">`M2`</ph>.</source>
          <target state="translated">Ein Delegat des Typs <ph id="ph1">`D2`</ph>, eine offene statische Methode darstellt, wird für die statische Methode erstellt <ph id="ph2">`M2`</ph>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Finally, a delegate of type <ph id="ph1">`D3`</ph>, closed over a string, is created for the static method <ph id="ph2">`M2`</ph>.</source>
          <target state="translated">Schließlich, einen Delegaten vom Typ <ph id="ph1">`D3`</ph>, über eine Zeichenfolge geschlossen, wird für die statische Methode erstellt <ph id="ph2">`M2`</ph>.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The method is invoked to show that it uses the bound string.</source>
          <target state="translated">Die Methode wird aufgerufen, um anzuzeigen, dass die gebundene Zeichenfolge verwendet.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><bpt id="p1">**</bpt>Example 2<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Beispiel 2<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The following code example demonstrates compatibility of parameter types and return types.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, die Kompatibilität der Parametertypen und Rückgabetypen.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>This code example uses the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload.</source>
          <target state="translated">Dieses Codebeispiel verwendet die <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> -methodenüberladung.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The use of other overloads that take <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> is similar.</source>
          <target state="translated">Die Verwendung der anderen Überladungen dieser <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> ähnelt.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The code example defines a base class named <ph id="ph1">`Base`</ph> and a class named <ph id="ph2">`Derived`</ph> that derives from <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">Das Codebeispiel definiert eine Basisklasse, die mit dem Namen <ph id="ph1">`Base`</ph> und eine Klasse namens <ph id="ph2">`Derived`</ph> abgeleitet, die <ph id="ph3">`Base`</ph>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The derived class has a <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) method named <ph id="ph3">`MyMethod`</ph> with one parameter of type <ph id="ph4">`Base`</ph> and a return type of <ph id="ph5">`Derived`</ph>.</source>
          <target state="translated">Die abgeleitete Klasse verfügt über eine <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) Methode mit dem Namen <ph id="ph3">`MyMethod`</ph> mit einem Parameter vom Typ <ph id="ph4">`Base`</ph> und dem Rückgabetyp der <ph id="ph5">`Derived`</ph>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The code example also defines a delegate named <ph id="ph1">`Example`</ph> that has one parameter of type <ph id="ph2">`Derived`</ph> and a return type of <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">Das Codebeispiel definiert auch einen Delegaten mit dem Namen <ph id="ph1">`Example`</ph> , die einen Parameter des Typs hat <ph id="ph2">`Derived`</ph> und dem Rückgabetyp der <ph id="ph3">`Base`</ph>.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The code example demonstrates that the delegate named <ph id="ph1">`Example`</ph> can be used to represent the method <ph id="ph2">`MyMethod`</ph>.</source>
          <target state="translated">Im Codebeispiel wird veranschaulicht, dass der Delegat mit dem Namen <ph id="ph1">`Example`</ph> können verwendet werden, um die Methode darstellen <ph id="ph2">`MyMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The method can be bound to the delegate because:</source>
          <target state="translated">Die Methode kann an den Delegaten gebunden werden, da:</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The parameter type of the delegate (<ph id="ph1">`Derived`</ph>) is more restrictive than the parameter type of <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>), so that it is always safe to pass the argument of the delegate to <ph id="ph4">`MyMethod`</ph>.</source>
          <target state="translated">Der Parametertyp des Delegaten (<ph id="ph1">`Derived`</ph>) ist stärker eingeschränkt als der Parametertyp der <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>), sodass es immer sicher, das Argument des Delegaten zu übergeben sind <ph id="ph4">`MyMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The return type of <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) is more restrictive than the parameter type of the delegate (<ph id="ph3">`Base`</ph>), so that it is always safe to cast the return type of the method to the return type of the delegate.</source>
          <target state="translated">Der Rückgabetyp der <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) ist stärker eingeschränkt als der Parametertyp des Delegaten (<ph id="ph3">`Base`</ph>), sodass immer den Rückgabetyp der Methode in den Rückgabetyp des Delegaten umgewandelt werden kann.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The code example produces no output.</source>
          <target state="translated">Das Codebeispiel erzeugt keine Ausgabe.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><bpt id="p1">**</bpt>Example 3<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Beispiel 3<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The following code example shows all the methods a single delegate type can represent, using the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method to create the delegates.</source>
          <target state="translated">Das folgende Codebeispiel zeigt alle Methoden ein einzelner Delegattyp darstellen kann, mithilfe der <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> Methode, um den Delegaten zu erstellen.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>There are two overloads of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specify <ph id="ph2">`firstArgument`</ph> and a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</source>
          <target state="translated">Es gibt zwei Überladungen der <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> Methode, die angeben <ph id="ph2">`firstArgument`</ph> und ein <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; ihre Funktionalität ist identisch, außer dass Ihnen die ermöglicht Angabe, ob bei Bindungsfehlern ausgelöst, und die andere immer löst.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>This code example uses both overloads.</source>
          <target state="translated">Dieses Codebeispiel verwendet beide Überladungen.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The code example defines two classes, <ph id="ph1">`C`</ph> and <ph id="ph2">`F`</ph>, and a delegate type <ph id="ph3">`D`</ph> with one argument of type <ph id="ph4">`C`</ph>.</source>
          <target state="translated">Im Codebeispiel werden zwei Klassen definiert <ph id="ph1">`C`</ph> und <ph id="ph2">`F`</ph>, und ein Delegattyp <ph id="ph3">`D`</ph> mit einem Argument des Typs <ph id="ph4">`C`</ph>.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The classes have matching static and instance methods <ph id="ph1">`M1`</ph>, <ph id="ph2">`M3`</ph>, and <ph id="ph3">`M4`</ph>, and class <ph id="ph4">`C`</ph> also has an instance method <ph id="ph5">`M2`</ph> that has no arguments.</source>
          <target state="translated">Die Klassen übereinstimmende statische und Instanzmethoden <ph id="ph1">`M1`</ph>, <ph id="ph2">`M3`</ph>, und <ph id="ph3">`M4`</ph>, und die Klasse <ph id="ph4">`C`</ph> verfügt auch über eine Instanzmethode <ph id="ph5">`M2`</ph> , die keine Argumente verfügt.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A third class named <ph id="ph1">`Example`</ph> contains the code that creates the delegates.</source>
          <target state="translated">Eine dritte Klasse mit dem Namen <ph id="ph1">`Example`</ph> enthält den Code, der den Delegaten erstellt.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Delegates are created for instance method <ph id="ph1">`M1`</ph> of type <ph id="ph2">`C`</ph> and type <ph id="ph3">`F`</ph>; each is closed over an instance of the respective type.</source>
          <target state="translated">Delegaten werden erstellt, z. B. Methode <ph id="ph1">`M1`</ph> des Typs <ph id="ph2">`C`</ph> und Typ <ph id="ph3">`F`</ph>; jede über eine Instanz des entsprechenden Typs geschlossen wird.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Method <ph id="ph1">`M1`</ph> of type <ph id="ph2">`C`</ph> displays the <ph id="ph3">`ID`</ph> properties of the bound instance and of the argument.</source>
          <target state="translated">Methode <ph id="ph1">`M1`</ph> des Typs <ph id="ph2">`C`</ph> zeigt die <ph id="ph3">`ID`</ph> Eigenschaften der gebundenen Instanz und des Arguments.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>A delegate is created for method <ph id="ph1">`M2`</ph> of type <ph id="ph2">`C`</ph>.</source>
          <target state="translated">Ein Delegat wird für die Methode erstellt <ph id="ph1">`M2`</ph> vom Typ <ph id="ph2">`C`</ph>.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>This is an open instance delegate, in which the argument of the delegate represents the hidden first argument on the instance method.</source>
          <target state="translated">Dies ist eine offene Instanz Delegaten, in dem das Argument des Delegaten als ausgeblendete erste Argument in der Instanzmethode darstellt.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The method has no other arguments.</source>
          <target state="translated">Die Methode hat keine anderen Argumente.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>It is called as if it were a static method.</source>
          <target state="translated">Sie wird aufgerufen, als wäre er eine statische Methode.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Delegates are created for static method <ph id="ph1">`M3`</ph> of type <ph id="ph2">`C`</ph> and type <ph id="ph3">`F`</ph>; these are open static delegates.</source>
          <target state="translated">Delegaten werden für die statische Methode erstellt <ph id="ph1">`M3`</ph> des Typs <ph id="ph2">`C`</ph> und Typ <ph id="ph3">`F`</ph>; Hierbei handelt es sich um open statische Delegaten.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Finally, delegates are created for static method <ph id="ph1">`M4`</ph> of type <ph id="ph2">`C`</ph> and type <ph id="ph3">`F`</ph>; each method has the declaring type as its first argument, and an instance of the type is supplied, so the delegates are closed over their first arguments.</source>
          <target state="translated">Abschließend werden die Delegaten für die statische Methode erstellt <ph id="ph1">`M4`</ph> des Typs <ph id="ph2">`C`</ph> und Typ <ph id="ph3">`F`</ph>; jede Methode verfügt über den deklarierenden Typ als erstes Argument und eine Instanz des Typs angegeben werden, damit die Delegaten über ihre erste Argumente geschlossen werden .</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Method <ph id="ph1">`M4`</ph> of type <ph id="ph2">`C`</ph> displays the <ph id="ph3">`ID`</ph> properties of the bound instance and of the argument.</source>
          <target state="translated">Methode <ph id="ph1">`M4`</ph> des Typs <ph id="ph2">`C`</ph> zeigt die <ph id="ph3">`ID`</ph> Eigenschaften der gebundenen Instanz und des Arguments.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> erbt nicht <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist keine <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Siehe <bpt id="p1">[</bpt>Laufzeittypen in Reflektion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> kann nicht gebunden werden.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist keine <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Siehe <bpt id="p1">[</bpt>Laufzeittypen in Reflektion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">Die <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph>-Methode von <ph id="ph2">&lt;paramref name="type" /&gt;</ph> wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> des zu erstellenden Delegaten.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>The class instance on which <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> is invoked.</source>
          <target state="translated">Die Klasseninstanz, für die <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>The name of the instance method that the delegate is to represent.</source>
          <target state="translated">Der Name der Instanzenmethode, die durch den Delegaten dargestellt werden soll.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</source>
          <target state="translated">Erstellt einen Delegaten vom angegebenen Typ, der die angegebene Instanzenmethode darstellt, die für die angegebene Klasseninstanz aufgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</source>
          <target state="translated">Ein Delegat vom angegebenen Typ, der die angegebene Instanzenmethode darstellt, die für die angegebene Klasseninstanz aufgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>This method creates delegates for instance methods only.</source>
          <target state="translated">Diese Methode erstellt nur Delegaten für die Instanz.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">Eine Instanzmethode ist eine Methode, die eine Instanz einer Klasse zugeordnet ist. eine statische Methode ist eine Methode, die die Klasse selbst zugeordnet ist.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload, specifying <ph id="ph2">`false`</ph> for <ph id="ph3">`ignoreCase`</ph> and <ph id="ph4">`true`</ph> for <ph id="ph5">`throwOnBindFailure`</ph>.</source>
          <target state="translated">Diese methodenüberladung entspricht dem Aufrufen der <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> -methodenüberladung angeben <ph id="ph2">`false`</ph> für <ph id="ph3">`ignoreCase`</ph> und <ph id="ph4">`true`</ph> für <ph id="ph5">`throwOnBindFailure`</ph>.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Methode kann verwendet werden, auf nicht öffentliche Methoden zuzugreifen, wenn der Aufrufer erteilt wurde <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit dem <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> kennzeichnen und erteilen Sie der Berechtigungssatz für die nicht öffentlichen Methoden an des Aufrufers beschränkt ist Set- oder eine Teilmenge davon.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsüberlegungen für die Reflektion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein. </target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> erbt nicht <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist keine <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Siehe <bpt id="p1">[</bpt>Laufzeittypen in Reflektion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not an instance method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist keine Instanzenmethode.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, for example because it cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> kann nicht gebunden werden, z. B. weil sie nicht gefunden wurde.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">Die <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph>-Methode von <ph id="ph2">&lt;paramref name="type" /&gt;</ph> wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> des zu erstellenden Delegaten.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> describing the static or instance method the delegate is to represent.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, die die statische Methode oder Instanzmethode beschreibt, die der Delegat darstellen soll.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> cannot be bound; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, um eine Ausnahme auszulösen, wenn <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> nicht gebunden werden kann, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>Creates a delegate of the specified type to represent the specified static method, with the specified behavior on failure to bind.</source>
          <target state="translated">Erstellt einen Delegaten vom angegeben Typ zum Darstellen der angegebenen statischen Methode mit dem angegebenen Verhalten bei Bindungsfehlern.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of the specified type to represent the specified static method.</source>
          <target state="translated">Ein Delegat vom angegebenen Typ, der die angegebene statische Methode darstellen soll.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>This method overload can create open static method delegates and open instance method delegates — that is, delegates that expose the hidden first argument of instance methods.</source>
          <target state="translated">Diese methodenüberladung kann statische Öffnungsmethode Delegaten zu erstellen und öffnen Sie Instanz-Methode delegiert – d. h. der Instanzmethoden Delegaten, die das ausgeblendete erste Argument der verfügbar zu machen.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>For a detailed explanation, see the more general <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload, which allows you to create all combinations of open or closed delegates for instance or static methods.</source>
          <target state="translated">Eine ausführliche Erläuterung finden Sie unter die allgemeinere <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> methodenüberladung, die Ihnen ermöglicht, alle Kombinationen von offenen und geschlossenen Delegaten für die Instanz zu erstellen oder statische Methoden.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>This method overload should be used when the delegate is not closed over its first argument, because it is somewhat faster in that case.</source>
          <target state="translated">Diese methodenüberladung sollte verwendet werden, wenn der Delegat nicht über dem ersten Argument geschlossen wird, da in diesem Fall etwas schneller ist.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Methode kann verwendet werden, auf nicht öffentliche Methoden zuzugreifen, wenn der Aufrufer erteilt wurde <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit dem <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> kennzeichnen und erteilen Sie der Berechtigungssatz für die nicht öffentlichen Methoden an des Aufrufers beschränkt ist Set- oder eine Teilmenge davon.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsüberlegungen für die Reflektion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein. </target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>Compatible Parameter Types and Return Type</source>
          <target state="translated">Kompatible Parametertypen und den Rückgabetyp</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</source>
          <target state="translated">Die Parametertypen und den Rückgabetyp eines Delegaten müssen mit den Parametertypen und den Rückgabetyp der Methode, die der Delegat darstellt kompatibel sein. die Typen müssen nicht exakt übereinstimmen.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>In the .NET Framework version 1.0 and 1.1, the types must match exactly.</source>
          <target state="translated">In .NET Framework, Version 1.0 und 1.1 müssen die Typen genau übereinstimmen.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</source>
          <target state="translated">Ein Parameter eines Delegaten ist mit dem entsprechenden Parameter einer Methode kompatibel, wenn der Typ des Delegatenparameters restriktiver ist als der Methodenparameter, da so gewährleistet ist, dass ein an den Delegaten übergebenes Argument problemlos an die Methode weitergeleitet werden kann.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</source>
          <target state="translated">Ebenso ist der Rückgabetyp eines Delegaten kompatibel mit dem Rückgabetyp einer Methode, wenn der Rückgabetyp der Methode restriktiver ist als der Rückgabetyp des Delegaten, da so gewährleistet ist, dass der Rückgabewert der Methode problemlos in den Rückgabetyp des Delegaten umgewandelt werden kann.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>For example, a delegate with a parameter of type <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> and a return type of <ph id="ph2">&lt;xref:System.Object&gt;</ph> can represent a method with a parameter of type <ph id="ph3">&lt;xref:System.Object&gt;</ph> and a return value of type <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Angenommen, ein Delegat mit einem Parameter vom Typ <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> und dem Rückgabetyp des <ph id="ph2">&lt;xref:System.Object&gt;</ph> kann eine Methode mit einem Parameter vom Typ darstellen <ph id="ph3">&lt;xref:System.Object&gt;</ph> sowie einen Rückgabewert vom Typ <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>This section contains two code examples.</source>
          <target state="translated">Dieser Abschnitt enthält zwei Codebeispiele.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The first example demonstrates the two kinds of delegates that can be created with this method overload: open over an instance method and open over a static method.</source>
          <target state="translated">Das erste Beispiel veranschaulicht die zwei Arten von Delegaten, die Überladung dieser Methode erstellt werden können: Öffnen Sie über eine Instanzmethode und über eine statische Methode.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The second code example demonstrates compatible parameter types and return types.</source>
          <target state="translated">Im zweiten Codebeispiel wird veranschaulicht, kompatible Parametertypen und Rückgabetypen.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><bpt id="p1">**</bpt>Example 1<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Beispiel 1<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The following code example demonstrates the two ways a delegate can be created using this overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, die zwei Möglichkeiten, ein Delegaten erstellt werden kann, verwenden diese Überladung von, der <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>There are two overloads of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specify a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> but not a first argument; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</source>
          <target state="translated">Es gibt zwei Überladungen der der <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> Methode, die angeben, ein <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> jedoch kein erstes Argument; ihre Funktionalität ist identisch, außer dass Ihnen die ermöglicht Angabe, ob bei Bindungsfehlern ausgelöst, und die andere immer löst.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>This code example uses both overloads.</source>
          <target state="translated">Dieses Codebeispiel verwendet beide Überladungen.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The example declares a class <ph id="ph1">`C`</ph> with a static method <ph id="ph2">`M2`</ph> and an instance method <ph id="ph3">`M1`</ph>, and two delegate types: <ph id="ph4">`D1`</ph> takes an instance of <ph id="ph5">`C`</ph> and a string, and <ph id="ph6">`D2`</ph> takes a string.</source>
          <target state="translated">Im Beispiel wird eine Klasse deklariert <ph id="ph1">`C`</ph> mit einer statischen Methode <ph id="ph2">`M2`</ph> und eine Instanzenmethode <ph id="ph3">`M1`</ph>, und zwei Delegattypen: <ph id="ph4">`D1`</ph> akzeptiert eine Instanz von <ph id="ph5">`C`</ph> und eine Zeichenfolge, und <ph id="ph6">`D2`</ph> nimmt eine Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>A second class named <ph id="ph1">`Example`</ph> contains the code that creates the delegates.</source>
          <target state="translated">Eine zweite Klasse <ph id="ph1">`Example`</ph> enthält den Code, der den Delegaten erstellt.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of type <ph id="ph1">`D1`</ph>, representing an open instance method, is created for the instance method <ph id="ph2">`M1`</ph>.</source>
          <target state="translated">Ein Delegat des Typs <ph id="ph1">`D1`</ph>, der eine offene Instanzmethode darstellt, wird für die Instanzmethode erstellt <ph id="ph2">`M1`</ph>.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>An instance must be passed when the delegate is invoked.</source>
          <target state="translated">Eine Instanz muss übergeben werden, wenn der Delegat aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of type <ph id="ph1">`D2`</ph>, representing an open static method, is created for the static method <ph id="ph2">`M2`</ph>.</source>
          <target state="translated">Ein Delegat des Typs <ph id="ph1">`D2`</ph>, eine offene statische Methode darstellt, wird für die statische Methode erstellt <ph id="ph2">`M2`</ph>.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><bpt id="p1">**</bpt>Example 2<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Beispiel 2<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The following code example demonstrates compatibility of parameter types and return types.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, die Kompatibilität der Parametertypen und Rückgabetypen.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>This code example uses the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload.</source>
          <target state="translated">Dieses Codebeispiel verwendet die <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> -methodenüberladung.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The use of other overloads that take <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> is similar.</source>
          <target state="translated">Die Verwendung der anderen Überladungen dieser <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> ähnelt.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example defines a base class named <ph id="ph1">`Base`</ph> and a class named <ph id="ph2">`Derived`</ph> that derives from <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">Das Codebeispiel definiert eine Basisklasse, die mit dem Namen <ph id="ph1">`Base`</ph> und eine Klasse namens <ph id="ph2">`Derived`</ph> abgeleitet, die <ph id="ph3">`Base`</ph>.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The derived class has a <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) method named <ph id="ph3">`MyMethod`</ph> with one parameter of type <ph id="ph4">`Base`</ph> and a return type of <ph id="ph5">`Derived`</ph>.</source>
          <target state="translated">Die abgeleitete Klasse verfügt über eine <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) Methode mit dem Namen <ph id="ph3">`MyMethod`</ph> mit einem Parameter vom Typ <ph id="ph4">`Base`</ph> und dem Rückgabetyp der <ph id="ph5">`Derived`</ph>.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example also defines a delegate named <ph id="ph1">`Example`</ph> that has one parameter of type <ph id="ph2">`Derived`</ph> and a return type of <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">Das Codebeispiel definiert auch einen Delegaten mit dem Namen <ph id="ph1">`Example`</ph> , die einen Parameter des Typs hat <ph id="ph2">`Derived`</ph> und dem Rückgabetyp der <ph id="ph3">`Base`</ph>.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example demonstrates that the delegate named <ph id="ph1">`Example`</ph> can be used to represent the method <ph id="ph2">`MyMethod`</ph>.</source>
          <target state="translated">Im Codebeispiel wird veranschaulicht, dass der Delegat mit dem Namen <ph id="ph1">`Example`</ph> können verwendet werden, um die Methode darstellen <ph id="ph2">`MyMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The method can be bound to the delegate because:</source>
          <target state="translated">Die Methode kann an den Delegaten gebunden werden, da:</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The parameter type of the delegate (<ph id="ph1">`Derived`</ph>) is more restrictive than the parameter type of <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>), so that it is always safe to pass the argument of the delegate to <ph id="ph4">`MyMethod`</ph>.</source>
          <target state="translated">Der Parametertyp des Delegaten (<ph id="ph1">`Derived`</ph>) ist stärker eingeschränkt als der Parametertyp der <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>), sodass es immer sicher, das Argument des Delegaten zu übergeben sind <ph id="ph4">`MyMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The return type of <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) is more restrictive than the parameter type of the delegate (<ph id="ph3">`Base`</ph>), so that it is always safe to cast the return type of the method to the return type of the delegate.</source>
          <target state="translated">Der Rückgabetyp der <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) ist stärker eingeschränkt als der Parametertyp des Delegaten (<ph id="ph3">`Base`</ph>), sodass immer den Rückgabetyp der Methode in den Rückgabetyp des Delegaten umgewandelt werden kann.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example produces no output.</source>
          <target state="translated">Das Codebeispiel erzeugt keine Ausgabe.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> erbt nicht <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist keine <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Siehe <bpt id="p1">[</bpt>Laufzeittypen in Reflektion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, and <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> kann nicht gebunden werden, und <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> ist <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist keine <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Siehe <bpt id="p1">[</bpt>Laufzeittypen in Reflektion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">Die <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph>-Methode von <ph id="ph2">&lt;paramref name="type" /&gt;</ph> wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> des zu erstellenden Delegaten.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the class that implements <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, der die Klasse darstellt, die <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> implementiert.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>The name of the static method that the delegate is to represent.</source>
          <target state="translated">Der Name der statischen Methode, die durch den Delegaten dargestellt werden soll.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>Creates a delegate of the specified type that represents the specified static method of the specified class.</source>
          <target state="translated">Erstellt einen Delegaten vom angegebenen Typ, der die angegebene statische Methode der angegebenen Klasse darstellt.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>A delegate of the specified type that represents the specified static method of the specified class.</source>
          <target state="translated">Ein Delegat vom angegebenen Typ, der die angegebene statische Methode der angegebenen Klasse darstellt.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>This method creates delegates for static methods only.</source>
          <target state="translated">Diese Methode erstellt Delegate für nur statische Methoden.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">Eine Instanzmethode ist eine Methode, die eine Instanz einer Klasse zugeordnet ist. eine statische Methode ist eine Methode, die die Klasse selbst zugeordnet ist.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload, specifying <ph id="ph2">`false`</ph> for <ph id="ph3">`ignoreCase`</ph> and <ph id="ph4">`true`</ph> for <ph id="ph5">`throwOnBindFailure`</ph>.</source>
          <target state="translated">Diese methodenüberladung entspricht dem Aufrufen der <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> -methodenüberladung angeben <ph id="ph2">`false`</ph> für <ph id="ph3">`ignoreCase`</ph> und <ph id="ph4">`true`</ph> für <ph id="ph5">`throwOnBindFailure`</ph>.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Methode kann verwendet werden, auf nicht öffentliche Methoden zuzugreifen, wenn der Aufrufer erteilt wurde <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit dem <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> kennzeichnen und erteilen Sie der Berechtigungssatz für die nicht öffentlichen Methoden an des Aufrufers beschränkt ist Set- oder eine Teilmenge davon.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsüberlegungen für die Reflektion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein. </target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> erbt nicht <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist keine <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Siehe <bpt id="p1">[</bpt>Laufzeittypen in Reflektion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> ist keine <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> ist ein offener generischer Typ.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>That is, its <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Das bedeutet, die <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph>-Eigenschaft ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="static" /&gt;</ph> method (<ph id="ph3">&lt;see langword="Shared" /&gt;</ph> method in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist keine <ph id="ph2">&lt;see langword="static" /&gt;</ph>-Methode (<ph id="ph3">&lt;see langword="Shared" /&gt;</ph>-Methode in Visual Basic).</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, for example because it cannot be found, and <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> kann nicht gebunden werden, z. B. weil sie nicht gefunden wurde, und <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> ist gleich <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">Die <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph>-Methode von <ph id="ph2">&lt;paramref name="type" /&gt;</ph> wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the type of delegate to create.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, der den Typ des zu erstellenden Delegaten darstellt.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> that is the first argument of the method the delegate represents.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>, das das erste Argument der Methode ist, die der Delegat darstellt.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>For instance methods, it must be compatible with the instance type.</source>
          <target state="translated">Bei Instanzmethoden muss dieses mit dem Instanztyp kompatibel sein.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> describing the static or instance method the delegate is to represent.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, die die statische Methode oder Instanzmethode beschreibt, die der Delegat darstellen soll.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> cannot be bound; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, um eine Ausnahme auszulösen, wenn <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> nicht gebunden werden kann, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument and the specified behavior on failure to bind.</source>
          <target state="translated">Erstellt einen Delegaten vom angegebenen Typ, der die angegebene statische Methode oder Instanzmethode mit dem angegebenen ersten Argument und dem angegebenen Verhalten bei Bindungsfehlern darstellt.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of the specified type that represents the specified static or instance method, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> is <ph id="ph3">&lt;see langword="false" /&gt;</ph> and the delegate cannot be bound to <ph id="ph4">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">Ein Delegat des angegebenen Typs, der die angegebene statische Methode oder Instanzmethode darstellt, oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> <ph id="ph3">&lt;see langword="false" /&gt;</ph> ist und der Delegat nicht an <ph id="ph4">&lt;paramref name="method" /&gt;</ph> gebunden werden kann.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This method overload and the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload, which always throws on failure to bind, provide the most flexible way to create delegates.</source>
          <target state="translated">Diese methodenüberladung und die <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29&gt;</ph> methodenüberladung, die immer bei Bindungsfehlern auslöst, geben Sie die flexibelste Möglichkeit zum Erstellen von Delegaten.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>You can use them to create delegates for either static or instance methods, with or without a first argument.</source>
          <target state="translated">Sie können zum Erstellen von Delegaten für statische oder Instanzmethoden, mit oder ohne ein erstes Argument.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If you do not supply a first argument, use the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload for better performance.</source>
          <target state="translated">Wenn Sie ein erstes Argument nicht angeben, verwenden Sie die <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> methodenüberladung für eine bessere Leistung.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The delegate type and the method must have compatible return types.</source>
          <target state="translated">Der Delegattyp und die Methode müssen kompatibel Rückgabetypen aufweisen.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>That is, the return type of <ph id="ph1">`method`</ph> must be assignable to the return type of <ph id="ph2">`type`</ph>.</source>
          <target state="translated">D. h., der Rückgabetyp der <ph id="ph1">`method`</ph> muss der Rückgabetyp der zugewiesen werden <ph id="ph2">`type`</ph>.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If <ph id="ph1">`firstArgument`</ph> is supplied, it is passed to <ph id="ph2">`method`</ph> every time the delegate is invoked; <ph id="ph3">`firstArgument`</ph> is said to be bound to the delegate, and the delegate is said to be closed over its first argument.</source>
          <target state="translated">Wenn <ph id="ph1">`firstArgument`</ph> wird angegeben, erfolgt eine Übergabe an <ph id="ph2">`method`</ph> jedes Mal, wenn der Delegat aufgerufen wird. <ph id="ph3">`firstArgument`</ph> gilt als an den Delegaten gebunden werden und der Delegat wird als über das erste Argument geschlossen werden.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If <ph id="ph1">`method`</ph> is <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic), the argument list supplied when invoking the delegate includes all parameters except the first; if <ph id="ph4">`method`</ph> is an instance method, then <ph id="ph5">`firstArgument`</ph> is passed to the hidden instance parameter (represented by <ph id="ph6">`this`</ph> in C#, or by <ph id="ph7">`Me`</ph> in Visual Basic).</source>
          <target state="translated">Wenn <ph id="ph1">`method`</ph> ist <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic), wird das Argument beim Aufrufen des Delegaten bereitgestellte Liste enthält alle Parameter außer der ersten; Wenn <ph id="ph4">`method`</ph> eine Instanzmethode ist, dann ist <ph id="ph5">`firstArgument`</ph> an der ausgeblendeten Instanz übergeben wird Parameter (dargestellt durch <ph id="ph6">`this`</ph> in c# oder durch <ph id="ph7">`Me`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If <ph id="ph1">`firstArgument`</ph> is supplied, the first parameter of <ph id="ph2">`method`</ph> must be a reference type, and <ph id="ph3">`firstArgument`</ph> must be compatible with that type.</source>
          <target state="translated">Wenn <ph id="ph1">`firstArgument`</ph> angegeben wird, der erste Parameter der <ph id="ph2">`method`</ph> muss ein Verweistyp sein und <ph id="ph3">`firstArgument`</ph> muss mit diesem Typ kompatibel sein.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If <ph id="ph1">`method`</ph> is <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) and its first parameter is of type <ph id="ph4">&lt;xref:System.Object&gt;</ph> or <ph id="ph5">&lt;xref:System.ValueType&gt;</ph>, then <ph id="ph6">`firstArgument`</ph> can be a value type.</source>
          <target state="translated">Wenn <ph id="ph1">`method`</ph> ist <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) und der erste Parameter ist vom Typ <ph id="ph4">&lt;xref:System.Object&gt;</ph> oder <ph id="ph5">&lt;xref:System.ValueType&gt;</ph>, klicken Sie dann <ph id="ph6">`firstArgument`</ph> kann ein Werttyp sein.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>In this case <ph id="ph1">`firstArgument`</ph> is automatically boxed.</source>
          <target state="translated">In diesem Fall <ph id="ph1">`firstArgument`</ph> automatisch mittels Boxing konvertiert.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Automatic boxing does not occur for any other arguments, as it would in a C# or Visual Basic function call.</source>
          <target state="translated">Automatische Boxing erfolgt für alle anderen Argumente nicht, wie es in einem C#- oder Visual Basic-Funktion aufrufen.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If <ph id="ph1">`firstArgument`</ph> is a null reference and <ph id="ph2">`method`</ph> is an instance method, the result depends on the signatures of the delegate type <ph id="ph3">`type`</ph> and of <ph id="ph4">`method`</ph>:</source>
          <target state="translated">Wenn <ph id="ph1">`firstArgument`</ph> ist ein null-Verweis und <ph id="ph2">`method`</ph> eine Instanzmethode ist, ist das Ergebnis hängt von den Signaturen des Delegattyps <ph id="ph3">`type`</ph> und <ph id="ph4">`method`</ph>:</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If the signature of <ph id="ph1">`type`</ph> explicitly includes the hidden first parameter of <ph id="ph2">`method`</ph>, the delegate is said to represent an open instance method.</source>
          <target state="translated">Wenn die Signatur der <ph id="ph1">`type`</ph> explizit schließt ausgeblendete ersten Parameters der <ph id="ph2">`method`</ph>, Delegaten gesagt, dass eine offene Instanzmethode darstellt.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>When the delegate is invoked, the first argument in the argument list is passed to the hidden instance parameter of <ph id="ph1">`method`</ph>.</source>
          <target state="translated">Wenn der Delegat aufgerufen wird, wird das erste Argument in der Argumentliste übergeben, auf den ausgeblendeten Instanzparameter <ph id="ph1">`method`</ph>.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If the signatures of <ph id="ph1">`method`</ph> and <ph id="ph2">`type`</ph> match (that is, all parameter types are compatible), then the delegate is said to be closed over a null reference.</source>
          <target state="translated">Wenn die Signaturen der <ph id="ph1">`method`</ph> und <ph id="ph2">`type`</ph> entsprechen (d. h., alle Parametertypen sind kompatibel), und klicken Sie dann der Delegaten gesagt, dass er über ein null-Verweis geschlossen werden.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Invoking the delegate is like calling an instance method on a null instance, which is not a particularly useful thing to do.</source>
          <target state="translated">Aufrufen des Delegaten entspricht dem Aufrufen einer Instanzmethode auf eine null-Instanz, die eine besonders nützlich, wenn man nicht ist.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If <ph id="ph1">`firstArgument`</ph> is a null reference and <ph id="ph2">`method`</ph> is static, the result depends on the signatures of the delegate type <ph id="ph3">`type`</ph> and of <ph id="ph4">`method`</ph>:</source>
          <target state="translated">Wenn <ph id="ph1">`firstArgument`</ph> ist ein null-Verweis und <ph id="ph2">`method`</ph> ist statisch, das Ergebnis hängt von den Signaturen des Delegattyps <ph id="ph3">`type`</ph> und <ph id="ph4">`method`</ph>:</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If the signature of <ph id="ph1">`method`</ph> and <ph id="ph2">`type`</ph> match (that is, all parameter types are compatible), the delegate is said to represent an open static method.</source>
          <target state="translated">Wenn die Signatur der <ph id="ph1">`method`</ph> und <ph id="ph2">`type`</ph> entsprechen (d. h., alle Parametertypen sind kompatibel), der Delegat wird als eine offene statische Methode darstellen.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This is the most common case for static methods.</source>
          <target state="translated">Dies ist der häufigste Fall für statische Methoden.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>In this case, you can get slightly better performance by using the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> method overload.</source>
          <target state="translated">In diesem Fall erhalten Sie eine etwas bessere Leistung mithilfe der <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29&gt;</ph> -methodenüberladung.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>If the signature of <ph id="ph1">`type`</ph> begins with the second parameter of <ph id="ph2">`method`</ph> and the rest of the parameter types are compatible, then the delegate is said to be closed over a null reference.</source>
          <target state="translated">Wenn die Signatur der <ph id="ph1">`type`</ph> beginnt mit der zweite Parameter der <ph id="ph2">`method`</ph> der Rest der Parametertypen kompatibel sind, und der Delegat wird als über ein null-Verweis geschlossen werden.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>When the delegate is invoked, a null reference is passed to the first parameter of <ph id="ph1">`method`</ph>.</source>
          <target state="translated">Wenn der Delegat aufgerufen wird, wird ein null-Verweis auf den ersten Parameter übergeben <ph id="ph1">`method`</ph>.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Methode kann verwendet werden, auf nicht öffentliche Methoden zuzugreifen, wenn der Aufrufer erteilt wurde <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit dem <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> kennzeichnen und erteilen Sie der Berechtigungssatz für die nicht öffentlichen Methoden an des Aufrufers beschränkt ist Set- oder eine Teilmenge davon.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsüberlegungen für die Reflektion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein. </target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Compatible Parameter Types and Return Type</source>
          <target state="translated">Kompatible Parametertypen und den Rückgabetyp</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</source>
          <target state="translated">Die Parametertypen und den Rückgabetyp eines Delegaten müssen mit den Parametertypen und den Rückgabetyp der Methode, die der Delegat darstellt kompatibel sein. die Typen müssen nicht exakt übereinstimmen.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>In the .NET Framework version 1.0 and 1.1 the types must match exactly.</source>
          <target state="translated">In .NET Framework, Version 1.0 und 1.1 müssen die Typen genau entsprechen.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</source>
          <target state="translated">Ein Parameter eines Delegaten ist mit dem entsprechenden Parameter einer Methode kompatibel, wenn der Typ des Delegatenparameters restriktiver ist als der Methodenparameter, da so gewährleistet ist, dass ein an den Delegaten übergebenes Argument problemlos an die Methode weitergeleitet werden kann.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</source>
          <target state="translated">Ebenso ist der Rückgabetyp eines Delegaten kompatibel mit dem Rückgabetyp einer Methode, wenn der Rückgabetyp der Methode restriktiver ist als der Rückgabetyp des Delegaten, da so gewährleistet ist, dass der Rückgabewert der Methode problemlos in den Rückgabetyp des Delegaten umgewandelt werden kann.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>For example, a delegate with a parameter of type <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> and a return type of <ph id="ph2">&lt;xref:System.Object&gt;</ph> can represent a method with a parameter of type <ph id="ph3">&lt;xref:System.Object&gt;</ph> and a return value of type <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</source>
          <target state="translated">Angenommen, ein Delegat mit einem Parameter vom Typ <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph> und dem Rückgabetyp des <ph id="ph2">&lt;xref:System.Object&gt;</ph> kann eine Methode mit einem Parameter vom Typ darstellen <ph id="ph3">&lt;xref:System.Object&gt;</ph> sowie einen Rückgabewert vom Typ <ph id="ph4">&lt;xref:System.Collections.Hashtable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Determining the Methods a Delegate Can Represent</source>
          <target state="translated">Bestimmen die Methoden kann ein Delegat darstellen.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Another useful way to think of the flexibility provided by this overload of <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is that any given delegate can represent four different combinations of method signature and method kind (static versus instance).</source>
          <target state="translated">Eine andere hilfreiche Möglichkeit, um die Flexibilität, die von dieser Überladung von vorstellen <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> darin, dass jeder angegebene Delegat vier verschiedene Kombinationen der Methodensignatur und die Methodenart (statisch oder Instanz) darstellen kann.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Consider a delegate type <ph id="ph1">`D`</ph> with one argument of type <ph id="ph2">`C`</ph>.</source>
          <target state="translated">Betrachten Sie einen Delegattyp <ph id="ph1">`D`</ph> mit einem Argument des Typs <ph id="ph2">`C`</ph>.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The following describes the methods <ph id="ph1">`D`</ph> can represent, ignoring the return type since it must match in all cases:</source>
          <target state="translated">Im folgenden werden die Methoden beschrieben <ph id="ph1">`D`</ph> darstellen kann, wird den Rückgabetyp wird ignoriert, da es in allen Fällen entsprechen muss:</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">`D`</ph> can represent any instance method that has exactly one argument of type <ph id="ph2">`C`</ph>, regardless of what type the instance method belongs to.</source>
          <target state="translated"><ph id="ph1">`D`</ph> kann Instanzmethode mit genau ein Argument des Typs darstellen <ph id="ph2">`C`</ph>, unabhängig davon, welchen Typ die Instanzmethode angehört.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is an instance of the type <ph id="ph3">`method`</ph> belongs to, and the resulting delegate is said to be closed over that instance.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> aufgerufen wird, <ph id="ph2">`firstArgument`</ph> ist eine Instanz des Typs <ph id="ph3">`method`</ph> gehört, und der resultierende Delegat herrscht die verbreitete über diese Instanz geschlossen werden.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>(Trivially, <ph id="ph1">`D`</ph> can also be closed over a null reference if <ph id="ph2">`firstArgument`</ph> is <ph id="ph3">`null`</ph>.)</source>
          <target state="translated">(Trivial, <ph id="ph1">`D`</ph> kann auch über ein null-Verweis geschlossen werden, wenn <ph id="ph2">`firstArgument`</ph> ist <ph id="ph3">`null`</ph>.)</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">`D`</ph> can represent an instance method of <ph id="ph2">`C`</ph> that has no arguments.</source>
          <target state="translated"><ph id="ph1">`D`</ph> kann eine Instanzmethode darstellen <ph id="ph2">`C`</ph> , die keine Argumente verfügt.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is a null reference.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> aufgerufen wird, <ph id="ph2">`firstArgument`</ph> ist ein null-Verweis.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The resulting delegate represents an open instance method, and an instance of <ph id="ph1">`C`</ph> must be supplied each time it is invoked.</source>
          <target state="translated">Der resultierende Delegat stellt eine offene Instanz-Methode und einer Instanz von <ph id="ph1">`C`</ph> muss angegeben werden, bei jedem Aufruf erfolgte.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">`D`</ph> can represent a static method that takes one argument of type <ph id="ph2">`C`</ph>, and that method can belong to any type.</source>
          <target state="translated"><ph id="ph1">`D`</ph> eine statische Methode, die ein Argument des Typs darstellen kann <ph id="ph2">`C`</ph>, und dass die Methode auf einen beliebigen Typ angehören kann.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is a null reference.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> aufgerufen wird, <ph id="ph2">`firstArgument`</ph> ist ein null-Verweis.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The resulting delegate represents an open static method, and an instance of <ph id="ph1">`C`</ph> must be supplied each time it is invoked.</source>
          <target state="translated">Der resultierende Delegat stellt eine offene statische Methode und einer Instanz von <ph id="ph1">`C`</ph> muss angegeben werden, bei jedem Aufruf erfolgte.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">`D`</ph> can represent a static method that belongs to type <ph id="ph2">`F`</ph> and has two arguments, of type <ph id="ph3">`F`</ph> and type <ph id="ph4">`C`</ph>.</source>
          <target state="translated"><ph id="ph1">`D`</ph> kann eine statische Methode, die zum Typ gehört darstellen <ph id="ph2">`F`</ph> und verfügt über zwei Argumente, des Typs <ph id="ph3">`F`</ph> und Typ <ph id="ph4">`C`</ph>.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>When <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> is called, <ph id="ph2">`firstArgument`</ph> is an instance of <ph id="ph3">`F`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> aufgerufen wird, <ph id="ph2">`firstArgument`</ph> ist eine Instanz der <ph id="ph3">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The resulting delegate represents a static method that is closed over that instance of <ph id="ph1">`F`</ph>.</source>
          <target state="translated">Der resultierende Delegat stellt eine statische Methode, die über diese Instanz geschlossen wird <ph id="ph1">`F`</ph>.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Note that in the case where <ph id="ph1">`F`</ph> and <ph id="ph2">`C`</ph> are the same type, the static method has two arguments of that type.</source>
          <target state="translated">Beachten Sie, dass im Fall, in dem <ph id="ph1">`F`</ph> und <ph id="ph2">`C`</ph> denselben Typ aufweisen, der die statische Methode verfügt über zwei Argumente des Typs.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>(In this case, <ph id="ph1">`D`</ph> is closed over a null reference if <ph id="ph2">`firstArgument`</ph> is <ph id="ph3">`null`</ph>.)</source>
          <target state="translated">(In diesem Fall <ph id="ph1">`D`</ph> ist über ein null-Verweis geschlossen, wenn <ph id="ph2">`firstArgument`</ph> ist <ph id="ph3">`null`</ph>.)</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This section contains three code examples.</source>
          <target state="translated">Dieser Abschnitt enthält drei Codebeispiele.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The first example demonstrates the four kinds of delegates that can be created: closed over an instance method, open over an instance method, open over a static method, and closed over a static method.</source>
          <target state="translated">Das erste Beispiel veranschaulicht die vier Arten von Delegaten, die erstellt werden können: über eine Instanzmethode ist, öffnen Sie über eine Instanzmethode ist, öffnen Sie über eine statische Methode geschlossen und über eine statische Methode geschlossen.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The second code example demonstrates compatible parameter types and return types.</source>
          <target state="translated">Im zweiten Codebeispiel wird veranschaulicht, kompatible Parametertypen und Rückgabetypen.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The third code example defines a single delegate type, and shows all the methods that delegate type can represent.</source>
          <target state="translated">Das dritte Codebeispiel definiert einen einzelne Delegattyp und zeigt, dass alle Methoden, die Delegattyp darstellen können.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><bpt id="p1">**</bpt>Example 1<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Beispiel 1<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The following code example demonstrates the four ways a delegate can be created using this overload of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, der ein Delegaten erstellt werden kann, verwenden diese Überladung von vier Arten der <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>There are two overloads of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specify <ph id="ph2">`firstArgument`</ph> and a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</source>
          <target state="translated">Es gibt zwei Überladungen der <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> Methode, die angeben <ph id="ph2">`firstArgument`</ph> und ein <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; ihre Funktionalität ist identisch, außer dass Ihnen die ermöglicht Angabe, ob bei Bindungsfehlern ausgelöst, und die andere immer löst.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This code example uses both overloads.</source>
          <target state="translated">Dieses Codebeispiel verwendet beide Überladungen.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The example declares a class <ph id="ph1">`C`</ph> with a static method <ph id="ph2">`M2`</ph> and an instance method <ph id="ph3">`M1`</ph>, and three delegate types: <ph id="ph4">`D1`</ph> takes an instance of <ph id="ph5">`C`</ph> and a string, <ph id="ph6">`D2`</ph> takes a string, and <ph id="ph7">`D3`</ph> has no arguments.</source>
          <target state="translated">Im Beispiel wird eine Klasse deklariert <ph id="ph1">`C`</ph> mit einer statischen Methode <ph id="ph2">`M2`</ph> und eine Instanzenmethode <ph id="ph3">`M1`</ph>, sowie drei Delegattypen: <ph id="ph4">`D1`</ph> akzeptiert eine Instanz von <ph id="ph5">`C`</ph> und eine Zeichenfolge, <ph id="ph6">`D2`</ph> akzeptiert eine Zeichenfolge und <ph id="ph7">`D3`</ph>besitzt keine Argumente.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A second class named <ph id="ph1">`Example`</ph> contains the code that creates the delegates.</source>
          <target state="translated">Eine zweite Klasse <ph id="ph1">`Example`</ph> enthält den Code, der den Delegaten erstellt.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of type <ph id="ph1">`D2`</ph>, closed over an instance of <ph id="ph2">`C`</ph>, is created for the instance method <ph id="ph3">`M1`</ph>.</source>
          <target state="translated">Ein Delegat des Typs <ph id="ph1">`D2`</ph>, über eine Instanz des geschlossenen <ph id="ph2">`C`</ph>, wird für die Instanzmethode erstellt <ph id="ph3">`M1`</ph>.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>It is invoked with different strings, to show that the bound instance of <ph id="ph1">`C`</ph> is always used.</source>
          <target state="translated">Wird aufgerufen, mit anderen Zeichenfolgen, um anzugeben, dass die gebundene Instanz von <ph id="ph1">`C`</ph> wird immer verwendet.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of type <ph id="ph1">`D1`</ph>, representing an open instance method, is created for the instance method <ph id="ph2">`M1`</ph>.</source>
          <target state="translated">Ein Delegat des Typs <ph id="ph1">`D1`</ph>, der eine offene Instanzmethode darstellt, wird für die Instanzmethode erstellt <ph id="ph2">`M1`</ph>.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>An instance must be passed when the delegate is invoked.</source>
          <target state="translated">Eine Instanz muss übergeben werden, wenn der Delegat aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate of type <ph id="ph1">`D2`</ph>, representing an open static method, is created for the static method <ph id="ph2">`M2`</ph>.</source>
          <target state="translated">Ein Delegat des Typs <ph id="ph1">`D2`</ph>, eine offene statische Methode darstellt, wird für die statische Methode erstellt <ph id="ph2">`M2`</ph>.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Finally, a delegate of type <ph id="ph1">`D3`</ph>, closed over a string, is created for the static method <ph id="ph2">`M2`</ph>.</source>
          <target state="translated">Schließlich, einen Delegaten vom Typ <ph id="ph1">`D3`</ph>, über eine Zeichenfolge geschlossen, wird für die statische Methode erstellt <ph id="ph2">`M2`</ph>.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The method is invoked to show that it uses the bound string.</source>
          <target state="translated">Die Methode wird aufgerufen, um anzuzeigen, dass die gebundene Zeichenfolge verwendet.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><bpt id="p1">**</bpt>Example 2<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Beispiel 2<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The following code example demonstrates compatibility of parameter types and return types.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, die Kompatibilität der Parametertypen und Rückgabetypen.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This code example uses the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> method overload.</source>
          <target state="translated">Dieses Codebeispiel verwendet die <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph> -methodenüberladung.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The use of other overloads that take <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> is similar.</source>
          <target state="translated">Die Verwendung der anderen Überladungen dieser <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> ähnelt.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example defines a base class named <ph id="ph1">`Base`</ph> and a class named <ph id="ph2">`Derived`</ph> that derives from <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">Das Codebeispiel definiert eine Basisklasse, die mit dem Namen <ph id="ph1">`Base`</ph> und eine Klasse namens <ph id="ph2">`Derived`</ph> abgeleitet, die <ph id="ph3">`Base`</ph>.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The derived class has a <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) method named <ph id="ph3">`MyMethod`</ph> with one parameter of type <ph id="ph4">`Base`</ph> and a return type of <ph id="ph5">`Derived`</ph>.</source>
          <target state="translated">Die abgeleitete Klasse verfügt über eine <ph id="ph1">`static`</ph> (<ph id="ph2">`Shared`</ph> in Visual Basic) Methode mit dem Namen <ph id="ph3">`MyMethod`</ph> mit einem Parameter vom Typ <ph id="ph4">`Base`</ph> und dem Rückgabetyp der <ph id="ph5">`Derived`</ph>.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example also defines a delegate named <ph id="ph1">`Example`</ph> that has one parameter of type <ph id="ph2">`Derived`</ph> and a return type of <ph id="ph3">`Base`</ph>.</source>
          <target state="translated">Das Codebeispiel definiert auch einen Delegaten mit dem Namen <ph id="ph1">`Example`</ph> , die einen Parameter des Typs hat <ph id="ph2">`Derived`</ph> und dem Rückgabetyp der <ph id="ph3">`Base`</ph>.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example demonstrates that the delegate named <ph id="ph1">`Example`</ph> can be used to represent the method <ph id="ph2">`MyMethod`</ph>.</source>
          <target state="translated">Im Codebeispiel wird veranschaulicht, dass der Delegat mit dem Namen <ph id="ph1">`Example`</ph> können verwendet werden, um die Methode darstellen <ph id="ph2">`MyMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The method can be bound to the delegate because:</source>
          <target state="translated">Die Methode kann an den Delegaten gebunden werden, da:</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The parameter type of the delegate (<ph id="ph1">`Derived`</ph>) is more restrictive than the parameter type of <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>), so that it is always safe to pass the argument of the delegate to <ph id="ph4">`MyMethod`</ph>.</source>
          <target state="translated">Der Parametertyp des Delegaten (<ph id="ph1">`Derived`</ph>) ist stärker eingeschränkt als der Parametertyp der <ph id="ph2">`MyMethod`</ph> (<ph id="ph3">`Base`</ph>), sodass es immer sicher, das Argument des Delegaten zu übergeben sind <ph id="ph4">`MyMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The return type of <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) is more restrictive than the parameter type of the delegate (<ph id="ph3">`Base`</ph>), so that it is always safe to cast the return type of the method to the return type of the delegate.</source>
          <target state="translated">Der Rückgabetyp der <ph id="ph1">`MyMethod`</ph> (<ph id="ph2">`Derived`</ph>) ist stärker eingeschränkt als der Parametertyp des Delegaten (<ph id="ph3">`Base`</ph>), sodass immer den Rückgabetyp der Methode in den Rückgabetyp des Delegaten umgewandelt werden kann.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example produces no output.</source>
          <target state="translated">Das Codebeispiel erzeugt keine Ausgabe.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><bpt id="p1">**</bpt>Example 3<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Beispiel 3<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The following code example shows all the methods a single delegate type can represent.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, die Methoden, die ein einzelner Delegattyp darstellen kann.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>There are two overloads of the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> method that specify <ph id="ph2">`firstArgument`</ph> and a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</source>
          <target state="translated">Es gibt zwei Überladungen der <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%2A&gt;</ph> Methode, die angeben <ph id="ph2">`firstArgument`</ph> und ein <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>; ihre Funktionalität ist identisch, außer dass Ihnen die ermöglicht Angabe, ob bei Bindungsfehlern ausgelöst, und die andere immer löst.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This code example uses both overloads.</source>
          <target state="translated">Dieses Codebeispiel verwendet beide Überladungen.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The code example defines two classes, <ph id="ph1">`C`</ph> and <ph id="ph2">`F`</ph>, and a delegate type <ph id="ph3">`D`</ph> with one argument of type <ph id="ph4">`C`</ph>.</source>
          <target state="translated">Im Codebeispiel werden zwei Klassen definiert <ph id="ph1">`C`</ph> und <ph id="ph2">`F`</ph>, und ein Delegattyp <ph id="ph3">`D`</ph> mit einem Argument des Typs <ph id="ph4">`C`</ph>.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The classes have matching static and instance methods <ph id="ph1">`M1`</ph>, <ph id="ph2">`M3`</ph>, and <ph id="ph3">`M4`</ph>, and class <ph id="ph4">`C`</ph> also has an instance method <ph id="ph5">`M2`</ph> that has no arguments.</source>
          <target state="translated">Die Klassen übereinstimmende statische und Instanzmethoden <ph id="ph1">`M1`</ph>, <ph id="ph2">`M3`</ph>, und <ph id="ph3">`M4`</ph>, und die Klasse <ph id="ph4">`C`</ph> verfügt auch über eine Instanzmethode <ph id="ph5">`M2`</ph> , die keine Argumente verfügt.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A third class named <ph id="ph1">`Example`</ph> contains the code that creates the delegates.</source>
          <target state="translated">Eine dritte Klasse mit dem Namen <ph id="ph1">`Example`</ph> enthält den Code, der den Delegaten erstellt.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Delegates are created for instance method <ph id="ph1">`M1`</ph> of type <ph id="ph2">`C`</ph> and type <ph id="ph3">`F`</ph>; each is closed over an instance of the respective type.</source>
          <target state="translated">Delegaten werden erstellt, z. B. Methode <ph id="ph1">`M1`</ph> des Typs <ph id="ph2">`C`</ph> und Typ <ph id="ph3">`F`</ph>; jede über eine Instanz des entsprechenden Typs geschlossen wird.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Method <ph id="ph1">`M1`</ph> of type <ph id="ph2">`C`</ph> displays the <ph id="ph3">`ID`</ph> properties of the bound instance and of the argument.</source>
          <target state="translated">Methode <ph id="ph1">`M1`</ph> des Typs <ph id="ph2">`C`</ph> zeigt die <ph id="ph3">`ID`</ph> Eigenschaften der gebundenen Instanz und des Arguments.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>A delegate is created for method <ph id="ph1">`M2`</ph> of type <ph id="ph2">`C`</ph>.</source>
          <target state="translated">Ein Delegat wird für die Methode erstellt <ph id="ph1">`M2`</ph> vom Typ <ph id="ph2">`C`</ph>.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>This is an open instance delegate, in which the argument of the delegate represents the hidden first argument on the instance method.</source>
          <target state="translated">Dies ist eine offene Instanz Delegaten, in dem das Argument des Delegaten als ausgeblendete erste Argument in der Instanzmethode darstellt.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The method has no other arguments.</source>
          <target state="translated">Die Methode hat keine anderen Argumente.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Delegates are created for static method <ph id="ph1">`M3`</ph> of type <ph id="ph2">`C`</ph> and type <ph id="ph3">`F`</ph>; these are open static delegates.</source>
          <target state="translated">Delegaten werden für die statische Methode erstellt <ph id="ph1">`M3`</ph> des Typs <ph id="ph2">`C`</ph> und Typ <ph id="ph3">`F`</ph>; Hierbei handelt es sich um open statische Delegaten.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Finally, delegates are created for static method <ph id="ph1">`M4`</ph> of type <ph id="ph2">`C`</ph> and type <ph id="ph3">`F`</ph>; each method has the declaring type as its first argument, and an instance of the type is supplied, so the delegates are closed over their first arguments.</source>
          <target state="translated">Abschließend werden die Delegaten für die statische Methode erstellt <ph id="ph1">`M4`</ph> des Typs <ph id="ph2">`C`</ph> und Typ <ph id="ph3">`F`</ph>; jede Methode verfügt über den deklarierenden Typ als erstes Argument und eine Instanz des Typs angegeben werden, damit die Delegaten über ihre erste Argumente geschlossen werden .</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Method <ph id="ph1">`M4`</ph> of type <ph id="ph2">`C`</ph> displays the <ph id="ph3">`ID`</ph> properties of the bound instance and of the argument.</source>
          <target state="translated">Methode <ph id="ph1">`M4`</ph> des Typs <ph id="ph2">`C`</ph> zeigt die <ph id="ph3">`ID`</ph> Eigenschaften der gebundenen Instanz und des Arguments.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> erbt nicht <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist keine <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Siehe <bpt id="p1">[</bpt>Laufzeittypen in Reflektion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, and <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> kann nicht gebunden werden, und <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> ist <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist keine <ph id="ph2">&lt;see langword="RuntimeMethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Siehe <bpt id="p1">[</bpt>Laufzeittypen in Reflektion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">Die <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph>-Methode von <ph id="ph2">&lt;paramref name="type" /&gt;</ph> wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> des zu erstellenden Delegaten.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>The class instance on which <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> is invoked.</source>
          <target state="translated">Die Klasseninstanz, für die <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>The name of the instance method that the delegate is to represent.</source>
          <target state="translated">Der Name der Instanzenmethode, die durch den Delegaten dargestellt werden soll.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>A Boolean indicating whether to ignore the case when comparing the name of the method.</source>
          <target state="translated">Ein boolescher Wert, der angibt, ob die Groß- und Kleinschreibung beim Vergleichen des Methodennamens berücksichtigt werden soll.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance with the specified case-sensitivity.</source>
          <target state="translated">Erstellt einen Delegaten vom angegebenen Typ, der die angegebene Instanzenmethode darstellt, die für die angegebene Klasseninstanz aufgerufen werden soll, wobei die Groß- und Kleinschreibung den Angaben entsprechend berücksichtigt bzw. nicht berücksichtigt wird.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</source>
          <target state="translated">Ein Delegat vom angegebenen Typ, der die angegebene Instanzenmethode darstellt, die für die angegebene Klasseninstanz aufgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>This method creates delegates for instance methods only.</source>
          <target state="translated">Diese Methode erstellt nur Delegaten für die Instanz.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">Eine Instanzmethode ist eine Methode, die eine Instanz einer Klasse zugeordnet ist. eine statische Methode ist eine Methode, die die Klasse selbst zugeordnet ist.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload, specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnBindFailure`</ph>.</source>
          <target state="translated">Diese methodenüberladung entspricht dem Aufrufen der <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> Methode zu überladen, Angeben von <ph id="ph2">`true`</ph> für <ph id="ph3">`throwOnBindFailure`</ph>.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Methode kann verwendet werden, auf nicht öffentliche Methoden zuzugreifen, wenn der Aufrufer erteilt wurde <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit dem <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> kennzeichnen und erteilen Sie der Berechtigungssatz für die nicht öffentlichen Methoden an des Aufrufers beschränkt ist Set- oder eine Teilmenge davon.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsüberlegungen für die Reflektion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein. </target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> erbt nicht <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist keine <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Siehe <bpt id="p1">[</bpt>Laufzeittypen in Reflektion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not an instance method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist keine Instanzenmethode.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, for example because it cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> kann nicht gebunden werden, z. B. weil sie nicht gefunden wurde.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">Die <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph>-Methode von <ph id="ph2">&lt;paramref name="type" /&gt;</ph> wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> des zu erstellenden Delegaten.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the class that implements <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, der die Klasse darstellt, die <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> implementiert.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>The name of the static method that the delegate is to represent.</source>
          <target state="translated">Der Name der statischen Methode, die durch den Delegaten dargestellt werden soll.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>A Boolean indicating whether to ignore the case when comparing the name of the method.</source>
          <target state="translated">Ein boolescher Wert, der angibt, ob die Groß- und Kleinschreibung beim Vergleichen des Methodennamens berücksichtigt werden soll.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity.</source>
          <target state="translated">Erstellt einen Delegaten vom angegebenen Typ, der die angegebene statische Methode der angegebenen Klasse mit der angegebenen Berücksichtigung von Groß- und Kleinschreibung darstellt.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>A delegate of the specified type that represents the specified static method of the specified class.</source>
          <target state="translated">Ein Delegat vom angegebenen Typ, der die angegebene statische Methode der angegebenen Klasse darstellt.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>This method creates delegates for static methods only.</source>
          <target state="translated">Diese Methode erstellt Delegate für nur statische Methoden.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">Eine Instanzmethode ist eine Methode, die eine Instanz einer Klasse zugeordnet ist. eine statische Methode ist eine Methode, die die Klasse selbst zugeordnet ist.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload, specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnBindFailure`</ph>.</source>
          <target state="translated">Diese methodenüberladung entspricht dem Aufrufen der <ph id="ph1">&lt;xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> Methode zu überladen, Angeben von <ph id="ph2">`true`</ph> für <ph id="ph3">`throwOnBindFailure`</ph>.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Methode kann verwendet werden, auf nicht öffentliche Methoden zuzugreifen, wenn der Aufrufer erteilt wurde <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit dem <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> kennzeichnen und erteilen Sie der Berechtigungssatz für die nicht öffentlichen Methoden an des Aufrufers beschränkt ist Set- oder eine Teilmenge davon.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsüberlegungen für die Reflektion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein. </target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> erbt nicht <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist keine <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Siehe <bpt id="p1">[</bpt>Laufzeittypen in Reflektion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> ist keine <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> ist ein offener generischer Typ.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>That is, its <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Das bedeutet, die <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph>-Eigenschaft ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="static" /&gt;</ph> method (<ph id="ph3">&lt;see langword="Shared" /&gt;</ph> method in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist keine <ph id="ph2">&lt;see langword="static" /&gt;</ph>-Methode (<ph id="ph3">&lt;see langword="Shared" /&gt;</ph>-Methode in Visual Basic).</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, for example because it cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> kann nicht gebunden werden, z. B. weil sie nicht gefunden wurde.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">Die <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph>-Methode von <ph id="ph2">&lt;paramref name="type" /&gt;</ph> wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> des zu erstellenden Delegaten.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>The class instance on which <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> is invoked.</source>
          <target state="translated">Die Klasseninstanz, für die <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>The name of the instance method that the delegate is to represent.</source>
          <target state="translated">Der Name der Instanzenmethode, die durch den Delegaten dargestellt werden soll.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>A Boolean indicating whether to ignore the case when comparing the name of the method.</source>
          <target state="translated">Ein boolescher Wert, der angibt, ob die Groß- und Kleinschreibung beim Vergleichen des Methodennamens berücksichtigt werden soll.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> cannot be bound; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, um eine Ausnahme auszulösen, wenn <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> nicht gebunden werden kann, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance, with the specified case-sensitivity and the specified behavior on failure to bind.</source>
          <target state="translated">Erstellt einen Delegaten vom angegebenen Typ, der die angegebene Instanzenmethode darstellt, die für die angegebene Klasseninstanz aufgerufen werden soll, wobei die Groß- und Kleinschreibung und das Verhalten bei Bindungsfehlern den Angaben entsprechend berücksichtigt bzw. nicht berücksichtigt wird.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</source>
          <target state="translated">Ein Delegat vom angegebenen Typ, der die angegebene Instanzenmethode darstellt, die für die angegebene Klasseninstanz aufgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>This method creates delegates for instance methods only.</source>
          <target state="translated">Diese Methode erstellt nur Delegaten für die Instanz.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">Eine Instanzmethode ist eine Methode, die eine Instanz einer Klasse zugeordnet ist. eine statische Methode ist eine Methode, die die Klasse selbst zugeordnet ist.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Methode kann verwendet werden, auf nicht öffentliche Methoden zuzugreifen, wenn der Aufrufer erteilt wurde <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit dem <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> kennzeichnen und erteilen Sie der Berechtigungssatz für die nicht öffentlichen Methoden an des Aufrufers beschränkt ist Set- oder eine Teilmenge davon.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsüberlegungen für die Reflektion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein. </target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> erbt nicht <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist keine <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Siehe <bpt id="p1">[</bpt>Laufzeittypen in Reflektion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not an instance method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist keine Instanzenmethode.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, for example because it cannot be found, and <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> kann nicht gebunden werden, z. B. weil sie nicht gefunden wurde, und <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> ist gleich <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">Die <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph>-Methode von <ph id="ph2">&lt;paramref name="type" /&gt;</ph> wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of delegate to create.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> des zu erstellenden Delegaten.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the class that implements <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, der die Klasse darstellt, die <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> implementiert.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>The name of the static method that the delegate is to represent.</source>
          <target state="translated">Der Name der statischen Methode, die durch den Delegaten dargestellt werden soll.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>A Boolean indicating whether to ignore the case when comparing the name of the method.</source>
          <target state="translated">Ein boolescher Wert, der angibt, ob die Groß- und Kleinschreibung beim Vergleichen des Methodennamens berücksichtigt werden soll.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> cannot be bound; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, um eine Ausnahme auszulösen, wenn <bpt id="p1">&lt;c&gt;</bpt>method<ept id="p1">&lt;/c&gt;</ept> nicht gebunden werden kann, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity and the specified behavior on failure to bind.</source>
          <target state="translated">Erstellt einen Delegaten vom angegebenen Typ, der die angegebene statische Methode der angegebenen Klasse darstellt, wobei die Groß- und Kleinschreibung und das Verhalten bei Bindungsfehlern den Angaben entsprechend berücksichtigt bzw. nicht berücksichtigt wird.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>A delegate of the specified type that represents the specified static method of the specified class.</source>
          <target state="translated">Ein Delegat vom angegebenen Typ, der die angegebene statische Methode der angegebenen Klasse darstellt.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>This method creates delegates for static methods only.</source>
          <target state="translated">Diese Methode erstellt Delegate für nur statische Methoden.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">Eine Instanzmethode ist eine Methode, die eine Instanz einer Klasse zugeordnet ist. eine statische Methode ist eine Methode, die die Klasse selbst zugeordnet ist.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public methods if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Methode kann verwendet werden, auf nicht öffentliche Methoden zuzugreifen, wenn der Aufrufer erteilt wurde <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit dem <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> kennzeichnen und erteilen Sie der Berechtigungssatz für die nicht öffentlichen Methoden an des Aufrufers beschränkt ist Set- oder eine Teilmenge davon.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsüberlegungen für die Reflektion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein. </target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not inherit <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> erbt nicht <ph id="ph2">&lt;see cref="T:System.MulticastDelegate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> ist keine <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>See <bpt id="p1">[</bpt>Runtime Types in Reflection<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</source>
          <target state="translated">Siehe <bpt id="p1">[</bpt>Laufzeittypen in Reflektion<ept id="p1">](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858)</ept>.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> ist keine <ph id="ph2">&lt;see langword="RuntimeType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="target" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="target" /&gt;</ph> ist ein offener generischer Typ.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>That is, its <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Das bedeutet, die <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph>-Eigenschaft ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a <ph id="ph2">&lt;see langword="static" /&gt;</ph> method (<ph id="ph3">&lt;see langword="Shared" /&gt;</ph> method in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> ist keine <ph id="ph2">&lt;see langword="static" /&gt;</ph>-Methode (<ph id="ph3">&lt;see langword="Shared" /&gt;</ph>-Methode in Visual Basic).</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> cannot be bound, for example because it cannot be found, and <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> kann nicht gebunden werden, z. B. weil sie nicht gefunden wurde, und <ph id="ph2">&lt;paramref name="throwOnBindFailure" /&gt;</ph> ist gleich <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is not found.</source>
          <target state="translated">Die <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph>-Methode von <ph id="ph2">&lt;paramref name="type" /&gt;</ph> wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>The caller does not have the permissions necessary to access <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</source>
          <target state="translated">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <ph id="ph1">&lt;paramref name="method" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>An array of objects that are the arguments to pass to the method represented by the current delegate.</source>
          <target state="translated">Ein Array von Objekten, das die Argumente darstellt, die der durch den aktuellen Delegaten dargestellten Methode übergeben werden.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph>, if the method represented by the current delegate does not require arguments.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn die durch den aktuellen Delegaten dargestellte Methode keine Argumente erfordert.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>Dynamically invokes (late-bound) the method represented by the current delegate.</source>
          <target state="translated">Ruft die durch den aktuellen Delegaten dargestellte Methode dynamisch (mit später Bindung) auf.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>The object returned by the method represented by the delegate.</source>
          <target state="translated">Das Objekt, das von der durch den Delegaten dargestellten Methode zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>This method calls the <ph id="ph1">&lt;xref:System.Delegate.DynamicInvokeImpl%2A&gt;</ph> method.</source>
          <target state="translated">Diese Methode ruft die <ph id="ph1">&lt;xref:System.Delegate.DynamicInvokeImpl%2A&gt;</ph>-Methode auf.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">Der Aufrufer verfügt nicht über Zugriff auf die Methode, die durch den Delegaten dargestellt wird (wenn die Methode z.B. privat ist).</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>The number, order, or type of parameters listed in <ph id="ph1">&lt;paramref name="args" /&gt;</ph> is invalid.</source>
          <target state="translated">Anzahl, Reihenfolge oder Typ der in <ph id="ph1">&lt;paramref name="args" /&gt;</ph> aufgeführten Parameter ist ungültig.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>The method represented by the delegate is invoked on an object or a class that does not support it.</source>
          <target state="translated">Die durch den Delegaten dargestellte Methode wird für ein Objekt oder eine Klasse aufgerufen, die die Methode nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>The method represented by the delegate is an instance method and the target object is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Die durch den Delegaten dargestellte Methode ist eine Instanzenmethode, und das Zielobjekt ist <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>One of the encapsulated methods throws an exception.</source>
          <target state="translated">Eine der gekapselten Methoden löst eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.DynamicInvoke(System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>An array of objects that are the arguments to pass to the method represented by the current delegate.</source>
          <target state="translated">Ein Array von Objekten, das die Argumente darstellt, die der durch den aktuellen Delegaten dargestellten Methode übergeben werden.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph>, if the method represented by the current delegate does not require arguments.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn die durch den aktuellen Delegaten dargestellte Methode keine Argumente erfordert.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>Dynamically invokes (late-bound) the method represented by the current delegate.</source>
          <target state="translated">Ruft die durch den aktuellen Delegaten dargestellte Methode dynamisch (mit später Bindung) auf.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>The object returned by the method represented by the delegate.</source>
          <target state="translated">Das Objekt, das von der durch den Delegaten dargestellten Methode zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>This method implements the <ph id="ph1">&lt;xref:System.Delegate.DynamicInvoke%2A&gt;</ph> method.</source>
          <target state="translated">Diese Methode implementiert die Methode <ph id="ph1">&lt;xref:System.Delegate.DynamicInvoke%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">Der Aufrufer verfügt nicht über Zugriff auf die Methode, die durch den Delegaten dargestellt wird (wenn die Methode z.B. privat ist).</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>The number, order, or type of parameters listed in <ph id="ph1">&lt;paramref name="args" /&gt;</ph> is invalid.</source>
          <target state="translated">Anzahl, Reihenfolge oder Typ der in <ph id="ph1">&lt;paramref name="args" /&gt;</ph> aufgeführten Parameter ist ungültig.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>The method represented by the delegate is invoked on an object or a class that does not support it.</source>
          <target state="translated">Die durch den Delegaten dargestellte Methode wird für ein Objekt oder eine Klasse aufgerufen, die die Methode nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>The method represented by the delegate is an instance method and the target object is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Die durch den Delegaten dargestellte Methode ist eine Instanzenmethode, und das Zielobjekt ist <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>One of the encapsulated methods throws an exception.</source>
          <target state="translated">Eine der gekapselten Methoden löst eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.DynamicInvokeImpl(System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Delegate.Equals(System.Object)">
          <source>The object to compare with the current delegate.</source>
          <target state="translated">Das Objekt, das mit dem aktuellen Delegaten verglichen werden soll.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Delegate.Equals(System.Object)">
          <source>Determines whether the specified object and the current delegate are of the same type and share the same targets, methods, and invocation list.</source>
          <target state="translated">Bestimmt, ob das angegebene Objekt und der aktuelle Delegat vom gleichen Typ sind und die gleichen Ziele, Methoden und Aufruflisten besitzen.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Delegate.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> and the current delegate have the same targets, methods, and invocation list; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> und der aktuelle Delegat die gleichen Ziele, Methoden und Aufruflisten aufweisen; andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>If the two delegates are not of the same type, they are not considered equal.</source>
          <target state="translated">Wenn die beiden Delegaten nicht vom gleichen Typ sind, sind sie nicht als gleich betrachtet.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>In the .NET Framework version 1.0 and 1.1, two delegates were considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</source>
          <target state="translated">In .NET Framework, Version 1.0 und 1.1 wurden zwei Delegaten als gleich betrachtet, wenn ihre Ziele, Methoden und Aufruflisten gleich sind, selbst wenn die Delegaten unterschiedliche Typen sind.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>The methods and targets are compared for equality as follows:</source>
          <target state="translated">Die Methoden und Ziele werden wie folgt auf Gleichheit verglichen:</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</source>
          <target state="translated">Wenn die beiden Methoden, die verglichen werden sowohl statische sind und die gleiche Methode in der gleichen Klasse, die Methoden als gleich betrachtet, und auch die Ziele als gleich betrachtet.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</source>
          <target state="translated">Wenn die beiden Methoden, die zu vergleichenden Instanzmethoden oder die gleiche Methode für das gleiche Objekt, die Methoden als gleich betrachtet, und die Ziele werden auch als gleich betrachtet.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</source>
          <target state="translated">Hingegen die Methoden nicht als gleich angesehen, und die Ziele sind auch nicht als gleich.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>Two invocation lists are considered identical only if they have the same order and the corresponding elements from the two lists represent the same method and target.</source>
          <target state="translated">Zwei Aufruflisten, als identisch betrachtet, nur, wenn sie die gleiche Reihenfolge aufweisen, und die entsprechenden Elemente aus den beiden Listen, die gleiche Methode und Ziel darstellen.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.Delegate.Equals(System.Object)">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">Der Aufrufer verfügt nicht über Zugriff auf die Methode, die durch den Delegaten dargestellt wird (wenn die Methode z.B. privat ist).</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Equals(System.Object)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetHashCode">
          <source>Returns a hash code for the delegate.</source>
          <target state="translated">Gibt einen Hashcode für den Delegaten zurück.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetHashCode">
          <source>A hash code for the delegate.</source>
          <target state="translated">Ein Hashcode für den Delegaten.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetHashCode">
          <source>The return value of this method must not be persisted for two reasons.</source>
          <target state="translated">Der Rückgabewert dieser Methode muss zwei Gründen nicht beibehalten werden.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetHashCode">
          <source>First, the hash function of a class might be altered to generate a better distribution, rendering any values from the old hash function useless.</source>
          <target state="translated">Zuerst kann der Hash-Funktion von einer Klasse zur besseren Verteilung, Rendern von Werten aus der alten Hashfunktion nutzlos geändert werden.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetHashCode">
          <source>Second, the default implementation of this class does not guarantee that the same value will be returned by different instances.</source>
          <target state="translated">Zweitens kann die standardmäßige Implementierung dieser Klasse nicht garantiert, dass es sich bei der gleiche Wert von anderen Instanzen zurückgegeben werden.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetHashCode">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetHashCode">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetInvocationList">
          <source>Returns the invocation list of the delegate.</source>
          <target state="translated">Gibt die Aufrufliste des Delegaten zurück.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetInvocationList">
          <source>An array of delegates representing the invocation list of the current delegate.</source>
          <target state="translated">Ein Array von Delegaten, das die Aufrufliste des aktuellen Delegaten darstellt.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetInvocationList">
          <source>Each delegate in the array represents exactly one method.</source>
          <target state="translated">Jeder Delegat im Array stellt genau eine Methode dar.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetInvocationList">
          <source>The order of the delegates in the array is the same order in which the current delegate invokes the methods that those delegates represent.</source>
          <target state="translated">Die Reihenfolge der Delegaten im Array ist die gleiche Reihenfolge, in der der aktuelle Delegat die Methoden aufruft, die diese Delegaten darstellen.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetInvocationList">
          <source>The following example assigns three methods to a delegate.</source>
          <target state="translated">Im folgenden Beispiel werden drei Methoden auf einen Delegaten zugewiesen.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetInvocationList">
          <source>It then calls the  <ph id="ph1">&lt;xref:System.Delegate.GetInvocationList%2A&gt;</ph> method to get a total count of the methods assigned to the delegate, to execute the delegates in reverse order, and to execute the methods whose name do not include the substring "File".</source>
          <target state="translated">Er ruft dann die <ph id="ph1">&lt;xref:System.Delegate.GetInvocationList%2A&gt;</ph> Methode zum Abrufen von Gesamtzahl der Methoden, die an den Delegaten zugewiesen wird, um die Delegaten in umgekehrter Reihenfolge ausgeführt und führen Sie die Methoden, deren Namen enthalten nicht die Teilzeichenfolge "File".</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetInvocationList">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetInvocationList">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetMethodImpl">
          <source>Gets the static method represented by the current delegate.</source>
          <target state="translated">Ruft die statische Methode ab, die durch den aktuellen Delegaten dargestellt wird.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetMethodImpl">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> describing the static method represented by the current delegate.</source>
          <target state="translated">Eine <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, die die durch den aktuellen Delegaten dargestellte statische Methode beschreibt.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetMethodImpl">
          <source>This method applies only if the current delegate represents a static method.</source>
          <target state="translated">Diese Methode gilt nur, wenn der aktuelle Delegat eine statische Methode darstellt.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetMethodImpl">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">Der Aufrufer verfügt nicht über Zugriff auf die Methode, die durch den Delegaten dargestellt wird (wenn die Methode z.B. privat ist).</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetMethodImpl">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetMethodImpl">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Not supported.</source>
          <target state="translated">Wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Not supported.</source>
          <target state="translated">Wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Not supported.</source>
          <target state="translated">Wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This method is not supported.</source>
          <target state="translated">Diese Methode wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="P:System.Delegate.Method">
          <source>Gets the method represented by the delegate.</source>
          <target state="translated">Ruft die Methode ab, die durch den Delegaten dargestellt wird.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Method">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> describing the method represented by the delegate.</source>
          <target state="translated">Eine <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, die die durch den Delegaten dargestellte Methode beschreibt.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" uid="P:System.Delegate.Method">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">Der Aufrufer verfügt nicht über Zugriff auf die Methode, die durch den Delegaten dargestellt wird (wenn die Methode z.B. privat ist).</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Method">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Method">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>The first delegate to compare.</source>
          <target state="translated">Der erste der zu vergleichenden Delegaten.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>The second delegate to compare.</source>
          <target state="translated">Der zweite der zu vergleichenden Delegaten.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>Determines whether the specified delegates are equal.</source>
          <target state="translated">Bestimmt, ob die angegebenen Delegaten gleich sind.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="d1" /&gt;</ph> is equal to <ph id="ph3">&lt;paramref name="d2" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;paramref name="d1" /&gt;</ph> und <ph id="ph3">&lt;paramref name="d2" /&gt;</ph> gleich sind, andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>Two delegates of the same type with the same targets, methods, and invocation lists are considered equal.</source>
          <target state="translated">Zwei Delegaten vom gleichen Typ mit dem gleichen Ziele, Methoden und Aufruflisten werden als gleich betrachtet.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>If the two delegates are not of the same type, they are not considered equal.</source>
          <target state="translated">Wenn die beiden Delegaten nicht vom gleichen Typ sind, sind sie nicht als gleich betrachtet.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>In the .NET Framework version 1.0 and 1.1, two delegates were considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</source>
          <target state="translated">In .NET Framework, Version 1.0 und 1.1 wurden zwei Delegaten als gleich betrachtet, wenn ihre Ziele, Methoden und Aufruflisten gleich sind, selbst wenn die Delegaten unterschiedliche Typen sind.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>The methods and targets are compared for equality as follows:</source>
          <target state="translated">Die Methoden und Ziele werden wie folgt auf Gleichheit verglichen:</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</source>
          <target state="translated">Wenn die beiden Methoden, die verglichen werden sowohl statische sind und die gleiche Methode in der gleichen Klasse, die Methoden als gleich betrachtet, und auch die Ziele als gleich betrachtet.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</source>
          <target state="translated">Wenn die beiden Methoden, die zu vergleichenden Instanzmethoden oder die gleiche Methode für das gleiche Objekt, die Methoden als gleich betrachtet, und die Ziele werden auch als gleich betrachtet.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</source>
          <target state="translated">Hingegen die Methoden nicht als gleich angesehen, und die Ziele sind auch nicht als gleich.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>Two invocation lists are considered identical if they have the same order and the corresponding elements from the two lists represent the same method and target.</source>
          <target state="translated">Zwei Aufruflisten werden als identisch angesehen, wenn sie die gleiche Reihenfolge aufweisen, und die entsprechenden Elemente aus den beiden Listen, die gleiche Methode und Ziel darstellen.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">Die entsprechende Methode für diesen Operator ist. <ph id="ph1">&lt;xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>The first delegate to compare.</source>
          <target state="translated">Der erste der zu vergleichenden Delegaten.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>The second delegate to compare.</source>
          <target state="translated">Der zweite der zu vergleichenden Delegaten.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>Determines whether the specified delegates are not equal.</source>
          <target state="translated">Bestimmt, ob die angegebenen Delegaten ungleich sind.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="d1" /&gt;</ph> is not equal to <ph id="ph3">&lt;paramref name="d2" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;paramref name="d1" /&gt;</ph> und <ph id="ph3">&lt;paramref name="d2" /&gt;</ph> ungleich sind, andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>Two delegates are considered not equal if they are of different types, or have different methods, different targets, or different invocation lists.</source>
          <target state="translated">Zwei Delegaten werden nicht als gleich betrachtet, wenn sie unterschiedlichen Typen gehören, oder haben Sie verschiedene Methoden, verschiedene Ziele oder Aufruflisten.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>If the two delegates are not of the same type, they are not considered equal.</source>
          <target state="translated">Wenn die beiden Delegaten nicht vom gleichen Typ sind, sind sie nicht als gleich betrachtet.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>In the .NET Framework version 1.0 and 1.1, two delegates are considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</source>
          <target state="translated">In .NET Framework, Version 1.0 und 1.1 werden zwei Delegaten als gleich betrachtet, wenn ihre Ziele, Methoden und Aufruflisten gleich sind, selbst wenn die Delegaten unterschiedliche Typen sind.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>The methods and targets are compared for equality as follows:</source>
          <target state="translated">Die Methoden und Ziele werden wie folgt auf Gleichheit verglichen:</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</source>
          <target state="translated">Wenn die beiden Methoden, die verglichen werden sowohl statische sind und die gleiche Methode in der gleichen Klasse, die Methoden als gleich betrachtet, und auch die Ziele als gleich betrachtet.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</source>
          <target state="translated">Wenn die beiden Methoden, die zu vergleichenden Instanzmethoden oder die gleiche Methode für das gleiche Objekt, die Methoden als gleich betrachtet, und die Ziele werden auch als gleich betrachtet.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</source>
          <target state="translated">Hingegen die Methoden nicht als gleich angesehen, und die Ziele sind auch nicht als gleich.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>Two invocation lists are not equal if they have different sizes, if they are ordered differently, or if at least one element from one list represents a method or target that is different from that represented by its corresponding element in the other list.</source>
          <target state="translated">Zwei Aufruflisten sind nicht gleich, besäßen sie unterschiedliche Größen haben, wenn sie anders angeordnet sind, oder wenn mindestens ein Element aus einer Liste stellt eine Methode oder ein Ziel, das sich aus, die von seinem entsprechenden Element in die andere Liste dargestellt.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>The equivalent method for this operator is <ph id="ph1">&lt;xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">Die entsprechende Methode für diesen Operator ist. <ph id="ph1">&lt;xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>The delegate from which to remove the invocation list of <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Der Delegat, aus dem die Aufrufliste von <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> entfernt werden soll.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>The delegate that supplies the invocation list to remove from the invocation list of <bpt id="p1">&lt;c&gt;</bpt>source<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Der Delegat, von dem die Aufrufliste stammt, die aus der Aufrufliste von <bpt id="p1">&lt;c&gt;</bpt>source<ept id="p1">&lt;/c&gt;</ept> entfernt werden soll.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>Removes the last occurrence of the invocation list of a delegate from the invocation list of another delegate.</source>
          <target state="translated">Entfernt das letzte Vorkommen der Aufrufliste eines Delegaten aus der Aufrufliste eines anderen Delegaten.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>A new delegate with an invocation list formed by taking the invocation list of <ph id="ph1">&lt;paramref name="source" /&gt;</ph> and removing the last occurrence of the invocation list of <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, if the invocation list of <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found within the invocation list of <ph id="ph4">&lt;paramref name="source" /&gt;</ph>.</source>
          <target state="translated">Ein neuer Delegat mit einer Aufrufliste, die aus der Aufrufliste von <ph id="ph1">&lt;paramref name="source" /&gt;</ph> besteht, aus der das letzte Vorkommen der Aufrufliste von <ph id="ph2">&lt;paramref name="value" /&gt;</ph> entfernt wurde, falls sich die Aufrufliste von <ph id="ph3">&lt;paramref name="value" /&gt;</ph> in der Aufrufliste von <ph id="ph4">&lt;paramref name="source" /&gt;</ph> befand.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>Returns <ph id="ph1">&lt;paramref name="source" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or if the invocation list of <ph id="ph4">&lt;paramref name="value" /&gt;</ph> is not found within the invocation list of <ph id="ph5">&lt;paramref name="source" /&gt;</ph>.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;paramref name="source" /&gt;</ph> zurück, wenn <ph id="ph2">&lt;paramref name="value" /&gt;</ph><ph id="ph3">&lt;see langword="null" /&gt;</ph> ist oder die Aufrufliste von <ph id="ph4">&lt;paramref name="value" /&gt;</ph> sich nicht innerhalb der Aufrufliste von <ph id="ph5">&lt;paramref name="source" /&gt;</ph> befand.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>Returns a null reference if the invocation list of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is equal to the invocation list of <ph id="ph2">&lt;paramref name="source" /&gt;</ph> or if <ph id="ph3">&lt;paramref name="source" /&gt;</ph> is a null reference.</source>
          <target state="translated">Gibt einen NULL-Verweis zurück, wenn die Aufrufliste von <ph id="ph1">&lt;paramref name="value" /&gt;</ph> gleich der Aufrufliste von <ph id="ph2">&lt;paramref name="source" /&gt;</ph> ist oder <ph id="ph3">&lt;paramref name="source" /&gt;</ph> ein NULL-Verweis ist.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>If the invocation list of <ph id="ph1">`value`</ph> matches a contiguous set of elements in the invocation list of <ph id="ph2">`source`</ph>, then the invocation list of <ph id="ph3">`value`</ph> is said to occur within the invocation list of <ph id="ph4">`source`</ph>.</source>
          <target state="translated">Wenn der Aufrufliste eines <ph id="ph1">`value`</ph> entspricht, einen zusammenhängenden Satz von Elementen in der Aufrufliste eines <ph id="ph2">`source`</ph>, klicken Sie dann die Aufrufliste von <ph id="ph3">`value`</ph> gilt als in der Aufrufliste eines auftreten <ph id="ph4">`source`</ph>.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>If the invocation list of <ph id="ph1">`value`</ph> occurs more than once in the invocation list of <ph id="ph2">`source`</ph>, the last occurrence is removed.</source>
          <target state="translated">Wenn der Aufrufliste eines <ph id="ph1">`value`</ph> tritt mehr als einmal in der Aufrufliste eines <ph id="ph2">`source`</ph>, wird das letzte Vorkommen entfernt.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">Der Aufrufer verfügt nicht über Zugriff auf die Methode, die durch den Delegaten dargestellt wird (wenn die Methode z.B. privat ist).</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>The delegate types do not match.</source>
          <target state="translated">Die Delegattypen stimmen nicht überein.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.Remove(System.Delegate,System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>The delegate from which to remove the invocation list of <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Der Delegat, aus dem die Aufrufliste von <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> entfernt werden soll.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>The delegate that supplies the invocation list to remove from the invocation list of <bpt id="p1">&lt;c&gt;</bpt>source<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Der Delegat, von dem die Aufrufliste stammt, die aus der Aufrufliste von <bpt id="p1">&lt;c&gt;</bpt>source<ept id="p1">&lt;/c&gt;</ept> entfernt werden soll.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>Removes all occurrences of the invocation list of a delegate from the invocation list of another delegate.</source>
          <target state="translated">Entfernt alle Vorkommen der Aufrufliste eines Delegaten aus der Aufrufliste eines anderen Delegaten.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>A new delegate with an invocation list formed by taking the invocation list of <ph id="ph1">&lt;paramref name="source" /&gt;</ph> and removing all occurrences of the invocation list of <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, if the invocation list of <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found within the invocation list of <ph id="ph4">&lt;paramref name="source" /&gt;</ph>.</source>
          <target state="translated">Ein neuer Delegat mit einer Aufrufliste, die aus der Aufrufliste von <ph id="ph1">&lt;paramref name="source" /&gt;</ph> besteht, aus der alle Vorkommen der Aufrufliste von <ph id="ph2">&lt;paramref name="value" /&gt;</ph> entfernt wurden, falls sich die Aufrufliste von <ph id="ph3">&lt;paramref name="value" /&gt;</ph> in der Aufrufliste von <ph id="ph4">&lt;paramref name="source" /&gt;</ph> befand.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>Returns <ph id="ph1">&lt;paramref name="source" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or if the invocation list of <ph id="ph4">&lt;paramref name="value" /&gt;</ph> is not found within the invocation list of <ph id="ph5">&lt;paramref name="source" /&gt;</ph>.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;paramref name="source" /&gt;</ph> zurück, wenn <ph id="ph2">&lt;paramref name="value" /&gt;</ph><ph id="ph3">&lt;see langword="null" /&gt;</ph> ist oder die Aufrufliste von <ph id="ph4">&lt;paramref name="value" /&gt;</ph> sich nicht innerhalb der Aufrufliste von <ph id="ph5">&lt;paramref name="source" /&gt;</ph> befand.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>Returns a null reference if the invocation list of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is equal to the invocation list of <ph id="ph2">&lt;paramref name="source" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="source" /&gt;</ph> contains only a series of invocation lists that are equal to the invocation list of <ph id="ph4">&lt;paramref name="value" /&gt;</ph>, or if <ph id="ph5">&lt;paramref name="source" /&gt;</ph> is a null reference.</source>
          <target state="translated">Gibt einen NULL-Verweis zurück, wenn die Aufrufliste von <ph id="ph1">&lt;paramref name="value" /&gt;</ph> gleich der Aufrufliste von <ph id="ph2">&lt;paramref name="source" /&gt;</ph> ist, wenn <ph id="ph3">&lt;paramref name="source" /&gt;</ph> nur eine Reihe von Aufruflisten enthält, die gleich der Aufrufliste von <ph id="ph4">&lt;paramref name="value" /&gt;</ph> sind, oder <ph id="ph5">&lt;paramref name="source" /&gt;</ph> ein NULL-Verweis ist.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>If the invocation list of <ph id="ph1">`value`</ph> matches a contiguous set of elements in the invocation list of <ph id="ph2">`source`</ph>, then the invocation list of <ph id="ph3">`value`</ph> is said to occur within the invocation list of <ph id="ph4">`source`</ph>.</source>
          <target state="translated">Wenn der Aufrufliste eines <ph id="ph1">`value`</ph> entspricht, einen zusammenhängenden Satz von Elementen in der Aufrufliste eines <ph id="ph2">`source`</ph>, klicken Sie dann die Aufrufliste von <ph id="ph3">`value`</ph> gilt als in der Aufrufliste eines auftreten <ph id="ph4">`source`</ph>.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>If the invocation list of <ph id="ph1">`value`</ph> occurs more than once in the invocation list of <ph id="ph2">`source`</ph>, all occurrences are removed.</source>
          <target state="translated">Wenn der Aufrufliste eines <ph id="ph1">`value`</ph> tritt mehr als einmal in der Aufrufliste eines <ph id="ph2">`source`</ph>, werden alle Vorkommen entfernt.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">Der Aufrufer verfügt nicht über Zugriff auf die Methode, die durch den Delegaten dargestellt wird (wenn die Methode z.B. privat ist).</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>The delegate types do not match.</source>
          <target state="translated">Die Delegattypen stimmen nicht überein.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>The delegate that supplies the invocation list to remove from the invocation list of the current delegate.</source>
          <target state="translated">Der Delegat, von dem die Aufrufliste stammt, die aus der Aufrufliste des aktuellen Delegaten entfernt werden soll.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>Removes the invocation list of a delegate from the invocation list of another delegate.</source>
          <target state="translated">Entfernt die Aufrufliste eines Delegaten aus der Aufrufliste eines anderen Delegaten.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>A new delegate with an invocation list formed by taking the invocation list of the current delegate and removing the invocation list of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, if the invocation list of <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is found within the current delegate's invocation list.</source>
          <target state="translated">Ein neuer Delegat mit einer Aufrufliste, die aus der Aufrufliste des aktuellen Delegaten besteht, aus der die Aufrufliste von <ph id="ph1">&lt;paramref name="value" /&gt;</ph> entfernt wurde, falls sich die Aufrufliste von <ph id="ph2">&lt;paramref name="value" /&gt;</ph> in der Aufrufliste des aktuellen Delegaten befand.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>Returns the current delegate if <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or if the invocation list of <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is not found within the current delegate's invocation list.</source>
          <target state="translated">Gibt den aktuellen Delegaten zurück, wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2">&lt;see langword="null" /&gt;</ph> ist oder wenn die Aufrufliste von <ph id="ph3">&lt;paramref name="value" /&gt;</ph> nicht innerhalb der Aufrufliste des aktuellen Delegaten gefunden wurde.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>Returns <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the invocation list of <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is equal to the current delegate's invocation list.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurück, wenn die Aufrufliste von <ph id="ph2">&lt;paramref name="value" /&gt;</ph> gleich der Aufrufliste des aktuellen Delegaten ist.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>If the invocation list of <ph id="ph1">`value`</ph> matches a contiguous set of elements in the current delegate's invocation list, then the invocation list of <ph id="ph2">`value`</ph> is said to occur within the current delegate's invocation list.</source>
          <target state="translated">Wenn der Aufrufliste eines <ph id="ph1">`value`</ph> entspricht, einen zusammenhängenden Satz von Elementen in der Aufrufliste des Delegaten, und klicken Sie dann auf der Aufrufliste eines <ph id="ph2">`value`</ph> gilt als in der Aufrufliste für den aktuellen Delegaten auftreten.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>If the invocation list of <ph id="ph1">`value`</ph> occurs more than once in the current delegate's invocation list, the last occurrence is removed.</source>
          <target state="translated">Wenn der Aufrufliste eines <ph id="ph1">`value`</ph> ist mehrfach in der Aufrufliste für den aktuellen Delegaten, wird das letzte Vorkommen entfernt.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>The caller does not have access to the method represented by the delegate (for example, if the method is private).</source>
          <target state="translated">Der Aufrufer verfügt nicht über Zugriff auf die Methode, die durch den Delegaten dargestellt wird (wenn die Methode z.B. privat ist).</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Delegate.RemoveImpl(System.Delegate)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="P:System.Delegate.Target">
          <source>Gets the class instance on which the current delegate invokes the instance method.</source>
          <target state="translated">Ruft die Klasseninstanz ab, für die der aktuelle Delegat die Instanzenmethode aufruft.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Target">
          <source>The object on which the current delegate invokes the instance method, if the delegate represents an instance method; <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the delegate represents a static method.</source>
          <target state="translated">Das Objekt, für das der aktuelle Delegat die Instanzmethode aufruft, wenn der Delegat eine Instanzmethode darstellt, <ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn der Delegat eine statische Methode darstellt.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Target">
          <source>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</source>
          <target state="translated">Eine Instanzmethode ist eine Methode, die eine Instanz einer Klasse zugeordnet ist. eine statische Methode ist eine Methode, die die Klasse selbst zugeordnet ist.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Target">
          <source>If the delegate invokes one or more instance methods, this property returns the target of the last instance method in the invocation list.</source>
          <target state="translated">Wenn eine oder mehrere Instanzmethoden der Delegat aufgerufen wird, gibt diese Eigenschaft das Ziel der letzten Instanzenmethode in der Aufrufliste an.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Target">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen spät gebundene durch Mechanismen wie z. B. <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Delegate.Target">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>